/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/C.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import "./interfaces/IBean.sol";
  7 |     | import "./interfaces/IProxyAdmin.sol";
  8 |     | import "./libraries/Decimal.sol";
  9 |     | import "./interfaces/IPipeline.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @title C
 13 |     |  * @notice Contains constants used throughout Beanstalk.
 14 |     |  */
 15 | *   | library C {
 16 |     |     using Decimal for Decimal.D256;
 17 |     | 
 18 |     |     //////////////////// Globals ////////////////////
 19 |     | 
 20 |     |     uint256 internal constant PRECISION = 1e18;
 21 |     |     /// @dev The absolute maximum amount of Beans or Soil that can be issued from the system.
 22 |     |     uint256 internal constant GLOBAL_ABSOLUTE_MAX = 800_000e6;
 23 |     |     /// @dev The maximum percentage of Beans or Soil that can be issued from the system.
 24 |     |     /// @dev Relative to the total supply.
 25 |     |     uint256 internal constant GLOBAL_RATIO_MAX = 0.04e18;
 26 |     | 
 27 |     |     //////////////////// Reentrancy ////////////////////
 28 | *   |     uint256 internal constant NOT_ENTERED = 1;
 29 | *   |     uint256 internal constant ENTERED = 2;
 30 |     | 
 31 |     |     //////////////////// Season ////////////////////
 32 |     | 
 33 |     |     /// @dev The length of a Season meaured in seconds.
 34 | *   |     uint256 internal constant CURRENT_SEASON_PERIOD = 3600; // 1 hour
 35 |     |     uint256 internal constant SOP_PRECISION = 1e30;
 36 |     | 
 37 |     |     //////////////////// Silo ////////////////////
 38 |     |     uint256 internal constant STALK_PER_BEAN = 1e10;
 39 |     |     uint256 private constant ROOTS_BASE = 1e12;
 40 |     | 
 41 |     |     //////////////////// Contracts ////////////////////
 42 |     |     address internal constant PIPELINE = 0xb1bE0001f5a373b69b1E132b420e6D9687155e80;
 43 |     | 
 44 |     |     //////////////////// Well ////////////////////
 45 |     | 
 46 |     |     /// @dev The minimum balance required to calculate the BDV of a Well Token.
 47 |     |     uint256 internal constant WELL_MINIMUM_BEAN_BALANCE = 10e6;
 48 |     |     /// @dev The absolute maximum amount of Beans or Soil that can be issued from a single Well.
 49 |     |     uint256 internal constant WELL_ABSOLUTE_MAX = 200_000e6;
 50 |     |     /// @dev The maximum percentage of Beans or Soil that can be issued from a single Well.
 51 |     |     /// @dev Relative to the total supply.
 52 |     |     uint256 internal constant WELL_RATIO_MAX = 0.02e18;
 53 |     | 
 54 |     |     //////////////////// Tractor ////////////////////
 55 |     | 
 56 |     |     uint80 internal constant SLOT_SIZE = 32;
 57 |     |     // Special index to indicate the data to copy is the publisher address.
 58 |     |     uint80 internal constant PUBLISHER_COPY_INDEX = type(uint80).max;
 59 |     |     // Special index to indicate the data to copy is the operator address.
 60 |     |     uint80 internal constant OPERATOR_COPY_INDEX = type(uint80).max - 1;
 61 |     | 
 62 |     |     function getRootsBase() internal pure returns (uint256) {
 63 |     |         return ROOTS_BASE;
 64 |     |     }
 65 |     | 
 66 |     |     function precision() internal pure returns (uint256) {
 67 |     |         return PRECISION;
 68 |     |     }
 69 |     | 
 70 |     |     function pipeline() internal pure returns (IPipeline) {
 71 |     |         return IPipeline(PIPELINE);
 72 |     |     }
 73 |     | }
 74 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/Diamond.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | /******************************************************************************\
  5 |     | * Authors: Nick Mudge (https://twitter.com/mudgen)
  6 |     | *
  7 |     | * Implementation of a diamond.
  8 |     | /******************************************************************************/
  9 |     | 
 10 |     | import {LibDiamond} from "../libraries/LibDiamond.sol";
 11 |     | import {DiamondCutFacet} from "./facets/diamond/DiamondCutFacet.sol";
 12 |     | import {DiamondLoupeFacet} from "./facets/diamond/DiamondLoupeFacet.sol";
 13 |     | import {OwnershipFacet} from "./facets/diamond/OwnershipFacet.sol";
 14 |     | import {AppStorage} from "./storage/AppStorage.sol";
 15 |     | import {IDiamondCut} from "../interfaces/IDiamondCut.sol";
 16 |     | import {IDiamondLoupe} from "../interfaces/IDiamondLoupe.sol";
 17 |     | 
 18 | *   | contract Diamond {
 19 |     |     AppStorage internal s;
 20 |     | 
 21 |     |     receive() external payable {}
 22 |     | 
 23 | *   |     constructor(address _contractOwner) {
 24 | *   |         LibDiamond.setContractOwner(_contractOwner);
 25 | *   |         LibDiamond.addDiamondFunctions(
 26 | *   |             address(new DiamondCutFacet()),
 27 | *   |             address(new DiamondLoupeFacet())
 28 |     |         );
 29 |     |     }
 30 |     | 
 31 |     |     // Find facet for function that is called and execute the
 32 |     |     // function if a facet is found and return any value.
 33 |     |     fallback() external payable {
 34 | *   |         LibDiamond.DiamondStorage storage ds;
 35 | *   |         bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;
 36 |     |         assembly {
 37 | *   |             ds.slot := position
 38 |     |         }
 39 | *   |         address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;
 40 | *   |         require(facet != address(0), "Diamond: Function does not exist");
 41 |     |         assembly {
 42 | *   |             calldatacopy(0, 0, calldatasize())
 43 | *   |             let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
 44 | *   |             returndatacopy(0, 0, returndatasize())
 45 | *   |             switch result
 46 | *   |             case 0 {
 47 | *   |                 revert(0, returndatasize())
 48 |     |             }
 49 |     |             default {
 50 | *   |                 return(0, returndatasize())
 51 |     |             }
 52 |     |         }
 53 |     |     }
 54 |     | }
 55 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/Invariable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   7 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
   8 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   9 |     | 
  10 |     | import {GerminationSide} from "contracts/beanstalk/storage/System.sol";
  11 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
  12 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  13 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  14 |     | 
  15 |     | /**
  16 |     |  * @title Invariable
  17 |     |  * @notice Implements modifiers that maintain protocol wide invariants.
  18 |     |  * @dev Every external writing function should use as many non-redundant invariant modifiers as possible.
  19 |     |  * @dev https://www.nascent.xyz/idea/youre-writing-require-statements-wrong
  20 |     |  **/
  21 |     | abstract contract Invariable {
  22 |     |     using LibRedundantMath256 for uint256;
  23 |     |     using LibRedundantMathSigned256 for int256;
  24 |     |     using SafeCast for uint256;
  25 |     | 
  26 |     |     /**
  27 |     |      * @notice Ensures all user asset entitlements are coverable by contract balances.
  28 |     |      * @dev Should be used on every function that can write. Excepting Diamond functions.
  29 |     |      */
  30 | *   |     modifier fundsSafu() {
  31 |     |         _;
  32 | *   |         address[] memory tokens = getTokensOfInterest();
  33 | *   |         (
  34 | *   |             uint256[] memory entitlements,
  35 | *   |             uint256[] memory balances
  36 | *   |         ) = getTokenEntitlementsAndBalances(tokens);
  37 | *   |         for (uint256 i; i < tokens.length; i++) {
  38 | *   |             require(balances[i] >= entitlements[i], "INV: Insufficient token balance");
  39 |     |         }
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @notice Watched token balances do not change and Stalk does not decrease.
  44 |     |      * @dev Applicable to the majority of functions, excepting functions that explicitly move assets.
  45 |     |      * @dev Roughly akin to a view only check where only routine modifications are allowed (ie mowing).
  46 |     |      */
  47 | *   |     modifier noNetFlow() {
  48 | *   |         uint256 initialStalk = LibAppStorage.diamondStorage().sys.silo.stalk;
  49 | *   |         address[] memory tokens = getTokensOfInterest();
  50 | *   |         uint256[] memory initialProtocolTokenBalances = getTokenBalances(tokens);
  51 |     |         _;
  52 | *   |         uint256[] memory finalProtocolTokenBalances = getTokenBalances(tokens);
  53 |     | 
  54 | *   |         require(
  55 | *   |             LibAppStorage.diamondStorage().sys.silo.stalk >= initialStalk,
  56 |     |             "INV: noNetFlow Stalk decreased"
  57 |     |         );
  58 | *   |         for (uint256 i; i < tokens.length; i++) {
  59 | *   |             require(
  60 | *   |                 initialProtocolTokenBalances[i] == finalProtocolTokenBalances[i],
  61 |     |                 "INV: noNetFlow Token balance changed"
  62 |     |             );
  63 |     |         }
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Watched token balances do not decrease and Stalk does not decrease.
  68 |     |      * @dev Favor noNetFlow where applicable.
  69 |     |      */
  70 | *   |     modifier noOutFlow() {
  71 | *   |         uint256 initialStalk = LibAppStorage.diamondStorage().sys.silo.stalk;
  72 | *   |         address[] memory tokens = getTokensOfInterest();
  73 | *   |         uint256[] memory initialProtocolTokenBalances = getTokenBalances(tokens);
  74 |     |         _;
  75 | *   |         uint256[] memory finalProtocolTokenBalances = getTokenBalances(tokens);
  76 |     | 
  77 | *   |         require(
  78 | *   |             LibAppStorage.diamondStorage().sys.silo.stalk >= initialStalk,
  79 |     |             "INV: noOutFlow Stalk decreased"
  80 |     |         );
  81 | *   |         for (uint256 i; i < tokens.length; i++) {
  82 | *   |             require(
  83 | *   |                 initialProtocolTokenBalances[i] <= finalProtocolTokenBalances[i],
  84 |     |                 "INV: noOutFlow Token balance decreased"
  85 |     |             );
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice All except one watched token balances do not decrease.
  91 |     |      * @dev Favor noNetFlow or noOutFlow where applicable.
  92 |     |      */
  93 | *   |     modifier oneOutFlow(address outboundToken) {
  94 | *   |         address[] memory tokens = getTokensOfInterest();
  95 | *   |         uint256[] memory initialProtocolTokenBalances = getTokenBalances(tokens);
  96 | *   |         _;
  97 | *   |         uint256[] memory finalProtocolTokenBalances = getTokenBalances(tokens);
  98 |     | 
  99 | *   |         for (uint256 i; i < tokens.length; i++) {
 100 | *   |             if (tokens[i] == outboundToken) {
 101 | *   |                 continue;
 102 |     |             }
 103 | *   |             require(
 104 | *   |                 initialProtocolTokenBalances[i] <= finalProtocolTokenBalances[i],
 105 |     |                 "INV: oneOutFlow multiple token balances decreased"
 106 |     |             );
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @notice Does not change the supply of Beans. No minting, no burning.
 112 |     |      * @dev Applies to all but a very few functions tht explicitly change supply.
 113 |     |      */
 114 | *   |     modifier noSupplyChange() {
 115 |     |         // Storage is not defined due to stack too deep errors.
 116 | *   |         uint256 initialSupply = BeanstalkERC20(LibAppStorage.diamondStorage().sys.bean)
 117 |     |             .totalSupply();
 118 | *   |         _;
 119 | *   |         require(
 120 | *   |             BeanstalkERC20(LibAppStorage.diamondStorage().sys.bean).totalSupply() == initialSupply,
 121 |     |             "INV: Supply changed"
 122 |     |         );
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @notice Supply of Beans does not increase. No minting.
 127 |     |      * @dev Prefer noSupplyChange where applicable.
 128 |     |      */
 129 |     |     modifier noSupplyIncrease() {
 130 |     |         uint256 initialSupply = BeanstalkERC20(LibAppStorage.diamondStorage().sys.bean)
 131 |     |             .totalSupply();
 132 |     |         _;
 133 |     |         require(
 134 |     |             BeanstalkERC20(LibAppStorage.diamondStorage().sys.bean).totalSupply() <= initialSupply,
 135 |     |             "INV: Supply increased"
 136 |     |         );
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Which tokens to monitor in the invariants.
 141 |     |      */
 142 | *   |     function getTokensOfInterest() internal view returns (address[] memory tokens) {
 143 | *   |         address[] memory whitelistedTokens = LibWhitelistedTokens.getWhitelistedTokens();
 144 | *   |         address[] memory sopTokens = LibWhitelistedTokens.getSopTokens();
 145 | *   |         uint256 totalLength = whitelistedTokens.length + sopTokens.length;
 146 | *   |         tokens = new address[](totalLength);
 147 |     | 
 148 | *   |         for (uint256 i = 0; i < whitelistedTokens.length; i++) {
 149 | *   |             tokens[i] = whitelistedTokens[i];
 150 |     |         }
 151 |     | 
 152 | *   |         for (uint256 i = 0; i < sopTokens.length; i++) {
 153 | *   |             tokens[whitelistedTokens.length + i] = sopTokens[i];
 154 |     |         }
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @notice Get the Beanstalk balance of an ERC20 token.
 159 |     |      */
 160 | *   |     function getTokenBalances(
 161 |     |         address[] memory tokens
 162 | *   |     ) internal view returns (uint256[] memory balances) {
 163 | *   |         balances = new uint256[](tokens.length);
 164 | *   |         for (uint256 i; i < tokens.length; i++) {
 165 | *   |             balances[i] = IERC20(tokens[i]).balanceOf(address(this));
 166 |     |         }
 167 |     |         return balances;
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @notice Get protocol level entitlements and balances for all tokens.
 172 |     |      */
 173 | *   |     function getTokenEntitlementsAndBalances(
 174 |     |         address[] memory tokens
 175 | *   |     ) internal view returns (uint256[] memory entitlements, uint256[] memory balances) {
 176 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 177 | *   |         entitlements = new uint256[](tokens.length);
 178 | *   |         balances = new uint256[](tokens.length);
 179 |     | 
 180 | *   |         for (uint256 i; i < tokens.length; i++) {
 181 | *   |             entitlements[i] =
 182 | *   |                 s.sys.silo.balances[tokens[i]].deposited +
 183 | *   |                 s.sys.silo.germinating[GerminationSide.ODD][tokens[i]].amount +
 184 | *   |                 s.sys.silo.germinating[GerminationSide.EVEN][tokens[i]].amount +
 185 | *   |                 s.sys.internalTokenBalanceTotal[IERC20(tokens[i])];
 186 | *   |             if (tokens[i] == s.sys.bean) {
 187 | *   |                 entitlements[i] += s.sys.orderLockedBeans;
 188 | *   |                 for (uint256 j; j < s.sys.fieldCount; j++) {
 189 |     |                     // Unharvested harvestable beans.
 190 | *   |                     entitlements[i] += (s.sys.fields[j].harvestable - s.sys.fields[j].harvested);
 191 |     |                 }
 192 |     |             }
 193 | *   |             entitlements[i] += s.sys.sop.plentyPerSopToken[tokens[i]];
 194 | *   |             balances[i] = IERC20(tokens[i]).balanceOf(address(this));
 195 |     |         }
 196 | *   |         return (entitlements, balances);
 197 |     |     }
 198 |     | }
 199 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {AppStorage} from "./storage/AppStorage.sol";
  6 |     | import {C} from "contracts/C.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title Variation of Oepn Zeppelins reentrant guard to include Beanstalk specific functionality.
 10 |     |  * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts%2Fsecurity%2FReentrancyGuard.sol
 11 |     |  *
 12 |     |  * The key difference between Beanstalk reentrancy and standard reentrancy is the need for Beanstalk
 13 |     |  * to be able to re-enter itself executing functions through farm-like functions. This Farm functiiionality
 14 |     |  * allows users to batch multiple Beanstalk functions into a single transaction.
 15 |     |  * Examples of Farm use can be seen in Farm, AdvancedFarm, Tractor, and PipelineConvert.
 16 |     |  * Reference _beanstalkCall() to see Farm interaction with ReentrancyGuard.
 17 |     |  **/
 18 |     | abstract contract ReentrancyGuard {
 19 |     |     AppStorage internal s;
 20 |     | 
 21 |     |     /**
 22 |     |      * @notice Verify Beanstalk is not already entered and lock entrance.
 23 |     |      * @dev Standard reentrancy is not compatible with farm-like features.
 24 |     |      */
 25 |     |     modifier nonReentrant() {
 26 | *   |         require(s.sys.reentrantStatus != C.ENTERED, "ReentrancyGuard: reentrant call");
 27 |     | 
 28 | *   |         s.sys.reentrantStatus = C.ENTERED;
 29 | *   |         _;
 30 | *   |         s.sys.reentrantStatus = C.NOT_ENTERED;
 31 |     |     }
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice Verify and lock both standard entrance and farming entrance.
 35 |     |      * @dev This modifier should be used on all functions that contain generalized Farm calls.
 36 |     |      */
 37 |     |     modifier nonReentrantFarm() {
 38 |     |         require(s.sys.farmingStatus != C.ENTERED, "ReentrancyGuard: reentrant farm call");
 39 |     |         require(s.sys.reentrantStatus != C.ENTERED, "ReentrancyGuard: reentrant call");
 40 |     | 
 41 |     |         s.sys.farmingStatus = C.ENTERED;
 42 |     |         s.sys.reentrantStatus = C.ENTERED;
 43 |     |         _;
 44 |     |         s.sys.farmingStatus = C.NOT_ENTERED;
 45 |     |         s.sys.reentrantStatus = C.NOT_ENTERED;
 46 |     |     }
 47 |     | }
 48 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/diamond/DiamondCutFacet.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | /******************************************************************************\
  7 |     | * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
  8 |     | * EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535
  9 |     | /******************************************************************************/
 10 |     | 
 11 |     | import {IDiamondCut} from "contracts/interfaces/IDiamondCut.sol";
 12 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
 13 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
 14 |     | 
 15 | *   | contract DiamondCutFacet is Invariable, IDiamondCut {
 16 |     |     /// @notice Add/replace/remove any number of functions and optionally execute
 17 |     |     ///         a function with delegatecall
 18 |     |     /// @param _diamondCut Contains the facet addresses and function selectors
 19 |     |     /// @param _init The address of the contract or facet to execute _calldata
 20 |     |     /// @param _calldata A function call, including function selector and arguments
 21 |     |     ///                  _calldata is executed with delegatecall on _init
 22 | *   |     function diamondCut(
 23 |     |         FacetCut[] calldata _diamondCut,
 24 |     |         address _init,
 25 |     |         bytes calldata _calldata
 26 |     |     ) external override {
 27 | *   |         LibDiamond.enforceIsContractOwner();
 28 | *   |         LibDiamond.diamondCut(_diamondCut, _init, _calldata);
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/diamond/DiamondLoupeFacet.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | /******************************************************************************\
  7 |     | * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
  8 |     | * EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535
  9 |     | /******************************************************************************/
 10 |     | 
 11 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
 12 |     | import {IDiamondLoupe} from "contracts/interfaces/IDiamondLoupe.sol";
 13 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
 14 |     | 
 15 | *   | contract DiamondLoupeFacet is IDiamondLoupe, IERC165 {
 16 |     |     // Diamond Loupe Functions
 17 |     |     ////////////////////////////////////////////////////////////////////
 18 |     |     /// These functions are expected to be called frequently by tools.
 19 |     |     //
 20 |     |     // struct Facet {
 21 |     |     //     address facetAddress;
 22 |     |     //     bytes4[] functionSelectors;
 23 |     |     // }
 24 |     | 
 25 |     |     /// @notice Gets all facets and their selectors.
 26 |     |     /// @return facets_ Facet
 27 |     |     function facets() external view override returns (Facet[] memory facets_) {
 28 |     |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 29 |     |         uint256 numFacets = ds.facetAddresses.length;
 30 |     |         facets_ = new Facet[](numFacets);
 31 |     |         for (uint256 i; i < numFacets; i++) {
 32 |     |             address facetAddress_ = ds.facetAddresses[i];
 33 |     |             facets_[i].facetAddress = facetAddress_;
 34 |     |             facets_[i].functionSelectors = ds
 35 |     |                 .facetFunctionSelectors[facetAddress_]
 36 |     |                 .functionSelectors;
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     /// @notice Gets all the function selectors provided by a facet.
 41 |     |     /// @param _facet The facet address.
 42 |     |     /// @return facetFunctionSelectors_
 43 |     |     function facetFunctionSelectors(
 44 |     |         address _facet
 45 |     |     ) external view override returns (bytes4[] memory facetFunctionSelectors_) {
 46 |     |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 47 |     |         facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;
 48 |     |     }
 49 |     | 
 50 |     |     /// @notice Get all the facet addresses used by a diamond.
 51 |     |     /// @return facetAddresses_
 52 |     |     function facetAddresses() external view override returns (address[] memory facetAddresses_) {
 53 |     |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 54 |     |         facetAddresses_ = ds.facetAddresses;
 55 |     |     }
 56 |     | 
 57 |     |     /// @notice Gets the facet that supports the given selector.
 58 |     |     /// @dev If facet is not found return address(0).
 59 |     |     /// @param _functionSelector The function selector.
 60 |     |     /// @return facetAddress_ The facet address.
 61 |     |     function facetAddress(
 62 |     |         bytes4 _functionSelector
 63 |     |     ) external view override returns (address facetAddress_) {
 64 |     |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 65 |     |         facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;
 66 |     |     }
 67 |     | 
 68 |     |     // This implements ERC-165.
 69 |     |     function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {
 70 |     |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 71 |     |         return ds.supportedInterfaces[_interfaceId];
 72 |     |     }
 73 |     | }
 74 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/diamond/OwnershipFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  6 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  7 |     | 
  8 | *   | contract OwnershipFacet {
  9 |     |     AppStorage internal s;
 10 |     | 
 11 |     |     function transferOwnership(address _newOwner) external {
 12 |     |         LibDiamond.enforceIsContractOwner();
 13 |     |         s.sys.ownerCandidate = _newOwner;
 14 |     |     }
 15 |     | 
 16 |     |     function claimOwnership() external {
 17 |     |         require(s.sys.ownerCandidate == msg.sender, "Ownership: Not candidate");
 18 |     |         LibDiamond.setContractOwner(msg.sender);
 19 |     |         delete s.sys.ownerCandidate;
 20 |     |     }
 21 |     | 
 22 |     |     function owner() external view returns (address owner_) {
 23 |     |         owner_ = LibDiamond.contractOwner();
 24 |     |     }
 25 |     | 
 26 |     |     function ownerCandidate() external view returns (address ownerCandidate_) {
 27 |     |         ownerCandidate_ = s.sys.ownerCandidate;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/diamond/PauseFacet.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  8 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  9 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @title Pause Facet handles the pausing/unpausing of Beanstalk.
 13 |     |  **/
 14 | *   | contract PauseFacet {
 15 |     |     AppStorage internal s;
 16 |     | 
 17 |     |     using LibRedundantMath256 for uint256;
 18 |     | 
 19 |     |     event Pause(uint256 timestamp);
 20 |     |     event Unpause(uint256 timestamp, uint256 timePassed);
 21 |     | 
 22 |     |     /**
 23 |     |      * Pause / Unpause
 24 |     |      **/
 25 |     | 
 26 |     |     function pause() external payable {
 27 |     |         LibDiamond.enforceIsOwnerOrContract();
 28 |     |         require(!s.sys.paused, "Pause: already paused.");
 29 |     |         s.sys.paused = true;
 30 |     |         s.sys.pausedAt = uint128(block.timestamp);
 31 |     |         emit Pause(block.timestamp);
 32 |     |     }
 33 |     | 
 34 |     |     function unpause() external payable {
 35 |     |         LibDiamond.enforceIsOwnerOrContract();
 36 |     |         require(s.sys.paused, "Pause: not paused.");
 37 |     |         s.sys.paused = false;
 38 |     |         uint256 timePassed = block.timestamp.sub(uint256(s.sys.pausedAt));
 39 |     |         timePassed = (timePassed.div(3600).add(1)).mul(3600);
 40 |     |         s.sys.season.start = s.sys.season.start.add(timePassed);
 41 |     |         emit Unpause(block.timestamp, timePassed);
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/farm/DepotFacet.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "contracts/interfaces/IPipeline.sol";
  8 |     | import "contracts/libraries/LibFunction.sol";
  9 |     | import "contracts/libraries/Token/LibEth.sol";
 10 |     | import {C} from "contracts/C.sol";
 11 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
 12 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
 13 |     | 
 14 |     | /**
 15 |     |  * @title Depot Facet
 16 |     |  * @notice DepotFacet wraps Pipeline's Pipe functions to facilitate the loading of non-Ether assets in Pipeline
 17 |     |  * in the same transaction that loads Ether, Pipes calls to other protocols and unloads Pipeline.
 18 |     |  **/
 19 |     | 
 20 | *   | contract DepotFacet is Invariable, ReentrancyGuard {
 21 |     |     /**
 22 |     |      * @notice Pipe a PipeCall through Pipeline.
 23 |     |      * @param p PipeCall to pipe through Pipeline
 24 |     |      * @return result PipeCall return value
 25 |     |      **/
 26 |     |     function pipe(
 27 |     |         PipeCall calldata p
 28 |     |     ) external payable fundsSafu noSupplyIncrease returns (bytes memory result) {
 29 |     |         result = C.pipeline().pipe(p);
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Pipe multiple PipeCalls through Pipeline.
 34 |     |      * Does not support sending Ether in the call
 35 |     |      * @param pipes list of PipeCalls to pipe through Pipeline
 36 |     |      * @return results list of return values from each PipeCall
 37 |     |      **/
 38 |     |     function multiPipe(
 39 |     |         PipeCall[] calldata pipes
 40 |     |     ) external payable fundsSafu noSupplyIncrease returns (bytes[] memory results) {
 41 |     |         results = C.pipeline().multiPipe(pipes);
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @notice Pipe multiple AdvancedPipeCalls through Pipeline.
 46 |     |      * @param pipes list of AdvancedPipeCalls to pipe through Pipeline
 47 |     |      * @return results list of return values from each AdvancedPipeCall
 48 |     |      **/
 49 |     |     function advancedPipe(
 50 |     |         AdvancedPipeCall[] calldata pipes,
 51 |     |         uint256 value
 52 |     |     ) external payable fundsSafu noSupplyIncrease returns (bytes[] memory results) {
 53 |     |         results = C.pipeline().advancedPipe{value: value}(pipes);
 54 |     |         LibEth.refundEth();
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @notice Pipe a PipeCall through Pipeline with an Ether value.
 59 |     |      * @param p PipeCall to pipe through Pipeline
 60 |     |      * @param value Ether value to send in Pipecall
 61 |     |      * @return result PipeCall return value
 62 |     |      **/
 63 |     |     function etherPipe(
 64 |     |         PipeCall calldata p,
 65 |     |         uint256 value
 66 |     |     ) external payable fundsSafu noSupplyIncrease returns (bytes memory result) {
 67 |     |         result = C.pipeline().pipe{value: value}(p);
 68 |     |         LibEth.refundEth();
 69 |     |     }
 70 |     | 
 71 |     |     /**
 72 |     |      * @notice Return the return value of a PipeCall without executing it.
 73 |     |      * @param p PipeCall to execute with a staticcall
 74 |     |      * @return result PipeCall return value
 75 |     |      **/
 76 |     |     function readPipe(PipeCall calldata p) external view returns (bytes memory result) {
 77 |     |         bool success;
 78 |     |         // Use a static call to ensure no state modification
 79 |     |         (success, result) = p.target.staticcall(p.data);
 80 |     |         LibFunction.checkReturn(success, result);
 81 |     |     }
 82 |     | }
 83 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/farm/FarmFacet.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  8 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  9 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
 10 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
 11 |     | import {LibEth} from "contracts/libraries/Token/LibEth.sol";
 12 |     | import {AdvancedFarmCall, LibFarm} from "contracts/libraries/LibFarm.sol";
 13 |     | import {LibFunction} from "contracts/libraries/LibFunction.sol";
 14 |     | 
 15 |     | /**
 16 |     |  * @title Farm Facet
 17 |     |  * @notice Perform multiple Beanstalk functions calls in a single transaction using Farm calls.
 18 |     |  * Any function stored in Beanstalk's EIP-2535 DiamondStorage can be called as a Farm call. (https://eips.ethereum.org/EIPS/eip-2535)
 19 |     |  **/
 20 |     | 
 21 | *   | contract FarmFacet is Invariable, ReentrancyGuard {
 22 |     |     /**
 23 |     |      * @notice Execute multiple Farm calls.
 24 |     |      * @param data The encoded function data for each of the calls
 25 |     |      * @return results The return data from each of the calls
 26 |     |      **/
 27 |     |     function farm(
 28 |     |         bytes[] calldata data
 29 |     |     ) external payable fundsSafu nonReentrantFarm returns (bytes[] memory results) {
 30 |     |         results = new bytes[](data.length);
 31 |     |         for (uint256 i; i < data.length; ++i) {
 32 |     |             results[i] = LibFarm._farm(data[i]);
 33 |     |         }
 34 |     |         LibEth.refundEth();
 35 |     |     }
 36 |     | 
 37 |     |     /**
 38 |     |      * @notice Execute multiple AdvancedFarmCalls.
 39 |     |      * @param data The encoded function data for each of the calls to make to this contract
 40 |     |      * See LibFunction.buildAdvancedCalldata for details on advanced data
 41 |     |      * @return results The results from each of the calls passed in via data
 42 |     |      **/
 43 |     |     function advancedFarm(
 44 |     |         AdvancedFarmCall[] calldata data
 45 |     |     ) external payable fundsSafu nonReentrantFarm returns (bytes[] memory results) {
 46 |     |         results = new bytes[](data.length);
 47 |     |         for (uint256 i = 0; i < data.length; ++i) {
 48 |     |             results[i] = LibFarm._advancedFarm(data[i], results);
 49 |     |         }
 50 |     |         LibEth.refundEth();
 51 |     |     }
 52 |     | }
 53 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/farm/TokenFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
   9 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  10 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  11 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  12 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  13 |     | import {LibWeth} from "contracts/libraries/Token/LibWeth.sol";
  14 |     | import {LibEth} from "contracts/libraries/Token/LibEth.sol";
  15 |     | import {LibTokenApprove} from "contracts/libraries/Token/LibTokenApprove.sol";
  16 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  17 |     | import {LibBalance} from "contracts/libraries/Token/LibBalance.sol";
  18 |     | import {IERC1155Receiver} from "contracts/interfaces/IERC1155Receiver.sol";
  19 |     | 
  20 |     | /**
  21 |     |  * @title TokenFacet handles transfers of assets
  22 |     |  */
  23 | *   | contract TokenFacet is Invariable, IERC1155Receiver, ReentrancyGuard {
  24 |     |     struct Balance {
  25 |     |         uint256 internalBalance;
  26 |     |         uint256 externalBalance;
  27 |     |         uint256 totalBalance;
  28 |     |     }
  29 |     | 
  30 |     |     using SafeERC20 for IERC20;
  31 |     |     using LibRedundantMath256 for uint256;
  32 |     | 
  33 |     |     //////////////////////// Transfer ////////////////////////
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice transfers a token from user to `recipient`.
  37 |     |      * @dev enables transfers between internal and external balances.
  38 |     |      *
  39 |     |      * @param token The token to transfer.
  40 |     |      * @param recipient The recipient of the transfer.
  41 |     |      * @param amount The amount to transfer.
  42 |     |      * @param fromMode The source of token from the sender. See {LibTransfer.From}.
  43 |     |      * @param toMode The destination of token to the recipient. See {LibTransfer.To}.
  44 |     |      */
  45 |     |     function transferToken(
  46 |     |         IERC20 token,
  47 |     |         address recipient,
  48 |     |         uint256 amount,
  49 |     |         LibTransfer.From fromMode,
  50 |     |         LibTransfer.To toMode
  51 |     |     ) external payable fundsSafu noSupplyChange oneOutFlow(address(token)) nonReentrant {
  52 |     |         LibTransfer.transferToken(token, LibTractor._user(), recipient, amount, fromMode, toMode);
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice transfers a token from `sender` to an `recipient` from Internal balance.
  57 |     |      * @dev differs from transferToken as sender != user.
  58 |     |      */
  59 |     |     function transferInternalTokenFrom(
  60 |     |         IERC20 token,
  61 |     |         address sender,
  62 |     |         address recipient,
  63 |     |         uint256 amount,
  64 |     |         LibTransfer.To toMode
  65 |     |     ) external payable fundsSafu noSupplyChange oneOutFlow(address(token)) nonReentrant {
  66 |     |         LibTransfer.transferToken(
  67 |     |             token,
  68 |     |             sender,
  69 |     |             recipient,
  70 |     |             amount,
  71 |     |             LibTransfer.From.INTERNAL,
  72 |     |             toMode
  73 |     |         );
  74 |     | 
  75 |     |         if (sender != LibTractor._user()) {
  76 |     |             LibTokenApprove.spendAllowance(sender, LibTractor._user(), token, amount);
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 |     |     //////////////////////// Transfer ////////////////////////
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice approves a token for a spender.
  84 |     |      * @dev this approves a token for both internal and external balances.
  85 |     |      */
  86 |     |     function approveToken(
  87 |     |         address spender,
  88 |     |         IERC20 token,
  89 |     |         uint256 amount
  90 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
  91 |     |         LibTokenApprove.approve(LibTractor._user(), spender, token, amount);
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice increases approval for a token for a spender.
  96 |     |      */
  97 |     |     function increaseTokenAllowance(
  98 |     |         address spender,
  99 |     |         IERC20 token,
 100 |     |         uint256 addedValue
 101 |     |     ) public virtual fundsSafu noNetFlow noSupplyChange nonReentrant returns (bool) {
 102 |     |         LibTokenApprove.approve(
 103 |     |             LibTractor._user(),
 104 |     |             spender,
 105 |     |             token,
 106 |     |             LibTokenApprove.allowance(LibTractor._user(), spender, token).add(addedValue)
 107 |     |         );
 108 |     |         return true;
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice decreases approval for a token for a spender.
 113 |     |      */
 114 |     |     function decreaseTokenAllowance(
 115 |     |         address spender,
 116 |     |         IERC20 token,
 117 |     |         uint256 subtractedValue
 118 |     |     ) public virtual fundsSafu noNetFlow noSupplyChange nonReentrant returns (bool) {
 119 |     |         uint256 currentAllowance = LibTokenApprove.allowance(LibTractor._user(), spender, token);
 120 |     |         require(currentAllowance >= subtractedValue, "Silo: decreased allowance below zero");
 121 |     |         LibTokenApprove.approve(
 122 |     |             LibTractor._user(),
 123 |     |             spender,
 124 |     |             token,
 125 |     |             currentAllowance.sub(subtractedValue)
 126 |     |         );
 127 |     |         return true;
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice returns the allowance for a token for a spender.
 132 |     |      */
 133 |     |     function tokenAllowance(
 134 |     |         address account,
 135 |     |         address spender,
 136 |     |         IERC20 token
 137 |     |     ) public view virtual returns (uint256) {
 138 |     |         return LibTokenApprove.allowance(account, spender, token);
 139 |     |     }
 140 |     | 
 141 |     |     //////////////////////// ERC1155Receiver ////////////////////////
 142 |     | 
 143 |     |     /**
 144 |     |      * @notice ERC1155Receiver function that allows the silo to receive ERC1155 tokens.
 145 |     |      *
 146 |     |      * @dev as ERC1155 deposits are not accepted yet,
 147 |     |      * this function will revert.
 148 |     |      */
 149 |     |     function onERC1155Received(
 150 |     |         address,
 151 |     |         address,
 152 |     |         uint256,
 153 |     |         uint256,
 154 |     |         bytes calldata
 155 |     |     ) external pure override returns (bytes4) {
 156 |     |         revert("Silo: ERC1155 deposits are not accepted yet.");
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @notice onERC1155BatchReceived function that allows the silo to receive ERC1155 tokens.
 161 |     |      *
 162 |     |      * @dev as ERC1155 deposits are not accepted yet,
 163 |     |      * this function will revert.
 164 |     |      */
 165 |     |     function onERC1155BatchReceived(
 166 |     |         address,
 167 |     |         address,
 168 |     |         uint256[] calldata,
 169 |     |         uint256[] calldata,
 170 |     |         bytes calldata
 171 |     |     ) external pure override returns (bytes4) {
 172 |     |         revert("Silo: ERC1155 deposits are not accepted yet.");
 173 |     |     }
 174 |     | 
 175 |     |     //////////////////////// WETH ////////////////////////
 176 |     | 
 177 |     |     /**
 178 |     |      * @notice wraps ETH into WETH.
 179 |     |      */
 180 |     |     function wrapEth(
 181 |     |         uint256 amount,
 182 |     |         LibTransfer.To mode
 183 |     |     ) external payable nonReentrant fundsSafu noOutFlow noSupplyChange {
 184 |     |         LibWeth.wrap(amount, mode);
 185 |     |         LibEth.refundEth();
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @notice unwraps WETH into ETH.
 190 |     |      */
 191 |     |     function unwrapEth(
 192 |     |         uint256 amount,
 193 |     |         LibTransfer.From mode
 194 |     |     ) external payable nonReentrant fundsSafu oneOutFlow(LibWeth.WETH) noSupplyChange {
 195 |     |         LibWeth.unwrap(amount, mode);
 196 |     |     }
 197 |     | 
 198 |     |     //////////////////////// GETTERS ////////////////////////
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice returns the internal balance of a token for an account.
 202 |     |      */
 203 |     |     function getInternalBalance(
 204 |     |         address account,
 205 |     |         IERC20 token
 206 |     |     ) public view returns (uint256 balance) {
 207 |     |         balance = LibBalance.getInternalBalance(account, token);
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice returns the internal balances of tokens for an account.
 212 |     |      */
 213 |     |     function getInternalBalances(
 214 |     |         address account,
 215 |     |         IERC20[] memory tokens
 216 |     |     ) external view returns (uint256[] memory balances) {
 217 |     |         balances = new uint256[](tokens.length);
 218 |     |         for (uint256 i; i < tokens.length; ++i) {
 219 |     |             balances[i] = getInternalBalance(account, tokens[i]);
 220 |     |         }
 221 |     |     }
 222 |     | 
 223 |     |     // External
 224 |     | 
 225 |     |     /**
 226 |     |      * @notice returns the external balance of a token for an account.
 227 |     |      */
 228 |     |     function getExternalBalance(
 229 |     |         address account,
 230 |     |         IERC20 token
 231 |     |     ) public view returns (uint256 balance) {
 232 |     |         balance = token.balanceOf(account);
 233 |     |     }
 234 |     | 
 235 |     |     /**
 236 |     |      * @notice returns the external balances of tokens for an account.
 237 |     |      */
 238 |     |     function getExternalBalances(
 239 |     |         address account,
 240 |     |         IERC20[] memory tokens
 241 |     |     ) external view returns (uint256[] memory balances) {
 242 |     |         balances = new uint256[](tokens.length);
 243 |     |         for (uint256 i; i < tokens.length; ++i) {
 244 |     |             balances[i] = getExternalBalance(account, tokens[i]);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @notice returns the total balance (internal and external)
 250 |     |      * of a token
 251 |     |      */
 252 |     |     function getBalance(address account, IERC20 token) public view returns (uint256 balance) {
 253 |     |         balance = LibBalance.getBalance(account, token);
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @notice returns the total balances (internal and external)
 258 |     |      * of a token for an account.
 259 |     |      */
 260 |     |     function getBalances(
 261 |     |         address account,
 262 |     |         IERC20[] memory tokens
 263 |     |     ) external view returns (uint256[] memory balances) {
 264 |     |         balances = new uint256[](tokens.length);
 265 |     |         for (uint256 i; i < tokens.length; ++i) {
 266 |     |             balances[i] = getBalance(account, tokens[i]);
 267 |     |         }
 268 |     |     }
 269 |     | 
 270 |     |     /**
 271 |     |      * @notice returns the total balance (internal and external)
 272 |     |      * of a token, in a balance struct (internal, external, total).
 273 |     |      */
 274 |     |     function getAllBalance(address account, IERC20 token) public view returns (Balance memory b) {
 275 |     |         b.internalBalance = getInternalBalance(account, token);
 276 |     |         b.externalBalance = getExternalBalance(account, token);
 277 |     |         b.totalBalance = b.internalBalance.add(b.externalBalance);
 278 |     |     }
 279 |     | 
 280 |     |     /**
 281 |     |      * @notice returns the total balance (internal and external)
 282 |     |      * of a token, in a balance struct (internal, external, total).
 283 |     |      */
 284 |     |     function getAllBalances(
 285 |     |         address account,
 286 |     |         IERC20[] memory tokens
 287 |     |     ) external view returns (Balance[] memory balances) {
 288 |     |         balances = new Balance[](tokens.length);
 289 |     |         for (uint256 i; i < tokens.length; ++i) {
 290 |     |             balances[i] = getAllBalance(account, tokens[i]);
 291 |     |         }
 292 |     |     }
 293 |     | }
 294 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/farm/TokenSupportFacet.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
  8 |     | import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
  9 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
 10 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
 11 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
 12 |     | 
 13 |     | /**
 14 |     |  * @title TokenSupportFacet
 15 |     |  * @notice Transfer ERC-721 and ERC-1155 tokens.
 16 |     |  * @dev To transfer ERC-20 tokens, use {TokenFacet.transferToken}.
 17 |     |  **/
 18 |     | 
 19 | *   | contract TokenSupportFacet is Invariable, ReentrancyGuard {
 20 |     |     /**
 21 |     |      *
 22 |     |      * ERC-721
 23 |     |      *
 24 |     |      **/
 25 |     | 
 26 |     |     /**
 27 |     |      * @notice Execute an ERC-721 token transfer
 28 |     |      * @dev Wraps {IERC721-safeBatchTransferFrom}.
 29 |     |      **/
 30 |     |     function transferERC721(
 31 |     |         IERC721 token,
 32 |     |         address to,
 33 |     |         uint256 id
 34 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 35 |     |         token.safeTransferFrom(LibTractor._user(), to, id);
 36 |     |     }
 37 |     | 
 38 |     |     /**
 39 |     |      *
 40 |     |      * ERC-1155
 41 |     |      *
 42 |     |      **/
 43 |     | 
 44 |     |     /**
 45 |     |      * @notice Execute an ERC-1155 token transfer of a single Id.
 46 |     |      * @dev Wraps {IERC1155-safeTransferFrom}.
 47 |     |      **/
 48 |     |     function transferERC1155(
 49 |     |         IERC1155 token,
 50 |     |         address to,
 51 |     |         uint256 id,
 52 |     |         uint256 value
 53 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 54 |     |         token.safeTransferFrom(LibTractor._user(), to, id, value, new bytes(0));
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @notice Execute an ERC-1155 token transfer of multiple Ids.
 59 |     |      * @dev Wraps {IERC1155-safeBatchTransferFrom}.
 60 |     |      **/
 61 |     |     function batchTransferERC1155(
 62 |     |         IERC1155 token,
 63 |     |         address to,
 64 |     |         uint256[] calldata ids,
 65 |     |         uint256[] calldata values
 66 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 67 |     |         token.safeBatchTransferFrom(LibTractor._user(), to, ids, values, new bytes(0));
 68 |     |     }
 69 |     | }
 70 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/farm/TractorFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
   8 |     | import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
   9 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  10 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  11 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  12 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  13 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  14 |     | import {AdvancedFarmCall, LibFarm} from "contracts/libraries/LibFarm.sol";
  15 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  16 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  17 |     | import {LibTransfer, IERC20} from "contracts/libraries/Token/LibTransfer.sol";
  18 |     | 
  19 |     | /**
  20 |     |  * @title TractorFacet handles tractor and blueprint operations.
  21 |     |  */
  22 | *   | contract TractorFacet is Invariable, ReentrancyGuard {
  23 |     |     using LibBytes for bytes32;
  24 |     |     using LibRedundantMath256 for uint256;
  25 |     | 
  26 |     |     event PublishRequisition(LibTractor.Requisition requisition);
  27 |     | 
  28 |     |     event CancelBlueprint(bytes32 indexed blueprintHash);
  29 |     | 
  30 |     |     event Tractor(
  31 |     |         address indexed operator,
  32 |     |         address indexed publisher,
  33 |     |         bytes32 indexed blueprintHash,
  34 |     |         uint256 nonce,
  35 |     |         uint256 gasleft
  36 |     |     );
  37 |     | 
  38 |     |     event TractorExecutionBegan(
  39 |     |         address indexed operator,
  40 |     |         address indexed publisher,
  41 |     |         bytes32 indexed blueprintHash,
  42 |     |         uint256 nonce,
  43 |     |         uint256 gasleft
  44 |     |     );
  45 |     | 
  46 |     |     /**
  47 |     |      * @notice Ensure requisition hash matches blueprint data and signer is publisher.
  48 |     |      */
  49 |     |     modifier verifyRequisition(LibTractor.Requisition calldata requisition) {
  50 |     |         bytes32 blueprintHash = LibTractor._getBlueprintHash(requisition.blueprint);
  51 |     |         require(blueprintHash == requisition.blueprintHash, "TractorFacet: invalid hash");
  52 |     |         address signer = ECDSA.recover(requisition.blueprintHash, requisition.signature);
  53 |     |         require(signer == requisition.blueprint.publisher, "TractorFacet: signer mismatch");
  54 |     |         _;
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice Verify nonce and time are acceptable, increment nonce, set publisher, clear publisher.
  59 |     |      */
  60 |     |     modifier runBlueprint(LibTractor.Requisition calldata requisition) {
  61 |     |         uint256 nonce = LibTractor._getBlueprintNonce(requisition.blueprintHash);
  62 |     |         require(nonce < requisition.blueprint.maxNonce, "TractorFacet: maxNonce reached");
  63 |     |         require(
  64 |     |             requisition.blueprint.startTime <= block.timestamp &&
  65 |     |                 block.timestamp <= requisition.blueprint.endTime,
  66 |     |             "TractorFacet: blueprint is not active"
  67 |     |         );
  68 |     | 
  69 |     |         emit TractorExecutionBegan(
  70 |     |             msg.sender,
  71 |     |             requisition.blueprint.publisher,
  72 |     |             requisition.blueprintHash,
  73 |     |             nonce,
  74 |     |             gasleft()
  75 |     |         );
  76 |     | 
  77 |     |         LibTractor._incrementBlueprintNonce(requisition.blueprintHash);
  78 |     |         LibTractor._setPublisher(payable(requisition.blueprint.publisher));
  79 |     |         _;
  80 |     |         LibTractor._resetPublisher();
  81 |     |         emit Tractor(
  82 |     |             msg.sender,
  83 |     |             requisition.blueprint.publisher,
  84 |     |             requisition.blueprintHash,
  85 |     |             nonce,
  86 |     |             gasleft()
  87 |     |         );
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Updates the tractor version used for EIP712 signatures.
  92 |     |      * @dev This function will render all existing blueprints invalid.
  93 |     |      */
  94 |     |     function updateTractorVersion(
  95 |     |         string calldata version
  96 |     |     ) external fundsSafu noNetFlow noSupplyChange nonReentrant {
  97 |     |         LibDiamond.enforceIsContractOwner();
  98 |     |         LibTractor._setVersion(version);
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @notice Get the current tractor version.
 103 |     |      * @dev Only blueprints using the current version can be run.
 104 |     |      */
 105 |     |     function getTractorVersion() external view returns (string memory) {
 106 |     |         return LibTractor._tractorStorage().version;
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @notice Publish a new blueprint by emitting its data in an event.
 111 |     |      */
 112 |     |     function publishRequisition(
 113 |     |         LibTractor.Requisition calldata requisition
 114 |     |     ) external fundsSafu noNetFlow noSupplyChange verifyRequisition(requisition) nonReentrant {
 115 |     |         require(
 116 |     |             LibTractor._getBlueprintNonce(requisition.blueprintHash) <
 117 |     |                 requisition.blueprint.maxNonce,
 118 |     |             "TractorFacet: maxNonce reached"
 119 |     |         );
 120 |     |         emit PublishRequisition(requisition);
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Destroy existing blueprint
 125 |     |      */
 126 |     |     function cancelBlueprint(
 127 |     |         LibTractor.Requisition calldata requisition
 128 |     |     ) external fundsSafu noNetFlow noSupplyChange verifyRequisition(requisition) nonReentrant {
 129 |     |         require(msg.sender == requisition.blueprint.publisher, "TractorFacet: not publisher");
 130 |     |         LibTractor._cancelBlueprint(requisition.blueprintHash);
 131 |     |         emit CancelBlueprint(requisition.blueprintHash);
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Execute a Tractor blueprint as an operator.
 136 |     |      */
 137 |     |     function tractor(
 138 |     |         LibTractor.Requisition calldata requisition,
 139 |     |         bytes memory operatorData
 140 |     |     )
 141 |     |         external
 142 |     |         payable
 143 |     |         fundsSafu
 144 |     |         nonReentrantFarm
 145 |     |         verifyRequisition(requisition)
 146 |     |         runBlueprint(requisition)
 147 |     |         returns (bytes[] memory results)
 148 |     |     {
 149 |     |         require(requisition.blueprint.data.length > 0, "Tractor: data empty");
 150 |     | 
 151 |     |         // Set current blueprint hash
 152 |     |         LibTractor._setCurrentBlueprintHash(requisition.blueprintHash);
 153 |     | 
 154 |     |         // Set operator
 155 |     |         LibTractor._setOperator(msg.sender);
 156 |     | 
 157 |     |         // Decode and execute advanced farm calls.
 158 |     |         // Cut out blueprint calldata selector.
 159 |     |         AdvancedFarmCall[] memory calls = abi.decode(
 160 |     |             LibBytes.sliceFrom(requisition.blueprint.data, 4),
 161 |     |             (AdvancedFarmCall[])
 162 |     |         );
 163 |     | 
 164 |     |         // Update data with operator-defined fillData.
 165 |     |         for (uint256 i; i < requisition.blueprint.operatorPasteInstrs.length; ++i) {
 166 |     |             bytes32 operatorPasteInstr = requisition.blueprint.operatorPasteInstrs[i];
 167 |     |             uint80 pasteCallIndex = operatorPasteInstr.getIndex1();
 168 |     |             require(calls.length > pasteCallIndex, "Tractor: pasteCallIndex OOB");
 169 |     | 
 170 |     |             LibBytes.pasteBytesTractor(
 171 |     |                 operatorPasteInstr,
 172 |     |                 operatorData,
 173 |     |                 calls[pasteCallIndex].callData
 174 |     |             );
 175 |     |         }
 176 |     | 
 177 |     |         results = new bytes[](calls.length);
 178 |     |         for (uint256 i = 0; i < calls.length; ++i) {
 179 |     |             require(calls[i].callData.length != 0, "Tractor: empty AdvancedFarmCall");
 180 |     |             results[i] = LibFarm._advancedFarm(calls[i], results);
 181 |     |         }
 182 |     | 
 183 |     |         // Clear current blueprint hash
 184 |     |         LibTractor._resetCurrentBlueprintHash();
 185 |     | 
 186 |     |         // Clear operator
 187 |     |         LibTractor._resetOperator();
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @notice Transfers a token from `msg.sender` to a `recipient` from the External balance.
 192 |     |      * @dev When any function is called via Tractor (e.g., from a blueprint), the protocol substitutes
 193 |     |      * the blueprint publisher as the sender instead of the actual caller.
 194 |     |      *
 195 |     |      * Some contracts within a blueprint may need to transfer ERC-20 tokens to an address's
 196 |     |      * internal balance (e.g., to deposit into the Silo or to sow into the Field).
 197 |     |      * This function facilitates such transfers.
 198 |     |      *
 199 |     |      * Tractor operators should be cautious when using this function, as it may result in
 200 |     |      * funds being withdrawn from their wallet. To mitigate risks, operators should ensure that:
 201 |     |      * 1) No ERC-20 permissions are granted to the Beanstalk contract, and/or
 202 |     |      * 2) This function is not exploited maliciously.
 203 |     |      *
 204 |     |      * Operators can check for this function in bytecode via the selector (0xca1e71ae)
 205 |     |      */
 206 |     |     function sendTokenToInternalBalance(
 207 |     |         IERC20 token,
 208 |     |         address recipient,
 209 |     |         uint256 amount
 210 |     |     ) external payable fundsSafu noSupplyChange noOutFlow nonReentrant {
 211 |     |         LibTransfer.transferToken(
 212 |     |             token,
 213 |     |             msg.sender,
 214 |     |             recipient,
 215 |     |             amount,
 216 |     |             LibTransfer.From.EXTERNAL,
 217 |     |             LibTransfer.To.INTERNAL
 218 |     |         );
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @notice Get current counter value for any account.
 223 |     |      * @dev Intended for external access.
 224 |     |      * @return count Counter value
 225 |     |      */
 226 |     |     function getCounter(address account, bytes32 counterId) external view returns (uint256 count) {
 227 |     |         return LibTractor._tractorStorage().blueprintCounters[account][counterId];
 228 |     |     }
 229 |     | 
 230 |     |     /**
 231 |     |      * @notice Get current counter value.
 232 |     |      * @dev Intended for access via Tractor farm call. QoL function.
 233 |     |      * @return count Counter value
 234 |     |      */
 235 |     |     function getPublisherCounter(bytes32 counterId) public view returns (uint256 count) {
 236 |     |         return
 237 |     |             LibTractor._tractorStorage().blueprintCounters[
 238 |     |                 LibTractor._tractorStorage().activePublisher
 239 |     |             ][counterId];
 240 |     |     }
 241 |     | 
 242 |     |     /**
 243 |     |      * @notice Update counter value.
 244 |     |      * @dev Intended for use via Tractor farm call.
 245 |     |      * @return count New value of counter
 246 |     |      */
 247 |     |     function updatePublisherCounter(
 248 |     |         bytes32 counterId,
 249 |     |         LibTractor.CounterUpdateType updateType,
 250 |     |         uint256 amount
 251 |     |     ) external fundsSafu noNetFlow noSupplyChange nonReentrant returns (uint256 count) {
 252 |     |         uint256 newCount;
 253 |     |         if (updateType == LibTractor.CounterUpdateType.INCREASE) {
 254 |     |             newCount = getPublisherCounter(counterId).add(amount);
 255 |     |         } else if (updateType == LibTractor.CounterUpdateType.DECREASE) {
 256 |     |             newCount = getPublisherCounter(counterId).sub(amount);
 257 |     |         }
 258 |     |         LibTractor._tractorStorage().blueprintCounters[
 259 |     |             LibTractor._tractorStorage().activePublisher
 260 |     |         ][counterId] = newCount;
 261 |     |         return newCount;
 262 |     |     }
 263 |     | 
 264 |     |     /**
 265 |     |      * @notice Get current blueprint nonce.
 266 |     |      * @return nonce current blueprint nonce
 267 |     |      */
 268 |     |     function getBlueprintNonce(bytes32 blueprintHash) external view returns (uint256) {
 269 |     |         return LibTractor._getBlueprintNonce(blueprintHash);
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @notice Get EIP712 compliant hash of the blueprint.
 274 |     |      * @return hash Hash of Blueprint
 275 |     |      */
 276 |     |     function getBlueprintHash(
 277 |     |         LibTractor.Blueprint calldata blueprint
 278 |     |     ) external view returns (bytes32) {
 279 |     |         return LibTractor._getBlueprintHash(blueprint);
 280 |     |     }
 281 |     | 
 282 |     |     /**
 283 |     |      * @notice Get the hash of the currently executing blueprint
 284 |     |      * @return The current blueprint hash
 285 |     |      */
 286 |     |     function getCurrentBlueprintHash() external view returns (bytes32) {
 287 |     |         return LibTractor._getCurrentBlueprintHash();
 288 |     |     }
 289 |     | 
 290 |     |     /**
 291 |     |      * @notice Get the user context for tractor operations.
 292 |     |      * @return user Current user, either active publisher or msg.sender
 293 |     |      */
 294 |     |     function tractorUser() external view returns (address payable) {
 295 |     |         return LibTractor._user();
 296 |     |     }
 297 |     | 
 298 |     |     function operator() external view returns (address) {
 299 |     |         return LibTractor._getOperator();
 300 |     |     }
 301 |     | }
 302 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/field/FieldFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
   9 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  10 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  11 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
  12 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  13 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  14 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  15 |     | import {LibDibbler} from "contracts/libraries/LibDibbler.sol";
  16 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  17 |     | import {LibMarket} from "contracts/libraries/LibMarket.sol";
  18 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  19 |     | 
  20 |     | interface IBeanstalk {
  21 |     |     function cancelPodListing(uint256 fieldId, uint256 index) external;
  22 |     | }
  23 |     | 
  24 |     | /**
  25 |     |  * @title FieldFacet
  26 |     |  * @notice The Field is where Beans are Sown and Pods are Harvested.
  27 |     |  */
  28 | *   | contract FieldFacet is Invariable, ReentrancyGuard {
  29 |     |     using LibRedundantMath256 for uint256;
  30 |     |     using LibRedundantMath32 for uint32;
  31 |     |     using LibRedundantMath128 for uint128;
  32 |     | 
  33 |     |     /**
  34 |     |      * @notice Plot struct contains the plot index and amount of pods the plot contains.
  35 |     |      */
  36 |     |     struct Plot {
  37 |     |         uint256 index;
  38 |     |         uint256 pods;
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Emitted when a new Field is added.
  43 |     |      * @param fieldId The index of the Field that was added.
  44 |     |      */
  45 |     |     event FieldAdded(uint256 fieldId);
  46 |     | 
  47 |     |     /**
  48 |     |      * @notice Emitted when the active Field is modified.
  49 |     |      * @param fieldId The index of the Field that was set to active.
  50 |     |      */
  51 |     |     event ActiveFieldSet(uint256 fieldId);
  52 |     | 
  53 |     |     /**
  54 |     |      * @notice Emitted when `account` claims the Beans associated with Harvestable Pods.
  55 |     |      * @param account The account that owns the `plots`
  56 |     |      * @param plots The indices of Plots that were harvested
  57 |     |      * @param beans The amount of Beans transferred to `account`
  58 |     |      */
  59 |     |     event Harvest(address indexed account, uint256 fieldId, uint256[] plots, uint256 beans);
  60 |     | 
  61 |     |     //////////////////// SOW ////////////////////
  62 |     | 
  63 |     |     /**
  64 |     |      * @notice Sow Beans in exchange for Pods.
  65 |     |      * @param beans The number of Beans to Sow
  66 |     |      * @param minTemperature The minimum Temperature at which to Sow
  67 |     |      * @param mode The balance to transfer Beans from; see {LibTransfer.From}
  68 |     |      * @return pods The number of Pods received
  69 |     |      * @dev
  70 |     |      *
  71 |     |      * `minTemperature` has precision of 1e6. Wraps {sowWithMin} with `minSoil = beans`.
  72 |     |      *
  73 |     |      * NOTE: previously minTemperature was measured to 1e2 (1% = 1)
  74 |     |      *
  75 |     |      * Rationale for {sow} accepting a `minTemperature` parameter:
  76 |     |      * If someone sends a Sow transaction at the end of a Season, it could be
  77 |     |      * executed early in the following Season, at which time the temperature may be
  78 |     |      * significantly lower due to Morning Auction functionality.
  79 |     |      */
  80 |     |     function sow(
  81 |     |         uint256 beans,
  82 |     |         uint256 minTemperature,
  83 |     |         LibTransfer.From mode
  84 |     |     )
  85 |     |         external
  86 |     |         payable
  87 |     |         fundsSafu
  88 |     |         noSupplyIncrease
  89 |     |         oneOutFlow(s.sys.bean)
  90 |     |         nonReentrant
  91 |     |         returns (uint256 pods)
  92 |     |     {
  93 |     |         return LibDibbler.sowWithMin(beans, minTemperature, beans, mode);
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice Sow Beans in exchange for Pods. Use at least `minSoil`.
  98 |     |      * @param beans The number of Beans to Sow
  99 |     |      * @param minTemperature The minimum Temperature at which to Sow
 100 |     |      * @param minSoil The minimum amount of Soil to use; reverts if there is
 101 |     |      * less than this much Soil available upon execution
 102 |     |      * @param mode The balance to transfer Beans from; see {LibTrasfer.From}
 103 |     |      * @return pods The number of Pods received
 104 |     |      */
 105 |     |     function sowWithMin(
 106 |     |         uint256 beans,
 107 |     |         uint256 minTemperature,
 108 |     |         uint256 minSoil,
 109 |     |         LibTransfer.From mode
 110 |     |     )
 111 |     |         external
 112 |     |         payable
 113 |     |         fundsSafu
 114 |     |         noSupplyIncrease
 115 |     |         oneOutFlow(s.sys.bean)
 116 |     |         nonReentrant
 117 |     |         returns (uint256 pods)
 118 |     |     {
 119 |     |         return LibDibbler.sowWithMin(beans, minTemperature, minSoil, mode);
 120 |     |     }
 121 |     | 
 122 |     |     //////////////////// HARVEST ////////////////////
 123 |     | 
 124 |     |     /**
 125 |     |      * @notice Harvest Pods from the Field.
 126 |     |      * @param fieldId The index of the Field to Harvest from.
 127 |     |      * @param plots List of plot IDs to Harvest
 128 |     |      * @param mode The balance to transfer Beans to; see {LibTrasfer.To}
 129 |     |      * @dev Redeems Pods for Beans. When Pods become Harvestable, they are
 130 |     |      * redeemable for 1 Bean each.
 131 |     |      *
 132 |     |      * The Beans used to pay Harvestable Pods are minted during {Sun.stepSun}.
 133 |     |      * Beanstalk holds these Beans until `harvest()` is called.
 134 |     |      *
 135 |     |      * Pods are "burned" when the corresponding Plot is deleted from
 136 |     |      * `s.accts[account].fields[fieldId].plots`.
 137 |     |      */
 138 |     |     function harvest(
 139 |     |         uint256 fieldId,
 140 |     |         uint256[] calldata plots,
 141 |     |         LibTransfer.To mode
 142 |     |     )
 143 |     |         external
 144 |     |         payable
 145 |     |         fundsSafu
 146 |     |         noSupplyChange
 147 |     |         oneOutFlow(s.sys.bean)
 148 |     |         nonReentrant
 149 |     |         returns (uint256 beansHarvested)
 150 |     |     {
 151 |     |         beansHarvested = _harvest(fieldId, plots);
 152 |     |         LibTransfer.sendToken(BeanstalkERC20(s.sys.bean), beansHarvested, LibTractor._user(), mode);
 153 |     |     }
 154 |     | 
 155 |     |     /**
 156 |     |      * @dev Ensure that each Plot is at least partially harvestable, burn the Plot,
 157 |     |      * update the total harvested, and emit a {Harvest} event.
 158 |     |      */
 159 |     |     function _harvest(
 160 |     |         uint256 fieldId,
 161 |     |         uint256[] calldata plots
 162 |     |     ) internal returns (uint256 beansHarvested) {
 163 |     |         for (uint256 i; i < plots.length; ++i) {
 164 |     |             // The Plot is partially harvestable if its index is less than
 165 |     |             // the current harvestable index.
 166 |     |             require(plots[i] < s.sys.fields[fieldId].harvestable, "Field: Plot not Harvestable");
 167 |     |             uint256 harvested = _harvestPlot(LibTractor._user(), fieldId, plots[i]);
 168 |     |             beansHarvested += harvested;
 169 |     |         }
 170 |     |         s.sys.fields[fieldId].harvested += beansHarvested;
 171 |     |         emit Harvest(LibTractor._user(), fieldId, plots, beansHarvested);
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Check if a Plot is at least partially Harvestable; calculate how many
 176 |     |      * Pods are Harvestable, create a new Plot if necessary.
 177 |     |      */
 178 |     |     function _harvestPlot(
 179 |     |         address account,
 180 |     |         uint256 fieldId,
 181 |     |         uint256 index
 182 |     |     ) private returns (uint256 harvestablePods) {
 183 |     |         // Check that `account` holds this Plot.
 184 |     |         uint256 pods = s.accts[account].fields[fieldId].plots[index];
 185 |     |         require(pods > 0, "Field: no plot");
 186 |     | 
 187 |     |         // Calculate how many Pods are harvestable.
 188 |     |         // The upstream _harvest function checks that at least some Pods
 189 |     |         // are harvestable.
 190 |     |         harvestablePods = s.sys.fields[fieldId].harvestable.sub(index);
 191 |     | 
 192 |     |         LibMarket._cancelPodListing(LibTractor._user(), fieldId, index);
 193 |     | 
 194 |     |         delete s.accts[account].fields[fieldId].plots[index];
 195 |     |         LibDibbler.removePlotIndexFromAccount(account, fieldId, index);
 196 |     | 
 197 |     |         // If the entire Plot was harvested, exit.
 198 |     |         if (harvestablePods >= pods) {
 199 |     |             return pods;
 200 |     |         }
 201 |     | 
 202 |     |         // Create a new Plot with remaining Pods.
 203 |     |         uint256 newIndex = index.add(harvestablePods);
 204 |     |         s.accts[account].fields[fieldId].plots[newIndex] = pods.sub(harvestablePods);
 205 |     |         s.accts[account].fields[fieldId].plotIndexes.push(newIndex);
 206 |     |         s.accts[account].fields[fieldId].piIndex[newIndex] =
 207 |     |             s.accts[account].fields[fieldId].plotIndexes.length -
 208 |     |             1;
 209 |     |     }
 210 |     | 
 211 |     |     //////////////////// CONFIG /////////////////////
 212 |     | 
 213 |     |     /**
 214 |     |      * @notice Add a new Field to the system.
 215 |     |      * @dev It is not possible to remove a Field, but a Field's Plan can be nullified.
 216 |     |      */
 217 | *   |     function addField() public fundsSafu noSupplyChange noNetFlow nonReentrant {
 218 | *   |         LibDiamond.enforceIsOwnerOrContract();
 219 | *   |         uint256 fieldId = s.sys.fieldCount;
 220 | *   |         s.sys.fieldCount++;
 221 | *   |         emit FieldAdded(fieldId);
 222 |     |     }
 223 |     | 
 224 |     |     /**
 225 |     |      * @notice Set the active Field. Only the active field is accrues Soil.
 226 |     |      * @param fieldId ID of the Field to set as active. ID is the Field Number.
 227 |     |      */
 228 | *   |     function setActiveField(
 229 |     |         uint256 fieldId,
 230 |     |         uint32 _temperature
 231 |     |     ) public fundsSafu noSupplyChange noNetFlow nonReentrant {
 232 | *   |         LibDiamond.enforceIsOwnerOrContract();
 233 | *   |         require(fieldId < s.sys.fieldCount, "Field: Field does not exist");
 234 | *   |         s.sys.activeField = fieldId;
 235 |     | 
 236 |     |         // Reset weather.
 237 | *   |         s.sys.weather.temp = _temperature;
 238 | *   |         s.sys.weather.thisSowTime = type(uint32).max;
 239 | *   |         s.sys.weather.lastSowTime = type(uint32).max;
 240 | *   |         s.sys.weather.lastDeltaSoil = 0;
 241 |     | 
 242 | *   |         emit ActiveFieldSet(fieldId);
 243 |     |     }
 244 |     | 
 245 |     |     //////////////////// GETTERS ////////////////////
 246 |     | 
 247 |     |     /**
 248 |     |      * @notice Returns the total number of Pods ever minted in the Field.
 249 |     |      * @param fieldId The index of the Field to query.
 250 |     |      */
 251 |     |     function podIndex(uint256 fieldId) public view returns (uint256) {
 252 |     |         return s.sys.fields[fieldId].pods;
 253 |     |     }
 254 |     | 
 255 |     |     /**
 256 |     |      * @notice Returns the index below which Pods are Harvestable.
 257 |     |      * @param fieldId The index of the Field to query.
 258 |     |      */
 259 |     |     function harvestableIndex(uint256 fieldId) public view returns (uint256) {
 260 |     |         return s.sys.fields[fieldId].harvestable;
 261 |     |     }
 262 |     | 
 263 |     |     /**
 264 |     |      * @notice Returns the number of outstanding Pods. Includes Pods that are
 265 |     |      * currently Harvestable but have not yet been Harvested.
 266 |     |      * @param fieldId The index of the Field to query.
 267 |     |      */
 268 |     |     function totalPods(uint256 fieldId) public view returns (uint256) {
 269 |     |         return s.sys.fields[fieldId].pods - s.sys.fields[fieldId].harvested;
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @notice Returns the number of Pods that have ever been Harvested.
 274 |     |      * @param fieldId The index of the Field to query.
 275 |     |      */
 276 |     |     function totalHarvested(uint256 fieldId) public view returns (uint256) {
 277 |     |         return s.sys.fields[fieldId].harvested;
 278 |     |     }
 279 |     | 
 280 |     |     /**
 281 |     |      * @notice Returns the number of Pods that are currently Harvestable but
 282 |     |      * have not yet been Harvested.
 283 |     |      * @dev This is the number of Pods that Beanstalk is prepared to pay back,
 284 |     |      * but that haven’t yet been claimed via the `harvest()` function.
 285 |     |      * @param fieldId The index of the Field to query.
 286 |     |      */
 287 |     |     function totalHarvestable(uint256 fieldId) public view returns (uint256) {
 288 |     |         return s.sys.fields[fieldId].harvestable - s.sys.fields[fieldId].harvested;
 289 |     |     }
 290 |     | 
 291 |     |     /**
 292 |     |      * @notice Returns the number of Pods that are currently Harvestable for the active Field.
 293 |     |      */
 294 |     |     function totalHarvestableForActiveField() public view returns (uint256) {
 295 |     |         return
 296 |     |             s.sys.fields[s.sys.activeField].harvestable - s.sys.fields[s.sys.activeField].harvested;
 297 |     |     }
 298 |     | 
 299 |     |     /**
 300 |     |      * @notice Returns the number of Pods that are not yet Harvestable. Also known as the Pod Line.
 301 |     |      * @param fieldId The index of the Field to query.
 302 |     |      */
 303 |     |     function totalUnharvestable(uint256 fieldId) public view returns (uint256) {
 304 |     |         return s.sys.fields[fieldId].pods - s.sys.fields[fieldId].harvestable;
 305 |     |     }
 306 |     | 
 307 |     |     /**
 308 |     |      * @notice Returns the number of Pods that are not yet Harvestable for the active Field.
 309 |     |      */
 310 |     |     function totalUnharvestableForActiveField() public view returns (uint256) {
 311 |     |         return s.sys.fields[s.sys.activeField].pods - s.sys.fields[s.sys.activeField].harvestable;
 312 |     |     }
 313 |     | 
 314 |     |     /**
 315 |     |      * @notice Returns the number of Pods that were made Harvestable during the last Season as a result of flooding.
 316 |     |      */
 317 |     |     function floodHarvestablePods() public view returns (uint256) {
 318 |     |         return s.sys.rain.floodHarvestablePods;
 319 |     |     }
 320 |     | 
 321 |     |     /**
 322 |     |      * @notice Returns true if there exists un-harvestable pods.
 323 |     |      * @param fieldId The index of the Field to query.
 324 |     |      */
 325 |     |     function isHarvesting(uint256 fieldId) public view returns (bool) {
 326 |     |         return totalUnharvestable(fieldId) > 0;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @notice Returns the number of Pods remaining in a Plot.
 331 |     |      * @dev Plots are only stored in the `s.accts[account].fields[fieldId].plots` mapping.
 332 |     |      * @param fieldId The index of the Field to query.
 333 |     |      */
 334 |     |     function plot(address account, uint256 fieldId, uint256 index) public view returns (uint256) {
 335 |     |         return s.accts[account].fields[fieldId].plots[index];
 336 |     |     }
 337 |     | 
 338 |     |     function activeField() public view returns (uint256) {
 339 |     |         return s.sys.activeField;
 340 |     |     }
 341 |     | 
 342 |     |     function fieldCount() public view returns (uint256) {
 343 |     |         return s.sys.fieldCount;
 344 |     |     }
 345 |     | 
 346 |     |     //////////////////// GETTERS: SOIL ////////////////////
 347 |     | 
 348 |     |     /**
 349 |     |      * @notice Returns the total amount of available Soil. 1 Bean can be Sown in
 350 |     |      * 1 Soil for Pods.
 351 |     |      * @dev When above peg, Soil is dynamic because the number of Pods that
 352 |     |      * Beanstalk is willing to mint is fixed.
 353 |     |      */
 354 |     |     function totalSoil() external view returns (uint256) {
 355 |     |         // Below peg: Soil is fixed to the amount set during {calcCaseId}.
 356 |     |         if (!s.sys.season.abovePeg) {
 357 |     |             return uint256(s.sys.soil);
 358 |     |         }
 359 |     | 
 360 |     |         // Above peg: Soil is dynamic
 361 |     |         return
 362 |     |             LibDibbler.scaleSoilUp(
 363 |     |                 uint256(s.sys.soil), // min soil
 364 |     |                 uint256(s.sys.weather.temp), // max temperature (1e6 precision)
 365 |     |                 LibDibbler.morningTemperature() // temperature adjusted by number of blocks since Sunrise
 366 |     |             );
 367 |     |     }
 368 |     | 
 369 |     |     function initialSoil() external view returns (uint256) {
 370 |     |         return uint256(s.sys.soil);
 371 |     |     }
 372 |     | 
 373 |     |     //////////////////// GETTERS: TEMPERATURE ////////////////////
 374 |     | 
 375 |     |     /**
 376 |     |      * @notice Returns the current Temperature, the interest rate offered by Beanstalk.
 377 |     |      * The Temperature scales up during the first 25 blocks after Sunrise.
 378 |     |      */
 379 |     |     function temperature() external view returns (uint256) {
 380 |     |         return LibDibbler.morningTemperature();
 381 |     |     }
 382 |     | 
 383 |     |     /**
 384 |     |      * @notice Returns the max Temperature that Beanstalk is willing to offer this Season.
 385 |     |      * @dev For gas efficiency, Beanstalk stores `s.sys.weather.temp` as a uint32 with precision of 1e6.
 386 |     |      */
 387 |     |     function maxTemperature() external view returns (uint256) {
 388 |     |         return uint256(s.sys.weather.temp);
 389 |     |     }
 390 |     | 
 391 |     |     //////////////////// GETTERS: PODS ////////////////////
 392 |     | 
 393 |     |     /**
 394 |     |      * @notice Returns the remaining Pods that could be issued this Season.
 395 |     |      */
 396 |     |     function remainingPods() external view returns (uint256) {
 397 |     |         return uint256(LibDibbler.remainingPods());
 398 |     |     }
 399 |     | 
 400 |     |     /**
 401 |     |      * @notice returns the plotIndexes owned by `account`.
 402 |     |      */
 403 |     |     function getPlotIndexesFromAccount(
 404 |     |         address account,
 405 |     |         uint256 fieldId
 406 |     |     ) external view returns (uint256[] memory plotIndexes) {
 407 |     |         return s.accts[account].fields[fieldId].plotIndexes;
 408 |     |     }
 409 |     | 
 410 |     |     /**
 411 |     |      * @notice returns the plots owned by `account`.
 412 |     |      */
 413 |     |     function getPlotsFromAccount(
 414 |     |         address account,
 415 |     |         uint256 fieldId
 416 |     |     ) external view returns (Plot[] memory plots) {
 417 |     |         uint256[] memory plotIndexes = s.accts[account].fields[fieldId].plotIndexes;
 418 |     |         if (plotIndexes.length == 0) return plots;
 419 |     |         plots = new Plot[](plotIndexes.length);
 420 |     |         for (uint256 i = 0; i < plotIndexes.length; i++) {
 421 |     |             uint256 index = plotIndexes[i];
 422 |     |             plots[i] = Plot(index, s.accts[account].fields[fieldId].plots[index]);
 423 |     |         }
 424 |     |     }
 425 |     | 
 426 |     |     /**
 427 |     |      * @notice returns the number of pods owned by `account` in a field.
 428 |     |      */
 429 |     |     function balanceOfPods(address account, uint256 fieldId) external view returns (uint256 pods) {
 430 |     |         uint256[] memory plotIndexes = s.accts[account].fields[fieldId].plotIndexes;
 431 |     |         for (uint256 i = 0; i < plotIndexes.length; i++) {
 432 |     |             pods += s.accts[account].fields[fieldId].plots[plotIndexes[i]];
 433 |     |         }
 434 |     |     }
 435 |     | }
 436 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/market/MarketplaceFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Order} from "./abstract/Order.sol";
   8 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
   9 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  10 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  11 |     | import {LibMarket} from "contracts/libraries/LibMarket.sol";
  12 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  13 |     | 
  14 |     | /**
  15 |     |  **/
  16 |     | 
  17 | *   | contract MarketplaceFacet is Invariable, Order {
  18 |     |     /*
  19 |     |      * Pod Listing
  20 |     |      */
  21 |     | 
  22 |     |     function createPodListing(
  23 |     |         PodListing calldata podListing
  24 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
  25 |     |         require(podListing.lister == LibTractor._user(), "Marketplace: Non-user create listing.");
  26 |     |         _createPodListing(podListing);
  27 |     |     }
  28 |     | 
  29 |     |     // Fill
  30 |     |     function fillPodListing(
  31 |     |         PodListing calldata podListing,
  32 |     |         uint256 beanAmount,
  33 |     |         LibTransfer.From mode
  34 |     |     ) external payable fundsSafu noSupplyChange oneOutFlow(s.sys.bean) nonReentrant {
  35 |     |         beanAmount = LibTransfer.transferToken(
  36 |     |             BeanstalkERC20(s.sys.bean),
  37 |     |             LibTractor._user(),
  38 |     |             podListing.lister,
  39 |     |             beanAmount,
  40 |     |             mode,
  41 |     |             podListing.mode
  42 |     |         );
  43 |     |         _fillListing(podListing, LibTractor._user(), beanAmount);
  44 |     |     }
  45 |     | 
  46 |     |     // Cancel
  47 |     |     function cancelPodListing(
  48 |     |         uint256 fieldId,
  49 |     |         uint256 index
  50 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
  51 |     |         LibMarket._cancelPodListing(LibTractor._user(), fieldId, index);
  52 |     |     }
  53 |     | 
  54 |     |     function getPodListing(uint256 fieldId, uint256 index) external view returns (bytes32 id) {
  55 |     |         return s.sys.podListings[fieldId][index];
  56 |     |     }
  57 |     | 
  58 |     |     /*
  59 |     |      * Pod Orders
  60 |     |      */
  61 |     | 
  62 |     |     // Create
  63 |     |     function createPodOrder(
  64 |     |         PodOrder calldata podOrder,
  65 |     |         uint256 beanAmount,
  66 |     |         LibTransfer.From mode
  67 |     |     ) external payable fundsSafu noSupplyChange noOutFlow nonReentrant returns (bytes32 id) {
  68 |     |         require(podOrder.orderer == LibTractor._user(), "Marketplace: Non-user create order.");
  69 |     |         beanAmount = LibTransfer.receiveToken(
  70 |     |             BeanstalkERC20(s.sys.bean),
  71 |     |             beanAmount,
  72 |     |             LibTractor._user(),
  73 |     |             mode
  74 |     |         );
  75 |     |         return _createPodOrder(podOrder, beanAmount);
  76 |     |     }
  77 |     | 
  78 |     |     // Fill
  79 |     |     function fillPodOrder(
  80 |     |         PodOrder calldata podOrder,
  81 |     |         uint256 index,
  82 |     |         uint256 start,
  83 |     |         uint256 amount,
  84 |     |         LibTransfer.To mode
  85 |     |     ) external payable fundsSafu noSupplyChange oneOutFlow(s.sys.bean) nonReentrant {
  86 |     |         _fillPodOrder(podOrder, LibTractor._user(), index, start, amount, mode);
  87 |     |     }
  88 |     | 
  89 |     |     // Cancel
  90 |     |     function cancelPodOrder(
  91 |     |         PodOrder calldata podOrder,
  92 |     |         LibTransfer.To mode
  93 |     |     ) external payable fundsSafu noSupplyChange oneOutFlow(s.sys.bean) nonReentrant {
  94 |     |         require(podOrder.orderer == LibTractor._user(), "Marketplace: Non-user cancel order.");
  95 |     |         _cancelPodOrder(podOrder, mode);
  96 |     |     }
  97 |     | 
  98 |     |     // Get
  99 |     | 
 100 |     |     function getOrderId(PodOrder calldata podOrder) external pure returns (bytes32 id) {
 101 |     |         return _getOrderId(podOrder);
 102 |     |     }
 103 |     | 
 104 |     |     function getPodOrder(bytes32 id) external view returns (uint256) {
 105 |     |         return s.sys.podOrders[id];
 106 |     |     }
 107 |     | 
 108 |     |     /*
 109 |     |      * Transfer Plot
 110 |     |      */
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice transfers a plot from `sender` to `recipient`.
 114 |     |      */
 115 |     |     function transferPlot(
 116 |     |         address sender,
 117 |     |         address recipient,
 118 |     |         uint256 fieldId,
 119 |     |         uint256 index,
 120 |     |         uint256 start,
 121 |     |         uint256 end
 122 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 123 |     |         require(
 124 |     |             sender != address(0) && recipient != address(0),
 125 |     |             "Field: Transfer to/from 0 address."
 126 |     |         );
 127 |     |         uint256 transferAmount = validatePlotAndReturnPods(fieldId, sender, index, start, end);
 128 |     |         if (
 129 |     |             LibTractor._user() != sender &&
 130 |     |             allowancePods(sender, LibTractor._user(), fieldId) != type(uint256).max
 131 |     |         ) {
 132 |     |             decrementAllowancePods(sender, LibTractor._user(), fieldId, transferAmount);
 133 |     |         }
 134 |     | 
 135 |     |         if (s.sys.podListings[fieldId][index] != bytes32(0)) {
 136 |     |             LibMarket._cancelPodListing(sender, fieldId, index);
 137 |     |         }
 138 |     |         _transferPlot(sender, recipient, fieldId, index, start, transferAmount);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @notice transfers multiple plots from `sender` to `recipient`.
 143 |     |      */
 144 |     |     function transferPlots(
 145 |     |         address sender,
 146 |     |         address recipient,
 147 |     |         uint256 fieldId,
 148 |     |         uint256[] calldata ids,
 149 |     |         uint256[] calldata starts,
 150 |     |         uint256[] calldata ends
 151 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 152 |     |         require(
 153 |     |             sender != address(0) && recipient != address(0),
 154 |     |             "Field: Transfer to/from 0 address."
 155 |     |         );
 156 |     |         require(
 157 |     |             ids.length == starts.length && ids.length == ends.length,
 158 |     |             "Field: Array length mismatch."
 159 |     |         );
 160 |     |         uint256 totalAmount = _transferPlots(sender, recipient, fieldId, ids, starts, ends);
 161 |     | 
 162 |     |         // Decrement allowance is done on totalAmount rather than per plot.
 163 |     |         if (
 164 |     |             LibTractor._user() != sender &&
 165 |     |             allowancePods(sender, LibTractor._user(), fieldId) != type(uint256).max
 166 |     |         ) {
 167 |     |             decrementAllowancePods(sender, LibTractor._user(), totalAmount, fieldId);
 168 |     |         }
 169 |     |     }
 170 |     | 
 171 |     |     /**
 172 |     |      * @notice internal function to transfer multiple plots from `sender` to `recipient`.
 173 |     |      * @dev placed in a function due to stack.
 174 |     |      */
 175 |     |     function _transferPlots(
 176 |     |         address sender,
 177 |     |         address recipient,
 178 |     |         uint256 fieldId,
 179 |     |         uint256[] calldata ids,
 180 |     |         uint256[] calldata starts,
 181 |     |         uint256[] calldata ends
 182 |     |     ) internal returns (uint256 totalAmount) {
 183 |     |         for (uint256 i; i < ids.length; i++) {
 184 |     |             uint256 amount = validatePlotAndReturnPods(fieldId, sender, ids[i], starts[i], ends[i]);
 185 |     |             if (s.sys.podListings[fieldId][ids[i]] != bytes32(0)) {
 186 |     |                 LibMarket._cancelPodListing(sender, fieldId, ids[i]);
 187 |     |             }
 188 |     |             _transferPlot(sender, recipient, fieldId, ids[i], starts[i], amount);
 189 |     |             totalAmount += amount;
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice validates the plot is valid and returns the pod being sent.
 195 |     |      */
 196 |     |     function validatePlotAndReturnPods(
 197 |     |         uint256 fieldId,
 198 |     |         address sender,
 199 |     |         uint256 id,
 200 |     |         uint256 start,
 201 |     |         uint256 end
 202 |     |     ) internal view returns (uint256 amount) {
 203 |     |         amount = s.accts[sender].fields[fieldId].plots[id];
 204 |     |         require(amount > 0, "Field: Plot not owned by user.");
 205 |     |         require(end > start && amount >= end, "Field: Pod range invalid.");
 206 |     |         amount = end - start;
 207 |     |     }
 208 |     | 
 209 |     |     /**
 210 |     |      * @notice Approves pods to be spent by `spender`.
 211 |     |      */
 212 |     |     function approvePods(
 213 |     |         address spender,
 214 |     |         uint256 fieldId,
 215 |     |         uint256 amount
 216 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 217 |     |         require(spender != address(0), "Field: Pod Approve to 0 address.");
 218 |     |         setAllowancePods(LibTractor._user(), spender, fieldId, amount);
 219 |     |         emit PodApproval(LibTractor._user(), spender, fieldId, amount);
 220 |     |     }
 221 |     | }
 222 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/market/abstract/Listing.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {PodTransfer} from "./PodTransfer.sol";
   8 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
   9 |     | import {LibMarket} from "contracts/libraries/LibMarket.sol";
  10 |     | 
  11 |     | abstract contract Listing is PodTransfer {
  12 |     |     struct PodListing {
  13 |     |         address lister;
  14 |     |         uint256 fieldId;
  15 |     |         uint256 index;
  16 |     |         uint256 start;
  17 |     |         uint256 podAmount;
  18 |     |         uint24 pricePerPod;
  19 |     |         uint256 maxHarvestableIndex;
  20 |     |         uint256 minFillAmount;
  21 |     |         LibTransfer.To mode;
  22 |     |     }
  23 |     | 
  24 |     |     event PodListingCreated(
  25 |     |         address indexed lister,
  26 |     |         uint256 fieldId,
  27 |     |         uint256 index,
  28 |     |         uint256 start,
  29 |     |         uint256 podAmount,
  30 |     |         uint24 pricePerPod,
  31 |     |         uint256 maxHarvestableIndex,
  32 |     |         uint256 minFillAmount,
  33 |     |         LibTransfer.To mode
  34 |     |     );
  35 |     | 
  36 |     |     event PodListingFilled(
  37 |     |         address indexed filler,
  38 |     |         address indexed lister,
  39 |     |         uint256 fieldId,
  40 |     |         uint256 index,
  41 |     |         uint256 start,
  42 |     |         uint256 podAmount,
  43 |     |         uint256 costInBeans
  44 |     |     );
  45 |     | 
  46 |     |     /*
  47 |     |      * Create
  48 |     |      */
  49 |     | 
  50 |     |     function _createPodListing(PodListing calldata podListing) internal {
  51 |     |         uint256 plotSize = s.accts[podListing.lister].fields[podListing.fieldId].plots[
  52 |     |             podListing.index
  53 |     |         ];
  54 |     | 
  55 |     |         require(podListing.podAmount > 0, "Marketplace: Invalid Amount.");
  56 |     |         require(
  57 |     |             plotSize >= (podListing.start + podListing.podAmount),
  58 |     |             "Marketplace: Invalid Plot."
  59 |     |         );
  60 |     |         require(podListing.pricePerPod > 0, "Marketplace: Pod price must be greater than 0.");
  61 |     |         require(
  62 |     |             s.sys.fields[podListing.fieldId].harvestable <= podListing.maxHarvestableIndex,
  63 |     |             "Marketplace: Expired."
  64 |     |         );
  65 |     |         require(
  66 |     |             podListing.minFillAmount <= podListing.podAmount,
  67 |     |             "Marketplace: minFillAmount must be <= podAmount."
  68 |     |         );
  69 |     | 
  70 |     |         if (s.sys.podListings[podListing.fieldId][podListing.index] != bytes32(0))
  71 |     |             LibMarket._cancelPodListing(podListing.lister, podListing.fieldId, podListing.index);
  72 |     | 
  73 |     |         s.sys.podListings[podListing.fieldId][podListing.index] = _hashListing(podListing);
  74 |     | 
  75 |     |         emit PodListingCreated(
  76 |     |             podListing.lister,
  77 |     |             podListing.fieldId,
  78 |     |             podListing.index,
  79 |     |             podListing.start,
  80 |     |             podListing.podAmount,
  81 |     |             podListing.pricePerPod,
  82 |     |             podListing.maxHarvestableIndex,
  83 |     |             podListing.minFillAmount,
  84 |     |             podListing.mode
  85 |     |         );
  86 |     |     }
  87 |     | 
  88 |     |     /*
  89 |     |      * Fill
  90 |     |      */
  91 |     | 
  92 |     |     function _fillListing(
  93 |     |         PodListing calldata podListing,
  94 |     |         address filler,
  95 |     |         uint256 beanPayAmount
  96 |     |     ) internal {
  97 |     |         require(
  98 |     |             s.sys.podListings[podListing.fieldId][podListing.index] == _hashListing(podListing),
  99 |     |             "Marketplace: Listing does not exist."
 100 |     |         );
 101 |     |         uint256 plotSize = s.accts[podListing.lister].fields[podListing.fieldId].plots[
 102 |     |             podListing.index
 103 |     |         ];
 104 |     |         require(podListing.podAmount > 0, "Marketplace: Invalid Amount.");
 105 |     |         require(
 106 |     |             plotSize >= (podListing.start + podListing.podAmount),
 107 |     |             "Marketplace: Invalid Plot."
 108 |     |         );
 109 |     |         require(
 110 |     |             s.sys.fields[podListing.fieldId].harvestable <= podListing.maxHarvestableIndex,
 111 |     |             "Marketplace: Listing has expired."
 112 |     |         );
 113 |     | 
 114 |     |         uint256 podReceiveAmount = (beanPayAmount * 1000000) / podListing.pricePerPod;
 115 |     |         require(
 116 |     |             podReceiveAmount <= podListing.podAmount,
 117 |     |             "Marketplace: Not enough pods in Listing."
 118 |     |         );
 119 |     | 
 120 |     |         // Round.
 121 |     |         if (podListing.podAmount - podReceiveAmount <= (1000000 / podListing.pricePerPod)) {
 122 |     |             podReceiveAmount = podListing.podAmount;
 123 |     |         }
 124 |     | 
 125 |     |         require(
 126 |     |             podReceiveAmount >= podListing.minFillAmount,
 127 |     |             "Marketplace: Fill must be >= minimum amount."
 128 |     |         );
 129 |     | 
 130 |     |         // Remove old listing and create new listing if necessary.
 131 |     |         delete s.sys.podListings[podListing.fieldId][podListing.index];
 132 |     | 
 133 |     |         if (podReceiveAmount < podListing.podAmount) {
 134 |     |             uint256 newIndex = podListing.index + podReceiveAmount + podListing.start;
 135 |     |             s.sys.podListings[podListing.fieldId][newIndex] = _hashListing(
 136 |     |                 PodListing(
 137 |     |                     podListing.lister,
 138 |     |                     podListing.fieldId,
 139 |     |                     newIndex,
 140 |     |                     0,
 141 |     |                     podListing.podAmount - podReceiveAmount,
 142 |     |                     podListing.pricePerPod,
 143 |     |                     podListing.maxHarvestableIndex,
 144 |     |                     podListing.minFillAmount,
 145 |     |                     podListing.mode
 146 |     |                 )
 147 |     |             );
 148 |     |         }
 149 |     | 
 150 |     |         emit PodListingFilled(
 151 |     |             filler,
 152 |     |             podListing.lister,
 153 |     |             podListing.fieldId,
 154 |     |             podListing.index,
 155 |     |             podListing.start,
 156 |     |             podReceiveAmount,
 157 |     |             beanPayAmount
 158 |     |         );
 159 |     | 
 160 |     |         _transferPlot(
 161 |     |             podListing.lister,
 162 |     |             filler,
 163 |     |             podListing.fieldId,
 164 |     |             podListing.index,
 165 |     |             podListing.start,
 166 |     |             podReceiveAmount
 167 |     |         );
 168 |     |     }
 169 |     | 
 170 |     |     /*
 171 |     |      * Get
 172 |     |      */
 173 |     | 
 174 |     |     function _hashListing(PodListing memory podListing) internal pure returns (bytes32 hash) {
 175 |     |         return
 176 |     |             keccak256(
 177 |     |                 abi.encodePacked(
 178 |     |                     podListing.lister,
 179 |     |                     podListing.fieldId,
 180 |     |                     podListing.index,
 181 |     |                     podListing.start,
 182 |     |                     podListing.podAmount,
 183 |     |                     podListing.pricePerPod,
 184 |     |                     podListing.maxHarvestableIndex,
 185 |     |                     podListing.minFillAmount,
 186 |     |                     podListing.mode
 187 |     |                 )
 188 |     |             );
 189 |     |     }
 190 |     | }
 191 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/market/abstract/Order.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Listing} from "./Listing.sol";
   8 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
   9 |     | import {LibMarket} from "contracts/libraries/LibMarket.sol";
  10 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  11 |     | 
  12 |     | abstract contract Order is Listing {
  13 |     |     struct PodOrder {
  14 |     |         address orderer;
  15 |     |         uint256 fieldId;
  16 |     |         uint24 pricePerPod;
  17 |     |         uint256 maxPlaceInLine;
  18 |     |         uint256 minFillAmount;
  19 |     |     }
  20 |     | 
  21 |     |     event PodOrderCreated(
  22 |     |         address indexed orderer,
  23 |     |         bytes32 id,
  24 |     |         uint256 beanAmount,
  25 |     |         uint256 fieldId,
  26 |     |         uint24 pricePerPod,
  27 |     |         uint256 maxPlaceInLine,
  28 |     |         uint256 minFillAmount
  29 |     |     );
  30 |     | 
  31 |     |     event PodOrderFilled(
  32 |     |         address indexed filler,
  33 |     |         address indexed orderer,
  34 |     |         bytes32 id,
  35 |     |         uint256 fieldId,
  36 |     |         uint256 index,
  37 |     |         uint256 start,
  38 |     |         uint256 podAmount,
  39 |     |         uint256 costInBeans
  40 |     |     );
  41 |     | 
  42 |     |     event PodOrderCancelled(address indexed orderer, bytes32 id);
  43 |     | 
  44 |     |     /*
  45 |     |      * Create
  46 |     |      */
  47 |     |     function _createPodOrder(
  48 |     |         PodOrder calldata podOrder,
  49 |     |         uint256 beanAmount
  50 |     |     ) internal returns (bytes32 id) {
  51 |     |         require(beanAmount > 0, "Marketplace: Order amount must be > 0.");
  52 |     |         require(podOrder.pricePerPod > 0, "Marketplace: Pod price must be greater than 0.");
  53 |     |         require(
  54 |     |             podOrder.minFillAmount > 0,
  55 |     |             "Marketplace: Minimum fill amount must be greater than 0."
  56 |     |         );
  57 |     | 
  58 |     |         id = _getOrderId(podOrder);
  59 |     | 
  60 |     |         if (s.sys.podOrders[id] > 0) _cancelPodOrder(podOrder, LibTransfer.To.INTERNAL);
  61 |     |         s.sys.podOrders[id] = beanAmount;
  62 |     |         s.sys.orderLockedBeans += beanAmount;
  63 |     | 
  64 |     |         emit PodOrderCreated(
  65 |     |             podOrder.orderer,
  66 |     |             id,
  67 |     |             beanAmount,
  68 |     |             podOrder.fieldId,
  69 |     |             podOrder.pricePerPod,
  70 |     |             podOrder.maxPlaceInLine,
  71 |     |             podOrder.minFillAmount
  72 |     |         );
  73 |     |     }
  74 |     | 
  75 |     |     /*
  76 |     |      * Fill
  77 |     |      * @param index The index of the plot in the order.
  78 |     |      * @dev Verification that sender == filler should be handled before calling this function.
  79 |     |      */
  80 |     |     function _fillPodOrder(
  81 |     |         PodOrder calldata podOrder,
  82 |     |         address filler,
  83 |     |         uint256 index,
  84 |     |         uint256 start,
  85 |     |         uint256 podAmount,
  86 |     |         LibTransfer.To mode
  87 |     |     ) internal {
  88 |     |         require(
  89 |     |             podAmount >= podOrder.minFillAmount,
  90 |     |             "Marketplace: Fill must be >= minimum amount."
  91 |     |         );
  92 |     |         require(
  93 |     |             s.accts[filler].fields[podOrder.fieldId].plots[index] >= (start + podAmount),
  94 |     |             "Marketplace: Invalid Plot."
  95 |     |         );
  96 |     |         require(
  97 |     |             (index + start + podAmount - s.sys.fields[podOrder.fieldId].harvestable) <=
  98 |     |                 podOrder.maxPlaceInLine,
  99 |     |             "Marketplace: Plot too far in line."
 100 |     |         );
 101 |     | 
 102 |     |         bytes32 id = _getOrderId(podOrder);
 103 |     | 
 104 |     |         uint256 costInBeans = (podAmount * podOrder.pricePerPod) / 1000000;
 105 |     |         require(costInBeans <= s.sys.podOrders[id], "Marketplace: Not enough beans in order.");
 106 |     |         s.sys.podOrders[id] = s.sys.podOrders[id] - costInBeans;
 107 |     |         s.sys.orderLockedBeans -= costInBeans;
 108 |     | 
 109 |     |         LibTransfer.sendToken(BeanstalkERC20(s.sys.bean), costInBeans, filler, mode);
 110 |     | 
 111 |     |         if (s.sys.podListings[podOrder.fieldId][index] != bytes32(0)) {
 112 |     |             LibMarket._cancelPodListing(filler, podOrder.fieldId, index);
 113 |     |         }
 114 |     | 
 115 |     |         _transferPlot(filler, podOrder.orderer, podOrder.fieldId, index, start, podAmount);
 116 |     | 
 117 |     |         if (s.sys.podOrders[id] == 0) {
 118 |     |             delete s.sys.podOrders[id];
 119 |     |         }
 120 |     | 
 121 |     |         emit PodOrderFilled(
 122 |     |             filler,
 123 |     |             podOrder.orderer,
 124 |     |             id,
 125 |     |             podOrder.fieldId,
 126 |     |             index,
 127 |     |             start,
 128 |     |             podAmount,
 129 |     |             costInBeans
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     /*
 134 |     |      * Cancel
 135 |     |      */
 136 |     |     function _cancelPodOrder(PodOrder memory podOrder, LibTransfer.To mode) internal {
 137 |     |         bytes32 id = _getOrderId(podOrder);
 138 |     |         uint256 amountBeans = s.sys.podOrders[id];
 139 |     |         s.sys.orderLockedBeans -= amountBeans;
 140 |     |         LibTransfer.sendToken(BeanstalkERC20(s.sys.bean), amountBeans, podOrder.orderer, mode);
 141 |     |         delete s.sys.podOrders[id];
 142 |     |         emit PodOrderCancelled(podOrder.orderer, id);
 143 |     |     }
 144 |     | 
 145 |     |     /*
 146 |     |      * Get
 147 |     |      */
 148 |     | 
 149 |     |     function _getOrderId(PodOrder memory podOrder) internal pure returns (bytes32 id) {
 150 |     |         return
 151 |     |             keccak256(
 152 |     |                 abi.encodePacked(
 153 |     |                     podOrder.orderer,
 154 |     |                     podOrder.fieldId,
 155 |     |                     podOrder.pricePerPod,
 156 |     |                     podOrder.maxPlaceInLine,
 157 |     |                     podOrder.minFillAmount
 158 |     |                 )
 159 |     |             );
 160 |     |     }
 161 |     | }
 162 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/market/abstract/PodTransfer.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
   9 |     | import {LibDibbler} from "contracts/libraries/LibDibbler.sol";
  10 |     | 
  11 |     | abstract contract PodTransfer is ReentrancyGuard {
  12 |     |     event PlotTransfer(
  13 |     |         address indexed from,
  14 |     |         address indexed to,
  15 |     |         uint256 fieldId,
  16 |     |         uint256 indexed index,
  17 |     |         uint256 amount
  18 |     |     );
  19 |     | 
  20 |     |     event PodApproval(
  21 |     |         address indexed owner,
  22 |     |         address indexed spender,
  23 |     |         uint256 fieldId,
  24 |     |         uint256 amount
  25 |     |     );
  26 |     | 
  27 |     |     /**
  28 |     |      * Getters
  29 |     |      **/
  30 |     | 
  31 |     |     function allowancePods(
  32 |     |         address owner,
  33 |     |         address spender,
  34 |     |         uint256 fieldId
  35 |     |     ) public view returns (uint256) {
  36 |     |         return s.accts[owner].fields[fieldId].podAllowances[spender];
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * Internal
  41 |     |      **/
  42 |     | 
  43 |     |     function _transferPlot(
  44 |     |         address from,
  45 |     |         address to,
  46 |     |         uint256 fieldId,
  47 |     |         uint256 index,
  48 |     |         uint256 start,
  49 |     |         uint256 amount
  50 |     |     ) internal {
  51 |     |         require(from != to, "Field: Cannot transfer Pods to oneself.");
  52 |     |         require(amount > 0, "Marketplace: amount must be > 0.");
  53 |     |         insertPlot(to, fieldId, index + start, amount);
  54 |     |         removePlot(from, fieldId, index, start, amount + start);
  55 |     |         emit PlotTransfer(from, to, fieldId, index + start, amount);
  56 |     |     }
  57 |     | 
  58 |     |     function insertPlot(address account, uint256 fieldId, uint256 index, uint256 amount) internal {
  59 |     |         s.accts[account].fields[fieldId].plots[index] = amount;
  60 |     |         s.accts[account].fields[fieldId].plotIndexes.push(index);
  61 |     |         s.accts[account].fields[fieldId].piIndex[index] =
  62 |     |             s.accts[account].fields[fieldId].plotIndexes.length -
  63 |     |             1;
  64 |     |     }
  65 |     | 
  66 |     |     function removePlot(
  67 |     |         address account,
  68 |     |         uint256 fieldId,
  69 |     |         uint256 index,
  70 |     |         uint256 start,
  71 |     |         uint256 end
  72 |     |     ) internal {
  73 |     |         uint256 amountAfterEnd = s.accts[account].fields[fieldId].plots[index] - end;
  74 |     | 
  75 |     |         if (start > 0) {
  76 |     |             s.accts[account].fields[fieldId].plots[index] = start;
  77 |     |         } else {
  78 |     |             delete s.accts[account].fields[fieldId].plots[index];
  79 |     |             LibDibbler.removePlotIndexFromAccount(account, fieldId, index);
  80 |     |         }
  81 |     | 
  82 |     |         if (amountAfterEnd > 0) {
  83 |     |             uint256 newIndex = index + end;
  84 |     |             s.accts[account].fields[fieldId].plots[newIndex] = amountAfterEnd;
  85 |     |             s.accts[account].fields[fieldId].plotIndexes.push(newIndex);
  86 |     |             s.accts[account].fields[fieldId].piIndex[newIndex] =
  87 |     |                 s.accts[account].fields[fieldId].plotIndexes.length -
  88 |     |                 1;
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     function decrementAllowancePods(
  93 |     |         address owner,
  94 |     |         address spender,
  95 |     |         uint256 fieldId,
  96 |     |         uint256 amount
  97 |     |     ) internal {
  98 |     |         uint256 currentAllowance = allowancePods(owner, spender, fieldId);
  99 |     |         if (currentAllowance < amount) {
 100 |     |             revert("Field: Insufficient approval.");
 101 |     |         }
 102 |     |         setAllowancePods(owner, spender, fieldId, currentAllowance - amount);
 103 |     |     }
 104 |     | 
 105 |     |     function setAllowancePods(
 106 |     |         address owner,
 107 |     |         address spender,
 108 |     |         uint256 fieldId,
 109 |     |         uint256 amount
 110 |     |     ) internal {
 111 |     |         s.accts[owner].fields[fieldId].podAllowances[spender] = amount;
 112 |     |     }
 113 |     | }
 114 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/metadata/MetadataFacet.sol
  1 |     | /*
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
  8 |     | 
  9 |     | import {MetadataImage} from "./abstract/MetadataImage.sol";
 10 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
 11 |     | import {LibBytes64} from "contracts/libraries/LibBytes64.sol";
 12 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
 13 |     | 
 14 |     | /**
 15 |     |  * @title MetadataFacet
 16 |     |  * @notice MetadataFacet is a contract that provides metadata for Pinto ERC1155 deposits,
 17 |     |  * as well as other auxiliary functions related to ERC1155 deposits.
 18 |     |  *
 19 |     |  * @dev Deposits are represented by a uint256, which is the concatination of the token address and the stem.
 20 |     |  */
 21 | *   | contract MetadataFacet is MetadataImage {
 22 |     |     using Strings for uint256;
 23 |     |     using Strings for int256;
 24 |     | 
 25 |     |     event URI(string _uri, uint256 indexed _id);
 26 |     | 
 27 |     |     /**
 28 |     |      * @notice Returns the URI for a given depositId.
 29 |     |      * @param depositId - the id of the deposit
 30 |     |      * @dev the URI is a base64 encoded JSON object that contains the metadata and base64 encoded svg.
 31 |     |      * Deposits are stored as a mapping of a uint256 to a Deposit struct.
 32 |     |      * ERC20 deposits are represented by the concatination of the token address and the stem. (20 + 12 bytes).
 33 |     |      */
 34 |     |     function uri(uint256 depositId) external view returns (string memory) {
 35 |     |         (address token, int96 stem) = LibBytes.unpackAddressAndStem(depositId);
 36 |     |         int96 stemTip = LibTokenSilo.stemTipForToken(token);
 37 |     | 
 38 |     |         // validate the uri
 39 |     |         // the deposit id must return
 40 |     |         // 1) a token in the silo whitelist (by checking milestone season)
 41 |     |         // 2) a stem that is less than or equal to the stem tip
 42 |     |         require(
 43 |     |             s.sys.silo.assetSettings[token].milestoneSeason != 0 && stemTip >= stem,
 44 |     |             "Silo: metadata does not exist"
 45 |     |         );
 46 |     |         bytes memory attributes = abi.encodePacked(
 47 |     |             ', "attributes": [ { "trait_type": "Token", "value": "',
 48 |     |             getTokenName(token),
 49 |     |             '"}, { "trait_type": "Token Address", "value": "',
 50 |     |             Strings.toHexString(uint256(uint160(token)), 20),
 51 |     |             '"}, { "trait_type": "Id", "value": "',
 52 |     |             depositId.toHexString(32),
 53 |     |             '"}, { "trait_type": "stem", "display_type": "number", "value": ',
 54 |     |             int256(stem).toStringSigned(),
 55 |     |             '}, { "trait_type": "initial stalk per PDV", "display_type": "number", "value": ',
 56 |     |             uint256(LibTokenSilo.stalkIssuedPerBdv(token)).toString(),
 57 |     |             '}, { "trait_type": "grown stalk per PDV", "display_type": "number", "value": ',
 58 |     |             uint256(int256(stemTip - stem)).toString(),
 59 |     |             '}, { "trait_type": "stalk grown per PDV per season", "display_type": "number", "value": ',
 60 |     |             uint256(LibTokenSilo.stalkEarnedPerSeason(token)).toString()
 61 |     |         );
 62 |     |         return
 63 |     |             string(
 64 |     |                 abi.encodePacked(
 65 |     |                     "data:application/json;base64,",
 66 |     |                     LibBytes64.encode(
 67 |     |                         abi.encodePacked(
 68 |     |                             "{",
 69 |     |                             '"name": "Pinto Silo Deposits", "description": "An ERC1155 representing an asset deposited in the Pinto Silo. Silo Deposits gain stalk and pinto seignorage. ',
 70 |     |                             '\\n\\nDISCLAIMER: Due diligence is imperative when assessing this NFT. Opensea and other NFT marketplaces cache the svg output and thus, may require the user to refresh the metadata to properly show the correct values."',
 71 |     |                             attributes,
 72 |     |                             string(abi.encodePacked(' }], "image": "', imageURI(token, stem), '"')),
 73 |     |                             "}"
 74 |     |                         )
 75 |     |                     )
 76 |     |                 )
 77 |     |             );
 78 |     |     }
 79 |     | 
 80 |     |     function name() external pure returns (string memory) {
 81 |     |         return "Pinto Silo Deposits";
 82 |     |     }
 83 |     | 
 84 |     |     function symbol() external pure returns (string memory) {
 85 |     |         return "DEPOSIT";
 86 |     |     }
 87 |     | }
 88 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/metadata/abstract/MetadataImage.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
  6 |     | import {C} from "contracts/C.sol";
  7 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  8 |     | import {LibBytes64} from "contracts/libraries/LibBytes64.sol";
  9 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
 10 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
 11 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
 12 |     | 
 13 |     | /**
 14 |     |  * @title MetadataImage
 15 |     |  * @notice Contains image metadata for ERC1155 deposits.
 16 |     |  * @dev fully on-chain generated SVG.
 17 |     |  */
 18 |     | 
 19 |     | abstract contract MetadataImage {
 20 |     |     AppStorage internal s;
 21 |     | 
 22 |     |     using Strings for uint256;
 23 |     |     using Strings for int256;
 24 |     |     using LibRedundantMath256 for uint256;
 25 |     | 
 26 |     |     string constant LEAF_COLOR_0 = "#A8C83A";
 27 |     |     string constant LEAF_COLOR_1 = "#89A62F";
 28 |     |     uint256 constant NUM_PLOTS = 21;
 29 |     |     uint256 constant STALK_GROWTH = 2e8;
 30 |     | 
 31 |     |     function imageURI(address token, int96 stem) public view returns (string memory) {
 32 |     |         return
 33 |     |             string(
 34 |     |                 abi.encodePacked(
 35 |     |                     "data:image/svg+xml;base64,",
 36 |     |                     LibBytes64.encode(bytes(generateImage(token, stem)))
 37 |     |                 )
 38 |     |             );
 39 |     |     }
 40 |     | 
 41 |     |     function generateImage(address token, int96 stem) internal view returns (string memory) {
 42 |     |         // Get deposit ID as uint256
 43 |     |         uint256 depositId = LibBytes.packAddressAndStem(token, stem);
 44 |     | 
 45 |     |         // Convert to hex string (will include '0x' prefix)
 46 |     |         string memory hexDepositId = Strings.toHexString(depositId, 32);
 47 |     | 
 48 |     |         // Get hash and convert to hex string
 49 |     |         bytes32 hash = keccak256(abi.encodePacked(hexDepositId));
 50 |     |         string memory hashString = Strings.toHexString(uint256(hash), 32);
 51 |     | 
 52 |     |         string memory truncatedId = string.concat(
 53 |     |             substring(hashString, 0, 8), // First 6 chars after '0x'
 54 |     |             "...",
 55 |     |             substring(hashString, bytes(hashString).length - 6, bytes(hashString).length) // Last 6 chars
 56 |     |         );
 57 |     | 
 58 |     |         // get the ERC20 name of the token
 59 |     |         string memory tokenText = ERC20(token).symbol();
 60 |     | 
 61 |     |         return
 62 |     |             string(
 63 |     |                 abi.encodePacked(
 64 |     |                     '<svg width="478" height="266" viewBox="0 0 478 266" fill="none" xmlns="http://www.w3.org/2000/svg"><defs><style>@import url(https://fonts.googleapis.com/css2?family=Inter:wght@500&amp;display=swap);</style></defs><rect width="478" height="266" rx="12" fill="url(#paint0_radial_2141_35163)"/><g filter="url(#filter0_i_2141_35163)"><text fill="#fff" xml:space="preserve" style="white-space:pre" font-family="Inter" font-size="16" font-weight="500" letter-spacing="0em"><tspan x="15" y="29.818">Deposit ',
 65 |     |                     truncatedId,
 66 |     |                     '</tspan></text></g><path d="M292.988 143.077c-1.153 2.554-3.291 3.447-5.801 3.447-5.333 0-9.753-2.121-13.128-6.411-.78-.992-1.285-2.145-1.417-3.435-.216-2.058.793-3.745 2.727-4.625 1.981-.905 4.059-.942 6.149-.583 3.183.546 6.017 1.91 8.443 4.142 1.37 1.252 2.355 2.777 3.039 4.513v2.952zm0-16.913c-.625 1.835-2.114 2.493-3.759 2.641-4.937.447-9.321-1.004-12.924-4.575-.636-.632-1.105-1.55-1.405-2.418-.408-1.178.072-2.22 1.105-2.988.937-.695 2.018-1.017 3.135-1.079 4.564-.273 8.599 1.103 12.034 4.241.865.793 1.406 1.81 1.826 2.901v1.277zm-54.096 42.804c-3.243.248-6.102-1.017-8.444-3.472-4.276-4.477-3.735-11.197 1.129-15.004 4.756-3.72 11.939-3.299 16.058.955 4.06 4.178 3.904 10.478-.348 14.483-2.27 2.145-4.684 3.025-8.383 3.025zm-29.51-6.458c-2.99-.025-5.212-.608-7.026-2.269-2.342-2.158-2.954-5.295-1.693-8.556 1.321-3.41 3.819-5.667 7.002-7.155 2.798-1.302 5.729-1.823 8.756-1.042 2.978.769 5.164 2.517 5.813 5.779.48 2.418-.204 4.625-1.538 6.596-2.894 4.254-6.918 6.374-11.314 6.647m58.892 0c2.99-.025 5.212-.608 7.026-2.269 2.342-2.158 2.955-5.295 1.694-8.556-1.322-3.41-3.82-5.667-7.003-7.155-2.798-1.302-5.729-1.823-8.755-1.042-2.979.769-5.165 2.517-5.814 5.779-.48 2.418.205 4.625 1.538 6.596 2.894 4.254 6.918 6.374 11.314 6.647m-28.049-16.854c-3.724 0-6.138-.583-8.264-2.108-1.933-1.389-3.219-3.199-3.062-5.779.132-2.132 1.273-3.658 2.894-4.836 2.57-1.872 5.477-2.492 8.588-2.207 2.066.199 3.999.819 5.741 2.021 4.18 2.902 4.204 7.887.048 10.801-2.138 1.5-4.54 2.083-5.933 2.083zm-49.292.955c-.636-.148-1.825-.285-2.906-.706-2.607-1.005-3.64-3.497-2.667-6.188.793-2.182 2.258-3.807 4.06-5.134 3.027-2.232 6.402-3.472 10.149-3.273a9.6 9.6 0 0 1 3.003.657c2.75 1.116 3.675 3.794 2.378 6.634-.661 1.438-1.61 2.629-2.787 3.646-3.099 2.678-6.642 4.154-11.242 4.352zm27.829-6.932c-2.511-.012-4.444-.384-6.186-1.488-2.63-1.661-3.243-4.588-1.501-7.204 1.249-1.885 3.027-3.063 5.056-3.844 3.279-1.265 6.606-1.525 9.921-.186 1.549.62 2.835 1.637 3.423 3.311.745 2.157-.072 3.943-1.489 5.468-1.85 1.997-4.192 3.075-6.774 3.609-.973.198-1.958.272-2.462.334zm41.089-.01c-3.015-.037-5.826-.83-8.252-2.678a10.2 10.2 0 0 1-2.354-2.505c-1.513-2.306-1.021-4.848 1.129-6.547 1.297-1.029 2.811-1.55 4.408-1.736 3.663-.434 7.074.322 10.125 2.53 1.009.731 1.862 1.624 2.462 2.752 1.297 2.443.721 4.911-1.501 6.498-1.586 1.128-3.711 1.724-6.005 1.686zm-62.131-21.825c1.357 0 2.678.162 3.903.819 1.718.917 2.21 2.455 1.309 4.228-.96 1.873-2.558 3.038-4.311 4.005-2.451 1.364-5.081 2.133-7.879 2.208-1.61.049-3.183-.137-4.54-1.191-.937-.731-1.273-1.785-.973-2.951.42-1.587 1.453-2.716 2.678-3.658 2.895-2.232 6.186-3.348 9.789-3.472zm68.124 9.038c-3.207-.124-6.209-.806-8.768-2.815-.78-.607-1.465-1.463-1.957-2.331-.781-1.376-.421-2.802.756-3.844 1.189-1.054 2.643-1.513 4.156-1.674 3.471-.384 6.762.273 9.717 2.257a9.1 9.1 0 0 1 2.306 2.269c1.201 1.724.78 3.559-.913 4.762-1.141.806-2.438 1.128-3.783 1.289-.517.062-1.033.062-1.502.087zm-53.544.137c-1.525.025-3.015-.161-4.408-.843-.564-.285-1.129-.645-1.573-1.104-1.273-1.302-1.189-3.137.108-4.724 1.093-1.339 2.498-2.22 4.048-2.864 3.014-1.24 6.113-1.637 9.272-.72a7.3 7.3 0 0 1 2.162 1.067c1.657 1.178 1.957 2.951.816 4.675-1.153 1.748-2.87 2.728-4.732 3.459a15.2 15.2 0 0 1-5.693 1.067zm41.233-19.58c2.678.049 4.972.446 7.05 1.661.745.434 1.465.992 2.018 1.65 1.093 1.289.864 2.728-.481 3.744-1.009.769-2.174 1.141-3.387 1.327-3.327.509-6.51.062-9.488-1.612-.625-.347-1.201-.843-1.682-1.389-1.117-1.289-.912-2.79.433-3.819 1.093-.831 2.354-1.215 3.675-1.413.721-.1 1.441-.137 1.85-.174zm-31.012 8.609c-2.378-.037-3.963-.236-5.464-.918-2.667-1.227-2.931-3.484-.625-5.307 1.597-1.265 3.471-1.86 5.429-2.17 2.234-.347 4.456-.335 6.606.484.684.26 1.357.657 1.921 1.128 1.141.992 1.177 2.369.205 3.559-1.153 1.389-2.715 2.096-4.36 2.53-1.454.384-2.955.558-3.712.694m48.679-9.599c3.111.087 6.077.744 8.66 2.617.708.508 1.321 1.227 1.801 1.971.613.955.373 2.096-.6 2.666-.805.471-1.73.881-2.643.98-4.071.471-7.843-.409-11.182-2.939-.432-.335-.804-.806-1.105-1.277-.684-1.079-.456-2.158.565-2.902 1.069-.793 2.306-.979 3.567-1.103.312-.025.625 0 .925 0zm-64.256.16c1.441 0 2.846.149 4.131.893 1.442.843 1.706 2.108.721 3.472-.228.323-.517.62-.805.881-1.429 1.252-3.123 1.984-4.9 2.48-2.414.682-4.864 1.004-7.339.334a5.6 5.6 0 0 1-1.681-.768c-.925-.633-1.129-1.612-.637-2.642.469-.992 1.273-1.661 2.15-2.244 2.234-1.488 5.429-2.393 8.36-2.393zm31.611 5.482c-1.838-.173-3.627-.421-5.273-1.302-.504-.272-.997-.607-1.405-1.016-.997-.992-.985-2.183-.036-3.224.901-.968 2.054-1.488 3.291-1.811 3.303-.868 6.546-.781 9.669.719.444.211.864.509 1.225.844 1.309 1.202 1.261 2.666-.12 3.794-1.202.98-2.619 1.438-4.096 1.674-1.081.174-2.174.223-3.267.322zm-19.997-5.903c-1.009 0-2.39-.112-3.699-.645a6 6 0 0 1-.733-.347c-1.441-.844-1.585-2.183-.336-3.324 1.213-1.103 2.69-1.649 4.227-2.02 2.475-.584 4.949-.708 7.411.061a5.6 5.6 0 0 1 1.597.806c1.021.732 1.177 1.86.253 2.716-.769.707-1.706 1.277-2.655 1.699-1.801.793-3.735 1.054-6.077 1.054zm40.632-.027c-2.378-.012-4.696-.409-6.822-1.55a6.2 6.2 0 0 1-1.609-1.277c-.757-.843-.649-1.761.192-2.517.889-.806 2.006-1.104 3.123-1.265 2.93-.434 5.789-.124 8.479 1.141.781.372 1.526.955 2.126 1.6.829.88.649 1.909-.324 2.628-1.249.918-2.703 1.104-4.168 1.24-.324.025-.661 0-.997 0M239.132 97c1.898.05 3.808.26 5.549 1.215.793.434 1.598.918 1.586 2.009 0 1.054-.805 1.538-1.598 1.934-2.066 1.042-4.276 1.228-6.522 1.129-1.489-.075-2.966-.273-4.335-.943a6.3 6.3 0 0 1-1.562-1.103c-.564-.533-.624-1.401-.084-1.947a6.8 6.8 0 0 1 1.85-1.327c1.597-.769 3.339-.917 5.116-.955z" fill="#F8F8F8"/><g filter="url(#filter1_i_2141_35163)"><text fill="#fff" xml:space="preserve" style="white-space:pre" font-family="Inter" font-size="16" font-weight="500" letter-spacing="0em" text-anchor="end"><tspan x="460" y="247.818">',
 67 |     |                     tokenText,
 68 |     |                     '</tspan></text></g><defs><filter id="filter0_i_2141_35163" x="16.278" y="17.898" width="214.464" height="19.375" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feBlend in="SourceGraphic" in2="BackgroundImageFix" result="shape"/><feColorMatrix in="SourceAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/><feOffset dy="4"/><feGaussianBlur stdDeviation="2"/><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/><feColorMatrix values="0 0 0 0 0.480811 0 0 0 0 0.480811 0 0 0 0 0.480811 0 0 0 0.2 0"/><feBlend in2="shape" result="effect1_innerShadow_2141_35163"/></filter><filter id="filter1_i_2141_35163" x="15" y="236.203" width="448" height="15.957" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feBlend in="SourceGraphic" in2="BackgroundImageFix" result="shape"/><feColorMatrix in="SourceAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/><feOffset dy="4"/><feGaussianBlur stdDeviation="2"/><feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/><feColorMatrix values="0 0 0 0 0.480811 0 0 0 0 0.480811 0 0 0 0 0.480811 0 0 0 0.2 0"/><feBlend in2="shape" result="effect1_innerShadow_2141_35163"/></filter><radialGradient id="paint0_radial_2141_35163" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="matrix(0 271.224 -487.387 0 239.722 0)"><stop offset=".128" stop-color="#88C4A6"/><stop offset=".297" stop-color="#68AD8B"/><stop offset=".461" stop-color="#45906A"/><stop offset=".64" stop-color="#387F5C"/><stop offset=".841" stop-color="#246645"/></radialGradient></defs></svg>'
 69 |     |                 )
 70 |     |             );
 71 |     |     }
 72 |     | 
 73 |     |     function substring(
 74 |     |         string memory str,
 75 |     |         uint startIndex,
 76 |     |         uint endIndex
 77 |     |     ) internal pure returns (string memory) {
 78 |     |         bytes memory strBytes = bytes(str);
 79 |     |         bytes memory result = new bytes(endIndex - startIndex);
 80 |     |         for (uint i = startIndex; i < endIndex; i++) {
 81 |     |             result[i - startIndex] = strBytes[i];
 82 |     |         }
 83 |     |         return string(result);
 84 |     |     }
 85 |     | 
 86 |     |     function getTokenName(address token) internal view returns (string memory tokenString) {
 87 |     |         tokenString = ERC20(token).symbol();
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/ApprovalFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {TokenSilo} from "./abstract/TokenSilo.sol";
   7 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
   8 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
   9 |     | import "contracts/C.sol";
  10 |     | import "contracts/libraries/Silo/LibSilo.sol";
  11 |     | import "contracts/libraries/Silo/LibTokenSilo.sol";
  12 |     | import "contracts/libraries/Math/LibRedundantMath32.sol";
  13 |     | import "contracts/libraries/Convert/LibConvert.sol";
  14 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title Handles Approval related functions for the Silo
  18 |     |  *
  19 |     |  */
  20 | *   | contract ApprovalFacet is Invariable, ReentrancyGuard {
  21 |     |     using LibRedundantMath256 for uint256;
  22 |     | 
  23 |     |     event ApprovalForAll(address indexed account, address indexed operator, bool approved);
  24 |     | 
  25 |     |     //////////////////////// APPROVE ////////////////////////
  26 |     | 
  27 |     |     /**
  28 |     |      * @notice Approve `spender` to Transfer Deposits for user.
  29 |     |      *
  30 |     |      * Sets the allowance to `amount`.
  31 |     |      *
  32 |     |      * @dev Gas optimization: We neglect to check whether `token` is actually
  33 |     |      * whitelisted. If a token is not whitelisted, it cannot be Deposited,
  34 |     |      * therefore it cannot be Transferred.
  35 |     |      */
  36 |     |     function approveDeposit(
  37 |     |         address spender,
  38 |     |         address token,
  39 |     |         uint256 amount
  40 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
  41 |     |         require(spender != address(0), "approve from the zero address");
  42 |     |         require(token != address(0), "approve to the zero address");
  43 |     |         LibSilo._approveDeposit(LibTractor._user(), spender, token, amount);
  44 |     |     }
  45 |     | 
  46 |     |     /**
  47 |     |      * @notice Increase the Transfer allowance for `spender`.
  48 |     |      *
  49 |     |      * @dev Gas optimization: We neglect to check whether `token` is actually
  50 |     |      * whitelisted. If a token is not whitelisted, it cannot be Deposited,
  51 |     |      * therefore it cannot be Transferred.
  52 |     |      */
  53 |     |     function increaseDepositAllowance(
  54 |     |         address spender,
  55 |     |         address token,
  56 |     |         uint256 addedValue
  57 |     |     ) public virtual fundsSafu noNetFlow noSupplyChange nonReentrant returns (bool) {
  58 |     |         LibSilo._approveDeposit(
  59 |     |             LibTractor._user(),
  60 |     |             spender,
  61 |     |             token,
  62 |     |             depositAllowance(LibTractor._user(), spender, token).add(addedValue)
  63 |     |         );
  64 |     |         return true;
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Decrease the Transfer allowance for `spender`.
  69 |     |      *
  70 |     |      * @dev Gas optimization: We neglect to check whether `token` is actually
  71 |     |      * whitelisted. If a token is not whitelisted, it cannot be Deposited,
  72 |     |      * therefore it cannot be Transferred.
  73 |     |      */
  74 |     |     function decreaseDepositAllowance(
  75 |     |         address spender,
  76 |     |         address token,
  77 |     |         uint256 subtractedValue
  78 |     |     ) public virtual fundsSafu noNetFlow noSupplyChange nonReentrant returns (bool) {
  79 |     |         uint256 currentAllowance = depositAllowance(LibTractor._user(), spender, token);
  80 |     |         require(currentAllowance >= subtractedValue, "Silo: decreased allowance below zero");
  81 |     |         LibSilo._approveDeposit(
  82 |     |             LibTractor._user(),
  83 |     |             spender,
  84 |     |             token,
  85 |     |             currentAllowance.sub(subtractedValue)
  86 |     |         );
  87 |     |         return true;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Returns how much of a `token` Deposit that `spender` can transfer on behalf of `owner`.
  92 |     |      * @param owner The account that has given `spender` approval to transfer Deposits.
  93 |     |      * @param spender The address (contract or EOA) that is allowed to transfer Deposits on behalf of `owner`.
  94 |     |      * @param token Whitelisted ERC20 token.
  95 |     |      */
  96 |     |     function depositAllowance(
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         address token
 100 |     |     ) public view virtual returns (uint256) {
 101 |     |         return s.accts[owner].depositAllowances[spender][token];
 102 |     |     }
 103 |     | 
 104 |     |     // ERC1155 Approvals
 105 |     |     function setApprovalForAll(
 106 |     |         address spender,
 107 |     |         bool approved
 108 |     |     ) external fundsSafu noNetFlow noSupplyChange nonReentrant {
 109 |     |         s.accts[LibTractor._user()].isApprovedForAll[spender] = approved;
 110 |     |         emit ApprovalForAll(LibTractor._user(), spender, approved);
 111 |     |     }
 112 |     | 
 113 |     |     function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
 114 |     |         return s.accts[_owner].isApprovedForAll[_operator];
 115 |     |     }
 116 |     | }
 117 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/BDVFacet.sol
  1 |     | /*
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "contracts/C.sol";
  8 |     | import "contracts/libraries/Well/LibWellBdv.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title BDVFacet
 12 |     |  * @notice Calculates BDV for whitelisted Silo tokens.
 13 |     |  */
 14 | *   | contract BDVFacet {
 15 |     |     using LibRedundantMath256 for uint256;
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the BDV of a given `amount` of Beans.
 19 |     |      */
 20 | *   |     function beanToBDV(uint256 amount) public pure returns (uint256) {
 21 | *   |         return amount;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the BDV of a given `amount` of Well LP Tokens given a Well `token`.
 26 |     |      * A Well's `token` address is the same as the Well address.
 27 |     |      * Any Well `token` that uses the `wellBdv` function as its BDV function must have 
 28 |     |      `encodeType = 1` in {AssetSettings}.
 29 |     |      */
 30 |     |     function wellBdv(address token, uint256 amount) external view returns (uint256) {
 31 |     |         return LibWellBdv.bdv(token, amount);
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/ClaimFacet.sol
   1 |     | /*
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | pragma abicoder v2;
   7 |     | 
   8 |     | import {C} from "contracts/C.sol";
   9 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  10 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  11 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  12 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  13 |     | import {LibWell, IWell} from "contracts/libraries/Well/LibWell.sol";
  14 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  15 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  16 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  17 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  18 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  19 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  20 |     | 
  21 |     | /**
  22 |     |  * @title ClaimFacet
  23 |     |  * @notice ClaimFacet contains functions for claiming rewards from beanstalk.
  24 |     |  */
  25 | *   | contract ClaimFacet is Invariable, ReentrancyGuard {
  26 |     |     using LibRedundantMath256 for uint256;
  27 |     | 
  28 |     |     struct ClaimPlentyData {
  29 |     |         address token;
  30 |     |         uint256 plenty;
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @notice Emitted when Token paid to `account` during a Flood is Claimed.
  35 |     |      * @param account Owns and receives the assets paid during a Flood.
  36 |     |      * @param plenty The amount of Token claimed by `account`. This is the amount
  37 |     |      * that `account` has been paid since their last {ClaimPlenty}.
  38 |     |      *
  39 |     |      * @dev Flood was previously called a "Season of Plenty". For backwards
  40 |     |      * compatibility, the event has not been changed. For more information on
  41 |     |      * Flood, see: {Weather.sop}.
  42 |     |      */
  43 |     |     event ClaimPlenty(address indexed account, address token, uint256 plenty);
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Emitted when the deposit associated with the Earned Beans of
  47 |     |      * `account` are Planted.
  48 |     |      * @param account Owns the Earned Beans
  49 |     |      * @param beans The amount of Earned Beans claimed by `account`.
  50 |     |      */
  51 |     |     event Plant(address indexed account, uint256 beans);
  52 |     | 
  53 |     |     /**
  54 |     |      * @notice Emitted when `account` gains or loses Stalk.
  55 |     |      * @param account The account that gained or lost Stalk.
  56 |     |      * @param delta The change in Stalk.
  57 |     |      * @param deltaRoots The change in Roots.
  58 |     |      *
  59 |     |      * @dev {StalkBalanceChanged} should be emitted anytime a Deposit is added, removed or transferred AND
  60 |     |      * anytime an account Mows Grown Stalk.
  61 |     |      */
  62 |     |     event StalkBalanceChanged(address indexed account, int256 delta, int256 deltaRoots);
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Claim rewards from a Flood (Was Season of Plenty)
  66 |     |      */
  67 |     |     function claimPlenty(
  68 |     |         address well,
  69 |     |         LibTransfer.To toMode
  70 |     |     )
  71 |     |         external
  72 |     |         payable
  73 |     |         fundsSafu
  74 |     |         noSupplyChange
  75 |     |         oneOutFlow(address(LibWell.getNonBeanTokenFromWell(well)))
  76 |     |         nonReentrant
  77 |     |         returns (uint256)
  78 |     |     {
  79 |     |         (uint256 plenty, ) = _claimPlenty(LibTractor._user(), well, toMode);
  80 |     |         return plenty;
  81 |     |     }
  82 |     | 
  83 |     |     function claimAllPlenty(
  84 |     |         LibTransfer.To toMode
  85 |     |     )
  86 |     |         external
  87 |     |         payable
  88 |     |         fundsSafu
  89 |     |         noSupplyChange
  90 |     |         nonReentrant
  91 |     |         returns (ClaimPlentyData[] memory allPlenty)
  92 |     |     {
  93 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
  94 |     |         allPlenty = new ClaimPlentyData[](tokens.length);
  95 |     |         for (uint i; i < tokens.length; i++) {
  96 |     |             (uint256 plenty, IERC20 sopToken) = _claimPlenty(LibTractor._user(), tokens[i], toMode);
  97 |     |             allPlenty[i] = ClaimPlentyData({token: address(sopToken), plenty: plenty});
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 |     |     //////////////////////// INTERNAL: SEASON OF PLENTY ////////////////////////
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Gas optimization: An account can call `{SiloFacet:claimPlenty}` even
 105 |     |      * if `s.accts[account].sop.plenty == 0`. This would emit a ClaimPlenty event
 106 |     |      * with an amount of 0.
 107 |     |      */
 108 |     |     function _claimPlenty(
 109 |     |         address account,
 110 |     |         address well,
 111 |     |         LibTransfer.To toMode
 112 |     |     ) internal returns (uint256 plenty, IERC20 sopToken) {
 113 |     |         plenty = s.accts[account].sop.perWellPlenty[well].plenty;
 114 |     |         if (plenty > 0 && LibWhitelistedTokens.wellIsOrWasSoppable(well)) {
 115 |     |             IERC20[] memory tokens = IWell(well).tokens();
 116 |     |             sopToken = tokens[0] != IERC20(s.sys.bean) ? tokens[0] : tokens[1];
 117 |     |             LibTransfer.sendToken(sopToken, plenty, LibTractor._user(), toMode);
 118 |     |             s.accts[account].sop.perWellPlenty[well].plenty = 0;
 119 |     | 
 120 |     |             // reduce from Beanstalk's total stored plenty for this well
 121 |     |             s.sys.sop.plentyPerSopToken[address(sopToken)] -= plenty;
 122 |     | 
 123 |     |             emit ClaimPlenty(account, address(sopToken), plenty);
 124 |     |         }
 125 |     |     }
 126 |     | 
 127 |     |     //////////////////////// YIELD DISTRUBUTION ////////////////////////
 128 |     | 
 129 |     |     /**
 130 |     |      * @notice Claim Grown Stalk for `account`.
 131 |     |      * @dev See {Silo-_mow}.
 132 |     |      */
 133 |     |     function mow(
 134 |     |         address account,
 135 |     |         address token
 136 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 137 |     |         LibSilo._mow(account, token);
 138 |     |     }
 139 |     | 
 140 |     |     //function to mow multiple tokens given an address
 141 |     |     function mowMultiple(
 142 |     |         address account,
 143 |     |         address[] calldata tokens
 144 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 145 |     |         for (uint256 i; i < tokens.length; ++i) {
 146 |     |             LibSilo._mow(account, tokens[i]);
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     //function to mow all tokens for a given account.
 151 |     |     function mowAll(
 152 |     |         address account
 153 |     |     ) public payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 154 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedTokens();
 155 |     |         for (uint256 i; i < tokens.length; ++i) {
 156 |     |             LibSilo._mow(account, tokens[i]);
 157 |     |         }
 158 |     |     }
 159 |     | 
 160 |     |     //function to mow multiple tokens for multiple accounts.
 161 |     |     function mowMultipleAccounts(
 162 |     |         address[] calldata accounts,
 163 |     |         address[][] calldata tokens
 164 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 165 |     |         for (uint256 i; i < accounts.length; ++i) {
 166 |     |             for (uint256 j; j < tokens[i].length; ++j) {
 167 |     |                 LibSilo._mow(accounts[i], tokens[i][j]);
 168 |     |             }
 169 |     |         }
 170 |     |     }
 171 |     | 
 172 |     |     //function to mow multiple tokens for multiple accounts.
 173 |     |     function mowAllMultipleAccounts(
 174 |     |         address[] calldata accounts
 175 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 176 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedTokens();
 177 |     |         for (uint256 i; i < accounts.length; ++i) {
 178 |     |             for (uint256 j; j < tokens.length; ++j) {
 179 |     |                 LibSilo._mow(accounts[i], tokens[j]);
 180 |     |             }
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @notice Claim Earned Beans and their associated Stalk and Plantable Seeds for
 186 |     |      * user.
 187 |     |      *
 188 |     |      * The Stalk associated with Earned Beans is commonly called "Earned Stalk".
 189 |     |      * Earned Stalk DOES contribute towards the Farmer's Stalk when earned beans is issued.
 190 |     |      *
 191 |     |      * The Seeds associated with Earned Beans are commonly called "Plantable
 192 |     |      * Seeds". The word "Plantable" is used to highlight that these Seeds aren't
 193 |     |      * yet earning the Farmer new Stalk. In other words, Seeds do NOT automatically
 194 |     |      * compound; they must first be Planted with {plant}.
 195 |     |      *
 196 |     |      * In practice, when Seeds are Planted, all Earned Beans are Deposited in
 197 |     |      * the current Season.
 198 |     |      */
 199 |     |     function plant()
 200 |     |         external
 201 |     |         payable
 202 |     |         fundsSafu
 203 |     |         noNetFlow
 204 |     |         noSupplyChange
 205 |     |         nonReentrant
 206 |     |         returns (uint256 beans, int96 stem)
 207 |     |     {
 208 |     |         return _plant(LibTractor._user());
 209 |     |     }
 210 |     | 
 211 |     |     //////////////////////// INTERNAL: PLANT ////////////////////////
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Plants the Plantable BDV of `account` associated with its Earned
 215 |     |      * Beans.
 216 |     |      *
 217 |     |      * For more info on Planting, see: {SiloFacet-plant}
 218 |     |      */
 219 |     | 
 220 |     |     function _plant(address account) internal returns (uint256 beans, int96 beanStem) {
 221 |     |         // Need to Mow for `account` before we calculate the balance of
 222 |     |         // Earned Beans.
 223 |     | 
 224 |     |         LibSilo._mow(account, s.sys.bean);
 225 |     |         uint256 accountStalk = s.accts[account].stalk;
 226 |     | 
 227 |     |         // Calculate balance of Earned Beans.
 228 |     |         beans = LibSilo._balanceOfEarnedBeans(accountStalk, s.accts[account].roots);
 229 |     | 
 230 |     |         // Earned Bean deposits do not germinate.
 231 |     |         // In order for a deposit to not be germinating,
 232 |     |         // the stem must be lower than the germinating stem.
 233 |     |         // assumes the germinating stem > 1, which is true for bean,
 234 |     |         // given that the earliest a plant can occur is at the 3rd season.
 235 |     |         LibGerminate.GermStem memory gs = LibGerminate.getGerminatingStem(s.sys.bean);
 236 |     |         beanStem = gs.germinatingStem - 1;
 237 |     |         if (beans == 0) return (0, beanStem);
 238 |     | 
 239 |     |         // Reduce the Silo's supply of Earned Beans.
 240 |     |         // SafeCast unnecessary because beans is <= s.sys.silo.earnedBeans.
 241 |     |         s.sys.silo.earnedBeans = s.sys.silo.earnedBeans.sub(uint128(beans));
 242 |     | 
 243 |     |         // Deposit Earned Beans if there are any. Note that 1 Bean = 1 BDV.
 244 |     |         LibTokenSilo.addDepositToAccount(
 245 |     |             account,
 246 |     |             s.sys.bean,
 247 |     |             beanStem,
 248 |     |             beans, // amount
 249 |     |             beans, // bdv
 250 |     |             LibTokenSilo.Transfer.emitTransferSingle
 251 |     |         );
 252 |     | 
 253 |     |         // Earned Stalk associated with Earned Beans generate more Earned Beans automatically (i.e., auto compounding).
 254 |     |         // Earned Stalk are minted when Earned Beans are minted during Sunrise. See {Sun.sol:rewardToSilo} for details.
 255 |     |         // Similarly, `account` does not receive additional Roots from Earned Stalk during a Plant.
 256 |     |         // The following lines allocate Earned Stalk that has already been minted to `account`.
 257 |     |         // Constant is used here rather than s.sys.silo.assetSettings[BEAN].stalkIssuedPerBdv
 258 |     |         // for gas savings.
 259 |     |         uint256 stalk = beans.mul(C.STALK_PER_BEAN);
 260 |     |         s.accts[account].stalk = accountStalk.add(stalk);
 261 |     |         emit StalkBalanceChanged(account, int256(stalk), 0);
 262 |     | 
 263 |     |         // mint the 1 season's worth of grown stalk for the deposit.
 264 |     |         // This is equivalent to a user `mowing` their deposit.
 265 |     |         // note: 1 Bean = 1 BDV
 266 |     |         uint256 grownStalk = LibSilo._balanceOfGrownStalk(beanStem, gs.stemTip, uint128(beans));
 267 |     |         LibSilo.mintActiveStalk(account, grownStalk);
 268 |     | 
 269 |     |         emit Plant(account, beans);
 270 |     |     }
 271 |     | }
 272 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/ConvertFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   8 |     | import {C} from "contracts/C.sol";
   9 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  10 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  11 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  12 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  13 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  14 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  15 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  16 |     | import {LibConvert} from "contracts/libraries/Convert/LibConvert.sol";
  17 |     | import {LibConvertData} from "contracts/libraries/Convert/LibConvertData.sol";
  18 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  19 |     | import {LibPipelineConvert} from "contracts/libraries/Convert/LibPipelineConvert.sol";
  20 |     | 
  21 |     | /**
  22 |     |  * @title ConvertFacet handles converting Deposited assets within the Silo.
  23 |     |  **/
  24 | *   | contract ConvertFacet is Invariable, ReentrancyGuard {
  25 |     |     using LibRedundantMathSigned256 for int256;
  26 |     |     using SafeCast for uint256;
  27 |     |     using LibConvertData for bytes;
  28 |     |     using LibRedundantMath256 for uint256;
  29 |     |     using SafeCast for uint256;
  30 |     |     using LibRedundantMath32 for uint32;
  31 |     | 
  32 |     |     event Convert(
  33 |     |         address indexed account,
  34 |     |         address fromToken,
  35 |     |         address toToken,
  36 |     |         uint256 fromAmount,
  37 |     |         uint256 toAmount
  38 |     |     );
  39 |     | 
  40 |     |     /**
  41 |     |      * @notice convert allows a user to convert a deposit to another deposit,
  42 |     |      * given that the conversion is supported by the ConvertFacet.
  43 |     |      * For example, a user can convert LP into Bean, only when beanstalk is below peg,
  44 |     |      * or convert beans into LP, only when beanstalk is above peg.
  45 |     |      * @param convertData  input parameters to determine the conversion type.
  46 |     |      * @param stems the stems of the deposits to convert
  47 |     |      * @param amounts the amounts within each deposit to convert
  48 |     |      * @return toStem the new stems of the converted deposit
  49 |     |      * @return fromAmount the amount of tokens converted from
  50 |     |      * @return toAmount the amount of tokens converted to
  51 |     |      * @return fromBdv the bdv of the deposits converted from
  52 |     |      * @return toBdv the bdv of the deposit converted to
  53 |     |      */
  54 |     |     function convert(
  55 |     |         bytes calldata convertData,
  56 |     |         int96[] memory stems,
  57 |     |         uint256[] memory amounts
  58 |     |     )
  59 |     |         external
  60 |     |         payable
  61 |     |         fundsSafu
  62 |     |         noSupplyChange
  63 |     |         nonReentrant
  64 |     |         returns (int96 toStem, uint256 fromAmount, uint256 toAmount, uint256 fromBdv, uint256 toBdv)
  65 |     |     {
  66 |     |         // if the convert is a well <> bean convert, cache the state to validate convert.
  67 |     |         LibPipelineConvert.PipelineConvertData memory pipeData = LibPipelineConvert.getConvertState(
  68 |     |             convertData
  69 |     |         );
  70 |     | 
  71 |     |         LibConvert.ConvertParams memory cp = LibConvert.convert(convertData);
  72 |     | 
  73 |     |         // if the account is 0, set it to `LibTractor._user()`
  74 |     |         // cp.account is only set upon a anti-lambda-lambda convert.
  75 |     |         if (cp.account == address(0)) {
  76 |     |             cp.account = LibTractor._user();
  77 |     |         }
  78 |     | 
  79 |     |         if (cp.decreaseBDV) {
  80 |     |             require(
  81 |     |                 stems.length == 1 && amounts.length == 1,
  82 |     |                 "Convert: DecreaseBDV only supports updating one deposit."
  83 |     |             );
  84 |     |         }
  85 |     | 
  86 |     |         require(cp.fromAmount > 0, "Convert: From amount is 0.");
  87 |     | 
  88 |     |         LibSilo._mow(cp.account, cp.fromToken);
  89 |     | 
  90 |     |         // If the fromToken and toToken are different, mow the toToken as well.
  91 |     |         if (cp.fromToken != cp.toToken) LibSilo._mow(cp.account, cp.toToken);
  92 |     | 
  93 |     |         // Withdraw the tokens from the deposit.
  94 |     |         uint256 deltaRainRoots;
  95 |     |         (pipeData.grownStalk, fromBdv, deltaRainRoots) = LibConvert._withdrawTokens(
  96 |     |             cp.fromToken,
  97 |     |             stems,
  98 |     |             amounts,
  99 |     |             cp.fromAmount,
 100 |     |             cp.account
 101 |     |         );
 102 |     | 
 103 |     |         // check for potential penalty
 104 |     |         LibPipelineConvert.checkForValidConvertAndUpdateConvertCapacity(
 105 |     |             pipeData,
 106 |     |             convertData,
 107 |     |             cp.fromToken,
 108 |     |             cp.toToken,
 109 |     |             fromBdv
 110 |     |         );
 111 |     | 
 112 |     |         // Calculate the bdv of the new deposit.
 113 |     |         uint256 newBdv = LibTokenSilo.beanDenominatedValue(cp.toToken, cp.toAmount);
 114 |     | 
 115 |     |         // If `decreaseBDV` flag is not enabled, set toBDV to the max of the two bdvs.
 116 |     |         toBdv = (newBdv > fromBdv || cp.decreaseBDV) ? newBdv : fromBdv;
 117 |     | 
 118 |     |         // if the Farmer is converting between beans and well LP, check for
 119 |     |         // potential germination. if the deposit is germinating, issue additional
 120 |     |         // grown stalk such that the deposit is no longer germinating.
 121 |     |         if (cp.shouldNotGerminate == true) {
 122 |     |             pipeData.grownStalk = LibConvert.calculateGrownStalkWithNonGerminatingMin(
 123 |     |                 cp.toToken,
 124 |     |                 pipeData.grownStalk,
 125 |     |                 toBdv
 126 |     |             );
 127 |     |         }
 128 |     | 
 129 |     |         if (cp.toToken != s.sys.bean && cp.fromToken == s.sys.bean) {
 130 |     |             uint256 grownStalkLost;
 131 |     |             (pipeData.grownStalk, grownStalkLost) = LibConvert.downPenalizedGrownStalk(
 132 |     |                 cp.toToken,
 133 |     |                 toBdv,
 134 |     |                 pipeData.grownStalk
 135 |     |             );
 136 |     |             emit LibConvert.ConvertDownPenalty(cp.account, grownStalkLost, pipeData.grownStalk);
 137 |     |         }
 138 |     | 
 139 |     |         toStem = LibConvert._depositTokensForConvert(
 140 |     |             cp.toToken,
 141 |     |             cp.toAmount,
 142 |     |             toBdv,
 143 |     |             pipeData.grownStalk,
 144 |     |             deltaRainRoots,
 145 |     |             cp.account
 146 |     |         );
 147 |     | 
 148 |     |         fromAmount = cp.fromAmount;
 149 |     |         toAmount = cp.toAmount;
 150 |     | 
 151 |     |         emit Convert(cp.account, cp.fromToken, cp.toToken, cp.fromAmount, cp.toAmount);
 152 |     |     }
 153 |     | }
 154 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/ConvertGettersFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {AppStorage, LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
   8 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   9 |     | import {LibConvert} from "contracts/libraries/Convert/LibConvert.sol";
  10 |     | import {LibWellMinting} from "contracts/libraries/Minting/LibWellMinting.sol";
  11 |     | import {LibDeltaB} from "contracts/libraries/Oracle/LibDeltaB.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title ConvertGettersFacet contains view functions related to converting Deposited assets.
  15 |     |  **/
  16 | *   | contract ConvertGettersFacet {
  17 |     |     using LibRedundantMath256 for uint256;
  18 |     | 
  19 |     |     /**
  20 |     |      * @notice Returns the maximum amount that can be converted of `tokenIn` to `tokenOut`.
  21 |     |      */
  22 |     |     function getMaxAmountIn(
  23 |     |         address tokenIn,
  24 |     |         address tokenOut
  25 |     |     ) external view returns (uint256 amountIn) {
  26 |     |         return LibConvert.getMaxAmountIn(tokenIn, tokenOut);
  27 |     |     }
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Returns the amount of `tokenOut` recieved from converting `amountIn` of `tokenIn`.
  31 |     |      */
  32 |     |     function getAmountOut(
  33 |     |         address tokenIn,
  34 |     |         address tokenOut,
  35 |     |         uint256 amountIn
  36 |     |     ) external view returns (uint256 amountOut) {
  37 |     |         return LibConvert.getAmountOut(tokenIn, tokenOut, amountIn);
  38 |     |     }
  39 |     | 
  40 |     |     function overallCappedDeltaB() external view returns (int256 deltaB) {
  41 |     |         return LibDeltaB.overallCappedDeltaB();
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice returns the overall current deltaB for all whitelisted well tokens.
  46 |     |      */
  47 |     |     function overallCurrentDeltaB() external view returns (int256 deltaB) {
  48 |     |         return LibDeltaB.overallCurrentDeltaB();
  49 |     |     }
  50 |     | 
  51 |     |     /*
  52 |     |      * @notice returns the scaled deltaB, based on LP supply before and after convert
  53 |     |      */
  54 |     |     function scaledDeltaB(
  55 |     |         uint256 beforeLpTokenSupply,
  56 |     |         uint256 afterLpTokenSupply,
  57 |     |         int256 deltaB
  58 |     |     ) external pure returns (int256) {
  59 |     |         return LibDeltaB.scaledDeltaB(beforeLpTokenSupply, afterLpTokenSupply, deltaB);
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @notice Returns the multi-block MEV resistant deltaB for a given token using capped reserves from the well.
  64 |     |      * @param well The well for which to return the capped reserves deltaB
  65 |     |      * @return deltaB The capped reserves deltaB for the well
  66 |     |      */
  67 |     |     function cappedReservesDeltaB(address well) external view returns (int256 deltaB) {
  68 |     |         return LibDeltaB.cappedReservesDeltaB(well);
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @notice calculates the deltaB for a given well using the reserves.
  73 |     |      * @dev reverts if the bean reserve is less than the minimum,
  74 |     |      * or if the usd oracle fails.
  75 |     |      * This differs from the twaDeltaB, as this function should not be used within the sunrise function.
  76 |     |      * @return deltaB The deltaB using the reserves.
  77 |     |      */
  78 |     |     function calculateDeltaBFromReserves(
  79 |     |         address well,
  80 |     |         uint256[] memory reserves,
  81 |     |         uint256 lookback
  82 |     |     ) external view returns (int256) {
  83 |     |         return LibDeltaB.calculateDeltaBFromReserves(well, reserves, lookback);
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Returns currently available convert power for this block
  88 |     |      * @return convertCapacity The amount of convert power available for this block
  89 |     |      */
  90 |     |     function getOverallConvertCapacity() external view returns (uint256) {
  91 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  92 |     |         uint256 _overallCappedDeltaB = LibConvert.abs(LibDeltaB.overallCappedDeltaB());
  93 |     |         uint256 overallConvertCapacityUsed = s
  94 |     |             .sys
  95 |     |             .convertCapacity[block.number]
  96 |     |             .overallConvertCapacityUsed;
  97 |     |         return
  98 |     |             overallConvertCapacityUsed > _overallCappedDeltaB
  99 |     |                 ? 0
 100 |     |                 : _overallCappedDeltaB.sub(overallConvertCapacityUsed);
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice returns the Convert Capacity for a given well
 105 |     |      * @dev the convert capacity is the amount of deltaB that can be converted in a block.
 106 |     |      * This is a function of the capped reserves deltaB.
 107 |     |      */
 108 |     |     function getWellConvertCapacity(address well) external view returns (uint256) {
 109 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 110 |     |         return
 111 |     |             LibConvert.abs(LibDeltaB.cappedReservesDeltaB(well)).sub(
 112 |     |                 s.sys.convertCapacity[block.number].wellConvertCapacityUsed[well]
 113 |     |             );
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice Calculates the bdv penalized by a convert.
 118 |     |      * @dev See {LibConvert.calculateStalkPenalty}.
 119 |     |      */
 120 |     |     function calculateStalkPenalty(
 121 |     |         LibConvert.DeltaBStorage memory dbs,
 122 |     |         uint256 bdvConverted,
 123 |     |         uint256 overallConvertCapacity,
 124 |     |         address inputToken,
 125 |     |         address outputToken
 126 |     |     )
 127 |     |         external
 128 |     |         view
 129 |     |         returns (
 130 |     |             uint256 stalkPenaltyBdv,
 131 |     |             uint256 overallConvertCapacityUsed,
 132 |     |             uint256 inputTokenAmountUsed,
 133 |     |             uint256 outputTokenAmountUsed
 134 |     |         )
 135 |     |     {
 136 |     |         return
 137 |     |             LibConvert.calculateStalkPenalty(
 138 |     |                 dbs,
 139 |     |                 bdvConverted,
 140 |     |                 overallConvertCapacity,
 141 |     |                 inputToken,
 142 |     |                 outputToken
 143 |     |             );
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @notice Returns the amount of grown stalk remaining after application of down penalty.
 148 |     |      * @dev Germinating deposits are not penalized.
 149 |     |      * @dev Does not factor in other sources of stalk change during convert.
 150 |     |      * @return newGrownStalk Amount of grown stalk to assign the output deposit.
 151 |     |      * @return grownStalkLost Amount of grown stalk lost due to down penalty.
 152 |     |      */
 153 |     |     function downPenalizedGrownStalk(
 154 |     |         address well,
 155 |     |         uint256 bdvToConvert,
 156 |     |         uint256 grownStalkToConvert
 157 |     |     ) external view returns (uint256 newGrownStalk, uint256 grownStalkLost) {
 158 |     |         return LibConvert.downPenalizedGrownStalk(well, bdvToConvert, grownStalkToConvert);
 159 |     |     }
 160 |     | }
 161 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/PipelineConvertFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   9 |     | import {C} from "contracts/C.sol";
  10 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  11 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  12 |     | import {AdvancedPipeCall} from "contracts/interfaces/IPipeline.sol";
  13 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  14 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  15 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  16 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  17 |     | import {LibConvert} from "contracts/libraries/Convert/LibConvert.sol";
  18 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  19 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  20 |     | import {LibPipelineConvert} from "contracts/libraries/Convert/LibPipelineConvert.sol";
  21 |     | import {LibDeltaB} from "contracts/libraries/Oracle/LibDeltaB.sol";
  22 |     | 
  23 |     | /**
  24 |     |  * @title PipelineConvertFacet handles converting Deposited assets within the Silo,
  25 |     |  * using pipeline.
  26 |     |  * @dev `pipelineConvert` uses a series of pipeline calls to convert assets.
  27 |     |  **/
  28 | *   | contract PipelineConvertFacet is Invariable, ReentrancyGuard {
  29 |     |     using LibRedundantMathSigned256 for int256;
  30 |     |     using SafeCast for uint256;
  31 |     |     using LibRedundantMath256 for uint256;
  32 |     |     using SafeCast for uint256;
  33 |     |     using LibRedundantMath32 for uint32;
  34 |     | 
  35 |     |     event Convert(
  36 |     |         address indexed account,
  37 |     |         address fromToken,
  38 |     |         address toToken,
  39 |     |         uint256 fromAmount,
  40 |     |         uint256 toAmount
  41 |     |     );
  42 |     | 
  43 |     |     /**
  44 |     |      * @notice Pipeline convert allows any type of convert using a series of
  45 |     |      * pipeline calls. A stalk penalty may be applied if the convert crosses deltaB.
  46 |     |      *
  47 |     |      * @param inputToken The token to convert from.
  48 |     |      * @param stems The stems of the deposits to convert from.
  49 |     |      * @param amounts The amounts of the deposits to convert from.
  50 |     |      * @param outputToken The token to convert to.
  51 |     |      * @param advancedPipeCalls The pipe calls to execute.
  52 |     |      * @return toStem the new stems of the converted deposit
  53 |     |      * @return fromAmount the amount of tokens converted from
  54 |     |      * @return toAmount the amount of tokens converted to
  55 |     |      * @return fromBdv the bdv of the deposits converted from
  56 |     |      * @return toBdv the bdv of the deposit converted to
  57 |     |      */
  58 |     |     function pipelineConvert(
  59 |     |         address inputToken,
  60 |     |         int96[] calldata stems,
  61 |     |         uint256[] calldata amounts,
  62 |     |         address outputToken,
  63 |     |         AdvancedPipeCall[] memory advancedPipeCalls
  64 |     |     )
  65 |     |         external
  66 |     |         payable
  67 |     |         fundsSafu
  68 |     |         nonReentrant
  69 |     |         returns (int96 toStem, uint256 fromAmount, uint256 toAmount, uint256 fromBdv, uint256 toBdv)
  70 |     |     {
  71 |     |         // Require that input and output tokens be wells.
  72 |     |         require(
  73 |     |             LibWell.isWell(inputToken) || inputToken == s.sys.bean,
  74 |     |             "Convert: Input token must be Bean or a well"
  75 |     |         );
  76 |     |         require(
  77 |     |             LibWell.isWell(outputToken) || outputToken == s.sys.bean,
  78 |     |             "Convert: Output token must be Bean or a well"
  79 |     |         );
  80 |     | 
  81 |     |         // mow input and output tokens:
  82 |     |         LibSilo._mow(LibTractor._user(), inputToken);
  83 |     |         LibSilo._mow(LibTractor._user(), outputToken);
  84 |     | 
  85 |     |         // Calculate the maximum amount of tokens to withdraw.
  86 |     |         for (uint256 i = 0; i < stems.length; i++) {
  87 |     |             fromAmount = fromAmount.add(amounts[i]);
  88 |     |         }
  89 |     | 
  90 |     |         // withdraw tokens from deposits and calculate the total grown stalk and bdv.
  91 |     |         uint256 grownStalk;
  92 |     |         uint256 deltaRainRoots;
  93 |     |         (grownStalk, fromBdv, deltaRainRoots) = LibConvert._withdrawTokens(
  94 |     |             inputToken,
  95 |     |             stems,
  96 |     |             amounts,
  97 |     |             fromAmount,
  98 |     |             LibTractor._user()
  99 |     |         );
 100 |     | 
 101 |     |         (toAmount, grownStalk, toBdv) = LibPipelineConvert.executePipelineConvert(
 102 |     |             inputToken,
 103 |     |             outputToken,
 104 |     |             fromAmount,
 105 |     |             fromBdv,
 106 |     |             grownStalk,
 107 |     |             advancedPipeCalls
 108 |     |         );
 109 |     | 
 110 |     |         if (outputToken != s.sys.bean && inputToken == s.sys.bean) {
 111 |     |             uint256 grownStalkLost;
 112 |     |             (grownStalk, grownStalkLost) = LibConvert.downPenalizedGrownStalk(
 113 |     |                 outputToken,
 114 |     |                 toBdv,
 115 |     |                 grownStalk
 116 |     |             );
 117 |     |             emit LibConvert.ConvertDownPenalty(LibTractor._user(), grownStalkLost, grownStalk);
 118 |     |         }
 119 |     | 
 120 |     |         toStem = LibConvert._depositTokensForConvert(
 121 |     |             outputToken,
 122 |     |             toAmount,
 123 |     |             toBdv,
 124 |     |             grownStalk,
 125 |     |             deltaRainRoots,
 126 |     |             LibTractor._user()
 127 |     |         );
 128 |     | 
 129 |     |         emit Convert(LibTractor._user(), inputToken, outputToken, fromAmount, toAmount);
 130 |     |     }
 131 |     | }
 132 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/SiloFacet.sol
   1 |     | /*
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | pragma abicoder v2;
   7 |     | 
   8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   9 |     | import {TokenSilo} from "./abstract/TokenSilo.sol";
  10 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  11 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  12 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  13 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  14 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  15 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  16 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @title SiloFacet
  20 |     |  * @notice SiloFacet is the entry point for all Silo functionality.
  21 |     |  *
  22 |     |  * SiloFacet           public functions for modifying an account's Silo.
  23 |     |  * ↖ TokenSilo         accounting & storage for Deposits, Withdrawals, allowances.
  24 |     |  * ↖ ReentrancyGuard   provides reentrancy guard modifier and access to {C}.
  25 |     |  */
  26 | *   | contract SiloFacet is Invariable, TokenSilo {
  27 |     |     using LibRedundantMath256 for uint256;
  28 |     |     using LibRedundantMath32 for uint32;
  29 |     | 
  30 |     |     //////////////////////// DEPOSIT ////////////////////////
  31 |     | 
  32 |     |     /**
  33 |     |      * @notice Deposits an ERC20 into the Silo.
  34 |     |      * @dev farmer is issued stalk and seeds based on token (i.e non-whitelisted tokens do not get any)
  35 |     |      * @param token address of ERC20
  36 |     |      * @param amount tokens to be transferred
  37 |     |      * @param mode source of funds (INTERNAL, EXTERNAL, EXTERNAL_INTERNAL, INTERNAL_TOLERANT)
  38 |     |      * @dev Depositing should:
  39 |     |      *
  40 |     |      *  1. Transfer `amount` of `token` from `account` to Beanstalk.
  41 |     |      *  2. Calculate the current Bean Denominated Value (BDV) for `amount` of `token`.
  42 |     |      *  3. Create or update a Deposit entry for `account` in the current Season.
  43 |     |      *  4. Mint Stalk to `account`.
  44 |     |      *  5. Emit an `AddDeposit` event.
  45 |     |      *
  46 |     |      */
  47 | *   |     function deposit(
  48 |     |         address token,
  49 |     |         uint256 _amount,
  50 |     |         LibTransfer.From mode
  51 |     |     )
  52 |     |         external
  53 |     |         payable
  54 |     |         fundsSafu
  55 |     |         noSupplyChange
  56 |     |         noOutFlow
  57 |     |         nonReentrant
  58 | *   |         mowSender(token)
  59 | *   |         returns (uint256 amount, uint256 _bdv, int96 stem)
  60 |     |     {
  61 | *   |         amount = LibTransfer.receiveToken(IERC20(token), _amount, LibTractor._user(), mode);
  62 | *   |         (_bdv, stem) = _deposit(LibTractor._user(), token, amount);
  63 |     |     }
  64 |     | 
  65 |     |     //////////////////////// WITHDRAW ////////////////////////
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Withdraws an ERC20 Deposit from the Silo.
  69 |     |      * @param token Address of the whitelisted ERC20 token to Withdraw.
  70 |     |      * @param stem The stem to Withdraw from.
  71 |     |      * @param amount Amount of `token` to Withdraw.
  72 |     |      *
  73 |     |      * @dev When Withdrawing a Deposit, the user must burn all of the Stalk
  74 |     |      * associated with it, including:
  75 |     |      *
  76 |     |      * - base Stalk, received based on the BDV of the Deposit.
  77 |     |      * - Grown Stalk, grown from BDV and stalkEarnedPerSeason while the deposit was held in the Silo.
  78 |     |      *
  79 |     |      * Note that the Grown Stalk associated with a Deposit is a function of the
  80 |     |      * delta between the current Season and the Season in which a Deposit was made.
  81 |     |      *
  82 |     |      * Typically, a Farmer wants to withdraw more recent Deposits first, since
  83 |     |      * these require less Stalk to be burned. This functionality is the default
  84 |     |      * provided by the Beanstalk SDK, but is NOT provided at the contract level.
  85 |     |      *
  86 |     |      */
  87 | *   |     function withdrawDeposit(
  88 |     |         address token,
  89 |     |         int96 stem,
  90 |     |         uint256 amount,
  91 |     |         LibTransfer.To mode
  92 | *   |     ) external payable fundsSafu noSupplyChange oneOutFlow(token) mowSender(token) nonReentrant {
  93 | *   |         _withdrawDeposit(LibTractor._user(), token, stem, amount);
  94 | *   |         LibTransfer.sendToken(IERC20(token), amount, LibTractor._user(), mode);
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Claims ERC20s from multiple Withdrawals.
  99 |     |      * @param token Address of the whitelisted ERC20 token to Withdraw.
 100 |     |      * @param stems stems to Withdraw from.
 101 |     |      * @param amounts Amounts of `token` to Withdraw from corresponding `stems`.
 102 |     |      *
 103 |     |      * deposits.
 104 |     |      * @dev Clients should factor in gas costs when withdrawing from multiple
 105 |     |      *
 106 |     |      * For example, if a user wants to withdraw X Beans, it may be preferable to
 107 |     |      * withdraw from 1 older Deposit, rather than from multiple recent Deposits,
 108 |     |      * if the difference in stems is minimal to save on gas.
 109 |     |      */
 110 |     | 
 111 | *   |     function withdrawDeposits(
 112 |     |         address token,
 113 |     |         int96[] calldata stems,
 114 |     |         uint256[] calldata amounts,
 115 |     |         LibTransfer.To mode
 116 | *   |     ) external payable fundsSafu noSupplyChange oneOutFlow(token) mowSender(token) nonReentrant {
 117 | *   |         uint256 amount = _withdrawDeposits(LibTractor._user(), token, stems, amounts);
 118 | *   |         LibTransfer.sendToken(IERC20(token), amount, LibTractor._user(), mode);
 119 |     |     }
 120 |     | 
 121 |     |     //////////////////////// TRANSFER ////////////////////////
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Transfer a single Deposit.
 125 |     |      * @param sender Current owner of Deposit.
 126 |     |      * @param recipient Destination account of Deposit.
 127 |     |      * @param token Address of the whitelisted ERC20 token to Transfer.
 128 |     |      * @param stem stem of Deposit from which to Transfer.
 129 |     |      * @param amount Amount of `token` to Transfer.
 130 |     |      * @return _bdv The BDV included in this transfer, now owned by `recipient`.
 131 |     |      *
 132 |     |      * @dev An allowance is required if sender != user
 133 |     |      *
 134 |     |      * The {mowSender} modifier is not used here because _both_ the `sender` and
 135 |     |      * `recipient` need their Silo updated, since both accounts experience a
 136 |     |      * change in deposited BDV. See {Silo-_mow}.
 137 |     |      */
 138 | *   |     function transferDeposit(
 139 |     |         address sender,
 140 |     |         address recipient,
 141 |     |         address token,
 142 |     |         int96 stem,
 143 |     |         uint256 amount
 144 | *   |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant returns (uint256 _bdv) {
 145 | *   |         return _transferDeposit(sender, recipient, token, stem, amount);
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Transfers multiple Deposits.
 150 |     |      * @param sender Source of Deposit.
 151 |     |      * @param recipient Destination of Deposit.
 152 |     |      * @param token Address of the whitelisted ERC20 token to Transfer.
 153 |     |      * @param stem stem of Deposit to Transfer.
 154 |     |      * @param amounts Amounts of `token` to Transfer from corresponding `stem`.
 155 |     |      * @return bdvs Array of BDV transferred from each Season, now owned by `recipient`.
 156 |     |      *
 157 |     |      * @dev An allowance is required if sender != user. There must be enough allowance
 158 |     |      * to transfer all of the requested Deposits, otherwise the transaction should revert.
 159 |     |      *
 160 |     |      * The {mowSender} modifier is not used here because _both_ the `sender` and
 161 |     |      * `recipient` need their Silo updated, since both accounts experience a
 162 |     |      * change in Seeds. See {Silo-_mow}.
 163 |     |      */
 164 | *   |     function transferDeposits(
 165 |     |         address sender,
 166 |     |         address recipient,
 167 |     |         address token,
 168 |     |         int96[] calldata stem,
 169 |     |         uint256[] calldata amounts
 170 |     |     )
 171 |     |         external
 172 |     |         payable
 173 |     |         fundsSafu
 174 |     |         noNetFlow
 175 |     |         noSupplyChange
 176 |     |         nonReentrant
 177 | *   |         returns (uint256[] memory bdvs)
 178 | *   |     {
 179 | *   |         require(amounts.length > 0, "Silo: amounts array is empty");
 180 | *   |         uint256 totalAmount;
 181 | *   |         for (uint256 i = 0; i < amounts.length; ++i) {
 182 | *   |             require(amounts[i] > 0, "Silo: amount in array is 0");
 183 |     | 
 184 | *   |             totalAmount = totalAmount.add(amounts[i]);
 185 |     |         }
 186 |     | 
 187 |     |         // Tractor operator does not use allowance.
 188 | *   |         if (sender != LibTractor._user()) {
 189 | *   |             LibSilo._spendDepositAllowance(sender, LibTractor._user(), token, totalAmount);
 190 |     |         }
 191 |     | 
 192 | *   |         LibSilo._mow(sender, token);
 193 |     |         // Need to update the recipient's Silo as well.
 194 | *   |         LibSilo._mow(recipient, token);
 195 | *   |         bdvs = _transferDeposits(sender, recipient, token, stem, amounts);
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @notice Transfer a single Deposit, conforming to the ERC1155 standard.
 200 |     |      * @param sender Source of Deposit.
 201 |     |      * @param recipient Destination of Deposit.
 202 |     |      * @param depositId ID of Deposit to Transfer.
 203 |     |      * @param amount Amount of `token` to Transfer.
 204 |     |      *
 205 |     |      * @dev the depositID is the token address and stem of a deposit,
 206 |     |      * concatinated into a single uint256.
 207 |     |      *
 208 |     |      */
 209 | *   |     function safeTransferFrom(
 210 |     |         address sender,
 211 |     |         address recipient,
 212 |     |         uint256 depositId,
 213 |     |         uint256 amount,
 214 |     |         bytes calldata
 215 | *   |     ) external fundsSafu noNetFlow noSupplyChange nonReentrant {
 216 | *   |         require(recipient != address(0), "ERC1155: transfer to the zero address");
 217 |     |         // allowance requirements are checked in transferDeposit
 218 | *   |         (address token, int96 cumulativeGrownStalkPerBDV) = LibBytes.unpackAddressAndStem(
 219 | *   |             depositId
 220 |     |         );
 221 | *   |         _transferDeposit(sender, recipient, token, cumulativeGrownStalkPerBDV, amount);
 222 |     |     }
 223 |     | 
 224 |     |     /**
 225 |     |      * @notice Transfer a multiple Deposits, conforming to the ERC1155 standard.
 226 |     |      * @param sender Source of Deposit.
 227 |     |      * @param recipient Destination of Deposit.
 228 |     |      * @param depositIds list of ID of deposits to Transfer.
 229 |     |      * @param amounts list of amounts of `token` to Transfer.
 230 |     |      *
 231 |     |      * @dev {transferDeposits} can be used to transfer multiple deposits, but only
 232 |     |      * if they are all of the same token. Since the ERC1155 standard requires the abilty
 233 |     |      * to transfer any set of depositIDs, the {transferDeposits} function cannot be used here.
 234 |     |      */
 235 | *   |     function safeBatchTransferFrom(
 236 |     |         address sender,
 237 |     |         address recipient,
 238 |     |         uint256[] calldata depositIds,
 239 |     |         uint256[] calldata amounts,
 240 |     |         bytes calldata
 241 | *   |     ) external fundsSafu noNetFlow noSupplyChange nonReentrant {
 242 | *   |         require(
 243 | *   |             depositIds.length == amounts.length,
 244 |     |             "Silo: depositIDs and amounts arrays must be the same length"
 245 |     |         );
 246 | *   |         require(recipient != address(0), "ERC1155: transfer to the zero address");
 247 |     |         // allowance requirements are checked in transferDeposit
 248 | *   |         address token;
 249 | *   |         int96 stem;
 250 | *   |         for (uint i; i < depositIds.length; ++i) {
 251 | *   |             (token, stem) = LibBytes.unpackAddressAndStem(depositIds[i]);
 252 | *   |             _transferDeposit(sender, recipient, token, stem, amounts[i]);
 253 |     |         }
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @notice Updates the sorted list of deposit IDs for a given account and token
 258 |     |      * @param account The address of the account to update deposit IDs for
 259 |     |      * @param token The token address to update deposit IDs for
 260 |     |      * @param sortedDepositIds The sorted list of deposit IDs to store
 261 |     |      * @dev This function verifies that:
 262 |     |      * 1. All deposit IDs exist in the current list
 263 |     |      * 2. All deposit IDs belong to the specified token
 264 |     |      * 3. The list is properly sorted (ascending order by stem)
 265 |     |      */
 266 |     |     function updateSortedDepositIds(
 267 |     |         address account,
 268 |     |         address token,
 269 |     |         uint256[] calldata sortedDepositIds
 270 |     |     ) external payable fundsSafu noSupplyChange nonReentrant {
 271 |     |         // Verify list is not empty
 272 |     |         require(sortedDepositIds.length > 0, "Empty deposit ID list");
 273 |     | 
 274 |     |         // Get existing deposit IDs
 275 |     |         uint256[] memory existingIds = s.accts[account].depositIdList[token].depositIds;
 276 |     |         require(sortedDepositIds.length == existingIds.length, "Length mismatch");
 277 |     | 
 278 |     |         // Verify all IDs exist in the current deposits list
 279 |     |         int96 lastStem = type(int96).min;
 280 |     |         for (uint256 i = 0; i < sortedDepositIds.length; i++) {
 281 |     |             // Verify deposit ID format
 282 |     |             (, int96 stem) = LibBytes.unpackAddressAndStem(sortedDepositIds[i]);
 283 |     |             // Verifying the token is not necessary, since the full id will be verified below
 284 |     | 
 285 |     |             // Verify ascending order (this also prevents duplicates since we use > instead of >=)
 286 |     |             require(stem > lastStem, "Deposit IDs not sorted");
 287 |     |             lastStem = stem;
 288 |     | 
 289 |     |             // Verify ID exists in current list
 290 |     |             bool idFound = false;
 291 |     |             for (uint256 j = 0; j < existingIds.length; j++) {
 292 |     |                 if (sortedDepositIds[i] == existingIds[j]) {
 293 |     |                     idFound = true;
 294 |     |                     break;
 295 |     |                 }
 296 |     |             }
 297 |     |             require(idFound, "ID not found in current list");
 298 |     |         }
 299 |     | 
 300 |     |         // Update the sorted list in storage
 301 |     |         LibSilo._setSortedDepositIds(account, token, sortedDepositIds);
 302 |     |     }
 303 |     | }
 304 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/SiloGettersFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Deposit, MowStatus, PerWellPlenty} from "contracts/beanstalk/storage/Account.sol";
   8 |     | import {AssetSettings, GerminationSide} from "contracts/beanstalk/storage/System.sol";
   9 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
  10 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  11 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  12 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  13 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  14 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  15 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  16 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  17 |     | import {C} from "contracts/C.sol";
  18 |     | import {LibFlood} from "contracts/libraries/Silo/LibFlood.sol";
  19 |     | import {LibWell, IERC20} from "contracts/libraries/Well/LibWell.sol";
  20 |     | 
  21 |     | /**
  22 |     |  * @title SiloGettersFacet contains view functions related to the silo.
  23 |     |  **/
  24 | *   | contract SiloGettersFacet is ReentrancyGuard {
  25 |     |     using LibRedundantMath256 for uint256;
  26 |     |     using LibRedundantMath128 for uint128;
  27 |     | 
  28 |     |     /**
  29 |     |      * @notice TokenDepositId contains the DepositsIds for a given token.
  30 |     |      */
  31 |     |     struct TokenDepositId {
  32 |     |         address token;
  33 |     |         uint256[] depositIds;
  34 |     |         Deposit[] tokenDeposits;
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Stores account-level Season of Plenty balances.
  39 |     |      *
  40 |     |      * Returned by {balanceOfSop}.
  41 |     |      */
  42 |     |     struct AccountSeasonOfPlenty {
  43 |     |         // The Season that it started Raining, if it was Raining during the last
  44 |     |         // Season in which `account` updated their Silo. Otherwise, 0.
  45 |     |         uint32 lastRain;
  46 |     |         // The last Season of Plenty starting Season processed for `account`.
  47 |     |         uint32 lastSop;
  48 |     |         // `account` balance of Roots when it started raining.
  49 |     |         uint256 roots;
  50 |     |         FarmerSops[] farmerSops;
  51 |     |     }
  52 |     | 
  53 |     |     struct FarmerSops {
  54 |     |         address well;
  55 |     |         PerWellPlenty wellsPlenty;
  56 |     |     }
  57 |     | 
  58 |     |     //////////////////////// GETTERS ////////////////////////
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Get the address of the Bean token.
  62 |     |      */
  63 |     |     function getBeanToken() external view returns (address) {
  64 |     |         return s.sys.bean;
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Find the amount and BDV of `token` that `account` has Deposited in stem index `stem`.
  69 |     |      *
  70 |     |      * Returns a deposit tuple `(uint256 amount, uint256 bdv)`.
  71 |     |      *
  72 |     |      * @return amount The number of tokens contained in this Deposit.
  73 |     |      * @return bdv The BDV associated with this Deposit.
  74 |     |      */
  75 |     |     function getDeposit(
  76 |     |         address account,
  77 |     |         address token,
  78 |     |         int96 stem
  79 |     |     ) external view returns (uint256, uint256) {
  80 |     |         return LibTokenSilo.getDeposit(account, token, stem);
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice Get the total amount of `token` currently Deposited in the Silo across all users.
  85 |     |      * @dev does not include germinating tokens.
  86 |     |      */
  87 |     |     function getTotalDeposited(address token) public view returns (uint256) {
  88 |     |         return s.sys.silo.balances[token].deposited;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @notice Get the total amount deposit for all whitelisted tokens across all users.
  93 |     |      * @dev does not include germinating tokens.
  94 |     |      */
  95 |     |     function getTotalSiloDeposited() external view returns (uint256[] memory depositedAmounts) {
  96 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedTokens();
  97 |     |         depositedAmounts = new uint256[](tokens.length);
  98 |     |         for (uint256 i; i < tokens.length; i++) {
  99 |     |             depositedAmounts[i] = getTotalDeposited(tokens[i]);
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Get the total bdv of `token` currently Deposited in the Silo across all users.
 105 |     |      * @dev does not include germinating bdv.
 106 |     |      */
 107 |     |     function getTotalDepositedBdv(address token) public view returns (uint256) {
 108 |     |         return s.sys.silo.balances[token].depositedBdv;
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Get the total bdv of all whitelisted tokens in the Silo across all users.
 113 |     |      * @dev does not include germinating bdv.
 114 |     |      */
 115 |     |     function getTotalSiloDepositedBdv() external view returns (uint256[] memory depositedBdvs) {
 116 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedTokens();
 117 |     |         depositedBdvs = new uint256[](tokens.length);
 118 |     |         for (uint256 i; i < tokens.length; i++) {
 119 |     |             depositedBdvs[i] = getTotalDepositedBdv(tokens[i]);
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice returns the germinating deposited amount of `token` for the current season.
 125 |     |      */
 126 |     |     function getGerminatingTotalDeposited(address token) external view returns (uint256 amount) {
 127 |     |         (, amount) = LibGerminate.getTotalGerminatingForToken(token);
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice returns the germinating deposited bdv of `token` for the current season.
 132 |     |      */
 133 |     |     function getGerminatingTotalDepositedBdv(address token) external view returns (uint256 _bdv) {
 134 |     |         (_bdv, ) = LibGerminate.getTotalGerminatingForToken(token);
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @notice Get the AssetSettings for a whitelisted Silo token.
 139 |     |      *
 140 |     |      * Contains:
 141 |     |      *  - the BDV function selector
 142 |     |      *  - Stalk per BDV
 143 |     |      *  - stalkEarnedPerSeason
 144 |     |      *  - milestoneSeason
 145 |     |      *  - lastStem
 146 |     |      */
 147 |     |     function tokenSettings(address token) external view returns (AssetSettings memory) {
 148 |     |         return s.sys.silo.assetSettings[token];
 149 |     |     }
 150 |     | 
 151 |     |     //////////////////////// ERC1155 ////////////////////////
 152 |     | 
 153 |     |     /**
 154 |     |      * @notice returns the amount of tokens in a Deposit.
 155 |     |      *
 156 |     |      * @dev see {getDeposit} for both the bdv and amount.
 157 |     |      */
 158 |     |     function balanceOf(address account, uint256 depositId) external view returns (uint256 amount) {
 159 |     |         return s.accts[account].deposits[depositId].amount;
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice returns an array of amounts corresponding to Deposits.
 164 |     |      */
 165 |     |     function balanceOfBatch(
 166 |     |         address[] calldata accounts,
 167 |     |         uint256[] calldata depositIds
 168 |     |     ) external view returns (uint256[] memory) {
 169 |     |         require(accounts.length == depositIds.length, "ERC1155: ids and amounts length mismatch");
 170 |     |         uint256[] memory balances = new uint256[](accounts.length);
 171 |     |         for (uint256 i = 0; i < accounts.length; i++) {
 172 |     |             balances[i] = s.accts[accounts[i]].deposits[depositIds[i]].amount;
 173 |     |         }
 174 |     |         return balances;
 175 |     |     }
 176 |     | 
 177 |     |     /**
 178 |     |      * @notice outputs the depositID given an token address and stem.
 179 |     |      */
 180 | *   |     function getDepositId(address token, int96 stem) external pure returns (uint256) {
 181 | *   |         return LibBytes.packAddressAndStem(token, stem);
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @notice outputs the token and stem given a depositId.
 186 |     |      */
 187 |     |     function getAddressAndStem(
 188 |     |         uint256 depositId
 189 |     |     ) external pure returns (address token, int96 stem) {
 190 |     |         return LibBytes.unpackAddressAndStem(depositId);
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice returns the bean denominated value ("bdv") of a token amount.
 195 |     |      */
 196 |     |     function bdv(address token, uint256 amount) public view returns (uint256 _bdv) {
 197 |     |         _bdv = LibTokenSilo.beanDenominatedValue(token, amount);
 198 |     |     }
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice returns the bean denominated values ("bdv") of an array of tokens and amounts.
 202 |     |      */
 203 |     |     function bdvs(
 204 |     |         address[] calldata tokens,
 205 |     |         uint256[] calldata amounts
 206 |     |     ) external view returns (uint256[] memory _bdvs) {
 207 |     |         _bdvs = new uint256[](tokens.length);
 208 |     |         for (uint256 i; i < tokens.length; i++) {
 209 |     |             _bdvs[i] = bdv(tokens[i], amounts[i]);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     //////////////////////// UTILTIES ////////////////////////
 214 |     | 
 215 |     |     /**
 216 |     |      * @notice Get the last Season in which `account` updated their Silo.
 217 |     |      */
 218 |     |     function lastUpdate(address account) external view returns (uint32) {
 219 |     |         return s.accts[account].lastUpdate;
 220 |     |     }
 221 |     | 
 222 |     |     //////////////////////// SILO: TOTALS ////////////////////////
 223 |     | 
 224 |     |     /**
 225 |     |      * @notice Returns the total supply of Stalk. Does NOT include Grown Stalk.
 226 |     |      */
 227 |     |     function totalStalk() external view returns (uint256) {
 228 |     |         return s.sys.silo.stalk;
 229 |     |     }
 230 |     | 
 231 |     |     /**
 232 |     |      * @notice Returns the unclaimed germinating stalk and roots for a season.
 233 |     |      */
 234 |     |     function getGerminatingStalkAndRootsForSeason(
 235 |     |         uint32 season
 236 |     |     ) external view returns (uint256, uint256) {
 237 |     |         return (
 238 |     |             s.sys.silo.unclaimedGerminating[season].stalk,
 239 |     |             s.sys.silo.unclaimedGerminating[season].roots
 240 |     |         );
 241 |     |     }
 242 |     | 
 243 |     |     /**
 244 |     |      * @notice Returns the unclaimed germinating stalk and roots for a season.
 245 |     |      */
 246 |     |     function getGerminatingStalkForSeason(uint32 season) external view returns (uint256) {
 247 |     |         return (s.sys.silo.unclaimedGerminating[season].stalk);
 248 |     |     }
 249 |     | 
 250 |     |     /**
 251 |     |      * @notice Returns the unclaimed germinating stalk and roots for a season.
 252 |     |      */
 253 |     |     function getGerminatingRootsForSeason(uint32 season) external view returns (uint256) {
 254 |     |         return (s.sys.silo.unclaimedGerminating[season].roots);
 255 |     |     }
 256 |     | 
 257 |     |     /**
 258 |     |      * @notice returns the stalk that is currently in the germination process.
 259 |     |      */
 260 |     |     function getTotalGerminatingStalk() external view returns (uint256) {
 261 |     |         return
 262 |     |             s.sys.silo.unclaimedGerminating[s.sys.season.current].stalk.add(
 263 |     |                 s.sys.silo.unclaimedGerminating[s.sys.season.current - 1].stalk
 264 |     |             );
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @notice returns the young and mature germinating stalk.
 269 |     |      * `young` germinating stalk are stalk that recently started the germination process.
 270 |     |      * (created in the current season)
 271 |     |      * `mature` germinating stalk are stalk that are paritially germinated,
 272 |     |      * and will finish germinating upon the next sunrise call.
 273 |     |      * (created in the previous season)
 274 |     |      */
 275 |     |     function getYoungAndMatureGerminatingTotalStalk()
 276 |     |         external
 277 |     |         view
 278 |     |         returns (uint256 matureGerminatingStalk, uint256 youngGerminatingStalk)
 279 |     |     {
 280 |     |         return (
 281 |     |             s.sys.silo.unclaimedGerminating[s.sys.season.current - 1].stalk,
 282 |     |             s.sys.silo.unclaimedGerminating[s.sys.season.current].stalk
 283 |     |         );
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @notice gets the total amount germinating for a given `token`.
 288 |     |      */
 289 |     |     function getTotalGerminatingAmount(address token) external view returns (uint256) {
 290 |     |         return
 291 |     |             s.sys.silo.germinating[GerminationSide.ODD][token].amount +
 292 |     |             s.sys.silo.germinating[GerminationSide.EVEN][token].amount;
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @notice gets the total amount of bdv germinating for a given `token`.
 297 |     |      */
 298 |     |     function getTotalGerminatingBdv(address token) external view returns (uint256) {
 299 |     |         return
 300 |     |             s.sys.silo.germinating[GerminationSide.ODD][token].bdv +
 301 |     |             s.sys.silo.germinating[GerminationSide.EVEN][token].bdv;
 302 |     |     }
 303 |     | 
 304 |     |     /**
 305 |     |      * @notice gets the odd germinating amount and bdv for a given `token`.
 306 |     |      */
 307 |     |     function getOddGerminating(address token) external view returns (uint256, uint256) {
 308 |     |         return (
 309 |     |             s.sys.silo.germinating[GerminationSide.ODD][token].amount,
 310 |     |             s.sys.silo.germinating[GerminationSide.ODD][token].bdv
 311 |     |         );
 312 |     |     }
 313 |     | 
 314 |     |     /**
 315 |     |      * @notice gets the even germinating amount and bdv for a given `token`.
 316 |     |      */
 317 |     |     function getEvenGerminating(address token) external view returns (uint256, uint256) {
 318 |     |         return (
 319 |     |             s.sys.silo.germinating[GerminationSide.EVEN][token].amount,
 320 |     |             s.sys.silo.germinating[GerminationSide.EVEN][token].bdv
 321 |     |         );
 322 |     |     }
 323 |     | 
 324 |     |     /**
 325 |     |      * @notice returns the amount of stalk that will finish germinating upon a silo interaction.
 326 |     |      */
 327 |     |     function balanceOfFinishedGerminatingStalkAndRoots(
 328 |     |         address account
 329 |     |     ) external view returns (uint256 gStalk, uint256 gRoots) {
 330 |     |         (gStalk, gRoots) = LibGerminate.getFinishedGerminatingStalkAndRoots(
 331 |     |             account,
 332 |     |             s.accts[account].lastUpdate,
 333 |     |             s.sys.season.current
 334 |     |         );
 335 |     |     }
 336 |     | 
 337 |     |     /**
 338 |     |      * @notice Returns the total supply of Roots.
 339 |     |      */
 340 |     |     function totalRoots() external view returns (uint256) {
 341 |     |         return s.sys.silo.roots;
 342 |     |     }
 343 |     | 
 344 |     |     /**
 345 |     |      * @notice Returns the total supply of Earned Beans.
 346 |     |      * @dev Beanstalk's "supply" of Earned Beans is a subset of the total Bean
 347 |     |      * supply. Earned Beans are simply seignorage Beans held by Beanstalk for
 348 |     |      * distribution to Stalkholders during {SiloFacet-plant}.
 349 |     |      */
 350 |     |     function totalEarnedBeans() external view returns (uint256) {
 351 |     |         return s.sys.silo.earnedBeans;
 352 |     |     }
 353 |     | 
 354 |     |     //////////////////////// SILO: ACCOUNT BALANCES ////////////////////////
 355 |     | 
 356 |     |     /**
 357 |     |      * @notice Returns the balance of Stalk for `account`.
 358 |     |      * Does NOT include Grown Stalk.
 359 |     |      * DOES include Earned Stalk.
 360 |     |      * DOES include Germinating Stalk that will end germination
 361 |     |      * upon a silo interaction.
 362 |     |      * @dev Earned Stalk earns Bean Mints, but Grown Stalk does not due to
 363 |     |      * computational complexity.
 364 |     |      */
 365 |     |     function balanceOfStalk(address account) external view returns (uint256) {
 366 |     |         (uint256 germinatingStalk, ) = LibGerminate.getFinishedGerminatingStalkAndRoots(
 367 |     |             account,
 368 |     |             s.accts[account].lastUpdate,
 369 |     |             s.sys.season.current
 370 |     |         );
 371 |     |         return s.accts[account].stalk.add(germinatingStalk).add(balanceOfEarnedStalk(account));
 372 |     |     }
 373 |     | 
 374 |     |     /**
 375 |     |      * @notice Returns the balance of Germinating Stalk for `account`.
 376 |     |      * @dev Germinating Stalk that will finish germination upon a silo interaction
 377 |     |      * is not included.
 378 |     |      */
 379 |     |     function balanceOfGerminatingStalk(address account) external view returns (uint256) {
 380 |     |         return LibGerminate.getCurrentGerminatingStalk(account, s.accts[account].lastUpdate);
 381 |     |     }
 382 |     | 
 383 |     |     /**
 384 |     |      * @notice returns the amount of young and mature germinating stalk that an account has.
 385 |     |      * `young` germinating stalk are the most recent germinating stalk issued to `account`.
 386 |     |      * `mature` germinating stalk are germinating stalk that are paritially germinated.
 387 |     |      * @dev both `young` and `old stalk here may have already finished the germination process
 388 |     |      * but require a silo interaction to update.
 389 |     |      */
 390 |     |     function balanceOfYoungAndMatureGerminatingStalk(
 391 |     |         address account
 392 |     |     ) external view returns (uint256 matureGerminatingStalk, uint256 youngGerminatingStalk) {
 393 |     |         // if the last mowed season is less than the current season - 1,
 394 |     |         // then there are no germinating stalk and roots (as all germinating assets have finished).
 395 |     |         if (s.accts[account].lastUpdate < s.sys.season.current - 1) {
 396 |     |             return (0, 0);
 397 |     |         } else {
 398 |     |             (youngGerminatingStalk, matureGerminatingStalk) = LibGerminate.getGerminatingStalk(
 399 |     |                 account,
 400 |     |                 LibGerminate.isSeasonOdd(s.accts[account].lastUpdate)
 401 |     |             );
 402 |     |         }
 403 |     |     }
 404 |     | 
 405 |     |     /**
 406 |     |      * @notice Returns the balance of Roots for `account`.
 407 |     |      * @dev Roots within Beanstalk are entirely separate from the
 408 |     |      * [ROOT ERC-20 token](https://roottoken.org/).
 409 |     |      *
 410 |     |      * Roots represent proportional ownership of Stalk:
 411 |     |      *  `balanceOfStalk / totalStalk = balanceOfRoots / totalRoots`
 412 |     |      *
 413 |     |      * Roots are used to calculate Earned Bean, Earned Stalk and Plantable Seed
 414 |     |      * balances.
 415 |     |      *
 416 |     |      * When a Flood occurs, Plenty is distributed based on a Farmer's balance
 417 |     |      * of Roots when it started Raining.
 418 |     |      */
 419 |     |     function balanceOfRoots(address account) external view returns (uint256) {
 420 |     |         (, uint256 germinatingRoots) = LibGerminate.getFinishedGerminatingStalkAndRoots(
 421 |     |             account,
 422 |     |             s.accts[account].lastUpdate,
 423 |     |             s.sys.season.current
 424 |     |         );
 425 |     |         return s.accts[account].roots.add(germinatingRoots);
 426 |     |     }
 427 |     | 
 428 |     |     /**
 429 |     |      * @notice Returns the balance of Grown Stalk for `account`. Grown Stalk is
 430 |     |      * earned each Season from BDV and must be Mown via `SiloFacet-mow` to
 431 |     |      * apply it to a user's balance.
 432 |     |      *
 433 |     |      * @dev This passes in the last stem the user mowed at and the current stem
 434 |     |      */
 435 |     |     function balanceOfGrownStalk(address account, address token) public view returns (uint256) {
 436 |     |         return
 437 |     |             LibSilo._balanceOfGrownStalk(
 438 |     |                 s.accts[account].mowStatuses[token].lastStem, //last stem farmer mowed
 439 |     |                 LibTokenSilo.stemTipForToken(token), //get latest stem for this token
 440 |     |                 s.accts[account].mowStatuses[token].bdv
 441 |     |             );
 442 |     |     }
 443 |     | 
 444 |     |     /**
 445 |     |      * @notice Returns the balance of Grown Stalk for `account` for multiple tokens.
 446 |     |      */
 447 |     |     function balanceOfGrownStalkMultiple(
 448 |     |         address account,
 449 |     |         address[] calldata tokens
 450 |     |     ) external view returns (uint256[] memory grownStalks) {
 451 |     |         grownStalks = new uint256[](tokens.length);
 452 |     |         for (uint256 i; i < tokens.length; i++) {
 453 |     |             grownStalks[i] = balanceOfGrownStalk(account, tokens[i]);
 454 |     |         }
 455 |     |     }
 456 |     | 
 457 |     |     /**
 458 |     |      * @notice Returns the balance of Grown Stalk for a single deposit of `token`
 459 |     |      * in `stem` for `account`. Grown Stalk is earned each Season from BDV and
 460 |     |      * must be Mown via `SiloFacet-mow` to apply it to a user's balance.
 461 |     |      *
 462 |     |      * @dev This passes in the last stem the user mowed at and the current stem
 463 |     |      */
 464 |     |     function grownStalkForDeposit(
 465 |     |         address account,
 466 |     |         address token,
 467 |     |         int96 stem
 468 |     |     ) external view returns (uint grownStalk) {
 469 |     |         return LibTokenSilo.grownStalkForDeposit(account, token, stem);
 470 |     |     }
 471 |     | 
 472 |     |     /**
 473 |     |      * @notice Returns the balance of Earned Beans for `account`. Earned Beans
 474 |     |      * are the Beans distributed to Stalkholders during {Sun-rewardToSilo}.
 475 |     |      */
 476 |     |     function balanceOfEarnedBeans(address account) public view returns (uint256 beans) {
 477 |     |         (uint256 germinatingStalk, uint256 germinatingRoots) = LibGerminate
 478 |     |             .getFinishedGerminatingStalkAndRoots(
 479 |     |                 account,
 480 |     |                 s.accts[account].lastUpdate,
 481 |     |                 s.sys.season.current
 482 |     |             );
 483 |     |         uint256 accountStalk = s.accts[account].stalk.add(germinatingStalk);
 484 |     |         uint256 accountRoots = s.accts[account].roots.add(germinatingRoots);
 485 |     |         beans = LibSilo._balanceOfEarnedBeans(accountStalk, accountRoots);
 486 |     |     }
 487 |     | 
 488 |     |     /**
 489 |     |      * @notice Return the `account` balance of Earned Stalk, the Stalk
 490 |     |      * associated with Earned Beans.
 491 |     |      * @dev Earned Stalk can be derived from Earned Beans because
 492 |     |      * 1 Bean => 1 Stalk. See {C-getStalkPerBean}.
 493 |     |      */
 494 |     |     function balanceOfEarnedStalk(address account) public view returns (uint256) {
 495 |     |         return balanceOfEarnedBeans(account).mul(C.STALK_PER_BEAN);
 496 |     |     }
 497 |     | 
 498 |     |     function balanceOfPlantableSeeds(address account) external view returns (uint256) {
 499 |     |         return
 500 |     |             balanceOfEarnedBeans(account) *
 501 |     |             s.sys.silo.assetSettings[s.sys.bean].stalkEarnedPerSeason;
 502 |     |     }
 503 |     | 
 504 |     |     /**
 505 |     |      * @dev Get the number of Stalk per BDV per Season for a set of whitelisted tokens.
 506 |     |      * Stalk has 16 decimal precision. Bean has 6 decimal precision.
 507 |     |      * => stalk earned per season: 1e10 units = 1 stalk per season
 508 |     |      */
 509 |     |     function stalkEarnedPerSeason(
 510 |     |         address[] calldata tokens
 511 |     |     ) external view returns (uint256[] memory stalkEarnedPerSeasons) {
 512 |     |         stalkEarnedPerSeasons = new uint256[](tokens.length);
 513 |     |         for (uint256 i; i < tokens.length; i++) {
 514 |     |             stalkEarnedPerSeasons[i] = LibTokenSilo.stalkEarnedPerSeason(tokens[i]);
 515 |     |         }
 516 |     |     }
 517 |     | 
 518 |     |     /**
 519 |     |      * @notice Return the balance of Deposited BDV of `token` for a given `account`.
 520 |     |      */
 521 |     |     function balanceOfDepositedBdv(
 522 |     |         address account,
 523 |     |         address token
 524 |     |     ) external view returns (uint256 depositedBdv) {
 525 |     |         depositedBdv = s.accts[account].mowStatuses[token].bdv;
 526 |     |     }
 527 |     | 
 528 |     |     /**
 529 |     |      * @notice Return the Stem at the time that `account` last mowed `token`.
 530 |     |      */
 531 |     |     function getLastMowedStem(
 532 |     |         address account,
 533 |     |         address token
 534 |     |     ) external view returns (int96 lastStem) {
 535 |     |         lastStem = s.accts[account].mowStatuses[token].lastStem;
 536 |     |     }
 537 |     | 
 538 |     |     /**
 539 |     |      * @notice Return the Mow Status of `token` for a given `account`.
 540 |     |      * Mow Status includes the Stem at the time that `account` last mowed `token`
 541 |     |      * and the balance of Deposited BDV of `token` for `account`.
 542 |     |      */
 543 |     |     function getMowStatus(
 544 |     |         address account,
 545 |     |         address token
 546 |     |     ) public view returns (MowStatus memory mowStatus) {
 547 |     |         mowStatus = s.accts[account].mowStatuses[token];
 548 |     |     }
 549 |     | 
 550 |     |     /**
 551 |     |      * @notice Return the Mow Status for multiple tokens for a given `account`.
 552 |     |      */
 553 |     |     function getMowStatus(
 554 |     |         address account,
 555 |     |         address[] calldata tokens
 556 |     |     ) external view returns (MowStatus[] memory mowStatuses) {
 557 |     |         mowStatuses = new MowStatus[](tokens.length);
 558 |     |         for (uint256 i; i < tokens.length; i++) {
 559 |     |             mowStatuses[i] = getMowStatus(account, tokens[i]);
 560 |     |         }
 561 |     |     }
 562 |     | 
 563 |     |     //////////////////////// SEASON OF PLENTY ////////////////////////
 564 |     | 
 565 |     |     /**
 566 |     |      * @notice Returns the last Season that it started Raining resulting in a
 567 |     |      * Season of Plenty.
 568 |     |      */
 569 |     |     function lastSeasonOfPlenty() external view returns (uint32) {
 570 |     |         return s.sys.season.lastSop;
 571 |     |     }
 572 |     | 
 573 |     |     /**
 574 |     |      * @notice Returns the `account` balance of unclaimed tokens earned from
 575 |     |      * Seasons of Plenty.
 576 |     |      */
 577 |     |     function balanceOfPlenty(address account, address well) external view returns (uint256 plenty) {
 578 |     |         return LibFlood.balanceOfPlenty(account, well);
 579 |     |     }
 580 |     | 
 581 |     |     /**
 582 |     |      * @notice Returns the `account` balance of Roots the last time it was
 583 |     |      * Raining during a Silo update.
 584 |     |      */
 585 |     |     function balanceOfRainRoots(address account) external view returns (uint256) {
 586 |     |         return s.accts[account].sop.rainRoots;
 587 |     |     }
 588 |     | 
 589 |     |     /**
 590 |     |      * @notice Returns the `account` Season of Plenty related state variables.
 591 |     |      * @dev See {AccountSeasonOfPlenty} struct.
 592 |     |      */
 593 |     |     function balanceOfSop(
 594 |     |         address account
 595 |     |     ) external view returns (AccountSeasonOfPlenty memory sop) {
 596 |     |         sop.lastRain = s.accts[account].lastRain;
 597 |     |         sop.lastSop = s.accts[account].lastSop;
 598 |     |         sop.roots = s.accts[account].sop.rainRoots;
 599 |     |         address[] memory wells = LibWhitelistedTokens.getSoppableWellLpTokens(); // includes previously whitelisted tokens
 600 |     |         sop.farmerSops = new FarmerSops[](wells.length);
 601 |     |         for (uint256 i; i < wells.length; i++) {
 602 |     |             PerWellPlenty memory wellSop = s.accts[account].sop.perWellPlenty[wells[i]];
 603 |     |             FarmerSops memory farmerSops = FarmerSops(wells[i], wellSop);
 604 |     |             sop.farmerSops[i] = farmerSops;
 605 |     |         }
 606 |     |     }
 607 |     | 
 608 |     |     function totalRainRoots() external view returns (uint256) {
 609 |     |         return s.sys.rain.roots;
 610 |     |     }
 611 |     | 
 612 |     |     //////////////////////// STEM ////////////////////////
 613 |     | 
 614 |     |     /**
 615 |     |      * @notice Returns the "stemTip" for a given token.
 616 |     |      * @dev the stemTip is the Cumulative Grown Stalk Per BDV
 617 |     |      * of a given deposited asset since whitelist.
 618 |     |      *
 619 |     |      * note that a deposit for a given asset may have
 620 |     |      * a higher Grown Stalk Per BDV than the stemTip.
 621 |     |      *
 622 |     |      * This can occur when a deposit is converted from an asset
 623 |     |      * with a larger seeds per BDV, to a lower seeds per BDV.
 624 |     |      */
 625 |     |     function stemTipForToken(address token) external view returns (int96 _stemTip) {
 626 |     |         _stemTip = LibTokenSilo.stemTipForToken(token);
 627 |     |     }
 628 |     | 
 629 |     |     /**
 630 |     |      * @notice Returns the stemTip for all whitelisted tokens.
 631 |     |      */
 632 |     |     function getStemTips() external view returns (int96[] memory _stemTips) {
 633 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedTokens();
 634 |     |         _stemTips = new int96[](tokens.length);
 635 |     |         for (uint256 i; i < tokens.length; i++) {
 636 |     |             _stemTips[i] = LibTokenSilo.stemTipForToken(tokens[i]);
 637 |     |         }
 638 |     |     }
 639 |     | 
 640 |     |     function calculateStemForTokenFromGrownStalk(
 641 |     |         address token,
 642 |     |         uint256 grownStalk,
 643 |     |         uint256 bdvOfDeposit
 644 |     |     ) external view returns (int96 stem, GerminationSide germ) {
 645 |     |         (stem, germ) = LibTokenSilo.calculateStemForTokenFromGrownStalk(
 646 |     |             token,
 647 |     |             grownStalk,
 648 |     |             bdvOfDeposit
 649 |     |         );
 650 |     |     }
 651 |     | 
 652 |     |     /**
 653 |     |      * @notice gets the germinating stem for a given token.
 654 |     |      * @dev deposits with a stem lower than the germinating stem are not germinating.
 655 |     |      * deposits with a stem equal or greater to the germinating stem are germinating.
 656 |     |      */
 657 |     |     function getGerminatingStem(address token) external view returns (int96 germinatingStem) {
 658 |     |         LibGerminate.GermStem memory g = LibGerminate.getGerminatingStem(token);
 659 |     |         return g.germinatingStem;
 660 |     |     }
 661 |     | 
 662 |     |     function getHighestNonGerminatingStem(address token) external view returns (int96 stem) {
 663 |     |         return LibGerminate.getHighestNonGerminatingStem(token);
 664 |     |     }
 665 |     | 
 666 |     |     /**
 667 |     |      * @notice returns the germinating stem for a list of tokens.
 668 |     |      */
 669 |     |     function getGerminatingStems(
 670 |     |         address[] memory tokens
 671 |     |     ) external view returns (int96[] memory germinatingStems) {
 672 |     |         germinatingStems = new int96[](tokens.length);
 673 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 674 |     |             germinatingStems[i] = LibGerminate.getGerminatingStem(tokens[i]).germinatingStem;
 675 |     |         }
 676 |     |     }
 677 |     | 
 678 |     |     function getHighestNonGerminatingStems(
 679 |     |         address[] memory tokens
 680 |     |     ) external view returns (int96[] memory highestNonGerminatingStems) {
 681 |     |         highestNonGerminatingStems = new int96[](tokens.length);
 682 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 683 |     |             highestNonGerminatingStems[i] = LibGerminate.getHighestNonGerminatingStem(tokens[i]);
 684 |     |         }
 685 |     |     }
 686 |     | 
 687 |     |     //////////////////////// INTERNAL ////////////////////////
 688 |     | 
 689 |     |     /**
 690 |     |      * @notice Returns the current Season number.
 691 |     |      */
 692 |     |     function _season() internal view returns (uint32) {
 693 |     |         return s.sys.season.current;
 694 |     |     }
 695 |     | 
 696 |     |     /**
 697 |     |      * @notice returns the deposits for an account for all whitelistedTokens.
 698 |     |      * @notice if a user has no deposits, the function will return an empty array.
 699 |     |      */
 700 |     |     function getDepositsForAccount(
 701 |     |         address account
 702 |     |     ) external view returns (TokenDepositId[] memory deposits) {
 703 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedTokens();
 704 |     |         deposits = new TokenDepositId[](tokens.length);
 705 |     |         for (uint256 i; i < tokens.length; i++) {
 706 |     |             deposits[i] = getTokenDepositsForAccount(account, tokens[i]);
 707 |     |         }
 708 |     |     }
 709 |     | 
 710 |     |     /**
 711 |     |      * @notice returns the deposits for an account for all specified tokens.
 712 |     |      * @notice if a user has no deposits, the function will return an empty array.
 713 |     |      */
 714 |     |     function getDepositsForAccount(
 715 |     |         address account,
 716 |     |         address[] calldata tokens
 717 |     |     ) external view returns (TokenDepositId[] memory deposits) {
 718 |     |         deposits = new TokenDepositId[](tokens.length);
 719 |     |         for (uint256 i; i < tokens.length; i++) {
 720 |     |             deposits[i] = getTokenDepositsForAccount(account, tokens[i]);
 721 |     |         }
 722 |     |     }
 723 |     | 
 724 |     |     /**
 725 |     |      * @notice returns an array of deposits for a given account and token.
 726 |     |      */
 727 |     |     function getTokenDepositsForAccount(
 728 |     |         address account,
 729 |     |         address token
 730 |     |     ) public view returns (TokenDepositId memory deposits) {
 731 |     |         uint256[] memory depositIds = s.accts[account].depositIdList[token].depositIds;
 732 |     |         if (depositIds.length == 0) return TokenDepositId(token, depositIds, new Deposit[](0));
 733 |     |         deposits.token = token;
 734 |     |         deposits.depositIds = depositIds;
 735 |     |         deposits.tokenDeposits = new Deposit[](depositIds.length);
 736 |     |         for (uint256 i; i < depositIds.length; i++) {
 737 |     |             deposits.tokenDeposits[i] = s.accts[account].deposits[depositIds[i]];
 738 |     |         }
 739 |     |     }
 740 |     | 
 741 |     |     /**
 742 |     |      * @notice returns the DepositList for a given account and token.
 743 |     |      */
 744 |     |     function getTokenDepositIdsForAccount(
 745 |     |         address account,
 746 |     |         address token
 747 |     |     ) public view returns (uint256[] memory depositIds) {
 748 |     |         return s.accts[account].depositIdList[token].depositIds;
 749 |     |     }
 750 |     | 
 751 |     |     function getIndexForDepositId(
 752 |     |         address account,
 753 |     |         address token,
 754 |     |         uint256 depositId
 755 |     |     ) external view returns (uint256) {
 756 |     |         return s.accts[account].depositIdList[token].idIndex[depositId];
 757 |     |     }
 758 |     | 
 759 |     |     function getBeanIndex(IERC20[] calldata tokens) external view returns (uint256) {
 760 |     |         return LibWell.getBeanIndex(tokens);
 761 |     |     }
 762 |     | 
 763 | *   |     function getNonBeanTokenAndIndexFromWell(
 764 |     |         address well
 765 | *   |     ) external view returns (address, uint256) {
 766 | *   |         return LibWell.getNonBeanTokenAndIndexFromWell(well);
 767 |     |     }
 768 |     | }
 769 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/WhitelistFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {WhitelistedTokens} from "./abstract/WhitelistedTokens.sol";
   8 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
   9 |     | import {LibWhitelist} from "contracts/libraries/Silo/LibWhitelist.sol";
  10 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  11 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  12 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  13 |     | import {EvaluationParameters} from "contracts/beanstalk/storage/System.sol";
  14 |     | import {Implementation} from "contracts/beanstalk/storage/System.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title Whitelist Facet
  18 |     |  * @notice Manages the Silo Whitelist including Adding to, Updating
  19 |     |  * and Removing from the Silo Whitelist
  20 |     |  **/
  21 | *   | contract WhitelistFacet is Invariable, WhitelistedTokens, ReentrancyGuard {
  22 |     |     /**
  23 |     |      * @notice emitted when {EvaluationParameters} is updated.
  24 |     |      */
  25 |     |     event UpdatedEvaluationParameters(EvaluationParameters);
  26 |     | 
  27 |     |     /**
  28 |     |      * @notice Removes a token from the Silo Whitelist.
  29 |     |      * @dev Can only be called by Beanstalk or Beanstalk owner.
  30 |     |      */
  31 |     |     function dewhitelistToken(
  32 |     |         address token
  33 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
  34 |     |         LibDiamond.enforceIsOwnerOrContract();
  35 |     |         LibWhitelist.dewhitelistToken(token);
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Adds a token to the Silo Whitelist.
  40 |     |      * @param token Address of the token that is being Whitelisted.
  41 |     |      * @param selector The function selector that is used to calculate the BDV of the token.
  42 |     |      * @param stalkIssuedPerBdv The amount of Stalk issued per BDV on Deposit.
  43 |     |      * @param stalkEarnedPerSeason The amount of Stalk earned per Season for each Deposited BDV.
  44 |     |      * @param encodeType The encode type that should be used to encode the BDV function call. See {LibTokenSilo.beanDenominatedValue}.
  45 |     |      * @param gaugePoints The initial gauge points for the token.
  46 |     |      * @param optimalPercentDepositedBdv The optimal percent of deposited BDV for the token.
  47 |     |      * @param oracleImplementation The implementation of the oracle that should be used to fetch the token price.
  48 |     |      * @param gaugePointImplementation The implementation of the gauge point function that should be used to calculate the gauge points.
  49 |     |      * @param liquidityWeightImplementation The implementation of the liquidity weight function that should be used to calculate the liquidity weight.
  50 |     |      *
  51 |     |      * @dev If the implementation addresses are 0, then beanstalk calls the selector on itself.
  52 |     |      * See {LibWhitelist.whitelistTokenWithExternalImplementation} for more info on implementation.
  53 |     |      * The selector MUST be a view function that returns an uint256 for all implementation.
  54 |     |      * The oracleImplementation selector should take:
  55 |     |      *  - `lookback` parameter
  56 |     |      *  - `decimals` parameter
  57 |     |      *  (foo(uint256)).
  58 |     |      * The gaugePointImplementation selector should take:
  59 |     |      *  - current gauge points,
  60 |     |      *  - optimal deposited bdv,
  61 |     |      *  - percent depositedbdv
  62 |     |      *  - data as bytes
  63 |     |      * (foo(uint256, uint256, uint256, bytes)).
  64 |     |      * The liquidityWeightImplementation selector should take:
  65 |     |      * (foo(bytes)).
  66 |     |      */
  67 |     |     function whitelistToken(
  68 |     |         address token,
  69 |     |         bytes4 selector,
  70 |     |         uint48 stalkIssuedPerBdv,
  71 |     |         uint40 stalkEarnedPerSeason,
  72 |     |         bytes1 encodeType,
  73 |     |         uint128 gaugePoints,
  74 |     |         uint64 optimalPercentDepositedBdv,
  75 |     |         Implementation memory oracleImplementation,
  76 |     |         Implementation memory gaugePointImplementation,
  77 |     |         Implementation memory liquidityWeightImplementation
  78 |     |     ) external payable {
  79 |     |         LibDiamond.enforceIsOwnerOrContract();
  80 |     |         LibWhitelist.whitelistToken(
  81 |     |             token,
  82 |     |             selector,
  83 |     |             stalkIssuedPerBdv,
  84 |     |             stalkEarnedPerSeason,
  85 |     |             encodeType,
  86 |     |             gaugePoints,
  87 |     |             optimalPercentDepositedBdv,
  88 |     |             oracleImplementation,
  89 |     |             gaugePointImplementation,
  90 |     |             liquidityWeightImplementation
  91 |     |         );
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice Updates the Stalk Per BDV Per Season for a given Token
  96 |     |      * @param token Address of the token that is being Whitelisted.
  97 |     |      * @param stalkEarnedPerSeason The new amount of Stalk earned per Season for each Deposited BDV.
  98 |     |      * @dev Can only be called by Beanstalk or Beanstalk owner.
  99 |     |      */
 100 |     |     function updateStalkPerBdvPerSeasonForToken(
 101 |     |         address token,
 102 |     |         uint40 stalkEarnedPerSeason
 103 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 104 |     |         LibDiamond.enforceIsOwnerOrContract();
 105 |     |         LibWhitelist.updateStalkPerBdvPerSeasonForToken(token, stalkEarnedPerSeason);
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Updates gauge settings for token.
 110 |     |      * @dev {LibWhitelistedTokens} must be updated to include the new token.
 111 |     |      * Assumes the gaugePoint and LiquidityWeight implementations are functions
 112 |     |      * implemented in the Beanstalk contract.
 113 |     |      */
 114 |     |     function updateGaugeForToken(
 115 |     |         address token,
 116 |     |         uint64 optimalPercentDepositedBdv,
 117 |     |         Implementation memory gpImplementation,
 118 |     |         Implementation memory lwImplementation
 119 |     |     ) external payable fundsSafu noNetFlow noSupplyChange nonReentrant {
 120 |     |         LibDiamond.enforceIsOwnerOrContract();
 121 |     |         LibWhitelist.updateGaugeForToken(
 122 |     |             token,
 123 |     |             optimalPercentDepositedBdv,
 124 |     |             gpImplementation,
 125 |     |             lwImplementation
 126 |     |         );
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @notice Updates the Oracle Implementation for a given Token.
 131 |     |      */
 132 | *   |     function updateOracleImplementationForToken(
 133 |     |         address token,
 134 |     |         Implementation memory impl
 135 |     |     ) external payable {
 136 | *   |         LibDiamond.enforceIsOwnerOrContract();
 137 | *   |         LibWhitelist.updateOracleImplementationForToken(token, impl);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @notice Updates the Liquidity Weight Implementation for a given Token.
 142 |     |      */
 143 |     |     function updateLiquidityWeightImplementationForToken(
 144 |     |         address token,
 145 |     |         Implementation memory impl
 146 |     |     ) external payable {
 147 |     |         LibDiamond.enforceIsOwnerOrContract();
 148 |     |         LibWhitelist.updateLiquidityWeightImplementationForToken(token, impl);
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice Updates the Gauge Point Implementation for a given Token.
 153 |     |      */
 154 |     |     function updateGaugePointImplementationForToken(
 155 |     |         address token,
 156 |     |         Implementation memory impl
 157 |     |     ) external payable {
 158 |     |         LibDiamond.enforceIsOwnerOrContract();
 159 |     |         LibWhitelist.updateGaugePointImplementationForToken(token, impl);
 160 |     |     }
 161 |     | 
 162 |     |     function updateSeedGaugeSettings(
 163 |     |         EvaluationParameters memory updatedSeedGaugeSettings
 164 |     |     ) external {
 165 |     |         LibDiamond.enforceIsOwnerOrContract();
 166 |     |         s.sys.evaluationParameters = updatedSeedGaugeSettings;
 167 |     |         emit UpdatedEvaluationParameters(updatedSeedGaugeSettings);
 168 |     |     }
 169 |     | 
 170 |     |     function getOracleImplementationForToken(
 171 |     |         address token
 172 |     |     ) external view returns (Implementation memory) {
 173 |     |         return s.sys.oracleImplementation[token];
 174 |     |     }
 175 |     | 
 176 |     |     function getGaugePointImplementationForToken(
 177 |     |         address token
 178 |     |     ) external view returns (Implementation memory) {
 179 |     |         return s.sys.silo.assetSettings[token].gaugePointImplementation;
 180 |     |     }
 181 |     | 
 182 |     |     function getLiquidityWeightImplementationForToken(
 183 |     |         address token
 184 |     |     ) external view returns (Implementation memory) {
 185 |     |         return s.sys.silo.assetSettings[token].liquidityWeightImplementation;
 186 |     |     }
 187 |     | }
 188 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/abstract/TokenSilo.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | pragma solidity ^0.8.20;
   5 |     | pragma abicoder v2;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   9 |     | import {GerminationSide} from "contracts/beanstalk/storage/System.sol";
  10 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  11 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  12 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
  13 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  14 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  15 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  16 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  17 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  18 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  19 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  20 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  21 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  22 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  23 |     | 
  24 |     | /**
  25 |     |  * @title TokenSilo
  26 |     |  * @notice This contract contains functions for depositing, withdrawing.
  27 |     |  * "Removing a Deposit" only removes from the `account`; the total amount
  28 |     |  * deposited in the Silo is decremented during withdrawal, _after_ a Withdrawal
  29 |     |  * is created. See "Finish Removal".
  30 |     |  */
  31 |     | abstract contract TokenSilo is ReentrancyGuard {
  32 |     |     using LibRedundantMath256 for uint256;
  33 |     |     using LibRedundantMath128 for uint128;
  34 |     |     using LibRedundantMath32 for uint32;
  35 |     |     using SafeCast for uint256;
  36 |     |     using SafeERC20 for IERC20;
  37 |     | 
  38 |     |     //////////////////////// INTERNAL: MOW ////////////////////////
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Claims the Grown Stalk for user. Requires token address to mow.
  42 |     |      */
  43 |     |     modifier mowSender(address token) {
  44 | *   |         LibSilo._mow(LibTractor._user(), token);
  45 |     |         _;
  46 |     |     }
  47 |     | 
  48 |     |     //////////////////////// DEPOSIT ////////////////////////
  49 |     | 
  50 |     |     /**
  51 |     |      * @dev Handle deposit accounting.
  52 |     |      *
  53 |     |      * - {LibTokenSilo.deposit} calculates BDV, adds a Deposit to `account`, and
  54 |     |      *   increments the total amount Deposited.
  55 |     |      * - {LibSilo.mintStalk} mints the Stalk associated with
  56 |     |      *   the Deposit.
  57 |     |      *
  58 |     |      * This step should enforce that new Deposits are placed into the current
  59 |     |      * `LibTokenSilo.stemTipForToken(token)`.
  60 |     |      */
  61 | *   |     function _deposit(
  62 |     |         address account,
  63 |     |         address token,
  64 |     |         uint256 amount
  65 | *   |     ) internal returns (uint256 stalk, int96 stem) {
  66 | *   |         GerminationSide side;
  67 | *   |         (stalk, side) = LibTokenSilo.deposit(
  68 | *   |             account,
  69 | *   |             token,
  70 | *   |             stem = LibTokenSilo.stemTipForToken(token),
  71 | *   |             amount
  72 |     |         );
  73 | *   |         LibSilo.mintGerminatingStalk(account, uint128(stalk), side);
  74 |     |     }
  75 |     | 
  76 |     |     //////////////////////// WITHDRAW ////////////////////////
  77 |     | 
  78 |     |     /**
  79 |     |      * @notice Handles withdraw accounting.
  80 |     |      *
  81 |     |      * - {LibSilo._removeDepositFromAccount} calculates the stalk
  82 |     |      * assoicated with a given deposit, and removes the deposit from the account.
  83 |     |      * emits `RemoveDeposit` and `TransferSingle` events.
  84 |     |      *
  85 |     |      * - {_withdraw} updates the total value deposited in the silo, and burns
  86 |     |      * the stalk assoicated with the deposits.
  87 |     |      *
  88 |     |      */
  89 | *   |     function _withdrawDeposit(address account, address token, int96 stem, uint256 amount) internal {
  90 |     |         // Remove the Deposit from `account`.
  91 | *   |         (
  92 | *   |             uint256 initalStalkRemoved,
  93 | *   |             uint256 grownStalkRemoved,
  94 | *   |             uint256 bdvRemoved,
  95 | *   |             GerminationSide side
  96 | *   |         ) = LibSilo._removeDepositFromAccount(
  97 | *   |                 account,
  98 | *   |                 token,
  99 | *   |                 stem,
 100 | *   |                 amount,
 101 | *   |                 LibTokenSilo.Transfer.emitTransferSingle
 102 |     |             );
 103 | *   |         if (side == GerminationSide.NOT_GERMINATING) {
 104 |     |             // remove the deposit from totals
 105 |     |             _withdraw(
 106 |     |                 account,
 107 |     |                 token,
 108 |     |                 amount,
 109 |     |                 bdvRemoved,
 110 |     |                 initalStalkRemoved.add(grownStalkRemoved)
 111 |     |             );
 112 |     |         } else {
 113 |     |             // remove deposit from germination, and burn the grown stalk.
 114 |     |             // grown stalk does not germinate and is not counted in germinating totals.
 115 | *   |             _withdrawGerminating(account, token, amount, bdvRemoved, initalStalkRemoved, side);
 116 |     | 
 117 | *   |             if (grownStalkRemoved > 0) {
 118 |     |                 LibSilo.burnActiveStalk(account, grownStalkRemoved);
 119 |     |             }
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Handles withdraw accounting for multiple deposits.
 125 |     |      *
 126 |     |      * - {LibSilo._removeDepositsFromAccount} removes the deposits from the account,
 127 |     |      * and returns the total tokens, stalk, and bdv removed from the account.
 128 |     |      *
 129 |     |      * - {_withdraw} updates the total value deposited in the silo, and burns
 130 |     |      * the stalk assoicated with the deposits.
 131 |     |      *
 132 |     |      */
 133 | *   |     function _withdrawDeposits(
 134 |     |         address account,
 135 |     |         address token,
 136 |     |         int96[] calldata stems,
 137 |     |         uint256[] calldata amounts
 138 | *   |     ) internal returns (uint256) {
 139 | *   |         require(stems.length == amounts.length, "Silo: Crates, amounts are diff lengths.");
 140 |     | 
 141 | *   |         LibSilo.AssetsRemoved memory ar = LibSilo._removeDepositsFromAccount(
 142 | *   |             account,
 143 | *   |             token,
 144 | *   |             stems,
 145 | *   |             amounts
 146 |     |         );
 147 |     | 
 148 |     |         // withdraw deposits that are not germinating.
 149 | *   |         if (ar.active.tokens > 0) {
 150 |     |             _withdraw(account, token, ar.active.tokens, ar.active.bdv, ar.active.stalk);
 151 |     |         }
 152 |     | 
 153 |     |         // withdraw Germinating deposits from odd seasons
 154 | *   |         if (ar.odd.tokens > 0) {
 155 | *   |             _withdrawGerminating(
 156 | *   |                 account,
 157 | *   |                 token,
 158 | *   |                 ar.odd.tokens,
 159 | *   |                 ar.odd.bdv,
 160 | *   |                 ar.odd.stalk,
 161 | *   |                 GerminationSide.ODD
 162 |     |             );
 163 |     |         }
 164 |     | 
 165 |     |         // withdraw Germinating deposits from even seasons
 166 | *   |         if (ar.even.tokens > 0) {
 167 |     |             _withdrawGerminating(
 168 |     |                 account,
 169 |     |                 token,
 170 |     |                 ar.even.tokens,
 171 |     |                 ar.even.bdv,
 172 |     |                 ar.even.stalk,
 173 |     |                 GerminationSide.EVEN
 174 |     |             );
 175 |     |         }
 176 |     | 
 177 | *   |         if (ar.grownStalkFromGermDeposits > 0) {
 178 |     |             LibSilo.burnActiveStalk(account, ar.grownStalkFromGermDeposits);
 179 |     |         }
 180 |     | 
 181 |     |         // we return the summation of all tokens removed from the silo.
 182 |     |         // to be used in {SiloFacet.withdrawDeposits}.
 183 | *   |         return ar.active.tokens.add(ar.odd.tokens).add(ar.even.tokens);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev internal helper function for withdraw accounting.
 188 |     |      */
 189 |     |     function _withdraw(
 190 |     |         address account,
 191 |     |         address token,
 192 |     |         uint256 amount,
 193 |     |         uint256 bdv,
 194 |     |         uint256 stalk
 195 |     |     ) private {
 196 |     |         // Decrement total deposited in the silo.
 197 |     |         LibTokenSilo.decrementTotalDeposited(token, amount, bdv);
 198 |     |         // Burn stalk and roots associated with the stalk.
 199 |     |         LibSilo.burnActiveStalk(account, stalk);
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev internal helper function for withdraw accounting with germination.
 204 |     |      * @param side determines whether to withdraw from odd or even germination.
 205 |     |      */
 206 | *   |     function _withdrawGerminating(
 207 |     |         address account,
 208 |     |         address token,
 209 |     |         uint256 amount,
 210 |     |         uint256 bdv,
 211 |     |         uint256 stalk,
 212 |     |         GerminationSide side
 213 |     |     ) private {
 214 |     |         // Decrement from total germinating.
 215 | *   |         LibTokenSilo.decrementTotalGerminating(token, amount, bdv, side); // Decrement total Germinating in the silo.
 216 | *   |         LibSilo.burnGerminatingStalk(account, uint128(stalk), side); // Burn stalk and roots associated with the stalk.
 217 |     |     }
 218 |     | 
 219 |     |     //////////////////////// TRANSFER ////////////////////////
 220 |     | 
 221 |     |     /**
 222 |     |      * @notice Intenral transfer logic accounting.
 223 |     |      *
 224 |     |      * @dev Removes `amount` of a single Deposit from `sender` and transfers
 225 |     |      * it to `recipient`. No Stalk are burned, and the total amount of
 226 |     |      * Deposited `token` in the Silo doesn't change.
 227 |     |      */
 228 | *   |     function _transferDeposit(
 229 |     |         address sender,
 230 |     |         address recipient,
 231 |     |         address token,
 232 |     |         int96 stem,
 233 |     |         uint256 amount
 234 | *   |     ) internal returns (uint256) {
 235 | *   |         if (sender != LibTractor._user()) {
 236 | *   |             LibSilo._spendDepositAllowance(sender, LibTractor._user(), token, amount);
 237 |     |         }
 238 | *   |         LibSilo._mow(sender, token);
 239 |     |         // Need to update the recipient's Silo as well.
 240 | *   |         LibSilo._mow(recipient, token);
 241 |     | 
 242 | *   |         (uint256 initialStalk, uint256 activeStalk, uint256 bdv, GerminationSide side) = LibSilo
 243 |     |             ._removeDepositFromAccount(
 244 | *   |                 sender,
 245 | *   |                 token,
 246 | *   |                 stem,
 247 | *   |                 amount,
 248 | *   |                 LibTokenSilo.Transfer.noEmitTransferSingle
 249 |     |             );
 250 | *   |         LibTokenSilo.addDepositToAccount(
 251 | *   |             recipient,
 252 | *   |             token,
 253 | *   |             stem,
 254 | *   |             amount,
 255 | *   |             bdv,
 256 | *   |             LibTokenSilo.Transfer.noEmitTransferSingle
 257 |     |         );
 258 |     | 
 259 | *   |         if (side == GerminationSide.NOT_GERMINATING) {
 260 |     |             LibSilo.transferStalk(sender, recipient, initialStalk.add(activeStalk));
 261 |     |         } else {
 262 | *   |             LibSilo.transferGerminatingStalk(sender, recipient, initialStalk, side);
 263 | *   |             if (activeStalk > 0) {
 264 |     |                 LibSilo.transferStalk(sender, recipient, activeStalk);
 265 |     |             }
 266 |     |         }
 267 |     | 
 268 |     |         /**
 269 |     |          * the current beanstalk system uses {AddDeposit}
 270 |     |          * and {RemoveDeposit} events to represent a transfer.
 271 |     |          * However, the ERC1155 standard has a dedicated {TransferSingle} event,
 272 |     |          * which is used here.
 273 |     |          */
 274 | *   |         emit LibTokenSilo.TransferSingle(
 275 | *   |             LibTractor._user(),
 276 | *   |             sender,
 277 | *   |             recipient,
 278 | *   |             LibBytes.packAddressAndStem(token, stem),
 279 | *   |             amount
 280 |     |         );
 281 |     | 
 282 | *   |         return bdv;
 283 |     |     }
 284 |     | 
 285 |     |     /**
 286 |     |      * @notice Intenral transfer logic accounting for multiple deposits.
 287 |     |      *
 288 |     |      * @dev Removes `amounts` of multiple Deposits from `sender` and transfers
 289 |     |      * them to `recipient`. No Stalk are burned, and the total amount of
 290 |     |      * Deposited `token` in the Silo doesn't change.
 291 |     |      */
 292 | *   |     function _transferDeposits(
 293 |     |         address sender,
 294 |     |         address recipient,
 295 |     |         address token,
 296 |     |         int96[] calldata stems,
 297 |     |         uint256[] calldata amounts
 298 | *   |     ) internal returns (uint256[] memory) {
 299 | *   |         require(stems.length == amounts.length, "Silo: Crates, amounts are diff lengths.");
 300 |     | 
 301 | *   |         LibSilo.AssetsRemoved memory ar;
 302 | *   |         uint256[] memory bdvs = new uint256[](stems.length);
 303 | *   |         uint256[] memory removedDepositIDs = new uint256[](stems.length);
 304 |     | 
 305 |     |         // get the germinating stem for the token
 306 | *   |         LibGerminate.GermStem memory germStem = LibGerminate.getGerminatingStem(token);
 307 |     |         // Similar to {removeDepositsFromAccount}, however the Deposit is also
 308 |     |         // added to the recipient's account during each iteration.
 309 | *   |         for (uint256 i; i < stems.length; ++i) {
 310 | *   |             GerminationSide side = LibGerminate._getGerminationState(stems[i], germStem);
 311 | *   |             uint256 crateBdv = LibTokenSilo.removeDepositFromAccount(
 312 | *   |                 sender,
 313 | *   |                 token,
 314 | *   |                 stems[i],
 315 | *   |                 amounts[i]
 316 |     |             );
 317 | *   |             LibTokenSilo.addDepositToAccount(
 318 | *   |                 recipient,
 319 | *   |                 token,
 320 | *   |                 stems[i],
 321 | *   |                 amounts[i],
 322 | *   |                 crateBdv,
 323 | *   |                 LibTokenSilo.Transfer.noEmitTransferSingle
 324 |     |             );
 325 | *   |             uint256 crateStalk = LibSilo.stalkReward(
 326 | *   |                 stems[i],
 327 | *   |                 germStem.stemTip,
 328 | *   |                 crateBdv.toUint128()
 329 |     |             );
 330 |     | 
 331 |     |             // if the deposit is germinating, increment germinating bdv and stalk,
 332 |     |             // otherwise increment deposited values.
 333 | *   |             ar.active.tokens = ar.active.tokens.add(amounts[i]);
 334 | *   |             if (side == GerminationSide.NOT_GERMINATING) {
 335 |     |                 ar.active.bdv = ar.active.bdv.add(crateBdv);
 336 |     |                 ar.active.stalk = ar.active.stalk.add(crateStalk);
 337 |     |             } else {
 338 | *   |                 if (side == GerminationSide.ODD) {
 339 | *   |                     ar.odd.bdv = ar.odd.bdv.add(crateBdv);
 340 | *   |                     ar.odd.stalk = ar.odd.stalk.add(crateStalk);
 341 |     |                 } else {
 342 |     |                     ar.even.bdv = ar.even.bdv.add(crateBdv);
 343 |     |                     ar.even.stalk = ar.even.stalk.add(crateStalk);
 344 |     |                 }
 345 |     |             }
 346 | *   |             bdvs[i] = crateBdv;
 347 | *   |             removedDepositIDs[i] = uint256(LibBytes.packAddressAndStem(token, stems[i]));
 348 |     |         }
 349 |     | 
 350 |     |         // transfer regular and germinating stalk (if appliable)
 351 | *   |         LibSilo.transferStalkAndGerminatingStalk(sender, recipient, token, ar);
 352 |     | 
 353 |     |         /**
 354 |     |          *  The current beanstalk system uses a mix of {AddDeposit}
 355 |     |          *  and {RemoveDeposits} events to represent a batch transfer.
 356 |     |          *  However, the ERC1155 standard has a dedicated {batchTransfer} event,
 357 |     |          *  which is used here.
 358 |     |          */
 359 | *   |         emit LibTokenSilo.TransferBatch(
 360 | *   |             LibTractor._user(),
 361 | *   |             sender,
 362 | *   |             recipient,
 363 | *   |             removedDepositIDs,
 364 | *   |             amounts
 365 |     |         );
 366 |     |         // emit RemoveDeposits event (tokens removed are summation).
 367 | *   |         emit LibSilo.RemoveDeposits(sender, token, stems, amounts, ar.active.tokens, bdvs);
 368 |     | 
 369 | *   |         return bdvs;
 370 |     |     }
 371 |     | }
 372 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/silo/abstract/WhitelistedTokens.sol
  1 |     | /*
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  8 |     | import {WhitelistStatus} from "contracts/beanstalk/storage/System.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title WhitelistedTokens
 12 |     |  * @notice Returns information related to WhitelistStatuses.
 13 |     |  */
 14 |     | abstract contract WhitelistedTokens {
 15 |     |     /**
 16 |     |      * @notice Returns all tokens that have been whitelisted and has not had its Whitelist Status manually removed.
 17 |     |      * @dev includes Dewhitelisted tokens with existing Deposits.
 18 |     |      */
 19 |     |     function getSiloTokens() external view returns (address[] memory tokens) {
 20 |     |         return LibWhitelistedTokens.getSiloTokens();
 21 |     |     }
 22 |     | 
 23 |     |     /**
 24 |     |      * @notice Returns the current Whitelisted tokens.
 25 |     |      */
 26 |     |     function getWhitelistedTokens() external view returns (address[] memory tokens) {
 27 |     |         return LibWhitelistedTokens.getWhitelistedTokens();
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @notice Returns the current Whitelisted LP tokens.
 32 |     |      */
 33 |     |     function getWhitelistedLpTokens() external view returns (address[] memory tokens) {
 34 |     |         return LibWhitelistedTokens.getWhitelistedLpTokens();
 35 |     |     }
 36 |     | 
 37 |     |     /**
 38 |     |      * @notice Returns the current Whitelisted Well LP tokens.
 39 |     |      */
 40 |     |     function getWhitelistedWellLpTokens() external view returns (address[] memory tokens) {
 41 |     |         return LibWhitelistedTokens.getWhitelistedWellLpTokens();
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @notice Returns the Whitelist statues for all tokens with a non-zero Deposit.
 46 |     |      */
 47 |     |     function getWhitelistStatuses()
 48 |     |         external
 49 |     |         view
 50 |     |         returns (WhitelistStatus[] memory _whitelistStatuses)
 51 |     |     {
 52 |     |         return LibWhitelistedTokens.getWhitelistedStatuses();
 53 |     |     }
 54 |     | 
 55 |     |     /**
 56 |     |      * @notice Returns the Whitelist statu for a given Deposit.
 57 |     |      */
 58 |     |     function getWhitelistStatus(
 59 |     |         address token
 60 |     |     ) external view returns (WhitelistStatus memory _whitelistStatuses) {
 61 |     |         return LibWhitelistedTokens.getWhitelistedStatus(token);
 62 |     |     }
 63 |     | }
 64 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/GaugeFacet.sol
   1 |     | /*
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {GaugeDefault} from "./abstract/GaugeDefault.sol";
   8 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
   9 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  10 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  11 |     | import {C} from "contracts/C.sol";
  12 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  13 |     | import {LibGaugeHelpers} from "contracts/libraries/LibGaugeHelpers.sol";
  14 |     | import {Gauge, GaugeId} from "contracts/beanstalk/storage/System.sol";
  15 |     | import {PRBMathUD60x18} from "@prb/math/contracts/PRBMathUD60x18.sol";
  16 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @title GaugeFacet
  20 |     |  * @notice Calculates the gaugePoints for whitelisted Silo LP tokens.
  21 |     |  */
  22 |     | interface IGaugeFacet {
  23 |     |     function defaultGaugePoints(
  24 |     |         uint256 currentGaugePoints,
  25 |     |         uint256 optimalPercentDepositedBdv,
  26 |     |         uint256 percentOfDepositedBdv,
  27 |     |         bytes memory
  28 |     |     ) external pure returns (uint256 newGaugePoints);
  29 |     | 
  30 |     |     function cultivationFactor(
  31 |     |         bytes memory value,
  32 |     |         bytes memory systemData,
  33 |     |         bytes memory gaugeData
  34 |     |     ) external view returns (bytes memory result);
  35 |     | 
  36 |     |     function convertDownPenaltyGauge(
  37 |     |         bytes memory value,
  38 |     |         bytes memory,
  39 |     |         bytes memory gaugeData
  40 |     |     ) external view returns (bytes memory, bytes memory);
  41 |     | }
  42 |     | 
  43 |     | /**
  44 |     |  * @notice GaugeFacet is a facet that contains the logic for all gauges in Beanstalk.
  45 |     |  * as well as adding, replacing, and removing Gauges.
  46 |     |  */
  47 | *   | contract GaugeFacet is GaugeDefault, ReentrancyGuard {
  48 |     |     uint256 internal constant PRICE_PRECISION = 1e6;
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice cultivationFactor is a gauge implementation that returns the adjusted cultivationFactor based on the podRate and the price of Pinto.
  52 |     |      */
  53 |     |     function cultivationFactor(
  54 |     |         bytes memory value,
  55 |     |         bytes memory systemData,
  56 |     |         bytes memory gaugeData
  57 |     |     ) external view returns (bytes memory, bytes memory) {
  58 |     |         uint256 currentValue = abi.decode(value, (uint256));
  59 |     |         LibEvaluate.BeanstalkState memory bs = abi.decode(systemData, (LibEvaluate.BeanstalkState));
  60 |     | 
  61 |     |         // if the price is 0, return the current value.
  62 |     |         if (bs.largestLiquidWellTwapBeanPrice == 0) {
  63 |     |             return (value, gaugeData);
  64 |     |         }
  65 |     | 
  66 |     |         // clamp the price to 1e6, to prevent overflows.
  67 |     |         if (bs.largestLiquidWellTwapBeanPrice > PRICE_PRECISION) {
  68 |     |             bs.largestLiquidWellTwapBeanPrice = PRICE_PRECISION;
  69 |     |         }
  70 |     | 
  71 |     |         (
  72 |     |             uint256 minDeltaCultivationFactor,
  73 |     |             uint256 maxDeltaCultivationFactor,
  74 |     |             uint256 minCultivationFactor,
  75 |     |             uint256 maxCultivationFactor
  76 |     |         ) = abi.decode(gaugeData, (uint256, uint256, uint256, uint256));
  77 |     | 
  78 |     |         // determine increase or decrease based on demand for soil.
  79 |     |         bool soilSoldOut = s.sys.weather.lastSowTime < type(uint32).max;
  80 |     |         // determine amount change as a function of podRate.
  81 |     |         uint256 amountChange = LibGaugeHelpers.linearInterpolation(
  82 |     |             bs.podRate.value,
  83 |     |             false,
  84 |     |             s.sys.evaluationParameters.podRateLowerBound,
  85 |     |             s.sys.evaluationParameters.podRateUpperBound,
  86 |     |             minDeltaCultivationFactor,
  87 |     |             maxDeltaCultivationFactor
  88 |     |         );
  89 |     |         // update the change based on price.
  90 |     |         amountChange = (amountChange * bs.largestLiquidWellTwapBeanPrice) / PRICE_PRECISION;
  91 |     | 
  92 |     |         // if soil did not sell out, inverse the amountChange.
  93 |     |         if (!soilSoldOut) {
  94 |     |             amountChange = 1e12 / amountChange;
  95 |     |         }
  96 |     | 
  97 |     |         // return the new cultivationFactor.
  98 |     |         // return unchanged gaugeData.
  99 |     |         return (
 100 |     |             abi.encode(
 101 |     |                 LibGaugeHelpers.linear(
 102 |     |                     int256(currentValue),
 103 |     |                     soilSoldOut,
 104 |     |                     amountChange,
 105 |     |                     int256(minCultivationFactor),
 106 |     |                     int256(maxCultivationFactor)
 107 |     |                 )
 108 |     |             ),
 109 |     |             gaugeData
 110 |     |         );
 111 |     |     }
 112 |     | 
 113 |     |     /**
 114 |     |      * @notice tracks the down convert penalty ratio and the rolling count of seasons above peg.
 115 |     |      * Penalty ratio is the % of grown stalk lost on a down convert (1e18 = 100% penalty).
 116 |     |      * value is encoded as (uint256, uint256):
 117 |     |      *     penaltyRatio - the penalty ratio.
 118 |     |      *     rollingSeasonsAbovePeg - the rolling count of seasons above peg.
 119 |     |      * gaugeData encoded as (uint256, uint256):
 120 |     |      *     rollingSeasonsAbovePegRate - amount to change the the rolling count by each season.
 121 |     |      *     rollingSeasonsAbovePegCap - upper limit of rolling count.
 122 |     |      * @dev returned penalty ratio has 18 decimal precision.
 123 |     |      */
 124 |     |     function convertDownPenaltyGauge(
 125 |     |         bytes memory value,
 126 |     |         bytes memory systemData,
 127 |     |         bytes memory gaugeData
 128 |     |     ) external view returns (bytes memory, bytes memory) {
 129 |     |         LibEvaluate.BeanstalkState memory bs = abi.decode(systemData, (LibEvaluate.BeanstalkState));
 130 |     |         (uint256 rollingSeasonsAbovePegRate, uint256 rollingSeasonsAbovePegCap) = abi.decode(
 131 |     |             gaugeData,
 132 |     |             (uint256, uint256)
 133 |     |         );
 134 |     | 
 135 |     |         (uint256 penaltyRatio, uint256 rollingSeasonsAbovePeg) = abi.decode(
 136 |     |             value,
 137 |     |             (uint256, uint256)
 138 |     |         );
 139 |     |         rollingSeasonsAbovePeg = uint256(
 140 |     |             LibGaugeHelpers.linear(
 141 |     |                 int256(rollingSeasonsAbovePeg),
 142 |     |                 bs.twaDeltaB > 0 ? true : false,
 143 |     |                 rollingSeasonsAbovePegRate,
 144 |     |                 0,
 145 |     |                 int256(rollingSeasonsAbovePegCap)
 146 |     |             )
 147 |     |         );
 148 |     | 
 149 |     |         // Do not update penalty ratio if l2sr failed to compute.
 150 |     |         if (bs.lpToSupplyRatio.value == 0) {
 151 |     |             return (abi.encode(penaltyRatio, rollingSeasonsAbovePeg), gaugeData);
 152 |     |         }
 153 |     | 
 154 |     |         // Scale L2SR by the optimal L2SR.
 155 |     |         uint256 l2srRatio = (1e18 * bs.lpToSupplyRatio.value) /
 156 |     |             s.sys.evaluationParameters.lpToSupplyRatioOptimal;
 157 |     | 
 158 |     |         uint256 timeRatio = (1e18 * PRBMathUD60x18.log2(rollingSeasonsAbovePeg * 1e18 + 1e18)) /
 159 |     |             PRBMathUD60x18.log2(rollingSeasonsAbovePegCap * 1e18 + 1e18);
 160 |     | 
 161 |     |         penaltyRatio = Math.min(1e18, l2srRatio * (1e18 - timeRatio) / 1e18);
 162 |     |         return (abi.encode(penaltyRatio, rollingSeasonsAbovePeg), gaugeData);
 163 |     |     }
 164 |     | 
 165 |     |     /// GAUGE ADD/REMOVE/UPDATE ///
 166 |     | 
 167 |     |     // function addGauge(GaugeId gaugeId, Gauge memory gauge) external {
 168 |     |     //     LibDiamond.enforceIsContractOwner();
 169 |     |     //     LibGaugeHelpers.addGauge(gaugeId, gauge);
 170 |     |     // }
 171 |     | 
 172 |     |     // function removeGauge(GaugeId gaugeId) external {
 173 |     |     //     LibDiamond.enforceIsContractOwner();
 174 |     |     //     LibGaugeHelpers.removeGauge(gaugeId);
 175 |     |     // }
 176 |     | 
 177 |     |     // function updateGauge(GaugeId gaugeId, Gauge memory gauge) external {
 178 |     |     //     LibDiamond.enforceIsContractOwner();
 179 |     |     //     LibGaugeHelpers.updateGauge(gaugeId, gauge);
 180 |     |     // }
 181 |     | 
 182 |     |     function getGauge(GaugeId gaugeId) external view returns (Gauge memory) {
 183 |     |         return s.sys.gaugeData.gauges[gaugeId];
 184 |     |     }
 185 |     | 
 186 |     |     function getGaugeValue(GaugeId gaugeId) external view returns (bytes memory) {
 187 |     |         return s.sys.gaugeData.gauges[gaugeId].value;
 188 |     |     }
 189 |     | 
 190 |     |     function getGaugeData(GaugeId gaugeId) external view returns (bytes memory) {
 191 |     |         return s.sys.gaugeData.gauges[gaugeId].data;
 192 |     |     }
 193 |     | 
 194 |     |     // /**
 195 |     |     //  * @notice returns the result of calling a gauge.
 196 |     |     //  */
 197 |     |     // function getGaugeResult(
 198 |     |     //     Gauge memory gauge,
 199 |     |     //     bytes memory systemData
 200 |     |     // ) external returns (bytes memory, bytes memory) {
 201 |     |     //     return LibGaugeHelpers.getGaugeResult(gauge, systemData);
 202 |     |     // }
 203 |     | 
 204 |     |     // /**
 205 |     |     //  * @notice returns the result of calling a gauge by its id.
 206 |     |     //  */
 207 |     |     // function getGaugeIdResult(
 208 |     |     //     GaugeId gaugeId,
 209 |     |     //     bytes memory systemData
 210 |     |     // ) external returns (bytes memory, bytes memory) {
 211 |     |     //     Gauge memory g = s.sys.gaugeData.gauges[gaugeId];
 212 |     |     //     return LibGaugeHelpers.getGaugeResult(g, systemData);
 213 |     |     // }
 214 |     | }
 215 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/GaugeGettersFacet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   6 |     | import {SeedGauge, GerminationSide, AssetSettings} from "contracts/beanstalk/storage/System.sol";
   7 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
   8 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
   9 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  10 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  11 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  12 |     | import {LibGauge} from "contracts/libraries/LibGauge.sol";
  13 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  14 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  15 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title GaugeGettersFacet
  19 |     |  * @notice Holds Getter view functions for Gauge-related Functionality.
  20 |     |  */
  21 | *   | contract GaugeGettersFacet {
  22 |     |     using LibRedundantMath256 for uint256;
  23 |     |     using LibRedundantMathSigned256 for int256;
  24 |     | 
  25 |     |     AppStorage internal s;
  26 |     | 
  27 |     |     //////////////////// SEED GAUGE GETTERS ////////////////////
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Returns the average grown stalk per BDV.
  31 |     |      */
  32 |     |     function getAverageGrownStalkPerBdv() public view returns (uint256) {
  33 |     |         return LibGauge.getAverageGrownStalkPerBdv();
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Returns the total Deposited BDV in Beanstalk.
  38 |     |      * @dev the total Deposited BDV may vary from the instantaneous BDV of all Deposited tokens
  39 |     |      * as the BDV of a Deposit is only updated when a Deposit is interacted with.
  40 |     |      */
  41 |     |     function getTotalBdv() external view returns (uint256 totalBdv) {
  42 |     |         return LibGauge.getTotalBdv();
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Returns the seed gauge struct.
  47 |     |      */
  48 |     |     function getSeedGauge() external view returns (SeedGauge memory) {
  49 |     |         return s.sys.seedGauge;
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Returns the average grown stalk per BDV per season.
  54 |     |      * @dev 6 decimal precision (1 GrownStalkPerBdvPerSeason = 1e6);
  55 |     |      * note that stalk has 16 decimals.
  56 |     |      */
  57 |     |     function getAverageGrownStalkPerBdvPerSeason() public view returns (uint128) {
  58 |     |         return s.sys.seedGauge.averageGrownStalkPerBdvPerSeason;
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice Returns the ratio between bean and max LP gp Per BDV, unscaled.
  63 |     |      * @dev 6 decimal precision (1% = 1e6)
  64 |     |      */
  65 |     |     function getBeanToMaxLpGpPerBdvRatio() external view returns (uint256) {
  66 |     |         return s.sys.seedGauge.beanToMaxLpGpPerBdvRatio;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Returns the ratio between bean and max LP gp Per BDV, scaled.
  71 |     |      * @dev 6 decimal precision (1% = 1e6)
  72 |     |      */
  73 |     |     function getBeanToMaxLpGpPerBdvRatioScaled() public view returns (uint256) {
  74 |     |         return LibGauge.getBeanToMaxLpGpPerBdvRatioScaled(s.sys.seedGauge.beanToMaxLpGpPerBdvRatio);
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @notice returns the Gauge Points per BDV for a given token.
  79 |     |      * @param token The token to get the Gauge Points per BDV for.
  80 |     |      */
  81 |     |     function getGaugePointsPerBdvForToken(address token) public view returns (uint256) {
  82 |     |         if (token == s.sys.bean) {
  83 |     |             return getBeanGaugePointsPerBdv();
  84 |     |         } else {
  85 |     |             return getGaugePointsPerBdvForWell(token);
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * gets the Gauge Points per BDV for a given well.
  91 |     |      * @param well The well to get the Gauge Points per BDV for.
  92 |     |      */
  93 |     |     function getGaugePointsPerBdvForWell(address well) public view returns (uint256) {
  94 |     |         if (LibWell.isWell(well)) {
  95 |     |             uint256 wellGaugePoints = s.sys.silo.assetSettings[well].gaugePoints;
  96 |     |             uint256 wellDepositedBdv = s.sys.silo.balances[well].depositedBdv;
  97 |     |             // avoid division by zero when no BDV is deposited or initial deposits are still germinating.
  98 |     |             if (wellDepositedBdv == 0) return 0;
  99 |     |             return wellGaugePoints.mul(LibGauge.BDV_PRECISION).div(wellDepositedBdv);
 100 |     |         } else {
 101 |     |             revert("Token not supported");
 102 |     |         }
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @notice returns the largest Gauge Points per BDV of all whitelisted LP tokens.
 107 |     |      */
 108 |     |     function getLargestGpPerBdv() public view returns (uint256) {
 109 |     |         uint256 largestGpPerBdv;
 110 |     |         address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();
 111 |     |         for (uint256 i; i < whitelistedLpTokens.length; i++) {
 112 |     |             uint256 gpPerBdv = getGaugePointsPerBdvForWell(whitelistedLpTokens[i]);
 113 |     |             if (gpPerBdv > largestGpPerBdv) largestGpPerBdv = gpPerBdv;
 114 |     |         }
 115 |     |         return largestGpPerBdv;
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @notice calculates the BEAN Gauge Points (GP) per BDV.
 120 |     |      */
 121 |     |     function getBeanGaugePointsPerBdv() public view returns (uint256) {
 122 |     |         uint256 beanToMaxLpGpPerBdvRatio = getBeanToMaxLpGpPerBdvRatioScaled();
 123 |     |         return getLargestGpPerBdv().mul(beanToMaxLpGpPerBdvRatio).div(100e18);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @notice calculates the grown stalk issued per season.
 128 |     |      */
 129 |     |     function getGrownStalkIssuedPerSeason() public view returns (uint256) {
 130 |     |         address[] memory lpGaugeTokens = LibWhitelistedTokens.getWhitelistedLpTokens();
 131 |     |         uint256 totalLpBdv;
 132 |     |         for (uint i; i < lpGaugeTokens.length; i++) {
 133 |     |             totalLpBdv = totalLpBdv.add(s.sys.silo.balances[lpGaugeTokens[i]].depositedBdv);
 134 |     |         }
 135 |     |         return
 136 |     |             uint256(s.sys.seedGauge.averageGrownStalkPerBdvPerSeason)
 137 |     |                 .mul(totalLpBdv.add(s.sys.silo.balances[s.sys.bean].depositedBdv))
 138 |     |                 .div(LibGauge.BDV_PRECISION);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @notice Gets the stalk per Gauge Point. Used In gauge system.
 143 |     |      */
 144 |     |     function getGrownStalkIssuedPerGp() external view returns (uint256) {
 145 |     |         address[] memory lpGaugeTokens = LibWhitelistedTokens.getWhitelistedLpTokens();
 146 |     |         uint256 totalGaugePoints;
 147 |     |         for (uint i; i < lpGaugeTokens.length; i++) {
 148 |     |             totalGaugePoints = totalGaugePoints.add(
 149 |     |                 s.sys.silo.assetSettings[lpGaugeTokens[i]].gaugePoints
 150 |     |             );
 151 |     |         }
 152 |     |         uint256 newGrownStalk = getGrownStalkIssuedPerSeason();
 153 |     |         totalGaugePoints = totalGaugePoints.add(
 154 |     |             getBeanGaugePointsPerBdv().mul(s.sys.silo.balances[s.sys.bean].depositedBdv).div(
 155 |     |                 LibGauge.BDV_PRECISION
 156 |     |             )
 157 |     |         );
 158 |     |         return newGrownStalk.mul(1e18).div(totalGaugePoints);
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @notice Returns the pod rate (unharvestable pods / total bean supply).
 163 |     |      */
 164 |     |     function getPodRate(uint256 fieldId) external view returns (uint256) {
 165 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 166 |     |         return
 167 |     |             Decimal
 168 |     |                 .ratio(s.sys.fields[fieldId].pods - s.sys.fields[fieldId].harvestable, beanSupply)
 169 |     |                 .value;
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice Returns the L2SR rate (total non-bean liquidity / total bean supply).
 174 |     |      */
 175 |     |     function getLiquidityToSupplyRatio() external view returns (uint256) {
 176 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 177 |     |         (Decimal.D256 memory l2sr, , ) = LibEvaluate.calcLPToSupplyRatio(beanSupply);
 178 |     |         return l2sr.value;
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @notice returns the change in demand for pods from the previous season.
 183 |     |      */
 184 |     |     function getDeltaPodDemand() external view returns (uint256) {
 185 |     |         Decimal.D256 memory deltaPodDemand;
 186 |     |         (deltaPodDemand, , ) = LibEvaluate.calcDeltaPodDemand(s.sys.beanSown);
 187 |     |         return deltaPodDemand.value;
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @notice Returns the current gauge points of a token.
 192 |     |      */
 193 |     |     function getGaugePoints(address token) external view returns (uint256) {
 194 |     |         return s.sys.silo.assetSettings[token].gaugePoints;
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @notice returns the new gauge point for a token,
 199 |     |      * if it were to be updated with the given parameters.
 200 |     |      */
 201 |     |     function calcGaugePointsWithParams(
 202 |     |         address token,
 203 |     |         uint256 percentOfDepositedBdv
 204 |     |     ) external view returns (uint256) {
 205 |     |         address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();
 206 |     |         uint256 totalOptimalDepositedBdvPercent;
 207 |     |         for (uint256 i; i < whitelistedLpTokens.length; ++i) {
 208 |     |             totalOptimalDepositedBdvPercent = totalOptimalDepositedBdvPercent.add(
 209 |     |                 s.sys.silo.assetSettings[whitelistedLpTokens[i]].optimalPercentDepositedBdv
 210 |     |             );
 211 |     |         }
 212 |     |         return
 213 |     |             LibGauge.calcGaugePoints(
 214 |     |                 s.sys.silo.assetSettings[token],
 215 |     |                 percentOfDepositedBdv,
 216 |     |                 totalOptimalDepositedBdvPercent
 217 |     |             );
 218 |     |     }
 219 |     | 
 220 |     |     /**
 221 |     |      * @notice returns the new gauge point for a token,
 222 |     |      * if it were to be updated with the current state.
 223 |     |      */
 224 |     |     function getGaugePointsWithParams(address token) external view returns (uint256) {
 225 |     |         address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();
 226 |     | 
 227 |     |         // get the germinating assets that will finish germination in the next season.
 228 |     |         GerminationSide side;
 229 |     |         if (
 230 |     |             LibGerminate.getGerminationStateForSeason(s.sys.season.current + 1) ==
 231 |     |             GerminationSide.ODD
 232 |     |         ) {
 233 |     |             side = GerminationSide.ODD;
 234 |     |         } else {
 235 |     |             side = GerminationSide.EVEN;
 236 |     |         }
 237 |     | 
 238 |     |         // Summate total deposited BDV across all whitelisted LP tokens.
 239 |     |         // get the total optimal deposited BDV percent for all LP tokens.
 240 |     |         uint256 totalLpBdv;
 241 |     |         uint256 totalOptimalDepositedBdvPercent;
 242 |     |         for (uint256 i; i < whitelistedLpTokens.length; ++i) {
 243 |     |             uint256 finishedGerminatingBdv = s
 244 |     |             .sys
 245 |     |             .silo
 246 |     |             .germinating[side][whitelistedLpTokens[i]].bdv;
 247 |     |             totalLpBdv = totalLpBdv
 248 |     |                 .add(s.sys.silo.balances[whitelistedLpTokens[i]].depositedBdv)
 249 |     |                 .add(finishedGerminatingBdv);
 250 |     |             totalOptimalDepositedBdvPercent = totalOptimalDepositedBdvPercent.add(
 251 |     |                 s.sys.silo.assetSettings[whitelistedLpTokens[i]].optimalPercentDepositedBdv
 252 |     |             );
 253 |     |         }
 254 |     |         uint256 depositedBdv = s.sys.silo.balances[token].depositedBdv;
 255 |     |         uint256 percentDepositedBdv = depositedBdv.mul(100e6).div(totalLpBdv);
 256 |     | 
 257 |     |         AssetSettings memory ss = s.sys.silo.assetSettings[token];
 258 |     |         return LibGauge.calcGaugePoints(ss, percentDepositedBdv, totalOptimalDepositedBdvPercent);
 259 |     |     }
 260 |     | }
 261 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/LiquidityWeightFacet.sol
  1 |     | /*
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | /**
  8 |     |  * @title LiquidityWeightFacet
  9 |     |  * @notice determines the liquidity weight. Used in the gauge system.
 10 |     |  */
 11 |     | interface ILiquidityWeightFacet {
 12 |     |     function maxWeight(bytes memory) external pure returns (uint256);
 13 |     | 
 14 |     |     function noWeight(bytes memory) external pure returns (uint256);
 15 |     | }
 16 |     | 
 17 | *   | contract LiquidityWeightFacet {
 18 |     |     uint256 constant MAX_WEIGHT = 1e18;
 19 |     | 
 20 |     |     function maxWeight(bytes memory) external pure returns (uint256) {
 21 |     |         return MAX_WEIGHT;
 22 |     |     }
 23 |     | 
 24 |     |     function noWeight(bytes memory) external pure returns (uint256) {
 25 |     |         return 0;
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/OracleFacet.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
   9 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  10 |     | import {LibUsdOracle, IERC20Decimals} from "contracts/libraries/Oracle/LibUsdOracle.sol";
  11 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title Oracle Facet
  15 |     |  * @notice Exposes Oracle Functionality
  16 |     |  **/
  17 | *   | contract OracleFacet is Invariable, ReentrancyGuard {
  18 |     |     /**
  19 |     |      * @notice Fetches the amount of tokens equal to 1 USD for a given token.
  20 |     |      * @param token address of the token to get the amount for.
  21 |     |      */
  22 |     |     function getUsdTokenPrice(address token) external view returns (uint256) {
  23 |     |         return LibUsdOracle.getUsdPrice(token, 0);
  24 |     |     }
  25 |     | 
  26 |     |     /**
  27 |     |      * @notice Returns the amount of tokens equal to 1 USD for a given token,
  28 |     |      * with a lookback. Used to protect against manipulation.
  29 |     |      * @param token address of the token to get the amount for.
  30 |     |      * @param lookback the amount of time to look back in seconds.
  31 |     |      */
  32 |     |     function getUsdTokenTwap(address token, uint256 lookback) external view returns (uint256) {
  33 |     |         return LibUsdOracle.getUsdPrice(token, lookback);
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Fetches the amount of USD equal 1 token is worth.
  38 |     |      * @param token address of token to get the price of.
  39 |     |      */
  40 |     |     function getTokenUsdPrice(address token) external view returns (uint256) {
  41 |     |         return LibUsdOracle.getTokenPrice(token, 0);
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Fetches the amount of USD equal 1 token is worth, using a lookback
  46 |     |      * @param token address of token to get the price of.
  47 |     |      * @param lookback the amount of time to look back in seconds.
  48 |     |      */
  49 |     |     function getTokenUsdTwap(address token, uint256 lookback) external view returns (uint256) {
  50 |     |         return LibUsdOracle.getTokenPrice(token, lookback);
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @notice Fetches the amount of tokens equal to 1 USD, using the oracle implementation.
  55 |     |      * @param token address of token to get the price of.
  56 |     |      * @param lookback the amount of time to look back in seconds.
  57 |     |      */
  58 |     |     function getUsdTokenPriceFromExternal(
  59 |     |         address token,
  60 |     |         uint256 lookback
  61 |     |     ) external view returns (uint256 usdToken) {
  62 |     |         return
  63 |     |             LibUsdOracle.getTokenPriceFromExternal(
  64 |     |                 token,
  65 |     |                 IERC20Decimals(token).decimals(),
  66 |     |                 lookback
  67 |     |             );
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice Fetches the amount of USD equal to 1 token, using the oracle implementation.
  72 |     |      * @param token address of token to get the price of.
  73 |     |      * @param lookback the amount of time to look back in seconds.
  74 |     |      * @dev returns 6 decimal precision.
  75 |     |      */
  76 |     |     function getTokenUsdPriceFromExternal(
  77 |     |         address token,
  78 |     |         uint256 lookback
  79 |     |     ) external view returns (uint256 tokenUsd) {
  80 |     |         return LibUsdOracle.getTokenPriceFromExternal(token, 0, lookback);
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Returns the price ratios between `tokens` and the index of Bean in `tokens`.
  85 |     |      * These actions are combined into a single function for gas efficiency.
  86 |     |      */
  87 |     |     function getRatiosAndBeanIndex(
  88 |     |         IERC20[] memory tokens,
  89 |     |         uint256 lookback
  90 |     |     ) external view returns (uint[] memory ratios, uint beanIndex, bool success) {
  91 |     |         (ratios, beanIndex, success) = LibWell.getRatiosAndBeanIndex(tokens, lookback);
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice Fetches the amount of tokens equal to 1 Million USD for a given token.
  96 |     |      * @param token address of the token to get the amount for.
  97 |     |      * @param lookback the amount of time to look back in seconds.
  98 |     |      */
  99 |     |     function getMillionUsdPrice(address token, uint256 lookback) external view returns (uint256) {
 100 |     |         return LibUsdOracle.getMillionUsdPrice(token, lookback);
 101 |     |     }
 102 |     | }
 103 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/SeasonFacet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {Weather} from "./abstract/Weather.sol";
   6 |     | import {LibIncentive} from "contracts/libraries/LibIncentive.sol";
   7 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
   8 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
   9 |     | import {LibGauge} from "contracts/libraries/LibGauge.sol";
  10 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  11 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  12 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  13 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
  14 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  15 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  16 |     | import {IBean} from "contracts/interfaces/IBean.sol";
  17 |     | import {GaugeId} from "contracts/beanstalk/storage/System.sol";
  18 |     | import {LibGaugeHelpers} from "contracts/libraries/LibGaugeHelpers.sol";
  19 |     | 
  20 |     | /**
  21 |     |  * @title SeasonFacet
  22 |     |  * @notice Holds the Sunrise function and handles all logic for Season changes.
  23 |     |  */
  24 | *   | contract SeasonFacet is Invariable, Weather {
  25 |     |     using LibRedundantMath256 for uint256;
  26 |     | 
  27 |     |     /**
  28 |     |      * @notice Emitted when the Season changes.
  29 |     |      * @param season The new Season number
  30 |     |      */
  31 |     |     event Sunrise(uint256 indexed season);
  32 |     | 
  33 |     |     //////////////////// SUNRISE ////////////////////
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Advances Beanstalk to the next Season, sending reward Beans to the caller's circulating balance.
  37 |     |      * @return reward The number of beans minted to the caller.
  38 |     |      * @dev No out flow because any externally sent reward beans are freshly minted.
  39 |     |      */
  40 |     |     function sunrise() external payable fundsSafu nonReentrant noOutFlow returns (uint256) {
  41 |     |         return _gm(LibTractor._user(), LibTransfer.To.EXTERNAL);
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Advances Beanstalk to the next Season, sending reward Beans to a specified address & balance.
  46 |     |      * @param account Indicates to which address reward Beans should be sent
  47 |     |      * @param mode Indicates whether the reward beans are sent to internal or circulating balance
  48 |     |      * @return reward The number of Beans minted to the caller.
  49 |     |      * @dev No out flow because any externally sent reward beans are freshly minted.
  50 |     |      */
  51 |     |     function gm(
  52 |     |         address account,
  53 |     |         LibTransfer.To mode
  54 |     |     ) public payable fundsSafu noOutFlow nonReentrant returns (uint256) {
  55 |     |         return _gm(account, mode);
  56 |     |     }
  57 |     | 
  58 |     |     function _gm(address account, LibTransfer.To mode) private returns (uint256) {
  59 |     |         require(!s.sys.paused, "Season: Paused.");
  60 |     |         require(seasonTime() > s.sys.season.current, "Season: Still current Season.");
  61 |     |         checkSeasonTime();
  62 |     |         uint32 season = stepSeason();
  63 |     |         int256 deltaB = stepOracle();
  64 |     |         LibGerminate.endTotalGermination(season, LibWhitelistedTokens.getWhitelistedTokens());
  65 |     |         (uint256 caseId, LibEvaluate.BeanstalkState memory bs) = calcCaseIdAndHandleRain(deltaB);
  66 |     |         stepGauges(bs);
  67 |     |         stepSun(caseId, bs);
  68 |     | 
  69 |     |         return incentivize(account, mode);
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @notice checks that 1) Beanstalk is unpaused and
  74 |     |      * 2) at least 1 period has passed since the last Season change.
  75 |     |      * @dev in the case where more than 1 period has passed,
  76 |     |      * s.sys.season.start is updated to reflect the time skipped,
  77 |     |      * such that multiple sunrises cannot be called in one transaction.
  78 |     |      */
  79 |     |     function checkSeasonTime() internal {
  80 |     |         require(!s.sys.paused, "Season: Paused.");
  81 |     |         uint32 _seasonTime = seasonTime();
  82 |     |         uint32 currentSeason = s.sys.season.current;
  83 |     |         require(_seasonTime > currentSeason, "Season: Still current Season.");
  84 |     |         if (_seasonTime > currentSeason + 1) {
  85 |     |             s.sys.season.start += s.sys.season.period.mul(_seasonTime - currentSeason - 1);
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice Returns the expected Season number given the current block timestamp.
  91 |     |      * {sunrise} can be called when `seasonTime() > s.sys.season.current`.
  92 |     |      */
  93 |     |     function seasonTime() public view virtual returns (uint32) {
  94 |     |         if (block.timestamp < s.sys.season.start) return 0;
  95 |     |         if (s.sys.season.period == 0) return type(uint32).max;
  96 |     |         return uint32((block.timestamp - s.sys.season.start) / s.sys.season.period);
  97 |     |     }
  98 |     | 
  99 |     |     //////////////////// SEASON INTERNAL ////////////////////
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Moves the Season forward by 1.
 103 |     |      */
 104 |     |     function stepSeason() private returns (uint32 season) {
 105 |     |         s.sys.season.current += 1;
 106 |     |         season = s.sys.season.current;
 107 |     |         s.sys.season.sunriseBlock = uint64(block.number); // Note: will overflow after 2^64 blocks.
 108 |     |         emit Sunrise(season);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Steps all gauges in the system.
 113 |     |      * @param bs The BeanstalkState memory struct containing data of beanstalk's current state.
 114 |     |      */
 115 |     |     function stepGauges(LibEvaluate.BeanstalkState memory bs) internal {
 116 |     |         bytes memory systemData = abi.encode(bs);
 117 |     |         LibGauge.stepGauge();
 118 |     |         LibGaugeHelpers.engage(systemData);
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @param account The address to which the reward beans are sent, may or may not
 123 |     |      * be the same as the caller of `sunrise()`
 124 |     |      * @param mode Send reward beans to Internal or Circulating balance
 125 |     |      * @dev Mints Beans to `account` as a reward for calling {sunrise()}.
 126 |     |      */
 127 |     |     function incentivize(address account, LibTransfer.To mode) private returns (uint256) {
 128 |     |         uint256 secondsLate = block.timestamp.sub(
 129 |     |             s.sys.season.start.add(s.sys.season.period.mul(s.sys.season.current))
 130 |     |         );
 131 |     | 
 132 |     |         // reset USD Token prices and TWA reserves in storage for all whitelisted Well LP Tokens.
 133 |     |         address[] memory whitelistedWells = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 134 |     |         for (uint256 i; i < whitelistedWells.length; i++) {
 135 |     |             LibWell.resetUsdTokenPriceForWell(whitelistedWells[i]);
 136 |     |             LibWell.resetTwaReservesForWell(whitelistedWells[i]);
 137 |     |         }
 138 |     | 
 139 |     |         uint256 incentiveAmount = LibIncentive.determineReward(secondsLate);
 140 |     | 
 141 |     |         LibTransfer.mintToken(IBean(s.sys.bean), incentiveAmount, account, mode);
 142 |     | 
 143 |     |         emit LibIncentive.Incentivization(account, incentiveAmount);
 144 |     |         return incentiveAmount;
 145 |     |     }
 146 |     | }
 147 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/SeasonGettersFacet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   6 |     | import {Season, Weather, Rain, EvaluationParameters, ExtEvaluationParameters, Deposited, AssetSettings} from "contracts/beanstalk/storage/System.sol";
   7 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
   8 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
   9 |     | import {LibUsdOracle} from "contracts/libraries/Oracle/LibUsdOracle.sol";
  10 |     | import {LibWellMinting} from "contracts/libraries/Minting/LibWellMinting.sol";
  11 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  12 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  13 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  14 |     | import {LibCases} from "contracts/libraries/LibCases.sol";
  15 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  16 |     | import {LibDeltaB} from "contracts/libraries/Oracle/LibDeltaB.sol";
  17 |     | import {LibFlood} from "contracts/libraries/Silo/LibFlood.sol";
  18 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  19 |     | import {LibMinting} from "contracts/libraries/Minting/LibMinting.sol";
  20 |     | import {C} from "contracts/C.sol";
  21 |     | 
  22 |     | /**
  23 |     |  * @title SeasonGettersFacet
  24 |     |  * @notice Holds Getter view functions for the SeasonFacet.
  25 |     |  */
  26 | *   | contract SeasonGettersFacet {
  27 |     |     using LibRedundantMath256 for uint256;
  28 |     |     using LibRedundantMathSigned256 for int256;
  29 |     | 
  30 |     |     AppStorage internal s;
  31 |     | 
  32 |     |     //////////////////// SEASON GETTERS ////////////////////
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Returns the current Season number.
  36 |     |      */
  37 |     |     function season() public view returns (uint32) {
  38 |     |         return s.sys.season.current;
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Returns whether Beanstalk is Paused. When Paused, the `sunrise()` function cannot be called.
  43 |     |      */
  44 |     |     function paused() public view returns (bool) {
  45 |     |         return s.sys.paused;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @notice Returns the Season struct. See {Season}.
  50 |     |      */
  51 |     |     function time() external view returns (Season memory) {
  52 |     |         return s.sys.season;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Returns whether Beanstalk started this Season above or below peg.
  57 |     |      */
  58 |     |     function abovePeg() external view returns (bool) {
  59 |     |         return s.sys.season.abovePeg;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @notice Returns the block during which the current Season started.
  64 |     |      */
  65 |     |     function sunriseBlock() external view returns (uint64) {
  66 |     |         return s.sys.season.sunriseBlock;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Returns the current Weather struct. See {Weather}.
  71 |     |      */
  72 |     |     function weather() public view returns (Weather memory) {
  73 |     |         return s.sys.weather;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice Returns the current Rain struct. See {AppStorage:Rain}.
  78 |     |      */
  79 |     |     function rain() public view returns (Rain memory) {
  80 |     |         return s.sys.rain;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice Returns the Plenty per Root for `season`.
  85 |     |      */
  86 |     |     function plentyPerRoot(uint32 _season, address well) external view returns (uint256) {
  87 |     |         return s.sys.sop.sops[_season][well];
  88 |     |     }
  89 |     | 
  90 |     |     //////////////////// ORACLE GETTERS ////////////////////
  91 |     | 
  92 |     |     /**
  93 |     |      * @notice Returns the total Delta B across all whitelisted minting liquidity Wells.
  94 |     |      * @dev returns the capped deltaB (globally, and per well).
  95 |     |      * max(max(800k, 4% of total supply), Σ max(200k, 2% of total supply) per well)
  96 |     |      */
  97 |     |     function totalDeltaB() external view returns (int256 deltaB) {
  98 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedLpTokens();
  99 |     |         if (tokens.length == 0) return 0;
 100 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 101 |     |             deltaB = deltaB.add(LibWellMinting.check(tokens[i]));
 102 |     |         }
 103 |     |         // cap deltaB to max(800k, 4% of total supply)
 104 |     |         deltaB = LibMinting.checkForMaxDeltaB(C.GLOBAL_ABSOLUTE_MAX, C.GLOBAL_RATIO_MAX, deltaB);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @notice Returns the total Delta B across all whitelisted minting liquidity Wells.
 109 |     |      * @dev No cap is applied to the deltaB.
 110 |     |      */
 111 |     |     function totalDeltaBNoCap() external view returns (int256 deltaB) {
 112 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedLpTokens();
 113 |     |         if (tokens.length == 0) return 0;
 114 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 115 |     |             deltaB = deltaB.add(LibWellMinting.checkDeltaB(tokens[i]));
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Returns the Time Weighted Average Delta B since the start of the Season for the requested pool.
 121 |     |      * @dev returns the capped deltaB (globally, and per well).
 122 |     |      * max(max(800k, 4% of total supply), Σ max(200k, 2% of total supply) per well)
 123 |     |      */
 124 |     |     function poolDeltaB(address pool) external view returns (int256) {
 125 |     |         if (LibWell.isWell(pool)) return LibWellMinting.check(pool);
 126 |     |         revert("Oracle: Pool not supported");
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @notice Returns the Time Weighted Average Delta B since the start of the Season for the requested pool.
 131 |     |      * @dev No cap is applied to the deltaB.
 132 |     |      */
 133 |     |     function poolDeltaBNoCap(address pool) external view returns (int256) {
 134 |     |         if (LibWell.isWell(pool)) return LibWellMinting.checkDeltaB(pool);
 135 |     |         revert("Oracle: Pool not supported");
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @notice Returns the current Delta B for a given well using `calculateDeltaBFromReserves`.
 140 |     |      * @return deltaB The deltaB for the well, calculated by its reserves.
 141 |     |      */
 142 |     |     function poolCurrentDeltaB(address pool) public view returns (int256 deltaB) {
 143 |     |         if (LibWell.isWell(pool)) {
 144 |     |             (deltaB) = LibDeltaB.currentDeltaB(pool);
 145 |     |             return deltaB;
 146 |     |         } else {
 147 |     |             revert("Oracle: Pool not supported");
 148 |     |         }
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice Returns the cumulative Delta B from a given list of wells.
 153 |     |      */
 154 |     |     function cumulativeCurrentDeltaB(
 155 |     |         address[] calldata pools
 156 |     |     ) external view returns (int256 deltaB) {
 157 |     |         for (uint256 i; i < pools.length; i++) {
 158 |     |             deltaB += poolCurrentDeltaB(pools[i]);
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice Returns the total instantaneous Delta B across all whitelisted Wells.
 164 |     |      */
 165 |     |     function totalInstantaneousDeltaB() external view returns (int256) {
 166 |     |         return LibWellMinting.getTotalInstantaneousDeltaB();
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @notice Returns the last Well Oracle Snapshot for a given `well`.
 171 |     |      * @return snapshot The encoded cumulative balances the last time the Oracle was captured.
 172 |     |      */
 173 |     |     function wellOracleSnapshot(address well) external view returns (bytes memory snapshot) {
 174 |     |         snapshot = s.sys.wellOracleSnapshots[well];
 175 |     |     }
 176 |     | 
 177 |     |     /**
 178 |     |      * @notice returns the twa liquidity for a well, using the values stored in beanstalk.
 179 |     |      */
 180 |     |     function getTwaLiquidityForWell(address well) public view returns (uint256) {
 181 |     |         (address token, ) = LibWell.getNonBeanTokenAndIndexFromWell(well);
 182 |     |         return LibWell.getTwaLiquidityFromPump(well, LibUsdOracle.getTokenPrice(token));
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice returns the twa liquidity for a well, using the values stored in beanstalk.
 187 |     |      * @dev This is the liquidity used in the gauge system.
 188 |     |      */
 189 |     |     function getWeightedTwaLiquidityForWell(address well) public view returns (uint256) {
 190 |     |         return LibEvaluate.getLiquidityWeight(well).mul(getTwaLiquidityForWell(well)).div(1e18);
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice Returns the total twa liquidity of beanstalk.
 195 |     |      */
 196 |     |     function getTotalUsdLiquidity() external view returns (uint256 totalLiquidity) {
 197 |     |         address[] memory wells = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 198 |     |         for (uint i; i < wells.length; i++) {
 199 |     |             totalLiquidity = totalLiquidity.add(getTwaLiquidityForWell(wells[i]));
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /**
 204 |     |      * @notice returns the total weighted liquidity of beanstalk.
 205 |     |      */
 206 |     |     function getTotalWeightedUsdLiquidity() external view returns (uint256 totalWeightedLiquidity) {
 207 |     |         address[] memory wells = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 208 |     |         for (uint i; i < wells.length; i++) {
 209 |     |             totalWeightedLiquidity = totalWeightedLiquidity.add(
 210 |     |                 getWeightedTwaLiquidityForWell(wells[i])
 211 |     |             );
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @notice Returns the well with the largest USD time weighted average liquidity.
 217 |     |      */
 218 |     |     function getLargestLiqWell() external view returns (address) {
 219 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 220 |     |         (, address well, ) = LibEvaluate.calcLPToSupplyRatio(beanSupply);
 221 |     |         return well;
 222 |     |     }
 223 |     | 
 224 |     |     //////////////////// CASES ////////////////////
 225 |     | 
 226 |     |     function getCases() external view returns (bytes32[144] memory cases) {
 227 |     |         return s.sys.casesV2;
 228 |     |     }
 229 |     | 
 230 |     |     function getCaseData(uint256 caseId) external view returns (bytes32 casesData) {
 231 |     |         return LibCases.getDataFromCase(caseId);
 232 |     |     }
 233 |     | 
 234 |     |     function getChangeFromCaseId(
 235 |     |         uint256 caseId
 236 |     |     ) public view returns (uint32, int32, uint80, int80) {
 237 |     |         LibCases.CaseData memory cd = LibCases.decodeCaseData(caseId);
 238 |     |         return (cd.mT, cd.bT, cd.mL, cd.bL);
 239 |     |     }
 240 |     | 
 241 |     |     function getAbsTemperatureChangeFromCaseId(uint256 caseId) external view returns (int32 t) {
 242 |     |         (, t, , ) = getChangeFromCaseId(caseId);
 243 |     |         return t;
 244 |     |     }
 245 |     | 
 246 |     |     function getRelTemperatureChangeFromCaseId(uint256 caseId) external view returns (uint32 mt) {
 247 |     |         (mt, , , ) = getChangeFromCaseId(caseId);
 248 |     |         return mt;
 249 |     |     }
 250 |     | 
 251 |     |     function getAbsBeanToMaxLpRatioChangeFromCaseId(
 252 |     |         uint256 caseId
 253 |     |     ) external view returns (uint80 ml) {
 254 |     |         (, , ml, ) = getChangeFromCaseId(caseId);
 255 |     |         return ml;
 256 |     |     }
 257 |     | 
 258 |     |     function getRelBeanToMaxLpRatioChangeFromCaseId(
 259 |     |         uint256 caseId
 260 |     |     ) external view returns (int80 l) {
 261 |     |         (, , , l) = getChangeFromCaseId(caseId);
 262 |     |         return l;
 263 |     |     }
 264 |     | 
 265 |     |     function getSeasonStruct() external view returns (Season memory) {
 266 |     |         return s.sys.season;
 267 |     |     }
 268 |     | 
 269 |     |     function getSeasonTimestamp() external view returns (uint256) {
 270 |     |         return s.sys.season.timestamp;
 271 |     |     }
 272 |     | 
 273 |     |     function getEvaluationParameters() external view returns (EvaluationParameters memory) {
 274 |     |         return s.sys.evaluationParameters;
 275 |     |     }
 276 |     | 
 277 |     |     function getExtEvaluationParameters() external view returns (ExtEvaluationParameters memory) {
 278 |     |         return s.sys.extEvaluationParameters;
 279 |     |     }
 280 |     | 
 281 |     |     function getMaxBeanMaxLpGpPerBdvRatio() external view returns (uint256) {
 282 |     |         return s.sys.evaluationParameters.maxBeanMaxLpGpPerBdvRatio;
 283 |     |     }
 284 |     | 
 285 |     |     function getMinBeanMaxLpGpPerBdvRatio() external view returns (uint256) {
 286 |     |         return s.sys.evaluationParameters.minBeanMaxLpGpPerBdvRatio;
 287 |     |     }
 288 |     | 
 289 |     |     function getTargetSeasonsToCatchUp() external view returns (uint256) {
 290 |     |         return s.sys.evaluationParameters.targetSeasonsToCatchUp;
 291 |     |     }
 292 |     | 
 293 |     |     function getPodRateLowerBound() external view returns (uint256) {
 294 |     |         return s.sys.evaluationParameters.podRateLowerBound;
 295 |     |     }
 296 |     | 
 297 |     |     function getPodRateOptimal() external view returns (uint256) {
 298 |     |         return s.sys.evaluationParameters.podRateOptimal;
 299 |     |     }
 300 |     | 
 301 |     |     function getPodRateUpperBound() external view returns (uint256) {
 302 |     |         return s.sys.evaluationParameters.podRateUpperBound;
 303 |     |     }
 304 |     | 
 305 |     |     function getDeltaPodDemandLowerBound() external view returns (uint256) {
 306 |     |         return s.sys.evaluationParameters.deltaPodDemandLowerBound;
 307 |     |     }
 308 |     | 
 309 |     |     function getDeltaPodDemandUpperBound() external view returns (uint256) {
 310 |     |         return s.sys.evaluationParameters.deltaPodDemandUpperBound;
 311 |     |     }
 312 |     | 
 313 |     |     function getLpToSupplyRatioUpperBound() external view returns (uint256) {
 314 |     |         return s.sys.evaluationParameters.lpToSupplyRatioUpperBound;
 315 |     |     }
 316 |     | 
 317 |     |     function getLpToSupplyRatioOptimal() external view returns (uint256) {
 318 |     |         return s.sys.evaluationParameters.lpToSupplyRatioOptimal;
 319 |     |     }
 320 |     | 
 321 |     |     function getLpToSupplyRatioLowerBound() external view returns (uint256) {
 322 |     |         return s.sys.evaluationParameters.lpToSupplyRatioLowerBound;
 323 |     |     }
 324 |     | 
 325 |     |     function getExcessivePriceThreshold() external view returns (uint256) {
 326 |     |         return s.sys.evaluationParameters.excessivePriceThreshold;
 327 |     |     }
 328 |     | 
 329 |     |     function getWellsByDeltaB()
 330 |     |         external
 331 |     |         view
 332 |     |         returns (
 333 |     |             LibFlood.WellDeltaB[] memory wellDeltaBs,
 334 |     |             uint256 totalPositiveDeltaB,
 335 |     |             uint256 totalNegativeDeltaB,
 336 |     |             uint256 positiveDeltaBCount
 337 |     |         )
 338 |     |     {
 339 |     |         return LibFlood.getWellsByDeltaB();
 340 |     |     }
 341 |     | }
 342 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/abstract/Distribution.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  6 |     | import {C} from "contracts/C.sol";
  7 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  8 |     | import {ShipmentRoute} from "contracts/beanstalk/storage/System.sol";
  9 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
 10 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title Distribution
 14 |     |  * @notice Handles shipping of new Bean mints.
 15 |     |  */
 16 |     | abstract contract Distribution is ReentrancyGuard {
 17 |     |     using SafeCast for uint256;
 18 |     | 
 19 |     |     /**
 20 |     |      * @notice Emitted when the shipment routes in storage are replaced with a new set of routes.
 21 |     |      * @param newShipmentRoutes New set of ShipmentRoutes.
 22 |     |      */
 23 |     |     event ShipmentRoutesSet(ShipmentRoute[] newShipmentRoutes);
 24 |     | 
 25 |     |     //////////////////// REWARD BEANS ////////////////////
 26 |     | 
 27 |     |     /**
 28 |     |      * @notice Gets the current set of ShipmentRoutes.
 29 |     |      */
 30 |     |     function getShipmentRoutes() external view returns (ShipmentRoute[] memory) {
 31 |     |         return s.sys.shipmentRoutes;
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @notice Replaces the entire set of ShipmentRoutes with a new set.
 36 |     |      * @dev Changes take effect immediately and will be seen at the next sunrise mint.
 37 |     |      */
 38 | *   |     function setShipmentRoutes(ShipmentRoute[] calldata shipmentRoutes) external {
 39 | *   |         LibDiamond.enforceIsOwnerOrContract();
 40 | *   |         delete s.sys.shipmentRoutes;
 41 | *   |         for (uint256 i; i < shipmentRoutes.length; i++) {
 42 | *   |             s.sys.shipmentRoutes.push(shipmentRoutes[i]);
 43 |     |         }
 44 | *   |         emit ShipmentRoutesSet(shipmentRoutes);
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/abstract/GaugeDefault.sol
   1 |     | /*
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @title GaugeDefault
   9 |     |  * @notice Calculates the gaugePoints for whitelisted Silo LP tokens
  10 |     |  * in a token-agnostic manner.
  11 |     |  */
  12 |     | abstract contract GaugeDefault {
  13 |     |     uint256 private constant EXTREME_FAR_POINT = 5e18;
  14 |     |     uint256 private constant RELATIVE_FAR_POINT = 3e18;
  15 |     |     uint256 private constant RELATIVE_CLOSE_POINT = 1e18;
  16 |     |     // uint256 private constant EXCESSIVELY_CLOSE_POINT = 0e18;
  17 |     | 
  18 |     |     uint256 private constant MAX_GAUGE_POINTS = 1000e18;
  19 |     |     uint256 private constant MAX_PERCENT = 100e6;
  20 |     | 
  21 |     |     uint256 private constant UPPER_THRESHOLD = 10050;
  22 |     |     uint256 private constant LOWER_THRESHOLD = 9950;
  23 |     |     uint256 private constant THRESHOLD_PRECISION = 10000;
  24 |     |     uint256 private constant EXCESSIVELY_FAR = 66.666666e6;
  25 |     |     uint256 private constant RELATIVELY_FAR = 33.333333e6;
  26 |     |     uint256 private constant RELATIVELY_CLOSE = 10e6;
  27 |     |     uint256 private constant PRECISION = 100e6;
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice defaultGaugePoints
  31 |     |      * is the default function to calculate the gauge points
  32 |     |      * of an LP asset.
  33 |     |      *
  34 |     |      * @dev If % of deposited BDV is within range of optimal,
  35 |     |      * keep gauge points the same (RELATIVELY_CLOSE).
  36 |     |      *
  37 |     |      * Cap gaugePoints to MAX_GAUGE_POINTS to avoid runaway gaugePoints.
  38 |     |      */
  39 |     |     function defaultGaugePoints(
  40 |     |         uint256 currentGaugePoints,
  41 |     |         uint256 optimalPercentDepositedBdv,
  42 |     |         uint256 percentOfDepositedBdv,
  43 |     |         bytes memory
  44 |     |     ) public pure returns (uint256 newGaugePoints) {
  45 |     |         if (percentOfDepositedBdv > getRelativelyCloseAbove(optimalPercentDepositedBdv)) {
  46 |     |             // Cap gauge points to MAX_PERCENT if it exceeds.
  47 |     |             if (percentOfDepositedBdv > MAX_PERCENT) {
  48 |     |                 percentOfDepositedBdv = MAX_PERCENT;
  49 |     |             }
  50 |     |             uint256 deltaPoints = getDeltaPoints(
  51 |     |                 optimalPercentDepositedBdv,
  52 |     |                 percentOfDepositedBdv,
  53 |     |                 true
  54 |     |             );
  55 |     | 
  56 |     |             // gauge points cannot go below 0.
  57 |     |             if (deltaPoints < currentGaugePoints) {
  58 |     |                 return currentGaugePoints - deltaPoints;
  59 |     |             } else {
  60 |     |                 // Cap gaugePoints to 0 if it exceeds.
  61 |     |                 return 0;
  62 |     |             }
  63 |     |         } else if (percentOfDepositedBdv < getRelativelyCloseBelow(optimalPercentDepositedBdv)) {
  64 |     |             uint256 deltaPoints = getDeltaPoints(
  65 |     |                 optimalPercentDepositedBdv,
  66 |     |                 percentOfDepositedBdv,
  67 |     |                 false
  68 |     |             );
  69 |     | 
  70 |     |             // gauge points cannot go above MAX_GAUGE_POINTS.
  71 |     |             if (deltaPoints + currentGaugePoints < MAX_GAUGE_POINTS) {
  72 |     |                 return currentGaugePoints + deltaPoints;
  73 |     |             } else {
  74 |     |                 // Cap gaugePoints to MAX_GAUGE_POINTS if it exceeds.
  75 |     |                 return MAX_GAUGE_POINTS;
  76 |     |             }
  77 |     |         } else {
  78 |     |             // If % of deposited BDV is .5% within range of optimal,
  79 |     |             // keep gauge points the same.
  80 |     |             return currentGaugePoints;
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice returns the amount of points to increase or decrease.
  86 |     |      * @dev the points change depending on the distance the % of deposited BDV
  87 |     |      * is from the optimal % of deposited BDV.
  88 |     |      */
  89 |     |     function getDeltaPoints(
  90 |     |         uint256 optimalPercentBdv,
  91 |     |         uint256 percentBdv,
  92 |     |         bool isAboveOptimal
  93 |     |     ) private pure returns (uint256) {
  94 |     |         uint256 exsFar;
  95 |     |         uint256 relFar;
  96 |     |         if (isAboveOptimal) {
  97 |     |             exsFar = getExtremelyFarAbove(optimalPercentBdv);
  98 |     |             relFar = getRelativelyFarAbove(optimalPercentBdv);
  99 |     | 
 100 |     |             if (percentBdv > exsFar) {
 101 |     |                 return EXTREME_FAR_POINT;
 102 |     |             } else if (percentBdv > relFar) {
 103 |     |                 return RELATIVE_FAR_POINT;
 104 |     |             } else {
 105 |     |                 return RELATIVE_CLOSE_POINT;
 106 |     |             }
 107 |     |         } else {
 108 |     |             exsFar = getExtremelyFarBelow(optimalPercentBdv);
 109 |     |             relFar = getRelativelyFarBelow(optimalPercentBdv);
 110 |     | 
 111 |     |             if (percentBdv < exsFar) {
 112 |     |                 return EXTREME_FAR_POINT;
 113 |     |             } else if (percentBdv < relFar) {
 114 |     |                 return RELATIVE_FAR_POINT;
 115 |     |             } else {
 116 |     |                 return RELATIVE_CLOSE_POINT;
 117 |     |             }
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 |     |     function getExtremelyFarAbove(uint256 optimalPercentBdv) public pure returns (uint256) {
 122 |     |         return
 123 |     |             (((MAX_PERCENT - optimalPercentBdv) * EXCESSIVELY_FAR) / PRECISION) + optimalPercentBdv;
 124 |     |     }
 125 |     | 
 126 |     |     function getRelativelyFarAbove(uint256 optimalPercentBdv) public pure returns (uint256) {
 127 |     |         return
 128 |     |             (((MAX_PERCENT - optimalPercentBdv) * RELATIVELY_FAR) / PRECISION) + optimalPercentBdv;
 129 |     |     }
 130 |     | 
 131 |     |     function getRelativelyCloseAbove(uint256 optimalPercentBdv) public pure returns (uint256) {
 132 |     |         return
 133 |     |             (((MAX_PERCENT - optimalPercentBdv) * RELATIVELY_CLOSE) / PRECISION) +
 134 |     |             optimalPercentBdv;
 135 |     |     }
 136 |     | 
 137 |     |     function getExtremelyFarBelow(uint256 optimalPercentBdv) public pure returns (uint256) {
 138 |     |         return (optimalPercentBdv * (PRECISION - EXCESSIVELY_FAR)) / PRECISION;
 139 |     |     }
 140 |     | 
 141 |     |     function getRelativelyFarBelow(uint256 optimalPercentBdv) public pure returns (uint256) {
 142 |     |         return (optimalPercentBdv * (PRECISION - RELATIVELY_FAR)) / PRECISION;
 143 |     |     }
 144 |     | 
 145 |     |     function getRelativelyCloseBelow(uint256 optimalPercentBdv) public pure returns (uint256) {
 146 |     |         return (optimalPercentBdv * (PRECISION - RELATIVELY_CLOSE)) / PRECISION;
 147 |     |     }
 148 |     | }
 149 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/abstract/Oracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {C} from "contracts/C.sol";
  6 |     | import {ReentrancyGuard} from "contracts/beanstalk/ReentrancyGuard.sol";
  7 |     | import {LibWellMinting} from "contracts/libraries/Minting/LibWellMinting.sol";
  8 |     | import {LibMinting} from "contracts/libraries/Minting/LibMinting.sol";
  9 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
 10 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title Oracle
 14 |     |  * @notice Tracks the Delta B in available pools.
 15 |     |  */
 16 |     | abstract contract Oracle is ReentrancyGuard {
 17 |     |     using LibRedundantMathSigned256 for int256;
 18 |     | 
 19 |     |     //////////////////// ORACLE INTERNAL ////////////////////
 20 |     | 
 21 |     |     function stepOracle() internal returns (int256 deltaB) {
 22 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 23 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 24 |     |             deltaB = deltaB.add(LibWellMinting.capture(tokens[i]));
 25 |     |         }
 26 |     |         s.sys.season.timestamp = block.timestamp;
 27 |     |         deltaB = LibMinting.checkForMaxDeltaB(C.GLOBAL_ABSOLUTE_MAX, C.GLOBAL_RATIO_MAX, deltaB);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/abstract/Sun.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   6 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
   7 |     | import {SignedMath} from "@openzeppelin/contracts/utils/math/SignedMath.sol";
   8 |     | import {Oracle, C} from "./Oracle.sol";
   9 |     | import {Distribution} from "./Distribution.sol";
  10 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
  11 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  12 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
  13 |     | import {LibShipping} from "contracts/libraries/LibShipping.sol";
  14 |     | import {LibWellMinting} from "contracts/libraries/Minting/LibWellMinting.sol";
  15 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  16 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  17 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  18 |     | import {LibDibbler} from "contracts/libraries/LibDibbler.sol";
  19 |     | import {IBeanstalk} from "contracts/interfaces/IBeanstalk.sol";
  20 |     | import {Gauge} from "contracts/beanstalk/storage/System.sol";
  21 |     | import {IGaugeFacet} from "contracts/beanstalk/facets/sun/GaugeFacet.sol";
  22 |     | import {LibGaugeHelpers} from "contracts/libraries/LibGaugeHelpers.sol";
  23 |     | import {GaugeId} from "contracts/beanstalk/storage/System.sol";
  24 |     | 
  25 |     | /**
  26 |     |  * @title Sun
  27 |     |  * @notice Sun controls the minting of new Beans to the Field and Silo.
  28 |     |  */
  29 |     | abstract contract Sun is Oracle, Distribution {
  30 |     |     using SafeCast for uint256;
  31 |     |     using LibRedundantMath256 for uint256;
  32 |     |     using LibRedundantMath128 for uint128;
  33 |     |     using SignedMath for int256;
  34 |     |     using Decimal for Decimal.D256;
  35 |     | 
  36 |     |     uint256 internal constant SOIL_PRECISION = 1e6;
  37 |     |     uint256 internal constant CULTIVATION_FACTOR_PRECISION = 1e6;
  38 |     |     /**
  39 |     |      * @notice Emitted during Sunrise when Beanstalk adjusts the amount of available Soil.
  40 |     |      * @param season The Season in which Soil was adjusted.
  41 |     |      * @param soil The new amount of Soil available.
  42 |     |      */
  43 |     |     event Soil(uint32 indexed season, uint256 soil);
  44 |     | 
  45 |     |     //////////////////// SUN INTERNAL ////////////////////
  46 |     | 
  47 |     |     /**
  48 |     |      * @param caseId Pre-calculated Weather case from {Weather.calcCaseId}.
  49 |     |      * @param bs Pre-calculated Beanstalk state from {LibEvaluate.evaluateBeanstalk}.
  50 |     |      * Includes deltaPodDemand, lpToSupplyRatio, podRate, largestLiquidWellTwapBeanPrice, twaDeltaB.
  51 |     |      *
  52 |     |      * - When below peg (twaDeltaB<0), Beanstalk wants to issue debt for beans to be sown(burned),
  53 |     |      * and removed from the supply, pushing the price up. It does that by fetching both the time
  54 |     |      * weighted average and instantaneous deltaB.
  55 |     |      *
  56 |     |      * -- If the instantaneous deltaB is also negative, Beanstalk compares the instDeltaB to the twaDeltaB
  57 |     |      * and picks the minimum of the two, to avoid over-issuing soil.
  58 |     |      * -- If the instDeltaB is positive, Beanstalk issues soil as a percentage of the twaDeltaB and scales it
  59 |     |      * according to the pod rate, as it does when above peg.
  60 |     |      *
  61 |     |      * Issuing soil below peg is also a function of the L2SR.
  62 |     |      * The higher the L2SR, the less soil is issued, as Beanstalk is more willing to
  63 |     |      * sacrifice liquidity via converts than to issue more debt to get back to peg.
  64 |     |      *
  65 |     |      * - When above peg, Beanstalk wants to gauge demand for Soil. Here it
  66 |     |      * issues the amount of Soil that would result in the same number of Pods
  67 |     |      * as became Harvestable during the last Season. It then scales that soil based
  68 |     |      * on the pod rate.
  69 |     |      */
  70 |     |     function stepSun(uint256 caseId, LibEvaluate.BeanstalkState memory bs) internal {
  71 |     |         int256 twaDeltaB = bs.twaDeltaB;
  72 |     |         // Above peg
  73 |     |         if (twaDeltaB > 0) {
  74 |     |             uint256 priorHarvestable = s.sys.fields[s.sys.activeField].harvestable;
  75 |     | 
  76 |     |             s.sys.season.standardMintedBeans = uint256(twaDeltaB);
  77 |     |             BeanstalkERC20(s.sys.bean).mint(address(this), uint256(twaDeltaB));
  78 |     |             LibShipping.ship(uint256(twaDeltaB));
  79 |     |             uint256 newHarvestable = s.sys.fields[s.sys.activeField].harvestable -
  80 |     |                 priorHarvestable +
  81 |     |                 s.sys.rain.floodHarvestablePods;
  82 |     |             setSoilAbovePeg(newHarvestable, caseId);
  83 |     |             s.sys.season.abovePeg = true;
  84 |     |         } else {
  85 |     |             // Below peg
  86 |     |             int256 instDeltaB = LibWellMinting.getTotalInstantaneousDeltaB();
  87 |     |             uint256 soil;
  88 |     |             if (instDeltaB > 0) {
  89 |     |                 // twaDeltaB < 0 and instDeltaB > 0, beanstalk ended the season above peg
  90 |     |                 soil =
  91 |     |                     (uint256(-twaDeltaB) * s.sys.extEvaluationParameters.abovePegDeltaBSoilScalar) /
  92 |     |                     SOIL_PRECISION;
  93 |     |                 setSoil(scaleSoilAbovePeg(soil, caseId));
  94 |     |             } else {
  95 |     |                 // twaDeltaB < 0 and instDeltaB <= 0, beanstalk ended the season below peg
  96 |     |                 soil = Math.min(uint256(-twaDeltaB), uint256(-instDeltaB));
  97 |     |                 setSoil(scaleSoilBelowPeg(soil, bs.lpToSupplyRatio));
  98 |     |             }
  99 |     |             s.sys.season.abovePeg = false;
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     //////////////////// SET SOIL ////////////////////
 104 |     | 
 105 |     |     /**
 106 |     |      * @param newHarvestable The number of Beans that were minted to the Field.
 107 |     |      * @param caseId The current Weather Case.
 108 |     |      * @dev To calculate the amount of Soil to issue, Beanstalk first calculates the number
 109 |     |      * of Harvestable Pods that would result in the same number of Beans as were minted to the Field.
 110 |     |      */
 111 |     |     function setSoilAbovePeg(uint256 newHarvestable, uint256 caseId) internal {
 112 |     |         uint256 newSoil = newHarvestable.mul(LibDibbler.ONE_HUNDRED_TEMP).div(
 113 |     |             LibDibbler.ONE_HUNDRED_TEMP + s.sys.weather.temp
 114 |     |         );
 115 |     |         // scale the soil according to pod rate
 116 |     |         setSoil(scaleSoilAbovePeg(newSoil, caseId));
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @param soilAmount The amount of Soil, as a result of the new Harvestable Pods (above peg)
 121 |     |      * or a percentage of the twaDeltaB (below peg).
 122 |     |      * @param caseId The current Weather Case.
 123 |     |      * @dev Scales the Soil amount above peg as a function of the Weather Case.
 124 |     |      * Beanstalk distinguishes between four cases of podRate
 125 |     |      * 1. podRate < lowerBound
 126 |     |      * 2. lowerBound <= podRate < optimal
 127 |     |      * 3. optimal <= podRate < upperBound
 128 |     |      * 4. podRate > upperBound
 129 |     |      * The higher the podRate, the less Soil is issued according to the soilCoefficients.
 130 |     |      */
 131 |     |     function scaleSoilAbovePeg(uint256 soilAmount, uint256 caseId) internal view returns (uint256) {
 132 |     |         if (caseId.mod(36) >= 27) {
 133 |     |             // podrate >=25%
 134 |     |             return soilAmount.mul(s.sys.evaluationParameters.soilCoefficientHigh).div(C.PRECISION);
 135 |     |         } else if (caseId.mod(36) >= 18) {
 136 |     |             // podrate 15-25%
 137 |     |             return
 138 |     |                 soilAmount.mul(s.sys.extEvaluationParameters.soilCoefficientRelativelyHigh).div(
 139 |     |                     C.PRECISION
 140 |     |                 );
 141 |     |         } else if (caseId.mod(36) >= 9) {
 142 |     |             // podrate 3-15%
 143 |     |             return
 144 |     |                 soilAmount.mul(s.sys.extEvaluationParameters.soilCoefficientRelativelyLow).div(
 145 |     |                     C.PRECISION
 146 |     |                 );
 147 |     |         } else {
 148 |     |             // podrate <=3%
 149 |     |             return soilAmount.mul(s.sys.evaluationParameters.soilCoefficientLow).div(C.PRECISION);
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     /**
 154 |     |      * @dev Scales the soil amount below peg as a function of L2SR, soil distribution period, and cultivationFactor.
 155 |     |      * @param soilAmount The amount of soil to scale.
 156 |     |      * @return The scaled amount of soil.
 157 |     |      */
 158 |     |     function scaleSoilBelowPeg(
 159 |     |         uint256 soilAmount,
 160 |     |         Decimal.D256 memory lpToSupplyRatio
 161 |     |     ) internal view returns (uint256) {
 162 |     |         // If soilAmount is 0, return 0 directly
 163 |     |         if (soilAmount == 0) return 0;
 164 |     | 
 165 |     |         Decimal.D256 memory scalar = Decimal.ratio(
 166 |     |             s.sys.extEvaluationParameters.belowPegSoilL2SRScalar,
 167 |     |             1e6
 168 |     |         );
 169 |     | 
 170 |     |         // Minimum of 1% of soilAmount.
 171 |     |         Decimal.D256 memory scaledL2SR = lpToSupplyRatio.mul(scalar);
 172 |     |         if (scaledL2SR.greaterThanOrEqualTo(Decimal.ratio(99, 100))) {
 173 |     |             scaledL2SR = Decimal.ratio(99, 100);
 174 |     |         }
 175 |     | 
 176 |     |         // (1 - L2SR * scalar) * soilAmount
 177 |     |         uint256 scaledAmount = Decimal
 178 |     |             .one()
 179 |     |             .sub(scaledL2SR)
 180 |     |             .mul(Decimal.from(soilAmount))
 181 |     |             .asUint256();
 182 |     | 
 183 |     |         // Scale by 1 hour (in seconds) / soilDistributionPeriod to distribute soil availability over the target distribution period
 184 |     |         scaledAmount = Math.mulDiv(
 185 |     |             scaledAmount,
 186 |     |             3600,
 187 |     |             s.sys.extEvaluationParameters.soilDistributionPeriod
 188 |     |         );
 189 |     | 
 190 |     |         // Apply cultivationFactor scaling (cultivationFactor is a percentage with 6 decimal places, where 100e6 = 100%)
 191 |     |         uint256 cultivationFactor = abi.decode(
 192 |     |             LibGaugeHelpers.getGaugeValue(GaugeId.CULTIVATION_FACTOR),
 193 |     |             (uint256)
 194 |     |         );
 195 |     |         return
 196 |     |             Math.max(
 197 |     |                 Math.mulDiv(scaledAmount, cultivationFactor, 100e6),
 198 |     |                 s.sys.extEvaluationParameters.minSoilIssuance
 199 |     |             );
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @param amount The new amount of Soil available.
 204 |     |      * @dev Sets the amount of Soil available and emits a Soil event.
 205 |     |      */
 206 |     |     function setSoil(uint256 amount) internal {
 207 |     |         s.sys.soil = amount.toUint128();
 208 |     |         emit Soil(s.sys.season.current, amount.toUint128());
 209 |     |     }
 210 |     | }
 211 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/facets/sun/abstract/Weather.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   6 |     | import {Sun, C} from "./Sun.sol";
   7 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
   8 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
   9 |     | import {LibCases} from "contracts/libraries/LibCases.sol";
  10 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  11 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  12 |     | import {AppStorage, LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
  13 |     | import {LibFlood} from "contracts/libraries/Silo/LibFlood.sol";
  14 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title Weather
  18 |     |  * @notice Weather controls the Temperature and Grown Stalk to LP on the Farm.
  19 |     |  */
  20 |     | abstract contract Weather is Sun {
  21 |     |     using LibRedundantMath256 for uint256;
  22 |     |     using LibRedundantMathSigned256 for int256;
  23 |     |     using LibRedundantMath128 for uint128;
  24 |     | 
  25 |     |     uint128 internal constant MAX_BEAN_LP_GP_PER_BDV_RATIO = 100e18;
  26 |     | 
  27 |     |     // @notice This controls the percentage of Bean supply that is flooded to the field.
  28 |     |     // 1000 represents 1/1000, or 0.1% of total Bean supply.
  29 |     |     uint256 internal constant FLOOD_PODLINE_PERCENT_DENOMINATOR = 1000;
  30 |     | 
  31 |     |     // @dev In-memory struct used to store current deltaB, and then reduction amount per-well.
  32 |     |     struct WellDeltaB {
  33 |     |         address well;
  34 |     |         int256 deltaB;
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Emitted when the Temperature (fka "Weather") changes.
  39 |     |      * @param season The current Season
  40 |     |      * @param caseId The Weather case, which determines how much the Temperature is adjusted.
  41 |     |      * @param absChange The absolute change in Temperature.
  42 |     |      * @dev formula: T_n = T_n-1 +/- bT
  43 |     |      */
  44 |     |     event TemperatureChange(
  45 |     |         uint256 indexed season,
  46 |     |         uint256 caseId,
  47 |     |         int32 absChange,
  48 |     |         uint256 fieldId
  49 |     |     );
  50 |     | 
  51 |     |     /**
  52 |     |      * @notice Emitted when the grownStalkToLP changes.
  53 |     |      * @param season The current Season
  54 |     |      * @param caseId The Weather case, which determines how the BeanToMaxLPGpPerBDVRatio is adjusted.
  55 |     |      * @param absChange The absolute change in the BeanToMaxLPGpPerBDVRatio.
  56 |     |      * @dev formula: L_n = L_n-1 +/- bL
  57 |     |      */
  58 |     |     event BeanToMaxLpGpPerBdvRatioChange(uint256 indexed season, uint256 caseId, int80 absChange);
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Emitted when Beans are minted to the Field during the Season of Plenty.
  62 |     |      * @param toField The amount of Beans which were distributed to remaining Pods in the Field.
  63 |     |      */
  64 |     |     event SeasonOfPlentyField(uint256 toField);
  65 |     | 
  66 |     |     //////////////////// WEATHER INTERNAL ////////////////////
  67 |     | 
  68 |     |     /**
  69 |     |      * @notice from deltaB, podRate, change in soil demand, and liquidity to supply ratio,
  70 |     |      * calculate the caseId, and update the temperature and grownStalkPerBdvToLp.
  71 |     |      * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.
  72 |     |      * @dev A detailed explanation of the temperature and grownStalkPerBdvToLp
  73 |     |      * mechanism can be found in the Beanstalk whitepaper.
  74 |     |      * An explanation of state variables can be found in {AppStorage}.
  75 |     |      */
  76 |     |     function calcCaseIdAndHandleRain(
  77 |     |         int256 deltaB
  78 |     |     ) internal returns (uint256 caseId, LibEvaluate.BeanstalkState memory bs) {
  79 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
  80 |     |         // prevents infinite L2SR and podrate
  81 |     |         if (beanSupply == 0) {
  82 |     |             s.sys.weather.temp = 1e6;
  83 |     |             // Returns an uninitialized Beanstalk State.
  84 |     |             return (9, bs); // Reasonably low
  85 |     |         }
  86 |     | 
  87 |     |         // Calculate Case Id
  88 |     |         (caseId, bs) = LibEvaluate.evaluateBeanstalk(deltaB, beanSupply);
  89 |     |         updateTemperatureAndBeanToMaxLpGpPerBdvRatio(caseId, bs, bs.oracleFailure);
  90 |     |         LibFlood.handleRain(caseId);
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice updates the temperature and BeanToMaxLpGpPerBdvRatio, based on the caseId.
  95 |     |      * @param caseId the state beanstalk is in, based on the current season.
  96 |     |      * @dev currently, an oracle failure does not affect the temperature, as
  97 |     |      * the temperature is not affected by liquidity levels. The function will
  98 |     |      * need to be updated if the temperature is affected by liquidity levels.
  99 |     |      * This is implemented such that liveliness in change in temperature is retained.
 100 |     |      */
 101 |     |     function updateTemperatureAndBeanToMaxLpGpPerBdvRatio(
 102 |     |         uint256 caseId,
 103 |     |         LibEvaluate.BeanstalkState memory bs,
 104 |     |         bool oracleFailure
 105 |     |     ) internal {
 106 |     |         LibCases.CaseData memory cd = LibCases.decodeCaseData(caseId);
 107 |     | 
 108 |     |         // if the podrate is > 100% and deltaB is negative, set bt based on soil demand:
 109 |     |         if (bs.podRate.value > 1e18) {
 110 |     |             if (bs.twaDeltaB < 0) {
 111 |     |                 if (caseId % 3 == 0) {
 112 |     |                     // decreasing
 113 |     |                     cd.bT = 0.5e6;
 114 |     |                 } else if (caseId % 3 == 1) {
 115 |     |                     // steady
 116 |     |                     cd.bT = 0;
 117 |     |                 } else if (caseId % 3 == 2) {
 118 |     |                     // increasing
 119 |     |                     cd.bT = -1e6;
 120 |     |                 }
 121 |     |             }
 122 |     |             // append 1000 to the caseId to indicate that the podrate is > 100%
 123 |     |             caseId = caseId + 1000;
 124 |     |         }
 125 |     | 
 126 |     |         updateTemperature(cd.bT, caseId);
 127 |     | 
 128 |     |         // if one of the oracles needed to calculate usd liquidity fails,
 129 |     |         // the beanToMaxLpGpPerBdvRatio should not be updated.
 130 |     |         if (oracleFailure) return;
 131 |     |         updateBeanToMaxLPRatio(cd.bL, caseId);
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Changes the current Temperature `s.weather.t` based on the Case Id.
 136 |     |      * @dev bT are set during edge cases such that the event emitted is valid.
 137 |     |      */
 138 |     |     function updateTemperature(int32 bT, uint256 caseId) private {
 139 |     |         uint256 t = s.sys.weather.temp;
 140 |     |         if (bT < 0) {
 141 |     |             if (t <= uint256(int256(-bT))) {
 142 |     |                 // if temp is to be decreased and the change is greater than the current temp,
 143 |     |                 // - then the new temp will be 1e6.
 144 |     |                 // - and the change in temp bT will be the difference between the new temp and the old temp.
 145 |     |                 // if (change < 0 && t <= uint32(-change)),
 146 |     |                 // then 0 <= t <= type(int32).max because change is an int32.
 147 |     |                 bT = 1e6 - int32(int256(t));
 148 |     |                 s.sys.weather.temp = 1e6;
 149 |     |             } else {
 150 |     |                 s.sys.weather.temp = uint32(t - uint256(int256(-bT)));
 151 |     |             }
 152 |     |         } else {
 153 |     |             s.sys.weather.temp = uint32(t + uint256(int256(bT)));
 154 |     |         }
 155 |     | 
 156 |     |         emit TemperatureChange(s.sys.season.current, caseId, bT, s.sys.activeField);
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @notice Changes the grownStalkPerBDVPerSeason based on the CaseId.
 161 |     |      * @dev bL are set during edge cases such that the event emitted is valid.
 162 |     |      */
 163 |     |     function updateBeanToMaxLPRatio(int80 bL, uint256 caseId) private {
 164 |     |         uint128 beanToMaxLpGpPerBdvRatio = s.sys.seedGauge.beanToMaxLpGpPerBdvRatio;
 165 |     |         if (bL < 0) {
 166 |     |             if (beanToMaxLpGpPerBdvRatio <= uint128(int128(-bL))) {
 167 |     |                 bL = -SafeCast.toInt80(int256(uint256(beanToMaxLpGpPerBdvRatio)));
 168 |     |                 s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = 0;
 169 |     |             } else {
 170 |     |                 s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpPerBdvRatio.sub(
 171 |     |                     uint128(int128(-bL))
 172 |     |                 );
 173 |     |             }
 174 |     |         } else {
 175 |     |             if (beanToMaxLpGpPerBdvRatio.add(uint128(int128(bL))) >= MAX_BEAN_LP_GP_PER_BDV_RATIO) {
 176 |     |                 // if (change > 0 && 100e18 - beanToMaxLpGpPerBdvRatio <= bL),
 177 |     |                 // then bL cannot overflow.
 178 |     |                 bL = int80(
 179 |     |                     SafeCast.toInt80(
 180 |     |                         int256(uint256(MAX_BEAN_LP_GP_PER_BDV_RATIO.sub(beanToMaxLpGpPerBdvRatio)))
 181 |     |                     )
 182 |     |                 );
 183 |     |                 s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = MAX_BEAN_LP_GP_PER_BDV_RATIO;
 184 |     |             } else {
 185 |     |                 s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpPerBdvRatio.add(
 186 |     |                     uint128(int128(bL))
 187 |     |                 );
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 |     |         emit BeanToMaxLpGpPerBdvRatioChange(s.sys.season.current, caseId, bL);
 192 |     |     }
 193 |     | }
 194 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/init/InitalizeDiamond.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {ILiquidityWeightFacet} from "contracts/beanstalk/facets/sun/LiquidityWeightFacet.sol";
   8 |     | import {IGaugeFacet} from "contracts/beanstalk/facets/sun/GaugeFacet.sol";
   9 |     | import {BDVFacet} from "contracts/beanstalk/facets/silo/BDVFacet.sol";
  10 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  11 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  12 |     | import {AssetSettings, Implementation} from "contracts/beanstalk/storage/System.sol";
  13 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  14 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  15 |     | import {LibCases} from "contracts/libraries/LibCases.sol";
  16 |     | import {LibGauge} from "contracts/libraries/LibGauge.sol";
  17 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  18 |     | import {Gauge, GaugeId} from "contracts/beanstalk/storage/System.sol";
  19 |     | import {LibGaugeHelpers} from "../../libraries/LibGaugeHelpers.sol";
  20 |     | import {C} from "contracts/C.sol";
  21 |     | 
  22 |     | /**
  23 |     |  * @title InitalizeDiamond
  24 |     |  * @notice InitalizeDiamond provides helper functions to initalize beanstalk.
  25 |     |  **/
  26 |     | 
  27 |     | contract InitalizeDiamond {
  28 |     |     AppStorage internal s;
  29 |     | 
  30 |     |     // INITIAL CONSTANTS //
  31 | *   |     uint128 constant INIT_BEAN_TO_MAX_LP_GP_RATIO = 33_333_333_333_333_333_333; // 33%
  32 | *   |     uint128 constant INIT_AVG_GSPBDV = 3e12;
  33 | *   |     uint32 constant INIT_BEAN_STALK_EARNED_PER_SEASON = 2e6;
  34 | *   |     uint32 constant INIT_BEAN_TOKEN_WELL_STALK_EARNED_PER_SEASON = 4e6;
  35 | *   |     uint48 constant INIT_STALK_ISSUED_PER_BDV = 1e10;
  36 | *   |     uint128 constant INIT_TOKEN_G_POINTS = 100e18;
  37 | *   |     uint32 constant INIT_BEAN_TOKEN_WELL_PERCENT_TARGET = 100e6;
  38 |     | 
  39 |     |     // Pod rate bounds
  40 | *   |     uint256 internal constant POD_RATE_LOWER_BOUND = 0.05e18; // 5%
  41 | *   |     uint256 internal constant POD_RATE_OPTIMAL = 0.15e18; // 15%
  42 | *   |     uint256 internal constant POD_RATE_UPPER_BOUND = 0.25e18; // 25%
  43 |     | 
  44 |     |     // Change in Soil demand bounds
  45 | *   |     uint256 internal constant DELTA_POD_DEMAND_LOWER_BOUND = 0.95e18; // 95%
  46 | *   |     uint256 internal constant DELTA_POD_DEMAND_UPPER_BOUND = 1.05e18; // 105%
  47 |     | 
  48 |     |     // Liquidity to supply ratio bounds
  49 | *   |     uint256 internal constant LP_TO_SUPPLY_RATIO_UPPER_BOUND = 0.8e18; // 80%
  50 | *   |     uint256 internal constant LP_TO_SUPPLY_RATIO_OPTIMAL = 0.4e18; // 40%
  51 | *   |     uint256 internal constant LP_TO_SUPPLY_RATIO_LOWER_BOUND = 0.12e18; // 12%
  52 |     | 
  53 |     |     // Excessive price threshold constant
  54 | *   |     uint256 internal constant EXCESSIVE_PRICE_THRESHOLD = 1.025e6;
  55 |     | 
  56 |     |     /// @dev When the Pod Rate is high, issue less Soil.
  57 | *   |     uint256 private constant SOIL_COEFFICIENT_HIGH = 0.25e18;
  58 |     | 
  59 | *   |     uint256 private constant SOIL_COEFFICIENT_REALATIVELY_HIGH = 0.5e18;
  60 |     | 
  61 |     |     /// @dev When the Pod Rate is low, issue more Soil.
  62 | *   |     uint256 private constant SOIL_COEFFICIENT_REALATIVELY_LOW = 1e18;
  63 |     | 
  64 | *   |     uint256 private constant SOIL_COEFFICIENT_LOW = 1.2e18;
  65 |     | 
  66 |     |     /// @dev Base BEAN reward to cover cost of operating a bot.
  67 | *   |     uint256 internal constant BASE_REWARD = 5e6; // 5 BEAN
  68 |     | 
  69 |     |     // Gauge
  70 | *   |     uint256 internal constant TARGET_SEASONS_TO_CATCHUP = 4320;
  71 | *   |     uint256 internal constant MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO = 150e18; // 150%
  72 | *   |     uint256 internal constant MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO = 50e18; // 50%
  73 | *   |     uint128 internal constant RAINING_MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO = 10e18;
  74 |     | 
  75 |     |     // Soil scalar.
  76 | *   |     uint256 internal constant BELOW_PEG_SOIL_L2SR_SCALAR = 1.0e6;
  77 |     | 
  78 |     |     // Delta B divisor when twaDeltaB < 0 and instDeltaB > 0
  79 | *   |     uint256 internal constant ABOVE_PEG_DELTA_B_SOIL_SCALAR = 0.01e6; // 1% of twaDeltaB (6 decimals)
  80 |     | 
  81 |     |     // Soil distribution period
  82 | *   |     uint256 internal constant SOIL_DISTRIBUTION_PERIOD = 24 * 60 * 60; // 24 hours
  83 |     | 
  84 |     |     // GAUGE DATA:
  85 |     | 
  86 |     |     // Cultivation Factor
  87 | *   |     uint256 internal constant INIT_CULTIVATION_FACTOR = 50e6; // 50%
  88 | *   |     uint256 internal constant MIN_DELTA_CULTIVATION_FACTOR = 0.5e6; // 0.5%
  89 | *   |     uint256 internal constant MAX_DELTA_CULTIVATION_FACTOR = 2e6; // 2%
  90 | *   |     uint256 internal constant MIN_CULTIVATION_FACTOR = 1e6; // 1%
  91 | *   |     uint256 internal constant MAX_CULTIVATION_FACTOR = 100e6; // 100%
  92 |     | 
  93 |     |     // Rolling Seasons Above Peg.
  94 |     |     // The % penalty to be applied to grown stalk when down converting.
  95 | *   |     uint256 internal constant INIT_CONVERT_DOWN_PENALTY_RATIO = 0;
  96 |     |     // Rolling count of seasons with a twap above peg.
  97 | *   |     uint256 internal constant INIT_ROLLING_SEASONS_ABOVE_PEG = 0;
  98 |     |     // Max magnitude for rolling seasons above peg count.
  99 | *   |     uint256 internal constant ROLLING_SEASONS_ABOVE_PEG_CAP = 12;
 100 |     |     // Rate at which rolling seasons above peg count changes. If not one, it is not actual count.
 101 | *   |     uint256 internal constant ROLLING_SEASONS_ABOVE_PEG_RATE = 1;
 102 |     | 
 103 |     |     // Min Soil Issuance
 104 | *   |     uint256 internal constant MIN_SOIL_ISSUANCE = 50e6; // 50
 105 |     | 
 106 |     |     // Min Soil Sown Demand
 107 | *   |     uint256 internal constant MIN_SOIL_SOWN_DEMAND = 5e6; // 5
 108 |     | 
 109 |     |     // EVENTS:
 110 |     |     event BeanToMaxLpGpPerBdvRatioChange(uint256 indexed season, uint256 caseId, int80 absChange);
 111 |     | 
 112 |     |     /**
 113 |     |      * @notice Initalizes the diamond with base conditions.
 114 |     |      * @dev the base initalization initalizes various parameters,
 115 |     |      * as well as whitelists the bean and bean:TKN pools.
 116 |     |      */
 117 | *   |     function initalizeDiamond(address bean, address beanTokenWell) internal {
 118 | *   |         addInterfaces();
 119 | *   |         initializeTokens(bean);
 120 | *   |         initalizeSeason();
 121 | *   |         initalizeField();
 122 | *   |         initalizeFarmAndTractor();
 123 | *   |         initializeGauges();
 124 |     | 
 125 | *   |         address[] memory tokens = new address[](2);
 126 | *   |         tokens[0] = bean;
 127 | *   |         tokens[1] = beanTokenWell;
 128 |     | 
 129 |     |         // note: bean and assets that are not in the gauge system
 130 |     |         // do not need to initalize the gauge system.
 131 | *   |         Implementation memory impl = Implementation(address(0), bytes4(0), bytes1(0), new bytes(0));
 132 | *   |         Implementation memory liquidityWeightImpl = Implementation(
 133 | *   |             address(0),
 134 | *   |             ILiquidityWeightFacet.maxWeight.selector,
 135 | *   |             bytes1(0),
 136 | *   |             new bytes(0)
 137 |     |         );
 138 | *   |         Implementation memory gaugePointImpl = Implementation(
 139 | *   |             address(0),
 140 | *   |             IGaugeFacet.defaultGaugePoints.selector,
 141 | *   |             bytes1(0),
 142 | *   |             new bytes(0)
 143 |     |         );
 144 |     | 
 145 | *   |         AssetSettings[] memory assetSettings = new AssetSettings[](2);
 146 | *   |         assetSettings[0] = AssetSettings({
 147 | *   |             selector: BDVFacet.beanToBDV.selector,
 148 |     |             stalkEarnedPerSeason: INIT_BEAN_STALK_EARNED_PER_SEASON,
 149 |     |             stalkIssuedPerBdv: INIT_STALK_ISSUED_PER_BDV,
 150 | *   |             milestoneSeason: s.sys.season.current,
 151 | *   |             milestoneStem: 0,
 152 | *   |             encodeType: 0x00,
 153 | *   |             deltaStalkEarnedPerSeason: 0,
 154 | *   |             gaugePoints: 0,
 155 | *   |             optimalPercentDepositedBdv: 0,
 156 | *   |             gaugePointImplementation: impl,
 157 | *   |             liquidityWeightImplementation: impl
 158 |     |         });
 159 |     | 
 160 | *   |         assetSettings[1] = AssetSettings({
 161 | *   |             selector: BDVFacet.wellBdv.selector,
 162 |     |             stalkEarnedPerSeason: INIT_BEAN_TOKEN_WELL_STALK_EARNED_PER_SEASON,
 163 |     |             stalkIssuedPerBdv: INIT_STALK_ISSUED_PER_BDV,
 164 | *   |             milestoneSeason: s.sys.season.current,
 165 | *   |             milestoneStem: 0,
 166 | *   |             encodeType: 0x01,
 167 | *   |             deltaStalkEarnedPerSeason: 0,
 168 |     |             gaugePoints: INIT_TOKEN_G_POINTS,
 169 |     |             optimalPercentDepositedBdv: INIT_BEAN_TOKEN_WELL_PERCENT_TARGET,
 170 | *   |             gaugePointImplementation: gaugePointImpl,
 171 | *   |             liquidityWeightImplementation: liquidityWeightImpl
 172 |     |         });
 173 |     | 
 174 | *   |         whitelistPools(tokens, assetSettings);
 175 |     | 
 176 |     |         // init usdTokenPrice. beanTokenWell should be
 177 |     |         // a bean well w/ the native token of the network.
 178 | *   |         s.sys.usdTokenPrice[beanTokenWell] = 1;
 179 | *   |         s.sys.twaReserves[beanTokenWell].reserve0 = 1;
 180 | *   |         s.sys.twaReserves[beanTokenWell].reserve1 = 1;
 181 |     | 
 182 |     |         // init tractor.
 183 | *   |         LibTractor._tractorStorage().activePublisher = payable(address(1));
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @notice Adds ERC1155 and ERC1155Metadata interfaces to the diamond.
 188 |     |      */
 189 | *   |     function addInterfaces() internal {
 190 | *   |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 191 |     | 
 192 | *   |         ds.supportedInterfaces[0xd9b67a26] = true; // ERC1155
 193 | *   |         ds.supportedInterfaces[0x0e89341c] = true; // ERC1155Metadata
 194 |     |     }
 195 |     | 
 196 | *   |     function initializeTokens(address bean) internal {
 197 | *   |         s.sys.bean = bean;
 198 |     |     }
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice Initalizes field parameters.
 202 |     |      */
 203 | *   |     function initalizeField() internal {
 204 | *   |         s.sys.weather.temp = 1e6;
 205 | *   |         s.sys.weather.thisSowTime = type(uint32).max;
 206 | *   |         s.sys.weather.lastSowTime = type(uint32).max;
 207 |     | 
 208 | *   |         s.sys.extEvaluationParameters.minSoilIssuance = MIN_SOIL_ISSUANCE;
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @notice Initalizes season parameters.
 213 |     |      */
 214 | *   |     function initalizeSeason() internal {
 215 |     |         // set current season to 1.
 216 | *   |         s.sys.season.current = 1;
 217 |     | 
 218 |     |         // initalize the duration of 1 season in seconds.
 219 | *   |         s.sys.season.period = C.CURRENT_SEASON_PERIOD;
 220 |     | 
 221 |     |         // initalize current timestamp.
 222 | *   |         s.sys.season.timestamp = block.timestamp;
 223 |     | 
 224 |     |         // initalize the start timestamp.
 225 |     |         // Rounds down to the nearest hour
 226 |     |         // if needed.
 227 | *   |         s.sys.season.start = s.sys.season.period > 0
 228 | *   |             ? (block.timestamp / s.sys.season.period) * s.sys.season.period
 229 |     |             : block.timestamp;
 230 |     | 
 231 |     |         // initalizes the cases that beanstalk uses
 232 |     |         // to change certain parameters of itself.
 233 | *   |         setCases();
 234 |     | 
 235 | *   |         initializeSeedGaugeSettings();
 236 |     |     }
 237 |     | 
 238 |     |     /**
 239 |     |      * @notice Initalize the cases for the diamond.
 240 |     |      */
 241 | *   |     function setCases() internal {
 242 | *   |         LibCases.setCasesV2();
 243 |     |     }
 244 |     | 
 245 | *   |     function initalizeSeedGauge(
 246 |     |         uint128 beanToMaxLpGpRatio,
 247 |     |         uint128 averageGrownStalkPerBdvPerSeason
 248 |     |     ) internal {
 249 |     |         // initalize the ratio of bean to max lp gp per bdv.
 250 | *   |         s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = beanToMaxLpGpRatio;
 251 |     | 
 252 |     |         // initalize the average grown stalk per bdv per season.
 253 | *   |         s.sys.seedGauge.averageGrownStalkPerBdvPerSeason = averageGrownStalkPerBdvPerSeason;
 254 |     | 
 255 |     |         // emit events.
 256 | *   |         emit BeanToMaxLpGpPerBdvRatioChange(
 257 | *   |             s.sys.season.current,
 258 | *   |             type(uint256).max,
 259 | *   |             int80(int128(s.sys.seedGauge.beanToMaxLpGpPerBdvRatio))
 260 |     |         );
 261 | *   |         emit LibGauge.UpdateAverageStalkPerBdvPerSeason(
 262 | *   |             s.sys.seedGauge.averageGrownStalkPerBdvPerSeason
 263 |     |         );
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * Whitelists the pools.
 268 |     |      * @param assetSettings The pools to whitelist.
 269 |     |      */
 270 | *   |     function whitelistPools(
 271 |     |         address[] memory tokens,
 272 |     |         AssetSettings[] memory assetSettings
 273 |     |     ) internal {
 274 | *   |         for (uint256 i = 0; i < tokens.length; i++) {
 275 |     |             // note: no error checking.
 276 | *   |             s.sys.silo.assetSettings[tokens[i]] = assetSettings[i];
 277 |     | 
 278 | *   |             bool isLPandWell = true;
 279 | *   |             if (tokens[i] == s.sys.bean) {
 280 | *   |                 isLPandWell = false;
 281 |     |             }
 282 |     | 
 283 |     |             // All tokens (excluding bean) are assumed to be
 284 |     |             // - whitelisted,
 285 |     |             // - an LP and well.
 286 | *   |             LibWhitelistedTokens.addWhitelistStatus(
 287 | *   |                 tokens[i],
 288 | *   |                 true, // is whitelisted,
 289 | *   |                 isLPandWell,
 290 | *   |                 isLPandWell,
 291 | *   |                 isLPandWell // assumes any well LP is soppable, may not be true in the future
 292 |     |             );
 293 |     |         }
 294 |     |     }
 295 |     | 
 296 | *   |     function initializeSeedGaugeSettings() internal {
 297 | *   |         s.sys.evaluationParameters.maxBeanMaxLpGpPerBdvRatio = MAX_BEAN_MAX_LP_GP_PER_BDV_RATIO;
 298 | *   |         s.sys.evaluationParameters.minBeanMaxLpGpPerBdvRatio = MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO;
 299 | *   |         s.sys.evaluationParameters.targetSeasonsToCatchUp = TARGET_SEASONS_TO_CATCHUP;
 300 | *   |         s.sys.evaluationParameters.podRateLowerBound = POD_RATE_LOWER_BOUND;
 301 | *   |         s.sys.evaluationParameters.podRateOptimal = POD_RATE_OPTIMAL;
 302 | *   |         s.sys.evaluationParameters.podRateUpperBound = POD_RATE_UPPER_BOUND;
 303 | *   |         s.sys.evaluationParameters.deltaPodDemandLowerBound = DELTA_POD_DEMAND_LOWER_BOUND;
 304 | *   |         s.sys.evaluationParameters.deltaPodDemandUpperBound = DELTA_POD_DEMAND_UPPER_BOUND;
 305 | *   |         s.sys.evaluationParameters.lpToSupplyRatioUpperBound = LP_TO_SUPPLY_RATIO_UPPER_BOUND;
 306 | *   |         s.sys.evaluationParameters.lpToSupplyRatioOptimal = LP_TO_SUPPLY_RATIO_OPTIMAL;
 307 | *   |         s.sys.evaluationParameters.lpToSupplyRatioLowerBound = LP_TO_SUPPLY_RATIO_LOWER_BOUND;
 308 | *   |         s.sys.evaluationParameters.excessivePriceThreshold = EXCESSIVE_PRICE_THRESHOLD;
 309 | *   |         s.sys.evaluationParameters.soilCoefficientHigh = SOIL_COEFFICIENT_HIGH;
 310 | *   |         s
 311 |     |             .sys
 312 |     |             .extEvaluationParameters
 313 |     |             .soilCoefficientRelativelyHigh = SOIL_COEFFICIENT_REALATIVELY_HIGH;
 314 | *   |         s
 315 |     |             .sys
 316 |     |             .extEvaluationParameters
 317 |     |             .soilCoefficientRelativelyLow = SOIL_COEFFICIENT_REALATIVELY_LOW;
 318 | *   |         s.sys.evaluationParameters.soilCoefficientLow = SOIL_COEFFICIENT_LOW;
 319 | *   |         s.sys.evaluationParameters.baseReward = BASE_REWARD;
 320 | *   |         s
 321 |     |             .sys
 322 |     |             .evaluationParameters
 323 |     |             .rainingMinBeanMaxLpGpPerBdvRatio = RAINING_MIN_BEAN_MAX_LP_GP_PER_BDV_RATIO;
 324 | *   |         s.sys.extEvaluationParameters.belowPegSoilL2SRScalar = BELOW_PEG_SOIL_L2SR_SCALAR;
 325 | *   |         s.sys.extEvaluationParameters.abovePegDeltaBSoilScalar = ABOVE_PEG_DELTA_B_SOIL_SCALAR;
 326 |     | 
 327 |     |         // Initialize soilDistributionPeriod to 24 hours (in seconds)
 328 | *   |         s.sys.extEvaluationParameters.soilDistributionPeriod = SOIL_DISTRIBUTION_PERIOD;
 329 | *   |         s.sys.extEvaluationParameters.minSoilSownDemand = MIN_SOIL_SOWN_DEMAND;
 330 |     |     }
 331 |     | 
 332 | *   |     function initalizeFarmAndTractor() internal {
 333 | *   |         LibTractor._resetPublisher();
 334 | *   |         LibTractor._setVersion("1.0.0");
 335 |     |     }
 336 |     | 
 337 | *   |     function initializeGauges() internal {
 338 | *   |         initalizeSeedGauge(INIT_BEAN_TO_MAX_LP_GP_RATIO, INIT_AVG_GSPBDV);
 339 |     | 
 340 | *   |         Gauge memory cultivationFactorGauge = Gauge(
 341 | *   |             abi.encode(INIT_CULTIVATION_FACTOR),
 342 | *   |             address(this),
 343 | *   |             IGaugeFacet.cultivationFactor.selector,
 344 | *   |             abi.encode(
 345 |     |                 MIN_DELTA_CULTIVATION_FACTOR,
 346 |     |                 MAX_DELTA_CULTIVATION_FACTOR,
 347 |     |                 MIN_CULTIVATION_FACTOR,
 348 |     |                 MAX_CULTIVATION_FACTOR
 349 |     |             )
 350 |     |         );
 351 | *   |         LibGaugeHelpers.addGauge(GaugeId.CULTIVATION_FACTOR, cultivationFactorGauge);
 352 |     | 
 353 | *   |         Gauge memory convertDownPenaltyGauge = Gauge(
 354 | *   |             abi.encode(INIT_CONVERT_DOWN_PENALTY_RATIO, INIT_ROLLING_SEASONS_ABOVE_PEG),
 355 | *   |             address(this),
 356 | *   |             IGaugeFacet.convertDownPenaltyGauge.selector,
 357 | *   |             abi.encode(ROLLING_SEASONS_ABOVE_PEG_RATE, ROLLING_SEASONS_ABOVE_PEG_CAP)
 358 |     |         );
 359 | *   |         LibGaugeHelpers.addGauge(GaugeId.CONVERT_DOWN_PENALTY, convertDownPenaltyGauge);
 360 |     |     }
 361 |     | }
 362 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/init/newInitDiamond.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {InitalizeDiamond} from "contracts/beanstalk/init/InitalizeDiamond.sol";
  8 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title InitDiamond
 12 |     |  * @notice InitDiamond initializes the Beanstalk Diamond.
 13 |     |  * A new bean token and bean:TOKEN well are deployed.
 14 |     |  *
 15 |     |  **/
 16 |     | contract InitDiamond is InitalizeDiamond {
 17 |     |     // Tokens
 18 |     |     address internal constant BEAN = address(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab);
 19 |     |     address internal constant BEAN_ETH_WELL = address(0xBEA0e11282e2bB5893bEcE110cF199501e872bAd);
 20 |     | 
 21 |     |     // initial reward for deploying beanstalk.
 22 |     |     uint256 internal constant INIT_SUPPLY = 100e6;
 23 |     | 
 24 |     |     function init() external {
 25 |     |         initalizeDiamond(BEAN, BEAN_ETH_WELL);
 26 |     | 
 27 |     |         BeanstalkERC20(BEAN).mint(msg.sender, INIT_SUPPLY);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/storage/Account.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | import {GerminationSide} from "./System.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title Account
  10 |     |  * @notice Stores Farmer-level Beanstalk state.
  11 |     |  * @param roots A Farmer's Root balance.
  12 |     |  * @param stalk Balance of the Farmer's Stalk.
  13 |     |  * @param lastUpdate The Season in which the Farmer last updated their Silo.
  14 |     |  * @param lastSop The last Season that a SOP occurred at the time the Farmer last updated their Silo.
  15 |     |  * @param lastRain The last Season that it started Raining at the time the Farmer last updated their Silo.
  16 |     |  * @param _buffer_0 Reserved storage for future additions.
  17 |     |  * @param deposits A mapping from depositId to Deposit.
  18 |     |  * @param depositIdList DepositListData for each token owned by the account.
  19 |     |  * @param field A mapping from FieldId to a Farmer's Field storage.
  20 |     |  * @param depositAllowances A mapping of `spender => Silo token address => amount`.
  21 |     |  * @param tokenAllowances Internal balance token allowances.
  22 |     |  * @param mowStatuses A mapping of whitelisted token address to MowStatus.
  23 |     |  * @param isApprovedForAll A mapping of ERC1155 operator to approved status. ERC1155 compatability.
  24 |     |  * @param germinatingStalk A Farmer's germinating stalk. Separated into odd and even stalk.
  25 |     |  * @param internalTokenBalance A mapping from Token address to Internal Balance. It stores the amount of the Token that the Farmer has stored as an Internal Balance in Beanstalk.
  26 |     |  * @param _buffer_1 Reserved storage for future additions.
  27 |     |  * @param silo A Farmer's Silo storage.
  28 |     |  * @param sop A Farmer's Season of Plenty storage.
  29 |     |  */
  30 |     | struct Account {
  31 |     |     uint256 roots;
  32 |     |     uint256 stalk;
  33 |     |     uint32 lastUpdate;
  34 |     |     uint32 lastSop;
  35 |     |     uint32 lastRain;
  36 |     |     bytes32[16] _buffer_0;
  37 |     |     mapping(uint256 => Deposit) deposits;
  38 |     |     mapping(address => DepositListData) depositIdList;
  39 |     |     mapping(uint256 => Field) fields;
  40 |     |     mapping(address => mapping(address => uint256)) depositAllowances;
  41 |     |     mapping(address => mapping(IERC20 => uint256)) tokenAllowances;
  42 |     |     mapping(address => MowStatus) mowStatuses;
  43 |     |     mapping(address => bool) isApprovedForAll;
  44 |     |     mapping(GerminationSide => uint128) germinatingStalk;
  45 |     |     mapping(IERC20 => uint256) internalTokenBalance;
  46 |     |     bytes32[16] _buffer_1;
  47 |     |     SeasonOfPlenty sop;
  48 |     | }
  49 |     | 
  50 |     | /**
  51 |     |  * @notice Stores a Farmer's Plots and Pod allowances.
  52 |     |  * @param plots A Farmer's Plots. Maps from Plot index to Pod amount.
  53 |     |  * @param podAllowances An allowance mapping for Pods similar to that of the ERC-20 standard. Maps from spender address to allowance amount.
  54 |     |  * @param plotIndexes An array of Plot indexes. Used to return the farm plots of a Farmer.
  55 |     |  * @param piIndex A mapping from Plot index to the index in plotIndexes.
  56 |     |  * @param _buffer Reserved storage for future additions.
  57 |     |  */
  58 |     | struct Field {
  59 |     |     mapping(uint256 => uint256) plots;
  60 |     |     mapping(address => uint256) podAllowances;
  61 |     |     uint256[] plotIndexes;
  62 |     |     mapping(uint256 => uint256) piIndex;
  63 |     |     bytes32[4] _buffer;
  64 |     | }
  65 |     | 
  66 |     | /**
  67 |     |  * @notice Stores a Farmer's Season of Plenty (SOP) balances.
  68 |     |  * @param roots The number of Roots a Farmer had when it started Raining.
  69 |     |  * @param plentyPerRoot The global Plenty Per Root index at the last time a Farmer updated their Silo.
  70 |     |  * @param plenty The balance of a Farmer's plenty. Plenty can be claimed directly for tokens.
  71 |     |  * @param _buffer Reserved storage for future additions.
  72 |     |  */
  73 |     | struct SeasonOfPlenty {
  74 |     |     uint256 rainRoots; // The number of Roots a Farmer had when it started Raining.
  75 |     |     mapping(address => PerWellPlenty) perWellPlenty; // a mapping from well to plentyPerRoot and plenty.
  76 |     |     bytes32[4] _buffer;
  77 |     | }
  78 |     | 
  79 |     | /**
  80 |     |  * @notice Stores a Farmer's Season of Plenty (SOP) balances.
  81 |     |  * @param plentyPerRoot The Plenty Per Root index for this well at the last time a Farmer updated their Silo.
  82 |     |  * @param plenty The balance of a Farmer's plenty. Plenty can be claimed directly for the well's non-Bean token.
  83 |     |  */
  84 |     | struct PerWellPlenty {
  85 |     |     uint256 plentyPerRoot;
  86 |     |     uint256 plenty;
  87 |     |     bytes32[4] _buffer;
  88 |     | }
  89 |     | 
  90 |     | /**
  91 |     |  * @notice Represents a Deposit of a given Token in the Silo at a given Season.
  92 |     |  * @param amount The amount of Tokens in the Deposit.
  93 |     |  * @param bdv The Bean-denominated value of the total amount of Tokens in the Deposit.
  94 |     |  * @param _buffer Reserved storage for future additions.
  95 |     |  * @dev `amount` and `bdv` are packed as uint128 to save gas.
  96 |     |  */
  97 |     | struct Deposit {
  98 |     |     uint128 amount;
  99 |     |     uint128 bdv;
 100 |     | }
 101 |     | 
 102 |     | /**
 103 |     |  * @notice Stores a Farmer's germinating stalk.
 104 |     |  * @param odd - stalk from assets deposited in odd seasons.
 105 |     |  * @param even - stalk from assets deposited in even seasons.
 106 |     |  * @param _buffer Reserved storage for future additions.
 107 |     |  */
 108 |     | struct GerminatingStalk {
 109 |     |     uint128 odd;
 110 |     |     uint128 even;
 111 |     | }
 112 |     | 
 113 |     | /**
 114 |     |  * @notice This struct stores the mow status for each whitelisted token, for each farmer.
 115 |     |  * This gets updated each time a farmer mows, or adds/removes deposits.
 116 |     |  * @param lastStem The last cumulative grown stalk per bdv index at which the farmer mowed.
 117 |     |  * @param bdv The bdv of all of a farmer's deposits of this token type.
 118 |     |  * @param _buffer Reserved storage for future additions.
 119 |     |  */
 120 |     | struct MowStatus {
 121 |     |     int96 lastStem;
 122 |     |     uint128 bdv;
 123 |     | }
 124 |     | 
 125 |     | /**
 126 |     |  * @notice This struct stores data for a deposit list for a given token.
 127 |     |  * a mapping from id to index was created to allow for O(1) retrieval of a deposit from the list.
 128 |     |  * @param depositIds An array of depositIds for a given token.
 129 |     |  * @param idIndex A mapping from depositId to index in depositIds.
 130 |     |  */
 131 |     | struct DepositListData {
 132 |     |     uint256[] depositIds;
 133 |     |     mapping(uint256 => uint256) idIndex;
 134 |     | }
 135 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/storage/AppStorage.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {Account} from "./Account.sol";
  6 |     | import {System} from "./System.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title AppStorage
 10 |     |  * @dev The Beanstalk diamond uses an AppStorage system that shares state across all facets.
 11 |     |  * @dev https://dev.to/mudgen/appstorage-pattern-for-state-variables-in-solidity-3lki
 12 |     |  */
 13 |     | 
 14 |     | /**
 15 |     |  * @title AppStorage
 16 |     |  * @notice Contains all state for the Beanstalk Diamond.
 17 |     |  * @param sys Contains shared state of the system as a whole.
 18 |     |  * @param accts Contains state of individual users.
 19 |     |  */
 20 |     | struct AppStorage {
 21 |     |     mapping(address => Account) accts;
 22 |     |     System sys;
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/beanstalk/storage/System.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title System
   9 |     |  * @notice Stores system-level Beanstalk state.
  10 |     |  * @param paused True if Beanstalk is Paused.
  11 |     |  * @param pausedAt The timestamp at which Beanstalk was last paused.
  12 |     |  * @param reentrantStatus An intra-transaction state variable to protect against reentrance.
  13 |     |  * @param farmingStatus Stores whether the function call originated in a Farm-like transaction - Farm, Tractor, PipelineConvert, etc.
  14 |     |  * @param ownerCandidate Stores a candidate address to transfer ownership to. The owner must claim the ownership transfer.
  15 |     |  * @param plenty The amount of plenty token held by the contract.
  16 |     |  * @param soil The number of Soil currently available. Adjusted during {Sun.stepSun}.
  17 |     |  * @param beanSown The number of Bean sown within the current Season. Reset during {Weather.calcCaseId}.
  18 |     |  * @param activeField ID of the active Field.
  19 |     |  * @param fieldCount Number of Fields that have ever been initialized.
  20 |     |  * @param orderLockedBeans The number of Beans locked in Pod Orders.
  21 |     |  * @param _buffer_0 Reserved storage for future additions.
  22 |     |  * @param podListings A mapping from fieldId to index to hash of Listing.
  23 |     |  * @param podOrders A mapping from the hash of a Pod Order to the amount of Pods that the Pod Order is still willing to buy.
  24 |     |  * @param internalTokenBalanceTotal Sum of all users internalTokenBalance.
  25 |     |  * @param wellOracleSnapshots A mapping from Well Oracle address to the Well Oracle Snapshot.
  26 |     |  * @param twaReserves A mapping from well to its twaReserves. Stores twaReserves during the sunrise function. Returns 1 otherwise for each asset. Currently supports 2 token wells.
  27 |     |  * @param usdTokenPrice A mapping from token address to usd price.
  28 |     |  * @param sops A mapping from Season to Plenty Per Root (PPR) in that Season. Plenty Per Root is 0 if a Season of Plenty did not occur.
  29 |     |  * @param fields mapping of Field ID to Storage.Field.
  30 |     |  * @param convertCapacity A mapping from block number to the amount of Beans that can be converted towards peg in this block before stalk penalty becomes applied.
  31 |     |  * @param oracleImplementation A mapping from token to its oracle implementation.
  32 |     |  * @param shipmentRoutes Define the distribution of newly minted Beans.
  33 |     |  * @param _buffer_1 Reserved storage for future additions.
  34 |     |  * @param casesV2 Stores the 144 Weather and seedGauge cases.
  35 |     |  * @param silo See {Silo}.
  36 |     |  * @param season See {Season}.
  37 |     |  * @param weather See {Weather}.
  38 |     |  * @param seedGauge Stores the seedGauge.
  39 |     |  * @param rain See {Rain}.
  40 |     |  * @param evaluationParameters See {EvaluationParameters}.
  41 |     |  * @param sop See {SeasonOfPlenty}.
  42 |     |  * @param gauges See {Gauge}.
  43 |     |  */
  44 |     | struct System {
  45 |     |     address bean;
  46 |     |     bool paused;
  47 |     |     uint128 pausedAt;
  48 |     |     uint256 reentrantStatus;
  49 |     |     uint256 farmingStatus;
  50 |     |     address ownerCandidate;
  51 |     |     uint128 soil;
  52 |     |     uint128 beanSown;
  53 |     |     uint256 activeField;
  54 |     |     uint256 fieldCount;
  55 |     |     uint256 orderLockedBeans;
  56 |     |     bytes32[16] _buffer_0;
  57 |     |     mapping(uint256 => mapping(uint256 => bytes32)) podListings;
  58 |     |     mapping(bytes32 => uint256) podOrders;
  59 |     |     mapping(IERC20 => uint256) internalTokenBalanceTotal;
  60 |     |     mapping(address => bytes) wellOracleSnapshots;
  61 |     |     mapping(address => TwaReserves) twaReserves;
  62 |     |     mapping(address => uint256) usdTokenPrice;
  63 |     |     mapping(uint256 => Field) fields;
  64 |     |     mapping(uint256 => ConvertCapacity) convertCapacity;
  65 |     |     mapping(address => Implementation) oracleImplementation;
  66 |     |     ShipmentRoute[] shipmentRoutes;
  67 |     |     bytes32[16] _buffer_1;
  68 |     |     bytes32[144] casesV2;
  69 |     |     Silo silo;
  70 |     |     Season season;
  71 |     |     Weather weather;
  72 |     |     SeedGauge seedGauge;
  73 |     |     Rain rain;
  74 |     |     EvaluationParameters evaluationParameters;
  75 |     |     SeasonOfPlenty sop;
  76 |     |     ExtEvaluationParameters extEvaluationParameters;
  77 |     |     GaugeData gaugeData;
  78 |     |     // A buffer is not included here, bc current layout of AppStorage makes it unnecessary.
  79 |     | }
  80 |     | 
  81 |     | /**
  82 |     |  * @notice System-level Silo state variables.
  83 |     |  * @param stalk The total amount of active Stalk (including Earned Stalk, excluding Grown Stalk).
  84 |     |  * @param roots The total amount of Roots.
  85 |     |  * @param earnedBeans The number of Beans distributed to the Silo that have not yet been Deposited as a result of the Earn function being called.
  86 |     |  * @param balances A mapping from Token address to Silo Balance storage (amount deposited and withdrawn).
  87 |     |  * @param assetSettings A mapping from Token address to Silo Settings for each Whitelisted Token. If a non-zero storage exists, a Token is whitelisted.
  88 |     |  * @param whitelistStatuses Stores a list of Whitelist Statues for all tokens that have been Whitelisted and have not had their Whitelist Status manually removed.
  89 |     |  * @param germinating Mapping from odd/even to token to germinating deposits data.
  90 |     |  * @param unclaimedGerminating A mapping from season to object containing the stalk and roots that are germinating.
  91 |     |  * @param _buffer Reserved storage for future expansion.
  92 |     |  */
  93 |     | struct Silo {
  94 |     |     uint256 stalk;
  95 |     |     uint256 roots;
  96 |     |     uint256 earnedBeans;
  97 |     |     mapping(address => AssetSilo) balances;
  98 |     |     mapping(address => AssetSettings) assetSettings;
  99 |     |     WhitelistStatus[] whitelistStatuses;
 100 |     |     mapping(GerminationSide => mapping(address => Deposited)) germinating;
 101 |     |     mapping(uint32 => GerminatingSilo) unclaimedGerminating;
 102 |     |     bytes32[8] _buffer;
 103 |     | }
 104 |     | 
 105 |     | /**
 106 |     |  * @notice System-level Field state variables.
 107 |     |  * @param pods The pod index; the total number of Pods ever minted.
 108 |     |  * @param harvested The harvested index; the total number of Pods that have ever been Harvested.
 109 |     |  * @param harvestable The harvestable index; the total number of Pods that have ever been Harvestable. Included previously Harvested Beans.
 110 |     |  * @param _buffer Reserved storage for future expansion.
 111 |     |  */
 112 |     | struct Field {
 113 |     |     uint256 pods;
 114 |     |     uint256 harvested;
 115 |     |     uint256 harvestable;
 116 |     |     bytes32[8] _buffer;
 117 |     | }
 118 |     | 
 119 |     | /**
 120 |     |  * @notice System-level Season state variables.
 121 |     |  * @param current The current Season in Beanstalk.
 122 |     |  * @param lastSop The Season in which the most recent consecutive series of Seasons of Plenty started.
 123 |     |  * @param lastSopSeason The Season in which the most recent consecutive series of Seasons of Plenty ended.
 124 |     |  * @param rainStart Stores the most recent Season in which Rain started.
 125 |     |  * @param raining True if it is Raining (P > 1, Pod Rate Excessively Low).
 126 |     |  * @param sunriseBlock The block of the start of the current Season.
 127 |     |  * @param abovePeg Boolean indicating whether the previous Season was above or below peg.
 128 |     |  * @param start The timestamp of the Beanstalk deployment rounded down to the nearest hour.
 129 |     |  * @param period The length of each season in Beanstalk in seconds.
 130 |     |  * @param timestamp The timestamp of the start of the current Season.
 131 |     |  * @param standardMintedBeans The number of Beans minted this season, excluding flood.
 132 |     |  * @param _buffer Reserved storage for future expansion.
 133 |     |  */
 134 |     | struct Season {
 135 |     |     uint32 current;
 136 |     |     uint32 lastSop;
 137 |     |     uint32 lastSopSeason;
 138 |     |     uint32 rainStart;
 139 |     |     bool raining;
 140 |     |     uint64 sunriseBlock;
 141 |     |     bool abovePeg;
 142 |     |     uint256 start;
 143 |     |     uint256 period;
 144 |     |     uint256 timestamp;
 145 |     |     uint256 standardMintedBeans;
 146 |     |     bytes32[8] _buffer;
 147 |     | }
 148 |     | 
 149 |     | /**
 150 |     |  * @notice System-level Weather state variables.
 151 |     |  * @param lastDeltaSoil Delta Soil; the number of Soil purchased last Season.
 152 |     |  * @param lastSowTime The number of seconds it took for Soil to sell out last Season.
 153 |     |  * @param thisSowTime The number of seconds it took for Soil to sell out this Season.
 154 |     |  * @param temp Temperature is max interest rate in current Season for sowing Beans in Soil. Adjusted each Season.
 155 |     |  * @param _buffer Reserved storage for future expansion.
 156 |     |  */
 157 |     | struct Weather {
 158 |     |     uint128 lastDeltaSoil; // ───┐ 16 (16)
 159 |     |     uint32 lastSowTime; //       │ 4  (20)
 160 |     |     uint32 thisSowTime; //       │ 4  (24)
 161 |     |     uint32 temp; // ─────────────┘ 4  (28/32)
 162 |     |     bytes32[4] _buffer;
 163 |     | }
 164 |     | 
 165 |     | /**
 166 |     |  * @notice System level variables used in the seed Gauge
 167 |     |  * @param averageGrownStalkPerBdvPerSeason The average Grown Stalk Per BDV
 168 |     |  * that beanstalk issues each season.
 169 |     |  * @param beanToMaxLpGpPerBdvRatio a scalar of the gauge points(GP) per bdv
 170 |     |  * issued to the largest LP share and Bean. 6 decimal precision.
 171 |     |  * @param avgGsPerBdvFlag update the average grown stalk per bdv per season, if true.
 172 |     |  * @param _buffer Reserved storage for future expansion.
 173 |     |  * @dev a beanToMaxLpGpPerBdvRatio of 0 means LP should be incentivized the most,
 174 |     |  * and that beans will have the minimum seeds ratio. see {LibGauge.getBeanToMaxLpGpPerBdvRatioScaled}
 175 |     |  */
 176 |     | struct SeedGauge {
 177 |     |     uint128 averageGrownStalkPerBdvPerSeason;
 178 |     |     uint128 beanToMaxLpGpPerBdvRatio;
 179 |     |     bool avgGsPerBdvFlag;
 180 |     |     bytes32[4] _buffer;
 181 |     | }
 182 |     | 
 183 |     | /**
 184 |     |  * @notice System-level Rain balances. Rain occurs when P > 1 and the Pod Rate Excessively Low.
 185 |     |  * @param pods The number of Pods when it last started Raining.
 186 |     |  * @param roots The number of Roots when it last started Raining.
 187 |     |  * @param _buffer Reserved storage for future expansion.
 188 |     |  */
 189 |     | struct Rain {
 190 |     |     uint256 pods;
 191 |     |     uint256 roots;
 192 |     |     uint128 floodHarvestablePods;
 193 |     |     bytes32[3] _buffer;
 194 |     | }
 195 |     | 
 196 |     | /**
 197 |     |  * @notice System-level Silo state; contains deposit and withdrawal data for a particular whitelisted Token.
 198 |     |  * @param deposited The total amount of this Token currently Deposited in the Silo.
 199 |     |  * @param depositedBdv The total bdv of this Token currently Deposited in the Silo.
 200 |     |  * @dev {State} contains a mapping from Token address => AssetSilo.
 201 |     |  * Currently, the bdv of deposits are asynchronous, and require an on-chain transaction to update.
 202 |     |  * Thus, the total bdv of deposits cannot be calculated, and must be stored and updated upon a bdv change.
 203 |     |  */
 204 |     | struct AssetSilo {
 205 |     |     uint128 deposited;
 206 |     |     uint128 depositedBdv;
 207 |     | }
 208 |     | 
 209 |     | /**
 210 |     |  * @notice Whitelist Status a token that has been Whitelisted before.
 211 |     |  * @param token the address of the token.
 212 |     |  * @param isWhitelisted whether the address is whitelisted.
 213 |     |  * @param isWhitelistedLp whether the address is a whitelisted LP token.
 214 |     |  * @param isWhitelistedWell whether the address is a whitelisted Well token.
 215 |     |  */
 216 |     | 
 217 |     | struct WhitelistStatus {
 218 |     |     address token;
 219 |     |     bool isWhitelisted;
 220 |     |     bool isWhitelistedLp;
 221 |     |     bool isWhitelistedWell;
 222 |     |     bool isSoppable;
 223 |     | }
 224 |     | 
 225 |     | /**
 226 |     |  * @notice Describes the settings for each Token that is Whitelisted in the Silo.
 227 |     |  * @param selector The encoded BDV function selector for the token that pertains to
 228 |     |  * an external view Beanstalk function with the following signature:
 229 |     |  * ```
 230 |     |  * function tokenToBdv(uint256 amount) external view returns (uint256);
 231 |     |  * ```
 232 |     |  * It is called by `LibTokenSilo` through the use of `delegatecall`
 233 |     |  * to calculate a token's BDV at the time of Deposit.
 234 |     |  * @param stalkEarnedPerSeason represents how much Stalk one BDV of the underlying deposited token
 235 |     |  * grows each season. In the past, this was represented by seeds. 6 decimal precision.
 236 |     |  * @param stalkIssuedPerBdv The Stalk Per BDV that the Silo grants in exchange for Depositing this Token.
 237 |     |  * previously called stalk.
 238 |     |  * @param milestoneSeason The last season in which the stalkEarnedPerSeason for this token was updated.
 239 |     |  * @param milestoneStem The cumulative amount of grown stalk per BDV for this token at the last stalkEarnedPerSeason update.
 240 |     |  * @param encodeType determine the encoding type of the selector.
 241 |     |  * a encodeType of 0x00 means the selector takes an input amount.
 242 |     |  * 0x01 means the selector takes an input amount and a token.
 243 |     |  * @param gpSelector The encoded gaugePoint function selector for the token that pertains to
 244 |     |  * an external view Beanstalk function with the following signature:
 245 |     |  * ```
 246 |     |  * function gaugePoints(
 247 |     |  *  uint256 currentGaugePoints,
 248 |     |  *  uint256 optimalPercentDepositedBdv,
 249 |     |  *  uint256 percentOfDepositedBdv
 250 |     |  *  bytes data
 251 |     |  *  ) external view returns (uint256);
 252 |     |  * ```
 253 |     |  * @param lwSelector The encoded liquidityWeight function selector for the token that pertains to
 254 |     |  * an external view Beanstalk function with the following signature `function liquidityWeight(bytes)`
 255 |     |  * @param gaugePoints the amount of Gauge points this LP token has in the LP Gauge. Only used for LP whitelisted assets.
 256 |     |  * GaugePoints has 18 decimal point precision (1 Gauge point = 1e18).
 257 |     |  * @param optimalPercentDepositedBdv The target percentage of the total LP deposited BDV for this token. 6 decimal precision.
 258 |     |  * @param gaugePointImplementation The implementation for the gauge points. Supports encodeType 0 and 1.
 259 |     |  * @param liquidityWeightImplementation The implementation for the liquidity weight.
 260 |     |  * @dev A Token is considered Whitelisted if there exists a non-zero {AssetSettings} selector.
 261 |     |  */
 262 |     | struct AssetSettings {
 263 |     |     bytes4 selector; // ────────────────────┐ 4
 264 |     |     uint40 stalkEarnedPerSeason; //         │ 5  (9)
 265 |     |     uint48 stalkIssuedPerBdv; //            │ 6  (15)
 266 |     |     uint32 milestoneSeason; //              │ 4  (19)
 267 |     |     int96 milestoneStem; //                 │ 12 (31)
 268 |     |     bytes1 encodeType; //                 ──┘ 1  (32)
 269 |     |     int40 deltaStalkEarnedPerSeason; // ────┐ 5
 270 |     |     uint128 gaugePoints; //                 │ 16 (21)
 271 |     |     uint64 optimalPercentDepositedBdv; //   │ 8  (29)
 272 |     |     // 3 bytes are left here.             ──┘ 3  (32)
 273 |     |     Implementation gaugePointImplementation;
 274 |     |     Implementation liquidityWeightImplementation;
 275 |     | }
 276 |     | 
 277 |     | /**
 278 |     |  * @notice Stores the twaReserves for each well during the sunrise function.
 279 |     |  */
 280 |     | struct TwaReserves {
 281 |     |     uint128 reserve0;
 282 |     |     uint128 reserve1;
 283 |     | }
 284 |     | 
 285 |     | /**
 286 |     |  * @notice Stores the total germination amounts for each whitelisted token.
 287 |     |  */
 288 |     | struct Deposited {
 289 |     |     uint128 amount;
 290 |     |     uint128 bdv;
 291 |     | }
 292 |     | 
 293 |     | /**
 294 |     |  * @notice Stores convert capacity data for a given block.
 295 |     |  * @param overallConvertCapacityUsed The amount of overall deltaB that can be converted towards peg within a block.
 296 |     |  * @param wellConvertCapacityUsed A mapping from well to the amount of deltaB
 297 |     |  * that can be converted in the given block.
 298 |     |  */
 299 |     | struct ConvertCapacity {
 300 |     |     uint256 overallConvertCapacityUsed;
 301 |     |     mapping(address => uint256) wellConvertCapacityUsed;
 302 |     | }
 303 |     | 
 304 |     | /**
 305 |     |  * @notice Stores the system level germination Silo data.
 306 |     |  */
 307 |     | struct GerminatingSilo {
 308 |     |     uint256 stalk;
 309 |     |     uint256 roots;
 310 |     | }
 311 |     | 
 312 |     | /**
 313 |     |  * @param planContract The address of the contract containing the plan getter view function.
 314 |     |  * @param planSelector The selector of the plan getter view function.
 315 |     |  * @param recipient The recipient enum of the shipment.
 316 |     |  * @param data The data to be passed to both the plan getter function and the receive function.
 317 |     |  */
 318 |     | struct ShipmentRoute {
 319 |     |     address planContract;
 320 |     |     bytes4 planSelector;
 321 |     |     ShipmentRecipient recipient;
 322 |     |     bytes data;
 323 |     | }
 324 |     | 
 325 |     | /**
 326 |     |  * @notice contains data in order for beanstalk to call a function with a specific selector.
 327 |     |  * @param target The address of the implementation.
 328 |     |  * @param selector The function selector that is used to call on the implementation.
 329 |     |  * @param encodeType The encode type that should be used to encode the function call.
 330 |     |  * The encodeType value depends on the context of each implementation.
 331 |     |  * @param data Any additional data, for example timeout
 332 |     |  * @dev assumes all future implementations will use the same parameters as the beanstalk
 333 |     |  * gaugePoint and liquidityWeight implementations.
 334 |     |  */
 335 |     | struct Implementation {
 336 |     |     address target; // 20 bytes
 337 |     |     bytes4 selector;
 338 |     |     bytes1 encodeType;
 339 |     |     bytes data;
 340 |     | }
 341 |     | 
 342 |     | struct GaugeData {
 343 |     |     GaugeId[] gaugeIds;
 344 |     |     mapping(GaugeId => Gauge) gauges;
 345 |     | }
 346 |     | 
 347 |     | /**
 348 |     |  * @notice Gauge is a generic struct that contains the logic for a "gauge".
 349 |     |  * A "gauge" updates a `value` based on some data and its implementation.
 350 |     |  * Any parameter that changes as a function of other parameters can be implemented as a gauge.
 351 |     |  * @param value value(s) being controlled by the gauge. Can be multiple values.
 352 |     |  * @param target The address in which `selector` is called at.
 353 |     |  * @param selector The logic that changes the gauge value.
 354 |     |  * @param data Additional data that the gauge may utilize.
 355 |     |  */
 356 |     | struct Gauge {
 357 |     |     bytes value;
 358 |     |     address target;
 359 |     |     bytes4 selector;
 360 |     |     bytes data;
 361 |     | }
 362 |     | 
 363 |     | /**
 364 |     |  * @notice Evaluation parameters used to determine the state of Beanstalk.
 365 |     |  * Used as hyperparameters in many aspects of the protocol, incluing the SeedGauge.
 366 |     |  * --------------------------------------------------------------
 367 |     |  * @param maxBeanMaxLpGpPerBdvRatio The maximum allowed ratio of the Seeds per BDV reward between
 368 |     |  * Deposited Bean and the Deposited LP token with the most Seeds.
 369 |     |  * --------------------------------------------------------------
 370 |     |  * @param minBeanMaxLpGpPerBdvRatio The minimum allowed ratio of the Seeds per BDV reward between
 371 |     |  * Deposited Bean and the Deposited LP token with the most Seeds.
 372 |     |  * --------------------------------------------------------------
 373 |     |  * @param targetSeasonsToCatchUp Determines the target number of Seasons for a new Deposit with
 374 |     |  * an average number of Seeds to catch up to the average Grown Stalk per BDV of existing Deposits
 375 |     |  * at the time of Deposit.
 376 |     |  * --------------------------------------------------------------
 377 |     |  * @dev podRate = The protocol debt level (Pod supply) relative to the Pinto supply.
 378 |     |  * L2SR = the protocol liquidity level relative to the bean supply.
 379 |     |  * Both metrics are used as a proxy of the protocol's health.
 380 |     |  * The protocol differentiates between the following 5 states of podRate and L2SR for various evaluations:
 381 |     |  * - Excessively low podRate/L2SR.
 382 |     |  * - Reasonably low podRate/L2SR.
 383 |     |  * - Optimal podRate/L2SR.
 384 |     |  * - Reasonably high podRate/L2SR.
 385 |     |  * - Excessively high podRate/L2SR.
 386 |     |  * The parameters below are used to mark the boundaries between these states.
 387 |     |  * --------------------------------------------------------------
 388 |     |  * @param podRateLowerBound The lower bound of the pod rate.
 389 |     |  * @param podRateOptimal The optimal pod rate.
 390 |     |  * @param podRateUpperBound The upper bound of the pod rate.
 391 |     |  * --------------------------------------------------------------
 392 |     |  * @dev Contrary to podRate and L2SR, there is no delta pod demand that is considered optimal.
 393 |     |  * @param deltaPodDemandLowerBound The lower bound of the delta pod demand.
 394 |     |  * @param deltaPodDemandUpperBound The upper bound of the delta pod demand.
 395 |     |  * --------------------------------------------------------------
 396 |     |  * @param lpToSupplyRatioUpperBound The upper bound of the LP to supply ratio.
 397 |     |  * @param lpToSupplyRatioOptimal The optimal LP to supply ratio.
 398 |     |  * @param lpToSupplyRatioLowerBound The lower bound of the LP to supply ratio.
 399 |     |  * ----------------------------------------------------------------
 400 |     |  * @param excessivePriceThreshold The threshold after which the price of bean is considered excessive.
 401 |     |  * Referenced as Q in the Beanstalk whitepaper. Used to make adjustments in protocol cases.
 402 |     |  * See {LibEvaluate.evaluateBeanstalk}, {LibCases.setCasesV2}.
 403 |     |  * --------------------------------------------------------------
 404 |     |  * @param soilCoefficientHigh The coefficient to scale soil by when
 405 |     |  * podRate > upperBound and beanstalk is above peg.
 406 |     |  * @param soilCoefficientLow The coefficient to scale soil by when
 407 |     |  * podRate < lowerBound and beanstalk is above peg.
 408 |     |  * --------------------------------------------------------------
 409 |     |  * @param baseReward The base reward for calling the sunrise function.
 410 |     |  * Used to calculate the sunrise incentive that increases as the season is delayed.
 411 |     |  * @param minAvgGsPerBdv The minimum average grown stalk per BDV.
 412 |     |  * Determines the floor for seeds of a whitelisted token.
 413 |     |  * @param rainingMinBeanMaxLpGpPerBdvRatio The minimum Bean Max LP GP per BDV ratio when
 414 |     |  * podRate is excessively low and P > 1.
 415 |     |  */
 416 |     | struct EvaluationParameters {
 417 |     |     uint256 maxBeanMaxLpGpPerBdvRatio;
 418 |     |     uint256 minBeanMaxLpGpPerBdvRatio;
 419 |     |     uint256 targetSeasonsToCatchUp;
 420 |     |     uint256 podRateLowerBound;
 421 |     |     uint256 podRateOptimal;
 422 |     |     uint256 podRateUpperBound;
 423 |     |     uint256 deltaPodDemandLowerBound;
 424 |     |     uint256 deltaPodDemandUpperBound;
 425 |     |     uint256 lpToSupplyRatioUpperBound;
 426 |     |     uint256 lpToSupplyRatioOptimal;
 427 |     |     uint256 lpToSupplyRatioLowerBound;
 428 |     |     uint256 excessivePriceThreshold;
 429 |     |     uint256 soilCoefficientHigh;
 430 |     |     uint256 soilCoefficientLow;
 431 |     |     uint256 baseReward;
 432 |     |     uint128 minAvgGsPerBdv;
 433 |     |     uint128 rainingMinBeanMaxLpGpPerBdvRatio;
 434 |     | }
 435 |     | 
 436 |     | /**
 437 |     |  * @notice Extended evaluation parameters.
 438 |     |  * @param belowPegSoilL2SRScalar The amount to scale L2SR by when adjusting soil below peg.
 439 |     |  * @param soilCoefficientRelativelyHigh The coefficient to scale soil by when
 440 |     |  * optimal <= podRate < upperBound and beanstalk is above peg.
 441 |     |  * @param soilCoefficientRelativelyLow The coefficient to scale soil by when
 442 |     |  * lowerBound <= podRate < optimal and beanstalk is above peg.
 443 |     |  * @param abovePegDeltaBSoilScalar The scalar for the time weighted average deltaB when
 444 |     |  * twaDeltaB is negative but beanstalk ended the season above peg.
 445 |     |  * @param soilDistributionPeriod The target period (in seconds) over which to distribute soil (e.g., 24*60*60 for 24 hours).
 446 |     |  * @param minSoilIssuance The minimum amount of soil to issue in a season when below peg.
 447 |     |  * @param minSoilSownDemand The minimum amount of soil that must be sown in a season for demand to be measured.
 448 |     |  * @param buffer The buffer for future evaluation parameters.
 449 |     |  */
 450 |     | struct ExtEvaluationParameters {
 451 |     |     uint256 belowPegSoilL2SRScalar;
 452 |     |     uint256 soilCoefficientRelativelyHigh;
 453 |     |     uint256 soilCoefficientRelativelyLow;
 454 |     |     uint256 abovePegDeltaBSoilScalar;
 455 |     |     uint256 soilDistributionPeriod;
 456 |     |     uint256 minSoilIssuance;
 457 |     |     uint256 minSoilSownDemand;
 458 |     |     bytes32[60] buffer;
 459 |     | }
 460 |     | 
 461 |     | /**
 462 |     |  * @param perWellPlenty A mapping from well amount of plenty (flooded tokens) per well
 463 |     |  * @param sops mapping of season to a mapping of wells to plentyPerRoot
 464 |     |  */
 465 |     | struct SeasonOfPlenty {
 466 |     |     mapping(address => uint256) plentyPerSopToken;
 467 |     |     mapping(uint32 => mapping(address => uint256)) sops;
 468 |     | }
 469 |     | 
 470 |     | /**
 471 |     |  * @notice Germinate determines what germination struct to use.
 472 |     |  * @dev "odd" and "even" refers to the value of the season counter.
 473 |     |  * "Odd" germinations are used when the season is odd, and vice versa.
 474 |     |  */
 475 |     | enum GerminationSide {
 476 |     |     ODD,
 477 |     |     EVEN,
 478 |     |     NOT_GERMINATING
 479 |     | }
 480 |     | 
 481 |     | /**
 482 |     |  * @notice Details which Beanstalk component receives the shipment.
 483 |     |  */
 484 |     | enum ShipmentRecipient {
 485 |     |     NULL,
 486 |     |     SILO,
 487 |     |     FIELD,
 488 |     |     INTERNAL_BALANCE,
 489 |     |     EXTERNAL_BALANCE
 490 |     | }
 491 |     | 
 492 |     | /**
 493 |     |  * @notice The id of the gauge. new gauges should be appended to the end of the enum.
 494 |     |  */
 495 |     | enum GaugeId {
 496 |     |     CULTIVATION_FACTOR,
 497 |     |     CONVERT_DOWN_PENALTY
 498 |     | }
 499 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/Drafter.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import {LibClipboard} from "contracts/libraries/LibClipboard.sol";
  5 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  6 |     | 
  7 | *   | contract Drafter {
  8 |     |     function encodeOperatorPasteInstr(
  9 |     |         uint80 _copyByteIndex,
 10 |     |         uint80 _pasteCallIndex,
 11 |     |         uint80 _pasteByteIndex
 12 |     |     ) external pure returns (bytes32) {
 13 |     |         return LibBytes.encode(_copyByteIndex, _pasteCallIndex, _pasteByteIndex);
 14 |     |     }
 15 |     | 
 16 |     |     function decodeOperatorPasteInstr(
 17 |     |         bytes32 operatorPasteInstr
 18 |     |     ) external pure returns (uint80, uint80, uint80) {
 19 |     |         return LibBytes.decode(operatorPasteInstr);
 20 |     |     }
 21 |     | 
 22 |     |     function encodeLibReturnPasteParam(
 23 |     |         uint80 _copyReturnIndex,
 24 |     |         uint80 _copyByteIndex,
 25 |     |         uint80 _pasteByteIndex
 26 |     |     ) external pure returns (bytes32) {
 27 |     |         return LibBytes.encode(_copyReturnIndex, _copyByteIndex, _pasteByteIndex);
 28 |     |     }
 29 |     | 
 30 |     |     function decodeLibReturnPasteParam(
 31 |     |         bytes32 returnPasteParam
 32 |     |     ) external pure returns (uint80, uint80, uint80) {
 33 |     |         return LibBytes.decode(returnPasteParam);
 34 |     |     }
 35 |     | 
 36 |     |     function encodeClipboard(
 37 |     |         uint256 etherValue,
 38 |     |         bytes32[] memory returnPasteParams
 39 |     |     ) external pure returns (bytes memory clipboard) {
 40 |     |         return LibClipboard.encode(etherValue, returnPasteParams);
 41 |     |     }
 42 |     | 
 43 |     |     function decodeClipboard(
 44 |     |         bytes memory clipboard
 45 |     |     ) public pure returns (bytes1 typeId, uint256 etherValue, bytes32[] memory returnPasteParams) {
 46 |     |         return LibClipboard.decode(clipboard);
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/GaugePriceThreshold.sol
   1 |     | /*
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {GaugeDefault} from "contracts/beanstalk/facets/sun/abstract/GaugeDefault.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title GaugePriceThreshold
  11 |     |  * @notice GaugePriceThreshold implements priceThresholdGaugePoints.
  12 |     |  * Falls back to GaugeDefault.defaultGaugePoints.
  13 |     |  * @dev Intended to be deployed externally with one contract per token.
  14 |     |  */
  15 |     | interface IBeanstalk {
  16 |     |     function getTokenUsdPrice(address) external view returns (uint256);
  17 |     | }
  18 |     | 
  19 |     | /**
  20 |     |  * @notice GaugePriceThreshold is an external contract for use with high risk assets.
  21 |     |  * @dev When the price of the asset is below a certain threshold, the gauge points
  22 |     |  * are set to a specified value. Can be used to set gauge points to 0 automatically
  23 |     |  * if price goes trends to 0, which prevents extreme point accumulation by users.
  24 |     |  */
  25 | *   | contract GaugePriceThreshold is GaugeDefault {
  26 |     |     address immutable beanstalk;
  27 |     |     address immutable token;
  28 |     |     uint256 immutable priceThreshold;
  29 |     |     uint256 immutable gaugePointsPrice;
  30 |     | 
  31 |     |     /**
  32 |     |      * @param _beanstalk The address of the Beanstalk contract.
  33 |     |      * @param _token The address of the token to check the price of.
  34 |     |      * @param _priceThreshold The price threshold to check against.
  35 |     |      * @param _gaugePointsPrice The gauge points price to return when the price is below the threshold.
  36 |     |      * @dev `priceThreshold` should have 6 decimal precision, regardless of token decimals.
  37 |     |      */
  38 | *   |     constructor(
  39 |     |         address _beanstalk,
  40 |     |         address _token,
  41 |     |         uint256 _priceThreshold,
  42 |     |         uint256 _gaugePointsPrice
  43 |     |     ) {
  44 | *   |         beanstalk = _beanstalk;
  45 | *   |         token = _token;
  46 | *   |         priceThreshold = _priceThreshold;
  47 | *   |         gaugePointsPrice = _gaugePointsPrice;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice priceThresholdGaugePoints
  52 |     |      * checks that the price of `token` is above `priceThreshold`.
  53 |     |      * When below the priceThreshold, the function returns the minimum of
  54 |     |      * `currentGaugepoints` and `gaugePointsPrice`.
  55 |     |      * Else, use the defaultGaugePoints implmentation defined in `GaugeDefault`.
  56 |     |      *
  57 |     |      * @dev `Price` is fetched from Beanstalk via {OracleFacet.getUsdPrice}. An instanteous Lookback
  58 |     |      * is used to get the most recent price from the Oracle.
  59 |     |      */
  60 |     |     function priceThresholdGaugePoints(
  61 |     |         uint256 currentGaugePoints,
  62 |     |         uint256 optimalPercentDepositedBdv,
  63 |     |         uint256 percentOfDepositedBdv,
  64 |     |         bytes memory data
  65 |     |     ) public view returns (uint256 newGaugePoints) {
  66 |     |         try IBeanstalk(beanstalk).getTokenUsdPrice(token) returns (uint256 price) {
  67 |     |             if (priceThreshold >= price) {
  68 |     |                 return
  69 |     |                     currentGaugePoints > gaugePointsPrice ? gaugePointsPrice : currentGaugePoints;
  70 |     |             } else {
  71 |     |                 return
  72 |     |                     defaultGaugePoints(
  73 |     |                         currentGaugePoints,
  74 |     |                         optimalPercentDepositedBdv,
  75 |     |                         percentOfDepositedBdv,
  76 |     |                         data
  77 |     |                     );
  78 |     |             }
  79 |     |         } catch {
  80 |     |             // If the price cannot be fetched, assume price manipulation.
  81 |     |             return currentGaugePoints > gaugePointsPrice ? gaugePointsPrice : currentGaugePoints;
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     function getBeanstalk() external view returns (address) {
  86 |     |         return beanstalk;
  87 |     |     }
  88 |     | 
  89 |     |     function getToken() external view returns (address) {
  90 |     |         return token;
  91 |     |     }
  92 |     | 
  93 |     |     function getPriceThreshold() external view returns (uint256) {
  94 |     |         return priceThreshold;
  95 |     |     }
  96 |     | 
  97 |     |     function getGaugePointsPrice() external view returns (uint256) {
  98 |     |         return gaugePointsPrice;
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/OperatorWhitelist.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title OperatorWhitelist
  8 |     |  * @author FordPinto
  9 |     |  * @notice Contract to manage a whitelist of operators
 10 |     |  */
 11 |     | 
 12 |     | interface IOperatorWhitelist {
 13 |     |     function addOperator(address operator) external;
 14 |     |     function removeOperator(address operator) external;
 15 |     |     function checkOperatorWhitelist(address operator) external view returns (bool);
 16 |     |     function getWhitelistedOperators() external view returns (address[] memory);
 17 |     | }
 18 |     | 
 19 | *   | contract OperatorWhitelist is Ownable, IOperatorWhitelist {
 20 |     |     // Mapping to track whitelisted operators
 21 |     |     mapping(address => bool) public whitelistedOperators;
 22 |     |     // Array to track all whitelisted operators for enumeration
 23 |     |     address[] private operators;
 24 |     | 
 25 |     |     event OperatorAdded(address indexed operator);
 26 |     |     event OperatorRemoved(address indexed operator);
 27 |     | 
 28 | *   |     constructor(address initialOwner) Ownable(initialOwner) {}
 29 |     | 
 30 |     |     /**
 31 |     |      * @notice Adds an operator to the whitelist
 32 |     |      * @param operator The address to add to the whitelist
 33 |     |      */
 34 |     |     function addOperator(address operator) external onlyOwner {
 35 |     |         require(operator != address(0), "Cannot whitelist zero address");
 36 |     |         require(!whitelistedOperators[operator], "Operator already whitelisted");
 37 |     | 
 38 |     |         whitelistedOperators[operator] = true;
 39 |     |         operators.push(operator);
 40 |     | 
 41 |     |         emit OperatorAdded(operator);
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @notice Removes an operator from the whitelist
 46 |     |      * @param operator The address to remove from the whitelist
 47 |     |      */
 48 |     |     function removeOperator(address operator) external onlyOwner {
 49 |     |         require(whitelistedOperators[operator], "Operator not whitelisted");
 50 |     | 
 51 |     |         whitelistedOperators[operator] = false;
 52 |     | 
 53 |     |         // Remove operator from array by swapping with last element and popping
 54 |     |         for (uint256 i = 0; i < operators.length; i++) {
 55 |     |             if (operators[i] == operator) {
 56 |     |                 operators[i] = operators[operators.length - 1];
 57 |     |                 operators.pop();
 58 |     |                 break;
 59 |     |             }
 60 |     |         }
 61 |     | 
 62 |     |         emit OperatorRemoved(operator);
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @notice Checks if an operator is whitelisted
 67 |     |      * @param operator The address to check
 68 |     |      * @return True if the operator is whitelisted, false otherwise
 69 |     |      */
 70 |     |     function checkOperatorWhitelist(address operator) external view returns (bool) {
 71 |     |         return whitelistedOperators[operator];
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @notice Gets all whitelisted operators
 76 |     |      * @return Array of whitelisted operator addresses
 77 |     |      */
 78 |     |     function getWhitelistedOperators() external view returns (address[] memory) {
 79 |     |         return operators;
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/PerFunctionPausable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title PerFunctionPausable
  8 |     |  * @notice Abstract contract that implements per-function pausing functionality
  9 |     |  * @dev Inherit from this contract to add per-function pausing capabilities
 10 |     |  */
 11 |     | abstract contract PerFunctionPausable is Ownable {
 12 |     |     // Function pause flags
 13 |     |     mapping(bytes4 => bool) public functionPaused;
 14 |     | 
 15 |     |     event FunctionPaused(bytes4 indexed functionSelector, bool isPaused);
 16 |     | 
 17 | *   |     constructor(address initialOwner) Ownable(initialOwner) {}
 18 |     | 
 19 |     |     /**
 20 |     |      * @notice Pauses a specific function
 21 |     |      * @param functionSelector The selector of the function to pause
 22 |     |      * @dev Can only be called by owner
 23 |     |      */
 24 |     |     function pauseFunction(bytes4 functionSelector) external onlyOwner {
 25 |     |         functionPaused[functionSelector] = true;
 26 |     |         emit FunctionPaused(functionSelector, true);
 27 |     |     }
 28 |     | 
 29 |     |     /**
 30 |     |      * @notice Unpauses a specific function
 31 |     |      * @param functionSelector The selector of the function to unpause
 32 |     |      * @dev Can only be called by owner
 33 |     |      */
 34 |     |     function unpauseFunction(bytes4 functionSelector) external onlyOwner {
 35 |     |         functionPaused[functionSelector] = false;
 36 |     |         emit FunctionPaused(functionSelector, false);
 37 |     |     }
 38 |     | 
 39 |     |     /**
 40 |     |      * @notice Modifier to check if a specific function is paused
 41 |     |      */
 42 |     |     modifier whenFunctionNotPaused() {
 43 |     |         require(!functionPaused[msg.sig], "Function is paused");
 44 |     |         _;
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/PriceManipulation.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {IMultiFlowPump} from "contracts/interfaces/basin/IMultiFlowPump.sol";
   5 |     | import {Call, IWell} from "contracts/interfaces/basin/IWell.sol";
   6 |     | import {IBeanstalk} from "contracts/interfaces/IBeanstalk.sol";
   7 |     | import {IWellFunction} from "contracts/interfaces/basin/IWellFunction.sol";
   8 |     | import {ISiloedPinto} from "contracts/interfaces/ISiloedPinto.sol";
   9 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  10 |     | import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
  11 |     | import {IMorphoOracle} from "contracts/interfaces/IMorphoOracle.sol";
  12 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title PriceManipulation
  16 |     |  * @author Beanstalk Farms
  17 |     |  * @notice Contract for checking Well deltaP values
  18 |     |  */
  19 | *   | contract PriceManipulation is IMorphoOracle {
  20 |     |     uint256 internal constant PINTO_DECIMALS = 1e6;
  21 |     |     uint256 internal constant SLIPPAGE_PRECISION = 1e18;
  22 |     |     uint256 internal constant MILLION = 1e6;
  23 |     | 
  24 |     |     // Morpho defined decimals as 36 + loan decimals (usdc, 6) - collateral decimals (sPinto, 18).
  25 |     |     uint256 public constant PRICE_DECIMALS = 24;
  26 |     | 
  27 |     |     address internal constant USDC = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;
  28 |     |     address internal constant S_PINTO = 0x00b174d66adA7d63789087F50A9b9e0e48446dc1;
  29 |     | 
  30 |     |     IBeanstalk public immutable protocol;
  31 |     | 
  32 | *   |     constructor(address protocolAddress) {
  33 | *   |         protocol = IBeanstalk(protocolAddress);
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @notice Query the well to get current and instant asset prices denominated in Pinto. Ensure
  38 |     |      * that the current price is within the % slippage of the instant price.
  39 |     |      * This price is susceptible to manipulation and this is why an additional check to
  40 |     |      * see if the wells instantaneous and current deltaPs are within a 1% margin is implemented.
  41 |     |      * @param well The well to check the prices of.
  42 |     |      * @param token The token to check the prices of. Must be the token paired with Pinto in the well.
  43 |     |      * @param slippageRatio The % slippage of the instant price. 18 decimal precision.
  44 |     |      * @return valid Whether the price is valid and within slippage bounds.
  45 |     |      */
  46 |     |     function isValidSlippage(
  47 |     |         IWell well,
  48 |     |         IERC20 token,
  49 |     |         uint256 slippageRatio
  50 |     |     ) external returns (bool) {
  51 |     |         Call memory pump = well.pumps()[0];
  52 |     |         Call memory wellFunction = IWell(well).wellFunction();
  53 |     | 
  54 |     |         (, uint256 nonBeanIndex) = protocol.getNonBeanTokenAndIndexFromWell(address(well));
  55 |     |         uint256 beanIndex = nonBeanIndex == 0 ? 1 : 0;
  56 |     | 
  57 |     |         // Call sync on well to update pump data and avoid stale reserves.
  58 |     |         well.sync(address(protocol), 0);
  59 |     | 
  60 |     |         // Capped reserves are the current reserves capped with the data from the pump.
  61 |     |         uint256[] memory currentReserves = IWell(well).getReserves();
  62 |     | 
  63 |     |         uint256 currentPintoPerAsset = LibWell.calculateTokenBeanPriceFromReserves(
  64 |     |             address(well),
  65 |     |             beanIndex,
  66 |     |             nonBeanIndex,
  67 |     |             currentReserves,
  68 |     |             wellFunction
  69 |     |         );
  70 |     |         if (currentPintoPerAsset == 0) return false;
  71 |     | 
  72 |     |         // InstantaneousReserves are exponential moving average (EMA).
  73 |     |         uint256[] memory instantReserves = IMultiFlowPump(pump.target).readInstantaneousReserves(
  74 |     |             address(well),
  75 |     |             pump.data
  76 |     |         );
  77 |     |         uint256 instantPintoPerAsset = LibWell.calculateTokenBeanPriceFromReserves(
  78 |     |             address(well),
  79 |     |             beanIndex,
  80 |     |             nonBeanIndex,
  81 |     |             instantReserves,
  82 |     |             wellFunction
  83 |     |         );
  84 |     |         if (instantPintoPerAsset == 0) return false;
  85 |     | 
  86 |     |         // Current rate must be within slippage bounds relative to instantaneous rate.
  87 |     |         uint256 lowerLimit = instantPintoPerAsset -
  88 |     |             (slippageRatio * instantPintoPerAsset) /
  89 |     |             SLIPPAGE_PRECISION;
  90 |     |         uint256 upperLimit = instantPintoPerAsset +
  91 |     |             (slippageRatio * instantPintoPerAsset) /
  92 |     |             SLIPPAGE_PRECISION;
  93 |     |         if (currentPintoPerAsset < lowerLimit || currentPintoPerAsset > upperLimit) {
  94 |     |             return false;
  95 |     |         }
  96 |     |         return true;
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @notice The EMA USDC price of Pinto.
 101 |     |      * @dev Price is liquidity weighted across all whitelisted wells.
 102 |     |      * @return pintoPerUsdc The price of one pinto in terms of USD. 24 decimals.
 103 |     |      */
 104 |     |     function aggregatePintoPerUsdc() public view returns (uint256 pintoPerUsdc) {
 105 |     |         address[] memory wells = protocol.getWhitelistedWellLpTokens();
 106 |     | 
 107 |     |         uint256[] memory wellPintoPerUsdc = new uint256[](wells.length); // 6 decimal
 108 |     |         // Total USD value of the well.
 109 |     |         uint256[] memory wellLiquidity = new uint256[](wells.length);
 110 |     |         uint256 totalLiquidity;
 111 |     | 
 112 |     |         uint256 usdcPerUsd = protocol.getUsdTokenPrice(USDC); // 6 decimal
 113 |     |         require(usdcPerUsd > 0, "Failed to fetch USDC price");
 114 |     | 
 115 |     |         // Go through each well and collect data.
 116 |     |         for (uint256 i; i < wells.length; i++) {
 117 |     |             IWell well = IWell(wells[i]);
 118 |     |             (address token, uint256 nonBeanIndex) = protocol.getNonBeanTokenAndIndexFromWell(
 119 |     |                 address(well)
 120 |     |             );
 121 |     |             uint256 beanIndex = nonBeanIndex == 0 ? 1 : 0;
 122 |     |             uint256 tokenDecimals = IERC20Metadata(token).decimals();
 123 |     | 
 124 |     |             uint256 pintoPerMillionUsd;
 125 |     | 
 126 |     |             Call memory pump = well.pumps()[0];
 127 |     |             // Instant reserves are the EMA reserves.
 128 |     |             uint256[] memory instantReserves = IMultiFlowPump(pump.target)
 129 |     |                 .readInstantaneousReserves(address(well), pump.data);
 130 |     | 
 131 |     |             // Calculate the price of the token in terms of Pinto.
 132 |     |             uint256 pintoPerToken = LibWell.calculateTokenBeanPriceFromReserves(
 133 |     |                 address(well),
 134 |     |                 beanIndex,
 135 |     |                 nonBeanIndex,
 136 |     |                 instantReserves,
 137 |     |                 well.wellFunction()
 138 |     |             ); // 6 decimal
 139 |     |             if (pintoPerToken == 0) {
 140 |     |                 continue;
 141 |     |             }
 142 |     | 
 143 |     |             uint256 tokenPerMillionUsd = protocol.getMillionUsdPrice(token, 0); // decimals match token
 144 |     |             if (tokenPerMillionUsd == 0) {
 145 |     |                 continue;
 146 |     |             }
 147 |     |             pintoPerMillionUsd = (pintoPerToken * tokenPerMillionUsd) / PINTO_DECIMALS; // decimals match token
 148 |     |             wellLiquidity[i] =
 149 |     |                 instantReserves[beanIndex] /
 150 |     |                 pintoPerMillionUsd /
 151 |     |                 MILLION /
 152 |     |                 (10 ** tokenDecimals) +
 153 |     |                 (instantReserves[nonBeanIndex] * MILLION) /
 154 |     |                 tokenPerMillionUsd;
 155 |     | 
 156 |     |             totalLiquidity += wellLiquidity[i];
 157 |     |             wellPintoPerUsdc[i] =
 158 |     |                 (10 ** (PRICE_DECIMALS - tokenDecimals) * pintoPerMillionUsd) /
 159 |     |                 usdcPerUsd; // 24 decimals
 160 |     |         }
 161 |     | 
 162 |     |         require(totalLiquidity > 0, "failed to retrieve reserves");
 163 |     | 
 164 |     |         for (uint256 i; i < wells.length; i++) {
 165 |     |             if (wellLiquidity[i] == 0) continue;
 166 |     |             pintoPerUsdc += (wellPintoPerUsdc[i] * wellLiquidity[i]) / totalLiquidity; // 24 decimals
 167 |     |         }
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @notice The EMA USDC price of sPinto.
 172 |     |      * @dev Price is liquidity weighted across all whitelisted wells.
 173 |     |      * @dev Reference https://docs.morpho.org/morpho/contracts/oracles/
 174 |     |      * @return usdcPerSPinto The price of one sPinto in terms of USDC. 24 decimals.
 175 |     |      */
 176 |     |     function price() public view override returns (uint256 usdcPerSPinto) {
 177 |     |         uint256 pintoPerUsdc = aggregatePintoPerUsdc(); // 24 decimals
 178 |     |         uint256 pintoPerSPinto = ISiloedPinto(S_PINTO).previewRedeem(1e18); // 6 decimal
 179 |     |         usdcPerSPinto = ((10 ** (PRICE_DECIMALS * 2 - 6)) * pintoPerSPinto) / pintoPerUsdc; // 24 decimals
 180 |     |     }
 181 |     | }
 182 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/ShipmentPlanner.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | import {Season} from "contracts/beanstalk/storage/System.sol";
   7 |     | import {IPayback} from "contracts/interfaces/IPayback.sol";
   8 |     | import {IBudget} from "contracts/interfaces/IBudget.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @notice Constraints of how many Beans to send to a given route at the current time.
  12 |     |  * @param points Weight of this shipment route relative to all routes. Expects precision of 1e18.
  13 |     |  * @param cap Maximum Beans that can be received by this stream at this time.
  14 |     |  */
  15 |     | struct ShipmentPlan {
  16 |     |     uint256 points;
  17 |     |     uint256 cap;
  18 |     | }
  19 |     | 
  20 |     | interface IBeanstalk {
  21 |     |     function isHarvesting(uint256 fieldId) external view returns (bool);
  22 |     | 
  23 |     |     function totalUnharvestable(uint256 fieldId) external view returns (uint256);
  24 |     | 
  25 |     |     function fieldCount() external view returns (uint256);
  26 |     | 
  27 |     |     function time() external view returns (Season memory);
  28 |     | }
  29 |     | 
  30 |     | /**
  31 |     |  * @title ShipmentPlanner
  32 |     |  * @notice Contains getters for retrieving ShipmentPlans for various Beanstalk components.
  33 |     |  * @dev Lives as a standalone immutable contract. Updating shipment plans requires deploying
  34 |     |  * a new instance and updating the ShipmentRoute planContract addresses help in AppStorage.
  35 |     |  * @dev Called via staticcall. New plan getters must be view/pure functions.
  36 |     |  */
  37 | *   | contract ShipmentPlanner {
  38 |     |     uint256 internal constant PRECISION = 1e18;
  39 |     | 
  40 |     |     uint256 constant FIELD_POINTS = 48_500_000_000_000_000;
  41 |     |     uint256 constant SILO_POINTS = 48_500_000_000_000_000;
  42 |     |     uint256 constant BUDGET_POINTS = 3_000_000_000_000_000;
  43 |     |     uint256 constant PAYBACK_FIELD_POINTS = 1_000_000_000_000_000;
  44 |     |     uint256 constant PAYBACK_CONTRACT_POINTS = 2_000_000_000_000_000;
  45 |     | 
  46 |     |     uint256 constant SUPPLY_BUDGET_FLIP = 1_000_000_000e6;
  47 |     | 
  48 |     |     IBeanstalk beanstalk;
  49 |     |     IERC20 bean;
  50 |     | 
  51 | *   |     constructor(address beanstalkAddress, address beanAddress) {
  52 | *   |         beanstalk = IBeanstalk(beanstalkAddress);
  53 | *   |         bean = IERC20(beanAddress);
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Get the current points and cap for Field shipments.
  58 |     |      * @dev The Field cap is the amount of outstanding Pods unharvestable pods.
  59 |     |      * @param data Encoded uint256 containing the index of the Field to receive the Beans.
  60 |     |      */
  61 |     |     function getFieldPlan(
  62 |     |         bytes memory data
  63 |     |     ) external view returns (ShipmentPlan memory shipmentPlan) {
  64 |     |         uint256 fieldId = abi.decode(data, (uint256));
  65 |     |         require(fieldId < beanstalk.fieldCount(), "Field does not exist");
  66 |     |         if (!beanstalk.isHarvesting(fieldId)) return shipmentPlan;
  67 |     |         return ShipmentPlan({points: FIELD_POINTS, cap: beanstalk.totalUnharvestable(fieldId)});
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice Get the current points and cap for Silo shipments.
  72 |     |      * @dev The Silo has no cap.
  73 |     |      * @dev data param is unused data to configure plan details.
  74 |     |      */
  75 |     |     function getSiloPlan(bytes memory) external pure returns (ShipmentPlan memory shipmentPlan) {
  76 |     |         return ShipmentPlan({points: SILO_POINTS, cap: type(uint256).max});
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @notice Get the current points and cap for budget shipments.
  81 |     |      * @dev data param is unused data to configure plan details.
  82 |     |      * @dev Reverts if the Bean supply is greater than the flipping point.
  83 |     |      * @dev Has a hard cap of 3% of the current season standard minted Beans.
  84 |     |      */
  85 |     |     function getBudgetPlan(bytes memory) external view returns (ShipmentPlan memory shipmentPlan) {
  86 |     |         uint256 budgetRatio = budgetMintRatio();
  87 |     |         require(budgetRatio > 0);
  88 |     |         uint256 points = (BUDGET_POINTS * budgetRatio) / PRECISION;
  89 |     |         uint256 cap = (beanstalk.time().standardMintedBeans * 3) / 100;
  90 |     |         return ShipmentPlan({points: points, cap: cap});
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice Get the current points and cap for the Field portion of payback shipments.
  95 |     |      * @dev data param is unused data to configure plan details.
  96 |     |      */
  97 |     |     function getPaybackFieldPlan(
  98 |     |         bytes memory data
  99 |     |     ) external view returns (ShipmentPlan memory shipmentPlan) {
 100 |     |         uint256 paybackRatio = PRECISION - budgetMintRatio();
 101 |     |         require(paybackRatio > 0);
 102 |     | 
 103 |     |         (uint256 fieldId, address paybackContract) = abi.decode(data, (uint256, address));
 104 |     |         (bool success, uint256 siloRemaining, uint256 barnRemaining) = paybacksRemaining(
 105 |     |             paybackContract
 106 |     |         );
 107 |     |         // If the contract does not exist yet.
 108 |     |         if (!success) {
 109 |     |             return
 110 |     |                 ShipmentPlan({
 111 |     |                     points: PAYBACK_FIELD_POINTS,
 112 |     |                     cap: beanstalk.totalUnharvestable(fieldId)
 113 |     |                 });
 114 |     |         }
 115 |     | 
 116 |     |         // Add strict % limits. Silo will be paid off first.
 117 |     |         uint256 points;
 118 |     |         uint256 cap = beanstalk.totalUnharvestable(fieldId);
 119 |     |         if (barnRemaining == 0) {
 120 |     |             points = PAYBACK_FIELD_POINTS + PAYBACK_CONTRACT_POINTS;
 121 |     |             cap = min(cap, (beanstalk.time().standardMintedBeans * 3) / 100); // 3%
 122 |     |         } else if (siloRemaining == 0) {
 123 |     |             points = PAYBACK_FIELD_POINTS + (PAYBACK_CONTRACT_POINTS * 1) / 4;
 124 |     |             cap = min(cap, (beanstalk.time().standardMintedBeans * 15) / 1000); // 1.5%
 125 |     |         } else {
 126 |     |             points = PAYBACK_FIELD_POINTS;
 127 |     |             cap = min(cap, (beanstalk.time().standardMintedBeans * 1) / 100); // 1%
 128 |     |         }
 129 |     | 
 130 |     |         // Scale points by distance to threshold.
 131 |     |         points = (points * paybackRatio) / PRECISION;
 132 |     | 
 133 |     |         return ShipmentPlan({points: points, cap: beanstalk.totalUnharvestable(fieldId)});
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Get the current points and cap for payback shipments.
 138 |     |      * @dev data param is unused data to configure plan details.
 139 |     |      * @dev If the payback contract does not yet exist, mints are still allocated to it.
 140 |     |      */
 141 |     |     function getPaybackPlan(
 142 |     |         bytes memory data
 143 |     |     ) external view returns (ShipmentPlan memory shipmentPlan) {
 144 |     |         uint256 paybackRatio = PRECISION - budgetMintRatio();
 145 |     |         require(paybackRatio > 0);
 146 |     | 
 147 |     |         address paybackContract = abi.decode(data, (address));
 148 |     |         (bool success, uint256 siloRemaining, uint256 barnRemaining) = paybacksRemaining(
 149 |     |             paybackContract
 150 |     |         );
 151 |     |         // If the contract does not exist yet, no cap.
 152 |     |         if (!success) {
 153 |     |             return ShipmentPlan({points: PAYBACK_CONTRACT_POINTS, cap: type(uint256).max});
 154 |     |         }
 155 |     | 
 156 |     |         uint256 points;
 157 |     |         uint256 cap = siloRemaining + barnRemaining;
 158 |     |         // Add strict % limits. Silo will be paid off first.
 159 |     |         if (siloRemaining == 0) {
 160 |     |             points = (PAYBACK_CONTRACT_POINTS * 3) / 4;
 161 |     |             cap = min(cap, (beanstalk.time().standardMintedBeans * 15) / 1000); // 1.5%
 162 |     |         } else {
 163 |     |             points = PAYBACK_CONTRACT_POINTS;
 164 |     |             cap = min(cap, (beanstalk.time().standardMintedBeans * 2) / 100); // 2%
 165 |     |         }
 166 |     | 
 167 |     |         // Scale points by distance to threshold.
 168 |     |         points = (points * paybackRatio) / PRECISION;
 169 |     | 
 170 |     |         return ShipmentPlan({points: points, cap: cap});
 171 |     |     }
 172 |     | 
 173 |     |     /**
 174 |     |      * @notice Returns a ratio to scale the seasonal mints between budget and payback.
 175 |     |      */
 176 |     |     function budgetMintRatio() private view returns (uint256) {
 177 |     |         uint256 beanSupply = bean.totalSupply();
 178 |     |         uint256 seasonalMints = beanstalk.time().standardMintedBeans;
 179 |     | 
 180 |     |         // 0% to budget.
 181 |     |         if (beanSupply > SUPPLY_BUDGET_FLIP + seasonalMints) {
 182 |     |             return 0;
 183 |     |         }
 184 |     |         // 100% to budget.
 185 |     |         else if (beanSupply + seasonalMints <= SUPPLY_BUDGET_FLIP) {
 186 |     |             return PRECISION;
 187 |     |         }
 188 |     |         // Partial budget allocation.
 189 |     |         else {
 190 |     |             uint256 remainingBudget = SUPPLY_BUDGET_FLIP - (beanSupply - seasonalMints);
 191 |     |             return (remainingBudget * PRECISION) / seasonalMints;
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     function paybacksRemaining(
 196 |     |         address paybackContract
 197 |     |     ) private view returns (bool totalSuccess, uint256 siloRemaining, uint256 barnRemaining) {
 198 |     |         (bool success, bytes memory returnData) = paybackContract.staticcall(
 199 |     |             abi.encodeWithSelector(IPayback.siloRemaining.selector)
 200 |     |         );
 201 |     |         totalSuccess = success;
 202 |     |         siloRemaining = success ? abi.decode(returnData, (uint256)) : 0;
 203 |     |         (success, returnData) = paybackContract.staticcall(
 204 |     |             abi.encodeWithSelector(IPayback.barnRemaining.selector)
 205 |     |         );
 206 |     |         totalSuccess = totalSuccess && success;
 207 |     |         barnRemaining = success ? abi.decode(returnData, (uint256)) : 0;
 208 |     |     }
 209 |     | 
 210 |     |     function min(uint256 a, uint256 b) private pure returns (uint256) {
 211 |     |         return a < b ? a : b;
 212 |     |     }
 213 |     | }
 214 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/SowBlueprintv0.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
   5 |     | import {IBeanstalk} from "contracts/interfaces/IBeanstalk.sol";
   6 |     | import {TractorHelpers} from "./TractorHelpers.sol";
   7 |     | import {PerFunctionPausable} from "./PerFunctionPausable.sol";
   8 |     | import {BeanstalkPrice} from "./price/BeanstalkPrice.sol";
   9 |     | import {LibTractorHelpers} from "contracts/libraries/Silo/LibTractorHelpers.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @title SowBlueprintv0
  13 |     |  * @author FordPinto
  14 |     |  * @notice Contract for sowing with Tractor, with a number of conditions
  15 |     |  */
  16 | *   | contract SowBlueprintv0 is PerFunctionPausable {
  17 |     |     /**
  18 |     |      * @notice Event emitted when a sow order is complete, or no longer executable due to min sow being less than min sow per season
  19 |     |      * @param blueprintHash The hash of the blueprint
  20 |     |      * @param publisher The address of the publisher
  21 |     |      * @param totalAmountSown The amount of beans sown
  22 |     |      * @param amountUnfulfilled The amount of beans that were not sown
  23 |     |      */
  24 |     |     event SowOrderComplete(
  25 |     |         bytes32 indexed blueprintHash,
  26 |     |         address indexed publisher,
  27 |     |         uint256 totalAmountSown,
  28 |     |         uint256 amountUnfulfilled
  29 |     |     );
  30 |     | 
  31 |     |     /**
  32 |     |      * @notice Struct to hold local variables for the sow operation to avoid stack too deep errors
  33 |     |      * @param currentTemp Current temperature from Beanstalk
  34 |     |      * @param availableSoil Amount of soil available for sowing at time of execution
  35 |     |      * @param beanToken Address of the Bean token
  36 |     |      * @param pintoLeftToSow Current value of the order counter
  37 |     |      * @param totalBeansNeeded Total amount of beans needed including tip
  38 |     |      * @param orderHash Hash of the current blueprint order
  39 |     |      * @param beansWithdrawn Amount of beans withdrawn from sources
  40 |     |      * @param tipAddress Address to send tip to
  41 |     |      * @param account Address of the user's account (current Tractor user), not operator
  42 |     |      * @param totalAmountToSow Total amount intended to sow
  43 |     |      * @param withdrawalPlan The plan for withdrawing beans
  44 |     |      */
  45 |     |     struct SowLocalVars {
  46 |     |         address beanToken;
  47 |     |         uint256 availableSoil;
  48 |     |         uint32 currentSeason;
  49 |     |         uint256 pintoLeftToSow;
  50 |     |         uint256 totalBeansNeeded;
  51 |     |         bytes32 orderHash;
  52 |     |         uint256 beansWithdrawn;
  53 |     |         address tipAddress;
  54 |     |         address account;
  55 |     |         uint256 totalAmountToSow;
  56 |     |         LibTractorHelpers.WithdrawalPlan withdrawalPlan;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Main struct for sow blueprint
  61 |     |      * @param sowParams Parameters related to sowing
  62 |     |      * @param opParams Parameters related to operators
  63 |     |      */
  64 |     |     struct SowBlueprintStruct {
  65 |     |         SowParams sowParams;
  66 |     |         OperatorParams opParams;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Struct to hold sow parameters
  71 |     |      * @param sourceTokenIndices Indices of source tokens to withdraw from
  72 |     |      * @param sowAmounts Amounts for sowing
  73 |     |      * @param minTemp Minimum temperature required for sowing
  74 |     |      * @param maxPodlineLength Maximum podline length allowed
  75 |     |      * @param maxGrownStalkPerBdv Maximum grown stalk per BDV allowed
  76 |     |      * @param runBlocksAfterSunrise Number of blocks to wait after sunrise before executing
  77 |     |      * @param slippageRatio The price slippage ratio for a lp token withdrawal, between the instantaneous price and the current price. Only applicable for lp token withdrawals.
  78 |     |      */
  79 |     |     struct SowParams {
  80 |     |         uint8[] sourceTokenIndices;
  81 |     |         SowAmounts sowAmounts;
  82 |     |         uint256 minTemp;
  83 |     |         uint256 maxPodlineLength;
  84 |     |         uint256 maxGrownStalkPerBdv;
  85 |     |         uint256 runBlocksAfterSunrise;
  86 |     |         uint256 slippageRatio;
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @notice Struct to hold sow amounts
  91 |     |      * @param totalAmountToSow Total amount intended to sow
  92 |     |      * @param minAmountToSowPerSeason Minimum amount that must be sown per season
  93 |     |      * @param maxAmountToSowPerSeason Maximum amount that can be sown per season
  94 |     |      */
  95 |     |     struct SowAmounts {
  96 |     |         uint256 totalAmountToSow;
  97 |     |         uint256 minAmountToSowPerSeason;
  98 |     |         uint256 maxAmountToSowPerSeason;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @notice Struct to hold operator parameters
 103 |     |      * @param whitelistedOperators Array of whitelisted operator addresses
 104 |     |      * @param tipAddress Address to send tip to
 105 |     |      * @param operatorTipAmount Amount of tip to pay to operator
 106 |     |      */
 107 |     |     struct OperatorParams {
 108 |     |         address[] whitelistedOperators;
 109 |     |         address tipAddress;
 110 |     |         int256 operatorTipAmount;
 111 |     |     }
 112 |     | 
 113 |     |     IBeanstalk immutable beanstalk;
 114 |     |     TractorHelpers public immutable tractorHelpers;
 115 |     | 
 116 |     |     // Default slippage ratio for LP token withdrawals (1%)
 117 |     |     uint256 internal constant DEFAULT_SLIPPAGE_RATIO = 0.01e18;
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Struct to hold order info
 121 |     |      * @param pintoSownCounter Counter for the number of maximum pinto that can be sown from this blueprint. Used for orders that sow over multiple seasons.
 122 |     |      * @param lastExecutedSeason Last season a blueprint was executed
 123 |     |      */
 124 |     |     struct OrderInfo {
 125 |     |         uint256 pintoSownCounter;
 126 |     |         uint32 lastExecutedSeason;
 127 |     |     }
 128 |     | 
 129 |     |     // Combined state mapping for order info
 130 |     |     mapping(bytes32 => OrderInfo) private orderInfo;
 131 |     | 
 132 | *   |     constructor(
 133 |     |         address _beanstalk,
 134 |     |         address _owner,
 135 |     |         address _tractorHelpers
 136 | *   |     ) PerFunctionPausable(_owner) {
 137 | *   |         beanstalk = IBeanstalk(_beanstalk);
 138 |     | 
 139 |     |         // Use existing TractorHelpers contract instead of deploying a new one
 140 | *   |         tractorHelpers = TractorHelpers(_tractorHelpers);
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @notice Sows beans using specified source tokens in order of preference
 145 |     |      * @param params The SowBlueprintStruct containing all parameters for the sow operation
 146 |     |      */
 147 |     |     function sowBlueprintv0(
 148 |     |         SowBlueprintStruct calldata params
 149 |     |     ) external payable whenFunctionNotPaused {
 150 |     |         // Initialize local variables
 151 |     |         SowLocalVars memory vars;
 152 |     | 
 153 |     |         // get order hash
 154 |     |         vars.orderHash = beanstalk.getCurrentBlueprintHash();
 155 |     | 
 156 |     |         vars.account = beanstalk.tractorUser();
 157 |     | 
 158 |     |         // Get various data from beanstalk and validate parameters
 159 |     |         (
 160 |     |             vars.availableSoil,
 161 |     |             vars.beanToken,
 162 |     |             vars.currentSeason,
 163 |     |             vars.pintoLeftToSow,
 164 |     |             vars.totalAmountToSow,
 165 |     |             vars.totalBeansNeeded,
 166 |     |             vars.withdrawalPlan
 167 |     |         ) = validateParamsAndReturnBeanstalkState(params, vars.orderHash, vars.account);
 168 |     | 
 169 |     |         // Check if the executing operator (msg.sender) is whitelisted
 170 |     |         require(
 171 |     |             tractorHelpers.isOperatorWhitelisted(params.opParams.whitelistedOperators),
 172 |     |             "Operator not whitelisted"
 173 |     |         );
 174 |     | 
 175 |     |         // Get tip address. If tip address is not set, set it to the operator
 176 |     |         if (params.opParams.tipAddress == address(0)) {
 177 |     |             vars.tipAddress = beanstalk.operator();
 178 |     |         } else {
 179 |     |             vars.tipAddress = params.opParams.tipAddress;
 180 |     |         }
 181 |     | 
 182 |     |         // if slippage ratio is not set, set a default parameter:
 183 |     |         uint256 slippageRatio = params.sowParams.slippageRatio;
 184 |     |         if (slippageRatio == 0) {
 185 |     |             slippageRatio = DEFAULT_SLIPPAGE_RATIO;
 186 |     |         }
 187 |     | 
 188 |     |         // Execute the withdrawal plan
 189 |     |         vars.beansWithdrawn = tractorHelpers.withdrawBeansFromSources(
 190 |     |             vars.account,
 191 |     |             params.sowParams.sourceTokenIndices,
 192 |     |             vars.totalBeansNeeded,
 193 |     |             params.sowParams.maxGrownStalkPerBdv,
 194 |     |             slippageRatio,
 195 |     |             LibTransfer.To.INTERNAL,
 196 |     |             vars.withdrawalPlan
 197 |     |         );
 198 |     | 
 199 |     |         // Update the counter
 200 |     |         // If this will use up all remaining amount, set to max to indicate completion
 201 |     |         if (vars.pintoLeftToSow - vars.totalAmountToSow == 0) {
 202 |     |             updatePintoLeftToSowCounter(vars.orderHash, type(uint256).max);
 203 |     |             // Order filled completely, emit event as such
 204 |     |             emit SowOrderComplete(vars.orderHash, vars.account, vars.totalAmountToSow, 0);
 205 |     |         } else {
 206 |     |             uint256 amountUnfulfilled = vars.pintoLeftToSow - vars.totalAmountToSow;
 207 |     |             updatePintoLeftToSowCounter(vars.orderHash, amountUnfulfilled);
 208 |     | 
 209 |     |             // If the min sow per season is greater than the amount unfulfilled, this order will
 210 |     |             // never be able to execute again, so emit event as such
 211 |     |             if (amountUnfulfilled < params.sowParams.sowAmounts.minAmountToSowPerSeason) {
 212 |     |                 emit SowOrderComplete(
 213 |     |                     vars.orderHash,
 214 |     |                     vars.account,
 215 |     |                     params.sowParams.sowAmounts.totalAmountToSow - amountUnfulfilled,
 216 |     |                     amountUnfulfilled
 217 |     |                 );
 218 |     |             }
 219 |     |         }
 220 |     | 
 221 |     |         // Tip the operator
 222 |     |         tractorHelpers.tip(
 223 |     |             vars.beanToken,
 224 |     |             vars.account,
 225 |     |             vars.tipAddress,
 226 |     |             params.opParams.operatorTipAmount,
 227 |     |             LibTransfer.From.INTERNAL,
 228 |     |             LibTransfer.To.INTERNAL
 229 |     |         );
 230 |     | 
 231 |     |         // Sow the withdrawn beans
 232 |     |         beanstalk.sowWithMin(
 233 |     |             vars.totalAmountToSow,
 234 |     |             params.sowParams.minTemp,
 235 |     |             params.sowParams.sowAmounts.minAmountToSowPerSeason,
 236 |     |             LibTransfer.From.INTERNAL
 237 |     |         );
 238 |     | 
 239 |     |         // Update the last executed season for this blueprint
 240 |     |         updateLastExecutedSeason(vars.orderHash, vars.currentSeason);
 241 |     |     }
 242 |     | 
 243 |     |     /**
 244 |     |      * @notice Validates the initial parameters for the sow operation
 245 |     |      * @param params The SowBlueprintStruct containing all parameters for the sow operation
 246 |     |      */
 247 |     |     function _validateParams(SowBlueprintStruct calldata params) internal view {
 248 |     |         require(
 249 |     |             params.sowParams.sourceTokenIndices.length > 0,
 250 |     |             "Must provide at least one source token"
 251 |     |         );
 252 |     | 
 253 |     |         // Require that maxAmountToSowPerSeason > 0
 254 |     |         require(
 255 |     |             params.sowParams.sowAmounts.maxAmountToSowPerSeason > 0,
 256 |     |             "Max amount to sow per season is 0"
 257 |     |         );
 258 |     | 
 259 |     |         // Require that minAmountToSowPerSeason <= maxAmountToSowPerSeason
 260 |     |         require(
 261 |     |             params.sowParams.sowAmounts.minAmountToSowPerSeason <=
 262 |     |                 params.sowParams.sowAmounts.maxAmountToSowPerSeason,
 263 |     |             "Min amount to sow per season is greater than max amount to sow per season"
 264 |     |         );
 265 |     | 
 266 |     |         // Check if enough blocks have passed since sunrise
 267 |     |         require(
 268 |     |             block.number >= beanstalk.sunriseBlock() + params.sowParams.runBlocksAfterSunrise,
 269 |     |             "Not enough blocks since sunrise"
 270 |     |         );
 271 |     | 
 272 |     |         // Check podline length
 273 |     |         require(
 274 |     |             beanstalk.totalUnharvestableForActiveField() <= params.sowParams.maxPodlineLength,
 275 |     |             "Podline too long"
 276 |     |         );
 277 |     |     }
 278 |     | 
 279 |     |     /**
 280 |     |      * @notice validates the blueprint parameters.
 281 |     |      */
 282 |     |     function _validateBlueprintAndPintoLeftToSow(
 283 |     |         bytes32 orderHash
 284 |     |     ) internal view returns (uint256 pintoLeftToSow) {
 285 |     |         require(orderHash != bytes32(0), "No active blueprint, function must run from Tractor");
 286 |     |         require(
 287 |     |             getLastExecutedSeason(orderHash) < beanstalk.time().current,
 288 |     |             "Blueprint already executed this season"
 289 |     |         );
 290 |     | 
 291 |     |         // Verify there's still sow amount available with the counter
 292 |     |         pintoLeftToSow = getPintosLeftToSow(orderHash);
 293 |     | 
 294 |     |         // If pintoLeftToSow is max uint256, then the sow order has already been fully used, so revert
 295 |     |         require(pintoLeftToSow != type(uint256).max, "Sow order already fulfilled");
 296 |     |     }
 297 |     | 
 298 |     |     /**
 299 |     |      * @notice Gets the last season a blueprint was executed
 300 |     |      * @param orderHash The hash of the blueprint
 301 |     |      * @return The last season the blueprint was executed, or 0 if never executed
 302 |     |      */
 303 |     |     function getLastExecutedSeason(bytes32 orderHash) public view returns (uint32) {
 304 |     |         return orderInfo[orderHash].lastExecutedSeason;
 305 |     |     }
 306 |     | 
 307 |     |     /**
 308 |     |      * @notice Gets the number of maximum pinto that can be sown from this blueprint
 309 |     |      * @param orderHash The hash of the order
 310 |     |      * @return The number of maximum pinto that can be sown from this blueprint
 311 |     |      */
 312 |     |     function getPintosLeftToSow(bytes32 orderHash) public view returns (uint256) {
 313 |     |         return orderInfo[orderHash].pintoSownCounter;
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @notice Updates the Pinto left to sow counter for a given order hash
 318 |     |      * @param orderHash The hash of the order
 319 |     |      * @param amount The amount to update by
 320 |     |      */
 321 |     |     function updatePintoLeftToSowCounter(bytes32 orderHash, uint256 amount) internal {
 322 |     |         orderInfo[orderHash].pintoSownCounter = amount;
 323 |     |     }
 324 |     | 
 325 |     |     /**
 326 |     |      * @notice Updates the last executed season for a given order hash
 327 |     |      * @param orderHash The hash of the order
 328 |     |      * @param season The season number
 329 |     |      */
 330 |     |     function updateLastExecutedSeason(bytes32 orderHash, uint32 season) internal {
 331 |     |         orderInfo[orderHash].lastExecutedSeason = season;
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @notice Determines the total amount to sow based on various constraints
 336 |     |      * @param totalAmountToSow Total amount intended to sow
 337 |     |      * @param pintoLeftToSow Current value of the running total requested to be sown
 338 |     |      * @param maxAmountToSowPerSeason Maximum amount that can be sown per season
 339 |     |      * @param availableSoil Amount of soil available for sowing
 340 |     |      * @return The determined total amount to sow
 341 |     |      */
 342 |     |     function determineTotalAmountToSow(
 343 |     |         uint256 totalAmountToSow,
 344 |     |         uint256 pintoLeftToSow,
 345 |     |         uint256 maxAmountToSowPerSeason,
 346 |     |         uint256 availableSoil
 347 |     |     ) internal pure returns (uint256) {
 348 |     |         // If the Pinto left to sow is less than the totalAmountToSow, use the remaining pinto left to sow
 349 |     |         if (pintoLeftToSow < totalAmountToSow) {
 350 |     |             totalAmountToSow = pintoLeftToSow;
 351 |     |         }
 352 |     | 
 353 |     |         // Check and enforce maxAmountToSowPerSeason limit first
 354 |     |         if (totalAmountToSow > maxAmountToSowPerSeason) {
 355 |     |             totalAmountToSow = maxAmountToSowPerSeason;
 356 |     |         }
 357 |     | 
 358 |     |         // Then check soil availability and adjust if needed
 359 |     |         if (totalAmountToSow > availableSoil) {
 360 |     |             totalAmountToSow = availableSoil;
 361 |     |         }
 362 |     | 
 363 |     |         return totalAmountToSow;
 364 |     |     }
 365 |     | 
 366 |     |     /**
 367 |     |      * @notice helper function to get various parameters from beanstalk.
 368 |     |      */
 369 |     |     function getAndValidateBeanstalkState(
 370 |     |         SowParams calldata params
 371 |     |     ) internal view returns (uint256 availableSoil, address beanToken, uint32 currentSeason) {
 372 |     |         availableSoil = beanstalk.totalSoil();
 373 |     |         beanToken = beanstalk.getBeanToken();
 374 |     |         currentSeason = beanstalk.time().current;
 375 |     | 
 376 |     |         // Check temperature and soil requirements
 377 |     |         require(beanstalk.temperature() >= params.minTemp, "Temperature too low");
 378 |     |         require(
 379 |     |             availableSoil >= params.sowAmounts.minAmountToSowPerSeason,
 380 |     |             "Not enough soil for min sow"
 381 |     |         );
 382 |     |     }
 383 |     | 
 384 |     |     /**
 385 |     |      * @notice Validates the sow parameters, and returns the beanstalk state
 386 |     |      * @param params The SowBlueprintStruct containing all parameters for the sow operation
 387 |     |      * @return availableSoil The amount of soil available for sowing
 388 |     |      * @return beanToken The address of the bean token
 389 |     |      * @return currentSeason The current season
 390 |     |      * @return pintoLeftToSow The total amount requested to be sown (considers stored value)
 391 |     |      * @return totalAmountToSow The total amount to sow, adjusted based on constraints
 392 |     |      * @return totalBeansNeeded The total beans needed (sow amount + tip)
 393 |     |      * @return plan The withdrawal plan to check if enough beans are available
 394 |     |      */
 395 |     |     function validateParamsAndReturnBeanstalkState(
 396 |     |         SowBlueprintStruct calldata params,
 397 |     |         bytes32 orderHash,
 398 |     |         address blueprintPublisher
 399 |     |     )
 400 |     |         public
 401 |     |         view
 402 |     |         returns (
 403 |     |             uint256 availableSoil,
 404 |     |             address beanToken,
 405 |     |             uint32 currentSeason,
 406 |     |             uint256 pintoLeftToSow,
 407 |     |             uint256 totalAmountToSow,
 408 |     |             uint256 totalBeansNeeded,
 409 |     |             LibTractorHelpers.WithdrawalPlan memory plan
 410 |     |         )
 411 |     |     {
 412 |     |         (availableSoil, beanToken, currentSeason) = getAndValidateBeanstalkState(params.sowParams);
 413 |     | 
 414 |     |         _validateParams(params);
 415 |     |         pintoLeftToSow = _validateBlueprintAndPintoLeftToSow(orderHash);
 416 |     | 
 417 |     |         // If the pintoLeftToSow is 0, then it has not been initialized yet, initialize it with the total amount to sow
 418 |     |         if (pintoLeftToSow == 0) {
 419 |     |             pintoLeftToSow = params.sowParams.sowAmounts.totalAmountToSow;
 420 |     |         }
 421 |     | 
 422 |     |         // Determine the total amount to sow based on various constraints
 423 |     |         totalAmountToSow = determineTotalAmountToSow(
 424 |     |             params.sowParams.sowAmounts.totalAmountToSow,
 425 |     |             pintoLeftToSow == 0 ? params.sowParams.sowAmounts.totalAmountToSow : pintoLeftToSow,
 426 |     |             params.sowParams.sowAmounts.maxAmountToSowPerSeason,
 427 |     |             availableSoil
 428 |     |         );
 429 |     | 
 430 |     |         // Calculate total beans needed (sow amount + tip if positive)
 431 |     |         totalBeansNeeded = totalAmountToSow;
 432 |     |         if (params.opParams.operatorTipAmount > 0) {
 433 |     |             totalBeansNeeded += uint256(params.opParams.operatorTipAmount);
 434 |     |         }
 435 |     | 
 436 |     |         // Check if enough beans are available using getWithdrawalPlan
 437 |     |         plan = tractorHelpers.getWithdrawalPlanExcludingPlan(
 438 |     |             blueprintPublisher,
 439 |     |             params.sowParams.sourceTokenIndices,
 440 |     |             totalBeansNeeded,
 441 |     |             params.sowParams.maxGrownStalkPerBdv,
 442 |     |             plan // Passed in plan is empty
 443 |     |         );
 444 |     | 
 445 |     |         // Verify enough beans are available
 446 |     |         if (plan.totalAvailableBeans < totalBeansNeeded) {
 447 |     |             require(
 448 |     |                 plan.totalAvailableBeans >=
 449 |     |                     params.sowParams.sowAmounts.minAmountToSowPerSeason +
 450 |     |                         uint256(params.opParams.operatorTipAmount),
 451 |     |                 "Not enough beans available"
 452 |     |             );
 453 |     |             totalBeansNeeded = plan.totalAvailableBeans;
 454 |     |             if (params.opParams.operatorTipAmount > 0) {
 455 |     |                 totalAmountToSow =
 456 |     |                     plan.totalAvailableBeans -
 457 |     |                     uint256(params.opParams.operatorTipAmount);
 458 |     |             } else {
 459 |     |                 totalAmountToSow = plan.totalAvailableBeans;
 460 |     |             }
 461 |     |         }
 462 |     |     }
 463 |     | 
 464 |     |     /**
 465 |     |      * @notice Validates multiple sow parameters and returns an array of valid order hashes
 466 |     |      * @param paramsArray Array of SowBlueprintStruct containing all parameters for the sow operations
 467 |     |      * @param orderHashes Array of order hashes to validate
 468 |     |      * @return validOrderHashes Array of valid order hashes that passed validation
 469 |     |      */
 470 |     |     function validateParamsAndReturnBeanstalkStateArray(
 471 |     |         SowBlueprintStruct[] calldata paramsArray,
 472 |     |         bytes32[] calldata orderHashes,
 473 |     |         address[] calldata blueprintPublishers
 474 |     |     ) external view returns (bytes32[] memory validOrderHashes) {
 475 |     |         uint256 length = paramsArray.length;
 476 |     |         validOrderHashes = new bytes32[](length);
 477 |     |         uint256 validCount = 0;
 478 |     | 
 479 |     |         for (uint256 i = 0; i < length; i++) {
 480 |     |             try
 481 |     |                 this.validateParamsAndReturnBeanstalkState(
 482 |     |                     paramsArray[i],
 483 |     |                     orderHashes[i],
 484 |     |                     blueprintPublishers[i]
 485 |     |                 )
 486 |     |             returns (
 487 |     |                 uint256, // availableSoil
 488 |     |                 address, // beanToken
 489 |     |                 uint32, // currentSeason
 490 |     |                 uint256, // pintoLeftToSow
 491 |     |                 uint256, // totalAmountToSow
 492 |     |                 uint256, // totalBeansNeeded
 493 |     |                 LibTractorHelpers.WithdrawalPlan memory // plan
 494 |     |             ) {
 495 |     |                 validOrderHashes[validCount] = orderHashes[i];
 496 |     |                 validCount++;
 497 |     |             } catch {
 498 |     |                 // Skip invalid parameters
 499 |     |                 continue;
 500 |     |             }
 501 |     |         }
 502 |     | 
 503 |     |         // Resize array to only include valid hashes
 504 |     |         assembly {
 505 |     |             mstore(validOrderHashes, validCount)
 506 |     |         }
 507 |     |     }
 508 |     | }
 509 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/TractorHelpers.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
   5 |     | import {Call, IWell, IERC20} from "../interfaces/basin/IWell.sol";
   6 |     | import {IBeanstalkWellFunction} from "contracts/interfaces/basin/IBeanstalkWellFunction.sol";
   7 |     | import {BeanstalkPrice, P} from "./price/BeanstalkPrice.sol";
   8 |     | import {ReservesType} from "./price/WellPrice.sol";
   9 |     | import {IBeanstalk} from "contracts/interfaces/IBeanstalk.sol";
  10 |     | import {Junction} from "./junction/Junction.sol";
  11 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  12 |     | import {PriceManipulation} from "./PriceManipulation.sol";
  13 |     | import {PerFunctionPausable} from "./PerFunctionPausable.sol";
  14 |     | import {IOperatorWhitelist} from "contracts/ecosystem/OperatorWhitelist.sol";
  15 |     | import {LibTractorHelpers} from "contracts/libraries/Silo/LibTractorHelpers.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title TractorHelpers
  19 |     |  * @author FordPinto
  20 |     |  * @notice Helper contract for Silo operations. For use with Tractor.
  21 |     |  */
  22 | *   | contract TractorHelpers is Junction, PerFunctionPausable {
  23 |     |     // Special token index values for withdrawal strategies
  24 |     |     uint8 internal constant LOWEST_PRICE_STRATEGY = type(uint8).max;
  25 |     |     uint8 internal constant LOWEST_SEED_STRATEGY = type(uint8).max - 1;
  26 |     | 
  27 |     |     IBeanstalk immutable beanstalk;
  28 |     |     BeanstalkPrice immutable beanstalkPrice;
  29 |     |     PriceManipulation immutable priceManipulation;
  30 |     | 
  31 |     |     enum RewardType {
  32 |     |         ERC20,
  33 |     |         ERC1155
  34 |     |     }
  35 |     | 
  36 |     |     event OperatorReward(
  37 |     |         RewardType rewardType,
  38 |     |         address indexed publisher,
  39 |     |         address indexed operator,
  40 |     |         address token,
  41 |     |         int256 amount
  42 |     |     );
  43 |     | 
  44 |     |     struct WithdrawLocalVars {
  45 |     |         address[] whitelistedTokens;
  46 |     |         address beanToken;
  47 |     |         uint256 remainingBeansNeeded;
  48 |     |         uint256 amountWithdrawn;
  49 |     |         int96[] stems;
  50 |     |         uint256[] amounts;
  51 |     |         uint256 availableAmount;
  52 |     |         uint256 lpNeeded;
  53 |     |         uint256 beansOut;
  54 |     |         // For valid source tracking
  55 |     |         address[] validSourceTokens;
  56 |     |         int96[][] validStems;
  57 |     |         uint256[][] validAmounts;
  58 |     |         uint256[] validAvailableBeans;
  59 |     |         uint256 validSourceCount;
  60 |     |         uint256 totalAvailableBeans;
  61 |     |     }
  62 |     | 
  63 | *   |     constructor(
  64 |     |         address _beanstalk,
  65 |     |         address _beanstalkPrice,
  66 |     |         address _owner,
  67 |     |         address _priceManipulation
  68 | *   |     ) PerFunctionPausable(_owner) {
  69 | *   |         beanstalk = IBeanstalk(_beanstalk);
  70 | *   |         beanstalkPrice = BeanstalkPrice(_beanstalkPrice);
  71 | *   |         priceManipulation = PriceManipulation(_priceManipulation);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Returns a plan for withdrawing beans from multiple sources
  76 |     |      * @param account The account to withdraw from
  77 |     |      * @param tokenIndices Array of indices corresponding to whitelisted tokens to try as sources.
  78 |     |      * Special cases when array length is 1:
  79 |     |      * - If value is LOWEST_PRICE_STRATEGY (uint8.max): Use tokens in ascending price order
  80 |     |      * - If value is LOWEST_SEED_STRATEGY (uint8.max - 1): Use tokens in ascending seed order
  81 |     |      * @param targetAmount The total amount of beans to withdraw
  82 |     |      * @param maxGrownStalkPerBdv The maximum amount of grown stalk allowed to be used for the withdrawal, per bdv
  83 |     |      * @param excludingPlan Optional plan containing deposits that have been partially used. The function will account for remaining amounts in these deposits.
  84 |     |      * @return plan The withdrawal plan containing source tokens, stems, amounts, and available beans
  85 |     |      */
  86 |     |     function getWithdrawalPlanExcludingPlan(
  87 |     |         address account,
  88 |     |         uint8[] memory tokenIndices,
  89 |     |         uint256 targetAmount,
  90 |     |         uint256 maxGrownStalkPerBdv,
  91 |     |         LibTractorHelpers.WithdrawalPlan memory excludingPlan
  92 |     |     ) public view returns (LibTractorHelpers.WithdrawalPlan memory plan) {
  93 |     |         require(tokenIndices.length > 0, "Must provide at least one source token");
  94 |     |         require(targetAmount > 0, "Must withdraw non-zero amount");
  95 |     | 
  96 |     |         WithdrawLocalVars memory vars;
  97 |     |         vars.whitelistedTokens = getWhitelistStatusAddresses();
  98 |     |         vars.beanToken = beanstalk.getBeanToken();
  99 |     |         vars.remainingBeansNeeded = targetAmount;
 100 |     | 
 101 |     |         // Handle strategy cases when array length is 1
 102 |     |         if (tokenIndices.length == 1) {
 103 |     |             if (tokenIndices[0] == LOWEST_PRICE_STRATEGY) {
 104 |     |                 // Use ascending price strategy
 105 |     |                 (tokenIndices, ) = getTokensAscendingPrice();
 106 |     |             } else if (tokenIndices[0] == LOWEST_SEED_STRATEGY) {
 107 |     |                 // Use ascending seeds strategy
 108 |     |                 (tokenIndices, ) = getTokensAscendingSeeds();
 109 |     |             }
 110 |     |         }
 111 |     | 
 112 |     |         vars.validSourceTokens = new address[](tokenIndices.length);
 113 |     |         vars.validStems = new int96[][](tokenIndices.length);
 114 |     |         vars.validAmounts = new uint256[][](tokenIndices.length);
 115 |     |         vars.validAvailableBeans = new uint256[](tokenIndices.length);
 116 |     |         vars.validSourceCount = 0;
 117 |     |         vars.totalAvailableBeans = 0;
 118 |     | 
 119 |     |         // Try each source token in order until we fulfill the target amount
 120 |     |         for (uint256 i = 0; i < tokenIndices.length && vars.remainingBeansNeeded > 0; i++) {
 121 |     |             require(tokenIndices[i] < vars.whitelistedTokens.length, "Invalid token index");
 122 |     | 
 123 |     |             address sourceToken = vars.whitelistedTokens[tokenIndices[i]];
 124 |     | 
 125 |     |             // Calculate minimum stem tip from grown stalk for this token
 126 |     |             (int96 minStem, ) = beanstalk.calculateStemForTokenFromGrownStalk(
 127 |     |                 sourceToken,
 128 |     |                 maxGrownStalkPerBdv,
 129 |     |                 1e6
 130 |     |             );
 131 |     | 
 132 |     |             // If source is bean token, calculate direct withdrawal
 133 |     |             if (sourceToken == vars.beanToken) {
 134 |     |                 (
 135 |     |                     vars.stems,
 136 |     |                     vars.amounts,
 137 |     |                     vars.availableAmount
 138 |     |                 ) = getDepositStemsAndAmountsToWithdraw(
 139 |     |                     account,
 140 |     |                     sourceToken,
 141 |     |                     vars.remainingBeansNeeded,
 142 |     |                     minStem,
 143 |     |                     excludingPlan
 144 |     |                 );
 145 |     | 
 146 |     |                 // Skip if no beans available from this source
 147 |     |                 if (vars.availableAmount == 0) continue;
 148 |     | 
 149 |     |                 // Update remainingBeansNeeded based on the amount available
 150 |     |                 vars.remainingBeansNeeded = vars.remainingBeansNeeded - vars.availableAmount;
 151 |     | 
 152 |     |                 // Add to valid sources
 153 |     |                 vars.validSourceTokens[vars.validSourceCount] = sourceToken;
 154 |     |                 vars.validStems[vars.validSourceCount] = vars.stems;
 155 |     |                 vars.validAmounts[vars.validSourceCount] = vars.amounts;
 156 |     |                 vars.validAvailableBeans[vars.validSourceCount] = vars.availableAmount;
 157 |     |                 vars.totalAvailableBeans += vars.availableAmount;
 158 |     |                 vars.validSourceCount++;
 159 |     |             } else {
 160 |     |                 // For LP tokens, first check how many beans we could get
 161 |     |                 vars.lpNeeded = getLPTokensToWithdrawForBeans(
 162 |     |                     vars.remainingBeansNeeded,
 163 |     |                     sourceToken
 164 |     |                 );
 165 |     | 
 166 |     |                 // Get available LP tokens
 167 |     |                 (
 168 |     |                     vars.stems,
 169 |     |                     vars.amounts,
 170 |     |                     vars.availableAmount
 171 |     |                 ) = getDepositStemsAndAmountsToWithdraw(
 172 |     |                     account,
 173 |     |                     sourceToken,
 174 |     |                     vars.lpNeeded,
 175 |     |                     minStem,
 176 |     |                     excludingPlan
 177 |     |                 );
 178 |     | 
 179 |     |                 // Skip if no LP available from this source
 180 |     |                 if (vars.availableAmount == 0) continue;
 181 |     | 
 182 |     |                 uint256 beansAvailable;
 183 |     | 
 184 |     |                 // If not enough LP to fulfill the full amount, see how many beans we can get
 185 |     |                 if (vars.availableAmount < vars.lpNeeded) {
 186 |     |                     // Calculate how many beans we can get from the available LP tokens
 187 |     |                     beansAvailable = IWell(sourceToken).getRemoveLiquidityOneTokenOut(
 188 |     |                         vars.availableAmount,
 189 |     |                         IERC20(vars.beanToken)
 190 |     |                     );
 191 |     |                 } else {
 192 |     |                     // If enough LP was available, it means there was enough to fulfill the full amount
 193 |     |                     beansAvailable = vars.remainingBeansNeeded;
 194 |     |                 }
 195 |     | 
 196 |     |                 vars.remainingBeansNeeded = vars.remainingBeansNeeded - beansAvailable;
 197 |     | 
 198 |     |                 // Add to valid sources
 199 |     |                 vars.validSourceTokens[vars.validSourceCount] = sourceToken;
 200 |     |                 vars.validStems[vars.validSourceCount] = vars.stems;
 201 |     |                 vars.validAmounts[vars.validSourceCount] = vars.amounts;
 202 |     |                 vars.validAvailableBeans[vars.validSourceCount] = beansAvailable;
 203 |     |                 vars.totalAvailableBeans += beansAvailable;
 204 |     |                 vars.validSourceCount++;
 205 |     |             }
 206 |     |         }
 207 |     | 
 208 |     |         require(vars.totalAvailableBeans != 0, "No beans available");
 209 |     | 
 210 |     |         // Now create the final plan with correctly sized arrays
 211 |     |         plan.sourceTokens = new address[](vars.validSourceCount);
 212 |     |         plan.stems = new int96[][](vars.validSourceCount);
 213 |     |         plan.amounts = new uint256[][](vars.validSourceCount);
 214 |     |         plan.availableBeans = new uint256[](vars.validSourceCount);
 215 |     |         plan.totalAvailableBeans = vars.totalAvailableBeans;
 216 |     | 
 217 |     |         // Copy valid sources to the final plan
 218 |     |         for (uint256 i = 0; i < vars.validSourceCount; i++) {
 219 |     |             plan.sourceTokens[i] = vars.validSourceTokens[i];
 220 |     |             plan.stems[i] = vars.validStems[i];
 221 |     |             plan.amounts[i] = vars.validAmounts[i];
 222 |     |             plan.availableBeans[i] = vars.validAvailableBeans[i];
 223 |     |         }
 224 |     | 
 225 |     |         return plan;
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice Returns a plan for withdrawing beans from multiple sources
 230 |     |      * @param account The account to withdraw from
 231 |     |      * @param tokenIndices Array of indices corresponding to whitelisted tokens to try as sources.
 232 |     |      * Special cases when array length is 1:
 233 |     |      * - If value is LOWEST_PRICE_STRATEGY (uint8.max): Use tokens in ascending price order
 234 |     |      * - If value is LOWEST_SEED_STRATEGY (uint8.max - 1): Use tokens in ascending seed order
 235 |     |      * @param targetAmount The total amount of beans to withdraw
 236 |     |      * @param maxGrownStalkPerBdv The maximum amount of grown stalk allowed to be used for the withdrawal, per bdv
 237 |     |      * @return plan The withdrawal plan containing source tokens, stems, amounts, and available beans
 238 |     |      */
 239 |     |     function getWithdrawalPlan(
 240 |     |         address account,
 241 |     |         uint8[] memory tokenIndices,
 242 |     |         uint256 targetAmount,
 243 |     |         uint256 maxGrownStalkPerBdv
 244 |     |     ) public view returns (LibTractorHelpers.WithdrawalPlan memory plan) {
 245 |     |         LibTractorHelpers.WithdrawalPlan memory emptyPlan;
 246 |     |         return
 247 |     |             getWithdrawalPlanExcludingPlan(
 248 |     |                 account,
 249 |     |                 tokenIndices,
 250 |     |                 targetAmount,
 251 |     |                 maxGrownStalkPerBdv,
 252 |     |                 emptyPlan
 253 |     |             );
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @notice Withdraws beans from multiple sources in order until the target amount is fulfilled
 258 |     |      * @param account The account to withdraw from
 259 |     |      * @param tokenIndices Array of indices corresponding to whitelisted tokens to try as sources.
 260 |     |      * Special cases when array length is 1:
 261 |     |      * - If value is LOWEST_PRICE_STRATEGY (uint8.max): Use tokens in ascending price order
 262 |     |      * - If value is LOWEST_SEED_STRATEGY (uint8.max - 1): Use tokens in ascending seed order
 263 |     |      * @param targetAmount The total amount of beans to withdraw
 264 |     |      * @param maxGrownStalkPerBdv The maximum amount of grown stalk allowed to be used for the withdrawal, per bdv
 265 |     |      * @param slippageRatio The price slippage ratio for a lp token withdrawal, between the instantaneous price and the current price
 266 |     |      * @param mode The transfer mode for sending tokens back to user
 267 |     |      * @param plan The withdrawal plan to use, or null to generate one
 268 |     |      * @return amountWithdrawn The total amount of beans withdrawn
 269 |     |      */
 270 |     |     function withdrawBeansFromSources(
 271 |     |         address account,
 272 |     |         uint8[] memory tokenIndices,
 273 |     |         uint256 targetAmount,
 274 |     |         uint256 maxGrownStalkPerBdv,
 275 |     |         uint256 slippageRatio,
 276 |     |         LibTransfer.To mode,
 277 |     |         LibTractorHelpers.WithdrawalPlan memory plan
 278 |     |     ) external payable whenFunctionNotPaused returns (uint256) {
 279 |     |         // If passed in plan is empty, get one
 280 |     |         if (plan.sourceTokens.length == 0) {
 281 |     |             plan = getWithdrawalPlan(account, tokenIndices, targetAmount, maxGrownStalkPerBdv);
 282 |     |         }
 283 |     | 
 284 |     |         uint256 amountWithdrawn = 0;
 285 |     |         address beanToken = beanstalk.getBeanToken();
 286 |     | 
 287 |     |         // Execute withdrawal plan
 288 |     |         for (uint256 i = 0; i < plan.sourceTokens.length; i++) {
 289 |     |             address sourceToken = plan.sourceTokens[i];
 290 |     | 
 291 |     |             // Skip Bean token for price manipulation check since it's not a Well
 292 |     |             if (sourceToken != beanToken) {
 293 |     |                 // Check for price manipulation in the Well
 294 |     |                 (address nonBeanToken, ) = IBeanstalk(beanstalk).getNonBeanTokenAndIndexFromWell(
 295 |     |                     sourceToken
 296 |     |                 );
 297 |     |                 require(
 298 |     |                     priceManipulation.isValidSlippage(
 299 |     |                         IWell(sourceToken),
 300 |     |                         IERC20(nonBeanToken),
 301 |     |                         slippageRatio
 302 |     |                     ),
 303 |     |                     "Price manipulation detected"
 304 |     |                 );
 305 |     |             }
 306 |     | 
 307 |     |             // If source is bean token, withdraw directly
 308 |     |             if (sourceToken == beanToken) {
 309 |     |                 beanstalk.withdrawDeposits(sourceToken, plan.stems[i], plan.amounts[i], mode);
 310 |     |                 amountWithdrawn += plan.availableBeans[i];
 311 |     |             } else {
 312 |     |                 // For LP tokens, first withdraw LP tokens to the user's internal balance
 313 |     |                 beanstalk.withdrawDeposits(
 314 |     |                     sourceToken,
 315 |     |                     plan.stems[i],
 316 |     |                     plan.amounts[i],
 317 |     |                     LibTransfer.To.INTERNAL
 318 |     |                 );
 319 |     | 
 320 |     |                 // Calculate total amount of LP tokens to transfer
 321 |     |                 uint256 totalLPAmount = 0;
 322 |     |                 for (uint256 j = 0; j < plan.amounts[i].length; j++) {
 323 |     |                     totalLPAmount += plan.amounts[i][j];
 324 |     |                 }
 325 |     | 
 326 |     |                 // Transfer LP tokens to this contract's external balance
 327 |     |                 beanstalk.transferInternalTokenFrom(
 328 |     |                     IERC20(sourceToken),
 329 |     |                     account,
 330 |     |                     address(this),
 331 |     |                     totalLPAmount, // Use the total sum of all amounts
 332 |     |                     LibTransfer.To.EXTERNAL
 333 |     |                 );
 334 |     | 
 335 |     |                 // Then remove liquidity to get Beans
 336 |     |                 IERC20(sourceToken).approve(sourceToken, totalLPAmount);
 337 |     |                 IWell(sourceToken).removeLiquidityOneToken(
 338 |     |                     totalLPAmount,
 339 |     |                     IERC20(beanToken),
 340 |     |                     plan.availableBeans[i],
 341 |     |                     address(this),
 342 |     |                     type(uint256).max
 343 |     |                 );
 344 |     | 
 345 |     |                 // Transfer from this contract's external balance to the user's internal/external balance depending on mode
 346 |     |                 if (mode == LibTransfer.To.INTERNAL) {
 347 |     |                     // approve spending of Beans from this contract's external balance
 348 |     |                     IERC20(beanToken).approve(address(beanstalk), plan.availableBeans[i]);
 349 |     |                     beanstalk.sendTokenToInternalBalance(
 350 |     |                         beanToken,
 351 |     |                         account,
 352 |     |                         plan.availableBeans[i]
 353 |     |                     );
 354 |     |                 } else {
 355 |     |                     IERC20(beanToken).transfer(account, plan.availableBeans[i]);
 356 |     |                 }
 357 |     |                 amountWithdrawn += plan.availableBeans[i];
 358 |     |             }
 359 |     |         }
 360 |     | 
 361 |     |         return amountWithdrawn;
 362 |     |     }
 363 |     | 
 364 |     |     /**
 365 |     |      * @notice Returns the BeanstalkPrice contract address
 366 |     |      */
 367 |     |     function getBeanstalkPrice() external view returns (address) {
 368 |     |         return address(beanstalkPrice);
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @notice Returns all whitelisted assets and their seed values, sorted from highest to lowest seeds
 373 |     |      * @return tokens Array of token addresses
 374 |     |      * @return seeds Array of corresponding seed values
 375 |     |      */
 376 |     |     function getSortedWhitelistedTokensBySeeds()
 377 |     |         external
 378 |     |         view
 379 |     |         returns (address[] memory tokens, uint256[] memory seeds)
 380 |     |     {
 381 |     |         // Get whitelisted tokens
 382 |     |         tokens = getWhitelistStatusAddresses();
 383 |     |         seeds = new uint256[](tokens.length);
 384 |     | 
 385 |     |         // Get seed values for each token
 386 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 387 |     |             seeds[i] = beanstalk.tokenSettings(tokens[i]).stalkEarnedPerSeason;
 388 |     |         }
 389 |     | 
 390 |     |         // Sort tokens and seeds arrays (bubble sort)
 391 |     |         (tokens, seeds) = sortTokens(tokens, seeds);
 392 |     | 
 393 |     |         return (tokens, seeds);
 394 |     |     }
 395 |     | 
 396 |     |     /**
 397 |     |      * @notice Returns the token with the highest seed value and its seed amount
 398 |     |      * @return highestSeedToken The token address with the highest seed value
 399 |     |      * @return seedAmount The seed value of the highest seed token
 400 |     |      */
 401 |     |     function getHighestSeedToken()
 402 |     |         external
 403 |     |         view
 404 |     |         returns (address highestSeedToken, uint256 seedAmount)
 405 |     |     {
 406 |     |         address[] memory tokens = getWhitelistStatusAddresses();
 407 |     |         require(tokens.length > 0, "No whitelisted tokens");
 408 |     | 
 409 |     |         highestSeedToken = tokens[0];
 410 |     |         seedAmount = beanstalk.tokenSettings(tokens[0]).stalkEarnedPerSeason;
 411 |     | 
 412 |     |         for (uint256 i = 1; i < tokens.length; i++) {
 413 |     |             uint256 currentSeed = beanstalk.tokenSettings(tokens[i]).stalkEarnedPerSeason;
 414 |     |             if (currentSeed > seedAmount) {
 415 |     |                 seedAmount = currentSeed;
 416 |     |                 highestSeedToken = tokens[i];
 417 |     |             }
 418 |     |         }
 419 |     | 
 420 |     |         return (highestSeedToken, seedAmount);
 421 |     |     }
 422 |     | 
 423 |     |     /**
 424 |     |      * @notice Returns the token with the lowest seed value and its seed amount
 425 |     |      * @return lowestSeedToken The token address with the lowest seed value
 426 |     |      * @return seedAmount The seed value of the lowest seed token
 427 |     |      */
 428 |     |     function getLowestSeedToken()
 429 |     |         external
 430 |     |         view
 431 |     |         returns (address lowestSeedToken, uint256 seedAmount)
 432 |     |     {
 433 |     |         address[] memory tokens = getWhitelistStatusAddresses();
 434 |     |         require(tokens.length > 0, "No whitelisted tokens");
 435 |     | 
 436 |     |         lowestSeedToken = tokens[0];
 437 |     |         seedAmount = beanstalk.tokenSettings(tokens[0]).stalkEarnedPerSeason;
 438 |     | 
 439 |     |         for (uint256 i = 1; i < tokens.length; i++) {
 440 |     |             uint256 currentSeed = beanstalk.tokenSettings(tokens[i]).stalkEarnedPerSeason;
 441 |     |             if (currentSeed < seedAmount) {
 442 |     |                 seedAmount = currentSeed;
 443 |     |                 lowestSeedToken = tokens[i];
 444 |     |             }
 445 |     |         }
 446 |     | 
 447 |     |         return (lowestSeedToken, seedAmount);
 448 |     |     }
 449 |     | 
 450 |     |     /**
 451 |     |      * @notice Gets the list of tokens that a user has deposited in the silo
 452 |     |      * @param account The address of the user
 453 |     |      * @return depositedTokens Array of token addresses that the user has deposited
 454 |     |      */
 455 |     |     function getUserDepositedTokens(
 456 |     |         address account
 457 |     |     ) external view returns (address[] memory depositedTokens) {
 458 |     |         address[] memory allWhitelistedTokens = getWhitelistStatusAddresses();
 459 |     | 
 460 |     |         // First, get the mow status for all tokens to check which ones have deposits
 461 |     |         IBeanstalk.MowStatus[] memory mowStatuses = beanstalk.getMowStatus(
 462 |     |             account,
 463 |     |             allWhitelistedTokens
 464 |     |         );
 465 |     | 
 466 |     |         // Count how many tokens have deposits (bdv > 0)
 467 |     |         uint256 depositedTokenCount = 0;
 468 |     |         for (uint256 i = 0; i < mowStatuses.length; i++) {
 469 |     |             if (mowStatuses[i].bdv > 0) {
 470 |     |                 depositedTokenCount++;
 471 |     |             }
 472 |     |         }
 473 |     | 
 474 |     |         // Create array of the right size for deposited tokens
 475 |     |         depositedTokens = new address[](depositedTokenCount);
 476 |     | 
 477 |     |         // Fill the array with tokens that have deposits
 478 |     |         uint256 index = 0;
 479 |     |         for (uint256 i = 0; i < mowStatuses.length; i++) {
 480 |     |             if (mowStatuses[i].bdv > 0) {
 481 |     |                 depositedTokens[index] = allWhitelistedTokens[i];
 482 |     |                 index++;
 483 |     |             }
 484 |     |         }
 485 |     | 
 486 |     |         return depositedTokens;
 487 |     |     }
 488 |     | 
 489 |     |     /**
 490 |     |      * @notice Returns arrays of stems and amounts for all deposits, sorted by stem in descending order
 491 |     |      * @dev This function could be made more gas efficient by using a more efficient sorting algorithm
 492 |     |      * @param account The address of the account that owns the deposits
 493 |     |      * @param token The token to get deposits for
 494 |     |      * @param amount The amount of tokens to withdraw
 495 |     |      * @param minStem The minimum stem value to consider for withdrawal
 496 |     |      * @param excludingPlan Optional plan containing deposits that have been partially used. The function will account for remaining amounts in these deposits.
 497 |     |      * @return stems Array of stems in descending order
 498 |     |      * @return amounts Array of corresponding amounts for each stem
 499 |     |      * @return availableAmount The total amount available to withdraw (may be less than requested amount)
 500 |     |      */
 501 |     |     function getDepositStemsAndAmountsToWithdraw(
 502 |     |         address account,
 503 |     |         address token,
 504 |     |         uint256 amount,
 505 |     |         int96 minStem,
 506 |     |         LibTractorHelpers.WithdrawalPlan memory excludingPlan
 507 |     |     )
 508 |     |         public
 509 |     |         view
 510 |     |         returns (int96[] memory stems, uint256[] memory amounts, uint256 availableAmount)
 511 |     |     {
 512 |     |         uint256[] memory depositIds = beanstalk.getTokenDepositIdsForAccount(account, token);
 513 |     |         if (depositIds.length == 0) return (new int96[](0), new uint256[](0), 0);
 514 |     | 
 515 |     |         // Initialize arrays with max possible size
 516 |     |         stems = new int96[](depositIds.length);
 517 |     |         amounts = new uint256[](depositIds.length);
 518 |     | 
 519 |     |         // Track state
 520 |     |         uint256 remainingBeansNeeded = amount;
 521 |     |         uint256 currentIndex;
 522 |     |         availableAmount = 0;
 523 |     | 
 524 |     |         // Process deposits in reverse order (highest stem to lowest)
 525 |     |         for (uint256 i = depositIds.length; i > 0; i--) {
 526 |     |             (, int96 stem) = getAddressAndStem(depositIds[i - 1]);
 527 |     | 
 528 |     |             // Skip if stem is less than minStem
 529 |     |             if (stem < minStem) {
 530 |     |                 continue;
 531 |     |             }
 532 |     | 
 533 |     |             (uint256 depositAmount, ) = beanstalk.getDeposit(account, token, stem);
 534 |     | 
 535 |     |             // Check if this deposit is in the existing plan and calculate remaining amount
 536 |     |             uint256 remainingAmount = depositAmount;
 537 |     |             for (uint256 j = 0; j < excludingPlan.sourceTokens.length; j++) {
 538 |     |                 if (excludingPlan.sourceTokens[j] == token) {
 539 |     |                     for (uint256 k = 0; k < excludingPlan.stems[j].length; k++) {
 540 |     |                         if (excludingPlan.stems[j][k] == stem) {
 541 |     |                             // If the deposit was fully used in the existing plan, skip it
 542 |     |                             if (excludingPlan.amounts[j][k] >= depositAmount) {
 543 |     |                                 remainingAmount = 0;
 544 |     |                                 break;
 545 |     |                             }
 546 |     |                             // Otherwise, subtract the used amount from the remaining amount
 547 |     |                             remainingAmount = depositAmount - excludingPlan.amounts[j][k];
 548 |     |                             break;
 549 |     |                         }
 550 |     |                     }
 551 |     |                     if (remainingAmount == 0) break;
 552 |     |                 }
 553 |     |             }
 554 |     | 
 555 |     |             // Skip if no remaining amount available
 556 |     |             if (remainingAmount == 0) continue;
 557 |     | 
 558 |     |             // Calculate amount to take from this deposit
 559 |     |             uint256 amountFromDeposit = remainingAmount;
 560 |     |             if (remainingAmount > remainingBeansNeeded) {
 561 |     |                 amountFromDeposit = remainingBeansNeeded;
 562 |     |             }
 563 |     | 
 564 |     |             stems[currentIndex] = stem;
 565 |     |             amounts[currentIndex] = amountFromDeposit;
 566 |     |             availableAmount += amountFromDeposit;
 567 |     |             remainingBeansNeeded -= amountFromDeposit;
 568 |     |             currentIndex++;
 569 |     | 
 570 |     |             if (remainingBeansNeeded == 0) break;
 571 |     |         }
 572 |     | 
 573 |     |         // Resize arrays using assembly to match currentIndex
 574 |     |         assembly {
 575 |     |             mstore(stems, currentIndex)
 576 |     |             mstore(amounts, currentIndex)
 577 |     |         }
 578 |     | 
 579 |     |         return (stems, amounts, availableAmount);
 580 |     |     }
 581 |     | 
 582 |     |     /**
 583 |     |      * @notice Returns arrays of stems and amounts for all deposits, sorted by stem in descending order
 584 |     |      * @dev This function could be made more gas efficient by using a more efficient sorting algorithm
 585 |     |      * @param account The address of the account that owns the deposits
 586 |     |      * @param token The token to get deposits for
 587 |     |      * @param amount The amount of tokens to withdraw
 588 |     |      * @param minStem The minimum stem value to consider for withdrawal
 589 |     |      * @return stems Array of stems in descending order
 590 |     |      * @return amounts Array of corresponding amounts for each stem
 591 |     |      * @return availableAmount The total amount available to withdraw (may be less than requested amount)
 592 |     |      */
 593 |     |     function getDepositStemsAndAmountsToWithdraw(
 594 |     |         address account,
 595 |     |         address token,
 596 |     |         uint256 amount,
 597 |     |         int96 minStem
 598 |     |     )
 599 |     |         public
 600 |     |         view
 601 |     |         returns (int96[] memory stems, uint256[] memory amounts, uint256 availableAmount)
 602 |     |     {
 603 |     |         LibTractorHelpers.WithdrawalPlan memory emptyPlan;
 604 |     |         return getDepositStemsAndAmountsToWithdraw(account, token, amount, minStem, emptyPlan);
 605 |     |     }
 606 |     | 
 607 |     |     /**
 608 |     |      * @notice Helper function to get the address and stem from a deposit ID
 609 |     |      * @dev This is a copy of LibBytes.unpackAddressAndStem for gas purposes
 610 |     |      * @param depositId The ID of the deposit to get the address and stem for
 611 |     |      * @return token The address of the token
 612 |     |      * @return stem The stem value of the deposit
 613 |     |      */
 614 |     |     function getAddressAndStem(uint256 depositId) public pure returns (address token, int96 stem) {
 615 |     |         return (address(uint160(depositId >> 96)), int96(int256(depositId)));
 616 |     |     }
 617 |     | 
 618 |     |     /**
 619 |     |      * @notice Returns the amount of LP tokens that must be withdrawn to receive a specific amount of Beans
 620 |     |      * @param beanAmount The amount of Beans desired
 621 |     |      * @param well The Well LP token address
 622 |     |      * @return lpAmount The amount of LP tokens needed
 623 |     |      */
 624 |     |     function getLPTokensToWithdrawForBeans(
 625 |     |         uint256 beanAmount,
 626 |     |         address well
 627 |     |     ) public view returns (uint256 lpAmount) {
 628 |     |         // Get current reserves if not provided
 629 |     |         uint256[] memory reserves = IWell(well).getReserves();
 630 |     | 
 631 |     |         // Get bean index in the well
 632 |     |         uint256 beanIndex = beanstalk.getBeanIndex(IWell(well).tokens());
 633 |     | 
 634 |     |         // Get the well function
 635 |     |         Call memory wellFunction = IWell(well).wellFunction();
 636 |     | 
 637 |     |         // Calculate current LP supply
 638 |     |         uint256 lpSupplyNow = IBeanstalkWellFunction(wellFunction.target).calcLpTokenSupply(
 639 |     |             reserves,
 640 |     |             wellFunction.data
 641 |     |         );
 642 |     | 
 643 |     |         // Calculate reserves after removing beans
 644 |     | 
 645 |     |         reserves[beanIndex] = reserves[beanIndex] - beanAmount;
 646 |     | 
 647 |     |         // Calculate new LP supply after removing beans
 648 |     |         uint256 lpSupplyAfter = IBeanstalkWellFunction(wellFunction.target).calcLpTokenSupply(
 649 |     |             reserves,
 650 |     |             wellFunction.data
 651 |     |         );
 652 |     | 
 653 |     |         // The difference is how many LP tokens need to be removed in order to withdraw beanAmount
 654 |     |         return lpSupplyNow - lpSupplyAfter;
 655 |     |     }
 656 |     | 
 657 |     |     /**
 658 |     |      * @notice Returns all whitelisted tokens sorted by seed value (ascending)
 659 |     |      * @return tokenIndices Array of token indices in the whitelisted tokens array, sorted by seed value (ascending)
 660 |     |      * @return seeds Array of corresponding seed values
 661 |     |      */
 662 |     |     function getTokensAscendingSeeds()
 663 |     |         public
 664 |     |         view
 665 |     |         returns (uint8[] memory tokenIndices, uint256[] memory seeds)
 666 |     |     {
 667 |     |         // Get whitelisted tokens with their status
 668 |     |         IBeanstalk.WhitelistStatus[] memory whitelistStatuses = beanstalk.getWhitelistStatuses();
 669 |     |         require(whitelistStatuses.length > 0, "No whitelisted tokens");
 670 |     | 
 671 |     |         // Count active whitelisted tokens (not dewhitelisted)
 672 |     |         uint256 whitelistedCount = 0;
 673 |     |         for (uint256 i = 0; i < whitelistStatuses.length; i++) {
 674 |     |             if (whitelistStatuses[i].isWhitelisted) {
 675 |     |                 whitelistedCount++;
 676 |     |             }
 677 |     |         }
 678 |     | 
 679 |     |         require(whitelistedCount > 0, "No active whitelisted tokens");
 680 |     | 
 681 |     |         // Initialize arrays with the count of active whitelisted tokens
 682 |     |         tokenIndices = new uint8[](whitelistedCount);
 683 |     |         seeds = new uint256[](whitelistedCount);
 684 |     | 
 685 |     |         // Populate arrays with only active whitelisted tokens
 686 |     |         uint256 activeIndex = 0;
 687 |     |         for (uint256 i = 0; i < whitelistStatuses.length; i++) {
 688 |     |             if (whitelistStatuses[i].isWhitelisted) {
 689 |     |                 // Keep the original index from whitelistStatuses for tokenIndices
 690 |     |                 tokenIndices[activeIndex] = uint8(i);
 691 |     |                 seeds[activeIndex] = beanstalk
 692 |     |                     .tokenSettings(whitelistStatuses[i].token)
 693 |     |                     .stalkEarnedPerSeason;
 694 |     |                 activeIndex++;
 695 |     |             }
 696 |     |         }
 697 |     | 
 698 |     |         // Sort arrays by seed value (ascending)
 699 |     |         (tokenIndices, seeds) = sortTokenIndices(tokenIndices, seeds);
 700 |     | 
 701 |     |         return (tokenIndices, seeds);
 702 |     |     }
 703 |     | 
 704 |     |     /**
 705 |     |      * @notice Returns all whitelisted tokens sorted by price (ascending)
 706 |     |      * @return tokenIndices Array of token indices in the whitelisted tokens array, sorted by price (ascending)
 707 |     |      * @return prices Array of corresponding prices
 708 |     |      */
 709 |     |     function getTokensAscendingPrice()
 710 |     |         public
 711 |     |         view
 712 |     |         returns (uint8[] memory tokenIndices, uint256[] memory prices)
 713 |     |     {
 714 |     |         // Get whitelisted tokens with their status
 715 |     |         IBeanstalk.WhitelistStatus[] memory whitelistStatuses = beanstalk.getWhitelistStatuses();
 716 |     |         require(whitelistStatuses.length > 0, "No whitelisted tokens");
 717 |     | 
 718 |     |         // Count active whitelisted tokens (not dewhitelisted)
 719 |     |         uint256 whitelistedCount = 0;
 720 |     |         for (uint256 i = 0; i < whitelistStatuses.length; i++) {
 721 |     |             if (whitelistStatuses[i].isWhitelisted) {
 722 |     |                 whitelistedCount++;
 723 |     |             }
 724 |     |         }
 725 |     | 
 726 |     |         require(whitelistedCount > 0, "No active whitelisted tokens");
 727 |     | 
 728 |     |         // Initialize arrays with the count of active whitelisted tokens
 729 |     |         tokenIndices = new uint8[](whitelistedCount);
 730 |     |         prices = new uint256[](whitelistedCount);
 731 |     | 
 732 |     |         // Get price from BeanstalkPrice for both Bean and LP tokens
 733 |     |         BeanstalkPrice.Prices memory p = beanstalkPrice.price(ReservesType.INSTANTANEOUS_RESERVES);
 734 |     | 
 735 |     |         // Populate arrays with only active whitelisted tokens
 736 |     |         uint256 activeIndex = 0;
 737 |     |         for (uint256 i = 0; i < whitelistStatuses.length; i++) {
 738 |     |             if (whitelistStatuses[i].isWhitelisted) {
 739 |     |                 // Keep the original index from whitelistStatuses for tokenIndices
 740 |     |                 tokenIndices[activeIndex] = uint8(i);
 741 |     |                 prices[activeIndex] = getTokenPrice(whitelistStatuses[i].token, p);
 742 |     |                 activeIndex++;
 743 |     |             }
 744 |     |         }
 745 |     | 
 746 |     |         // Sort arrays by price (ascending)
 747 |     |         (tokenIndices, prices) = sortTokenIndices(tokenIndices, prices);
 748 |     | 
 749 |     |         return (tokenIndices, prices);
 750 |     |     }
 751 |     | 
 752 |     |     /**
 753 |     |      * @notice Returns arrays of stems and amounts for all deposits, sorted by stem in descending order
 754 |     |      * @dev This function could be made more gas efficient by using a more efficient sorting algorithm
 755 |     |      * @param account The address of the account that owns the deposits
 756 |     |      * @param token The token to get deposits for
 757 |     |      * @return stems Array of stems in descending order
 758 |     |      * @return amounts Array of corresponding amounts for each stem
 759 |     |      */
 760 |     |     function getSortedDeposits(
 761 |     |         address account,
 762 |     |         address token
 763 |     |     ) public view returns (int96[] memory stems, uint256[] memory amounts) {
 764 |     |         uint256[] memory depositIds = beanstalk.getTokenDepositIdsForAccount(account, token);
 765 |     |         if (depositIds.length == 0) revert("No deposits");
 766 |     | 
 767 |     |         // Initialize arrays with exact size since we know all deposits are valid
 768 |     |         stems = new int96[](depositIds.length);
 769 |     |         amounts = new uint256[](depositIds.length);
 770 |     | 
 771 |     |         // Collect all deposits
 772 |     |         for (uint256 i = 0; i < depositIds.length; i++) {
 773 |     |             (, int96 stem) = getAddressAndStem(depositIds[i]);
 774 |     |             (uint256 amount, ) = beanstalk.getDeposit(account, token, stem);
 775 |     |             stems[i] = stem;
 776 |     |             amounts[i] = amount;
 777 |     |         }
 778 |     | 
 779 |     |         // Sort deposits by stem in descending order using bubble sort
 780 |     |         for (uint256 i = 0; i < depositIds.length - 1; i++) {
 781 |     |             for (uint256 j = 0; j < depositIds.length - i - 1; j++) {
 782 |     |                 if (stems[j] < stems[j + 1]) {
 783 |     |                     // Swap stems
 784 |     |                     int96 tempStem = stems[j];
 785 |     |                     stems[j] = stems[j + 1];
 786 |     |                     stems[j + 1] = tempStem;
 787 |     | 
 788 |     |                     // Swap corresponding amounts
 789 |     |                     uint256 tempAmount = amounts[j];
 790 |     |                     amounts[j] = amounts[j + 1];
 791 |     |                     amounts[j + 1] = tempAmount;
 792 |     |                 }
 793 |     |             }
 794 |     |         }
 795 |     |     }
 796 |     | 
 797 |     |     /**
 798 |     |      * @notice Returns the total amount of Beans available from a given token
 799 |     |      * @param account The address of the account that owns the deposits
 800 |     |      * @param token The token to calculate available beans from (either Bean or LP token)
 801 |     |      * @return beanAmountAvailable The amount of Beans available if token is Bean, or the amount of
 802 |     |      * Beans that would be received from removing all LP if token is an LP token
 803 |     |      */
 804 |     |     function getBeanAmountAvailable(
 805 |     |         address account,
 806 |     |         address token
 807 |     |     ) external view returns (uint256 beanAmountAvailable) {
 808 |     |         // Get total amount deposited
 809 |     |         (, uint256[] memory amounts) = getSortedDeposits(account, token);
 810 |     |         uint256 totalAmount;
 811 |     |         for (uint256 i = 0; i < amounts.length; i++) {
 812 |     |             totalAmount += amounts[i];
 813 |     |         }
 814 |     | 
 815 |     |         // If token is Bean, return total amount
 816 |     |         if (token == beanstalk.getBeanToken()) {
 817 |     |             return totalAmount;
 818 |     |         }
 819 |     | 
 820 |     |         // If token is LP and we have deposits, calculate Bean amount from LP
 821 |     |         if (totalAmount > 0) {
 822 |     |             return
 823 |     |                 IWell(token).getRemoveLiquidityOneTokenOut(
 824 |     |                     totalAmount,
 825 |     |                     IERC20(beanstalk.getBeanToken())
 826 |     |                 );
 827 |     |         }
 828 |     | 
 829 |     |         return 0;
 830 |     |     }
 831 |     | 
 832 |     |     /**
 833 |     |      * @notice Returns the index of a token in the whitelisted tokens array
 834 |     |      * @dev Returns 0 for the bean token, otherwise returns the index in the whitelisted tokens array
 835 |     |      * @param token The token to get the index for
 836 |     |      * @return index The index of the token (0 for bean token, otherwise index in whitelisted tokens array)
 837 |     |      */
 838 |     |     function getTokenIndex(address token) public view returns (uint8 index) {
 839 |     |         // This relies on the assumption that the Bean token is whitelisted first
 840 |     |         if (token == beanstalk.getBeanToken()) {
 841 |     |             return 0;
 842 |     |         }
 843 |     |         address[] memory whitelistedTokens = getWhitelistStatusAddresses();
 844 |     |         for (uint256 i = 0; i < whitelistedTokens.length; i++) {
 845 |     |             if (whitelistedTokens[i] == token) {
 846 |     |                 return uint8(i);
 847 |     |             }
 848 |     |         }
 849 |     |         revert("Token not found");
 850 |     |     }
 851 |     | 
 852 |     |     /**
 853 |     |      * @notice Helper function to get the price of a token from BeanstalkPrice
 854 |     |      * @param token The token to get the price for
 855 |     |      * @param p The Prices struct from BeanstalkPrice
 856 |     |      * @return price The price of the token
 857 |     |      */
 858 |     |     function getTokenPrice(
 859 |     |         address token,
 860 |     |         BeanstalkPrice.Prices memory p
 861 |     |     ) internal view returns (uint256 price) {
 862 |     |         address bean = beanstalk.getBeanToken();
 863 |     |         if (token == bean) {
 864 |     |             return p.price;
 865 |     |         }
 866 |     |         // Find the non-Bean token in the pool's tokens array
 867 |     |         for (uint256 j = 0; j < p.ps.length; j++) {
 868 |     |             if (p.ps[j].pool == token) {
 869 |     |                 return p.ps[j].price;
 870 |     |             }
 871 |     |         }
 872 |     |         revert("Token price not found");
 873 |     |     }
 874 |     | 
 875 |     |     /**
 876 |     |      * @notice Sorts tokens in ascending order based on the index array
 877 |     |      * @param tokens The tokens to sort
 878 |     |      * @param index The index array
 879 |     |      * @return sortedTokens The sorted tokens
 880 |     |      * @return sortedIndex The sorted index
 881 |     |      */
 882 |     |     function sortTokens(
 883 |     |         address[] memory tokens,
 884 |     |         uint256[] memory index
 885 |     |     ) internal pure returns (address[] memory, uint256[] memory) {
 886 |     |         return LibTractorHelpers.sortTokens(tokens, index);
 887 |     |     }
 888 |     | 
 889 |     |     function sortTokenIndices(
 890 |     |         uint8[] memory tokenIndices,
 891 |     |         uint256[] memory index
 892 |     |     ) internal pure returns (uint8[] memory, uint256[] memory) {
 893 |     |         return LibTractorHelpers.sortTokenIndices(tokenIndices, index);
 894 |     |     }
 895 |     | 
 896 |     |     /**
 897 |     |      * @notice helper function to tip the operator.
 898 |     |      * @dev if `tipAmount` is negative, the publisher is tipped instead.
 899 |     |      */
 900 |     |     function tip(
 901 |     |         address token,
 902 |     |         address publisher,
 903 |     |         address tipAddress,
 904 |     |         int256 tipAmount,
 905 |     |         LibTransfer.From from,
 906 |     |         LibTransfer.To to
 907 |     |     ) external {
 908 |     |         // Handle tip transfer based on whether it's positive or negative
 909 |     |         if (tipAmount > 0) {
 910 |     |             // Transfer tip to operator
 911 |     |             beanstalk.transferToken(IERC20(token), tipAddress, uint256(tipAmount), from, to);
 912 |     |         } else if (tipAmount < 0) {
 913 |     |             // Transfer tip from operator to user
 914 |     |             beanstalk.transferInternalTokenFrom(
 915 |     |                 IERC20(token),
 916 |     |                 tipAddress,
 917 |     |                 publisher,
 918 |     |                 uint256(-tipAmount),
 919 |     |                 to
 920 |     |             );
 921 |     |         }
 922 |     | 
 923 |     |         emit OperatorReward(RewardType.ERC20, publisher, tipAddress, token, tipAmount);
 924 |     |     }
 925 |     | 
 926 |     |     /**
 927 |     |      * @notice Checks if the current operator is whitelisted
 928 |     |      * @param whitelistedOperators Array of whitelisted operator addresses
 929 |     |      * @return isWhitelisted Whether the current operator is whitelisted
 930 |     |      */
 931 |     |     function isOperatorWhitelisted(
 932 |     |         address[] calldata whitelistedOperators
 933 |     |     ) external view returns (bool) {
 934 |     |         return LibTractorHelpers.isOperatorWhitelisted(whitelistedOperators, beanstalk);
 935 |     |     }
 936 |     | 
 937 |     |     /**
 938 |     |      * @notice Combines multiple withdrawal plans into a single plan
 939 |     |      * @dev This function aggregates the amounts used from each deposit across all plans
 940 |     |      * @param plans Array of withdrawal plans to combine
 941 |     |      * @return combinedPlan A single withdrawal plan that represents the total usage across all input plans
 942 |     |      */
 943 |     |     function combineWithdrawalPlans(
 944 |     |         LibTractorHelpers.WithdrawalPlan[] memory plans
 945 |     |     ) external view returns (LibTractorHelpers.WithdrawalPlan memory) {
 946 |     |         // Call the library function directly
 947 |     |         return LibTractorHelpers.combineWithdrawalPlans(plans, beanstalk);
 948 |     |     }
 949 |     | 
 950 |     |     /**
 951 |     |      * @notice Returns the addresses of all whitelisted tokens, even those that have been Dewhitelisted
 952 |     |      * @return addresses The addresses of all whitelisted tokens
 953 |     |      */
 954 |     |     function getWhitelistStatusAddresses() public view returns (address[] memory) {
 955 |     |         IBeanstalk.WhitelistStatus[] memory whitelistStatuses = beanstalk.getWhitelistStatuses();
 956 |     |         address[] memory addresses = new address[](whitelistStatuses.length);
 957 |     |         for (uint256 i = 0; i < whitelistStatuses.length; i++) {
 958 |     |             addresses[i] = whitelistStatuses[i].token;
 959 |     |         }
 960 |     |         return addresses;
 961 |     |     }
 962 |     | }
 963 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/junction/Junction.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {MathJunction} from "./MathJunction.sol";
  8 |     | import {LogicJunction} from "./LogicJunction.sol";
  9 |     | 
 10 | *   | contract Junction is MathJunction, LogicJunction {
 11 |     |     function check(bool condition) public pure {
 12 |     |         require(condition, "Junction: check failed");
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/junction/LogicJunction.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | /**
  8 |     |  * @title LogicJunction
  9 |     |  * @notice A Junction library that contains basic logic operations on uint256.
 10 |     |  **/
 11 | *   | contract LogicJunction {
 12 |     |     function gt(uint256 a, uint256 b) public pure returns (bool) {
 13 |     |         return a > b;
 14 |     |     }
 15 |     | 
 16 |     |     function gte(uint256 a, uint256 b) public pure returns (bool) {
 17 |     |         return a >= b;
 18 |     |     }
 19 |     | 
 20 |     |     function lt(uint256 a, uint256 b) public pure returns (bool) {
 21 |     |         return a < b;
 22 |     |     }
 23 |     | 
 24 |     |     function lte(uint256 a, uint256 b) public pure returns (bool) {
 25 |     |         return a <= b;
 26 |     |     }
 27 |     | 
 28 |     |     function eq(uint256 a, uint256 b) public pure returns (bool) {
 29 |     |         return a == b;
 30 |     |     }
 31 |     | 
 32 |     |     function neq(uint256 a, uint256 b) public pure returns (bool) {
 33 |     |         return a != b;
 34 |     |     }
 35 |     | 
 36 |     |     function bytes32Switch(
 37 |     |         uint256 selector,
 38 |     |         bytes32[] calldata options
 39 |     |     ) public pure returns (bytes32) {
 40 |     |         return options[selector];
 41 |     |     }
 42 |     | }
 43 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/junction/MathJunction.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | /**
  8 |     |  * @title MathJunction
  9 |     |  * @notice A Junction library that enables basic safe math functionality for blueprint encoded calls.
 10 |     |  **/
 11 | *   | contract MathJunction {
 12 |     |     function add(uint256 a, uint256 b) public pure returns (uint256) {
 13 |     |         return a + b;
 14 |     |     }
 15 |     | 
 16 |     |     function sub(uint256 a, uint256 b) public pure returns (uint256) {
 17 |     |         return a - b;
 18 |     |     }
 19 |     | 
 20 |     |     function mul(uint256 a, uint256 b) public pure returns (uint256) {
 21 |     |         return a * b;
 22 |     |     }
 23 |     | 
 24 |     |     function div(uint256 a, uint256 b) public pure returns (uint256) {
 25 |     |         return a / b;
 26 |     |     }
 27 |     | 
 28 |     |     function mod(uint256 a, uint256 b) public pure returns (uint256) {
 29 |     |         return a % b;
 30 |     |     }
 31 |     | 
 32 |     |     function mulDiv(uint256 a, uint256 b, uint256 c) public pure returns (uint256) {
 33 |     |         return (a * b) / c;
 34 |     |     }
 35 |     | }
 36 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/oracles/LSDChainlinkOracle.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {LibChainlinkOracle} from "contracts/libraries/Oracle/LibChainlinkOracle.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title LSDChainlinkOracle
 10 |     |  * @notice An oracle implementation that returns the price of a ETH LSD in USD.
 11 |     |  * @dev This is done by multiplying the price of xETH/ETH by the price of ETH/USD.
 12 |     |  */
 13 | *   | contract LSDChainlinkOracle {
 14 |     |     uint256 internal constant PRECISION = 1e6;
 15 | *   |     uint256 internal constant ETH_DECIMALS = 18;
 16 |     | 
 17 |     |     /**
 18 |     |      * @notice decodes data using the same format that the getPrice function uses.
 19 |     |      * Used to verify the data is encoded correctly.
 20 |     |      */
 21 |     |     function decodeData(
 22 |     |         bytes memory data
 23 |     |     )
 24 |     |         external
 25 |     |         pure
 26 |     |         returns (
 27 |     |             address ethChainlinkOracle,
 28 |     |             uint256 ethTimeout,
 29 |     |             address xEthChainlinkOracle,
 30 |     |             uint256 xEthTimeout
 31 |     |         )
 32 |     |     {
 33 |     |         (ethChainlinkOracle, ethTimeout, xEthChainlinkOracle, xEthTimeout) = abi.decode(
 34 |     |             data,
 35 |     |             (address, uint256, address, uint256)
 36 |     |         );
 37 |     |     }
 38 |     | 
 39 |     |     /**
 40 |     |      * @notice returns the price of the token.
 41 |     |      * if decimals are greater than 0, return the USD/TOKEN price.
 42 |     |      * else, return the TOKEN/USD price.
 43 |     |      * TOKEN/USD has 6 decimal precision, whereas USD/TOKEN has the token's decimal precision.
 44 |     |      * @dev if lookback is set to 0, use the instanteous price, else use the TWAP.
 45 |     |      */
 46 | *   |     function getPrice(
 47 |     |         uint256 decimals,
 48 |     |         uint256 lookback,
 49 |     |         bytes memory data
 50 | *   |     ) external view returns (uint256) {
 51 | *   |         (
 52 | *   |             address ethChainlinkOracle,
 53 | *   |             uint256 ethTimeout,
 54 | *   |             address xEthChainlinkOracle,
 55 | *   |             uint256 xEthTimeout
 56 | *   |         ) = abi.decode(data, (address, uint256, address, uint256));
 57 |     | 
 58 |     |         // cache the isMillion flag by checking the last byte of the data
 59 | *   |         bool isMillion;
 60 | *   |         if (data.length > 128) {
 61 |     |             isMillion = data[data.length - 1] == 0x01;
 62 |     |         }
 63 |     | 
 64 |     |         // get the price of xETH/ETH or ETH/xETH, depending on decimals.
 65 | *   |         uint256 xEthEthPrice = LibChainlinkOracle.getTokenPrice(
 66 | *   |             xEthChainlinkOracle,
 67 | *   |             xEthTimeout,
 68 | *   |             decimals,
 69 | *   |             lookback
 70 |     |         );
 71 |     | 
 72 |     |         // get the price of ETH/USD or USD/ETH. (note: ETH has 18 decimals.)
 73 | *   |         uint256 ethUsdPrice = LibChainlinkOracle.getTokenPrice(
 74 | *   |             ethChainlinkOracle,
 75 | *   |             ethTimeout,
 76 | *   |             decimals == 0 ? 0 : ETH_DECIMALS,
 77 | *   |             lookback,
 78 | *   |             isMillion
 79 |     |         );
 80 |     | 
 81 | *   |         if (decimals == 0) {
 82 |     |             // xETH/ETH (6 decimals) * ETH/USD (6 decimals) / PRECISION = xETH/USD (6 decimals)
 83 |     |             return (xEthEthPrice * ethUsdPrice) / PRECISION;
 84 |     |         } else {
 85 |     |             // USD/ETH (n decimals) * ETH/xETH (18 decimals) / 10 ** ETH_DECIMALS = USD/xETH (n decimals)
 86 | *   |             return (xEthEthPrice * ethUsdPrice) / (10 ** ETH_DECIMALS);
 87 |     |         }
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/price/BeanstalkPrice.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  5 |     | import {WellPrice, P, C, ReservesType} from "./WellPrice.sol";
  6 |     | 
  7 | *   | contract BeanstalkPrice is WellPrice {
  8 |     |     using LibRedundantMath256 for uint256;
  9 |     | 
 10 | *   |     constructor(address beanstalk) WellPrice(beanstalk) {}
 11 |     | 
 12 |     |     struct Prices {
 13 |     |         uint256 price;
 14 |     |         uint256 liquidity;
 15 |     |         int deltaB;
 16 |     |         P.Pool[] ps;
 17 |     |     }
 18 |     | 
 19 |     |     /**
 20 |     |      * @notice Returns the manipulation or non-manipulation resistant on-chain liquidity, deltaB and price data for
 21 |     |      * Bean in all whitelisted liquidity pools.
 22 |     |      **/
 23 |     |     function price(ReservesType reservesType) external view returns (Prices memory p) {
 24 |     |         address[] memory wells = beanstalk.getWhitelistedWellLpTokens();
 25 |     |         return priceForWells(wells, reservesType);
 26 |     |     }
 27 |     | 
 28 |     |     /**
 29 |     |      * @notice Returns the non-manipulation resistant on-chain liquidity, deltaB and price data for
 30 |     |      * Bean in all whitelisted liquidity pools.
 31 |     |      **/
 32 |     |     function price() external view returns (Prices memory p) {
 33 |     |         address[] memory wells = beanstalk.getWhitelistedWellLpTokens();
 34 |     |         return priceForWells(wells, ReservesType.CURRENT_RESERVES);
 35 |     |     }
 36 |     | 
 37 |     |     /**
 38 |     |      * @notice Returns the manipulation or non-manipulation resistant on-chain liquidity, deltaB and price data for
 39 |     |      * Bean for the passed in wells.
 40 |     |      **/
 41 |     |     function priceForWells(
 42 |     |         address[] memory wells,
 43 |     |         ReservesType reservesType
 44 |     |     ) public view returns (Prices memory p) {
 45 |     |         p.ps = new P.Pool[](wells.length);
 46 |     |         for (uint256 i = 0; i < wells.length; i++) {
 47 |     |             p.ps[i] = getWell(wells[i], reservesType);
 48 |     |         }
 49 |     |         for (uint256 i = 0; i < p.ps.length; i++) {
 50 |     |             p.price += p.ps[i].price.mul(p.ps[i].liquidity);
 51 |     |             p.liquidity += p.ps[i].liquidity;
 52 |     |             p.deltaB += p.ps[i].deltaB;
 53 |     |         }
 54 |     |         p.price = p.price.div(p.liquidity);
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @notice Returns the non-manipulation resistant on-chain liquidity, deltaB and price data for
 59 |     |      * Bean for the passed in wells.
 60 |     |      **/
 61 |     |     function priceForWells(address[] memory wells) public view returns (Prices memory p) {
 62 |     |         return priceForWells(wells, ReservesType.CURRENT_RESERVES);
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @notice Returns the manipulation or non-manipulation resistant on-chain liquidity, deltaB and price data for
 67 |     |      * Bean in the specified liquidity pools.
 68 |     |      **/
 69 |     |     function poolPrice(
 70 |     |         address pool,
 71 |     |         ReservesType reservesType
 72 |     |     ) public view returns (P.Pool memory p) {
 73 |     |         return getWell(pool, reservesType);
 74 |     |     }
 75 |     | 
 76 |     |     /**
 77 |     |      * @notice Returns the non-manipulation resistant on-chain liquidity, deltaB and price data for
 78 |     |      * Bean in the specified liquidity pools.
 79 |     |      **/
 80 |     |     function poolPrice(address pool) public view returns (P.Pool memory p) {
 81 |     |         return poolPrice(pool, ReservesType.CURRENT_RESERVES);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/price/P.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | contract P {
  5 |     |     struct Pool {
  6 |     |         address pool;
  7 |     |         address[2] tokens;
  8 |     |         uint256[2] balances;
  9 |     |         uint256 price;
 10 |     |         uint256 liquidity;
 11 |     |         uint256 beanLiquidity;
 12 |     |         uint256 nonBeanLiquidity;
 13 |     |         int256 deltaB;
 14 |     |         uint256 lpUsd;
 15 |     |         uint256 lpBdv;
 16 |     |     }
 17 |     | 
 18 |     |     struct Prices {
 19 |     |         address pool;
 20 |     |         address[] tokens;
 21 |     |         uint256 price;
 22 |     |         uint256 liquidity;
 23 |     |         int deltaB;
 24 |     |         P.Pool[] ps;
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/ecosystem/price/WellPrice.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {P} from "./P.sol";
   5 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   6 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   7 |     | import {Call, IWell, IERC20} from "../../interfaces/basin/IWell.sol";
   8 |     | import {IBeanstalkWellFunction} from "../../interfaces/basin/IBeanstalkWellFunction.sol";
   9 |     | import {C} from "../../C.sol";
  10 |     | import {IBeanstalk} from "../../interfaces/IBeanstalk.sol";
  11 |     | import {IMultiFlowPump} from "contracts/interfaces/basin/IMultiFlowPump.sol";
  12 |     | 
  13 |     | interface dec {
  14 |     |     function decimals() external view returns (uint256);
  15 |     | }
  16 |     | 
  17 |     | enum ReservesType {
  18 |     |     CURRENT_RESERVES,
  19 |     |     INSTANTANEOUS_RESERVES,
  20 |     |     CAPPED_RESERVES
  21 |     | }
  22 |     | 
  23 | *   | contract WellPrice {
  24 |     |     using LibRedundantMath256 for uint256;
  25 |     |     using SafeCast for uint256;
  26 |     | 
  27 |     |     IBeanstalk immutable beanstalk;
  28 |     | 
  29 | *   |     constructor(address _beanstalk) {
  30 | *   |         beanstalk = IBeanstalk(_beanstalk);
  31 |     |     }
  32 |     | 
  33 |     |     uint256 private constant WELL_DECIMALS = 1e18;
  34 |     |     uint256 private constant PRICE_PRECISION = 1e6;
  35 |     | 
  36 |     |     struct Pool {
  37 |     |         address pool;
  38 |     |         address[2] tokens;
  39 |     |         uint256[2] balances;
  40 |     |         uint256 price;
  41 |     |         uint256 liquidity;
  42 |     |         uint256 beanLiquidity;
  43 |     |         uint256 nonBeanLiquidity;
  44 |     |         int256 deltaB;
  45 |     |         uint256 lpUsd;
  46 |     |         uint256 lpBdv;
  47 |     |     }
  48 |     | 
  49 |     |     struct SwapData {
  50 |     |         address well;
  51 |     |         address token;
  52 |     |         uint256 usdValue;
  53 |     |         uint256 amountOut;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Returns the non-manipulation resistant on-chain liquidity, deltaB and price data for
  58 |     |      * Bean in a given Well.
  59 |     |      * @dev No protocol should use this function to calculate manipulation resistant Bean price data.
  60 |     |      **/
  61 |     |     function getWell(address wellAddress) public view returns (P.Pool memory) {
  62 |     |         return getWell(wellAddress, ReservesType.CURRENT_RESERVES);
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Returns the on-chain liquidity according to the passed in reservesType, deltaB and price data for
  67 |     |      * Bean in a given Well.
  68 |     |      **/
  69 |     |     function getWell(
  70 |     |         address wellAddress,
  71 |     |         ReservesType reservesType
  72 |     |     ) public view returns (P.Pool memory pool) {
  73 |     |         IWell well = IWell(wellAddress);
  74 |     |         pool.pool = wellAddress;
  75 |     |         IERC20[] memory wellTokens = well.tokens();
  76 |     |         pool.tokens = [address(wellTokens[0]), address(wellTokens[1])];
  77 |     |         uint256[] memory wellBalances;
  78 |     |         if (reservesType == ReservesType.INSTANTANEOUS_RESERVES) {
  79 |     |             Call memory pump = well.pumps()[0];
  80 |     |             // Get the readInstantaneousReserves from the pump
  81 |     |             wellBalances = IMultiFlowPump(pump.target).readInstantaneousReserves(
  82 |     |                 wellAddress,
  83 |     |                 pump.data
  84 |     |             );
  85 |     |         } else if (reservesType == ReservesType.CAPPED_RESERVES) {
  86 |     |             Call memory pump = well.pumps()[0];
  87 |     |             wellBalances = IMultiFlowPump(pump.target).readCappedReserves(wellAddress, pump.data);
  88 |     |         } else {
  89 |     |             // Current reserves
  90 |     |             wellBalances = well.getReserves();
  91 |     |         }
  92 |     |         if (wellBalances[0] == 0 || wellBalances[1] == 0) return pool;
  93 |     |         pool.balances = [wellBalances[0], wellBalances[1]];
  94 |     |         uint256 beanIndex = beanstalk.getBeanIndex(wellTokens);
  95 |     |         uint256 tknIndex = beanIndex == 0 ? 1 : 0;
  96 |     | 
  97 |     |         // swap 1 bean of the opposite asset to get the bean price
  98 |     |         // price = amtOut/tknOutPrice
  99 |     |         uint256 assetPrice = beanstalk.getMillionUsdPrice(pool.tokens[tknIndex], 0); // $1000000 gets assetPrice worth of tokens
 100 |     |         if (assetPrice > 0) {
 101 |     |             pool.price = well
 102 |     |                 .getSwapOut(wellTokens[beanIndex], wellTokens[tknIndex], 1e6)
 103 |     |                 .mul(PRICE_PRECISION * PRICE_PRECISION)
 104 |     |                 .div(assetPrice);
 105 |     |         }
 106 |     | 
 107 |     |         // liquidity is calculated by getting the usd value of the bean portion of the pool,
 108 |     |         // and the usd value of the non-bean portion of the pool.
 109 |     | 
 110 |     |         pool.beanLiquidity = pool.balances[beanIndex].mul(pool.price).div(PRICE_PRECISION);
 111 |     |         pool.nonBeanLiquidity = WELL_DECIMALS.mul(pool.balances[tknIndex]).div(assetPrice).div(
 112 |     |             PRICE_PRECISION
 113 |     |         );
 114 |     | 
 115 |     |         pool.liquidity = pool.beanLiquidity.add(pool.nonBeanLiquidity);
 116 |     | 
 117 |     |         // attempt to get deltaB, if it fails, set deltaB to 0.
 118 |     |         try beanstalk.poolCurrentDeltaB(wellAddress) returns (int256 deltaB) {
 119 |     |             pool.deltaB = deltaB;
 120 |     |         } catch {}
 121 |     |         uint256 totalSupply = IERC20(wellAddress).totalSupply();
 122 |     |         if (totalSupply > 0) {
 123 |     |             pool.lpUsd = pool.liquidity.mul(WELL_DECIMALS).div(totalSupply);
 124 |     |         }
 125 |     |         try beanstalk.bdv(wellAddress, WELL_DECIMALS) returns (uint256 bdv) {
 126 |     |             pool.lpBdv = bdv;
 127 |     |         } catch {}
 128 |     |     }
 129 |     | 
 130 |     |     ////////////////////////// BEAN IN //////////////////////////
 131 |     | 
 132 |     |     /**
 133 |     |      * @notice given an amount of Beans, return the Well that will yield the
 134 |     |      * largest usd value.
 135 |     |      * @param beans the amount of Beans to consider (Bean has 6 decimals).
 136 |     |      * @return sd the SwapData struct containing the well, token, usd value, and amount out.
 137 |     |      * @dev this is an estimation and not a guarantee.
 138 |     |      * if the usd value is the same for multiple wells, the last well in the whitelist is returned.
 139 |     |      **/
 140 |     |     function getBestWellForBeanIn(uint256 beans) public view returns (SwapData memory sd) {
 141 |     |         address[] memory wells = beanstalk.getWhitelistedWellLpTokens();
 142 |     |         for (uint256 i = 0; i < wells.length; i++) {
 143 |     |             SwapData memory wellSwapData = getSwapDataBeanIn(wells[i], beans);
 144 |     |             if (wellSwapData.usdValue > sd.usdValue) {
 145 |     |                 sd = wellSwapData;
 146 |     |             }
 147 |     |         }
 148 |     |         return sd;
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice given an amount of Beans, return the SwapData struct for all wells.
 153 |     |      * @param beans the amount of Beans to consider (Bean has 6 decimal precision).
 154 |     |      * @return sds the SwapData struct for all wells.
 155 |     |      **/
 156 |     |     function getSwapDataBeanInAll(uint256 beans) external view returns (SwapData[] memory sds) {
 157 |     |         address[] memory wells = beanstalk.getWhitelistedWellLpTokens();
 158 |     |         sds = new SwapData[](wells.length);
 159 |     |         for (uint256 i = 0; i < wells.length; i++) {
 160 |     |             sds[i] = getSwapDataBeanIn(wells[i], beans);
 161 |     |         }
 162 |     |         return sds;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @notice given an amount of Beans, return the SwapData struct for a given well.
 167 |     |      * @param well the address of the well.
 168 |     |      * @param beans the amount of Beans to consider (Bean has 6 decimal precision).
 169 |     |      * @return sd the SwapData struct.
 170 |     |      **/
 171 |     |     function getSwapDataBeanIn(
 172 |     |         address well,
 173 |     |         uint256 beans
 174 |     |     ) public view returns (SwapData memory sd) {
 175 |     |         (
 176 |     |             IERC20 beanToken,
 177 |     |             IERC20 nonBeanToken,
 178 |     |             uint256 oneToken,
 179 |     |             uint256 nonBeanTokenUsdPrice
 180 |     |         ) = getTokensAndNonBeanTokenData(well);
 181 |     | 
 182 |     |         // calculate the token amount out of the well for the given amount of beans
 183 |     |         uint256 tokenAmountOut = IWell(well).getSwapOut(beanToken, nonBeanToken, beans);
 184 |     |         // calculate the usd value of the amount out
 185 |     |         uint256 usdAmountOut = (nonBeanTokenUsdPrice * tokenAmountOut) / oneToken;
 186 |     | 
 187 |     |         sd.well = well;
 188 |     |         sd.token = address(nonBeanToken);
 189 |     |         sd.usdValue = usdAmountOut;
 190 |     |         sd.amountOut = tokenAmountOut;
 191 |     |         return sd;
 192 |     |     }
 193 |     | 
 194 |     |     ////////////////////////// USD IN //////////////////////////
 195 |     | 
 196 |     |     /**
 197 |     |      * @notice given an amount of USD, return the address of the well that will yield the
 198 |     |      * largest amount of Beans.
 199 |     |      * @param usdAmount the amount of USD to consider (6 decimal precision).
 200 |     |      * @return sd the SwapData struct containing the well, token, usd value, and amount out.
 201 |     |      * @dev This is an estimation and not a guarantee.
 202 |     |      * if the amount out is the same for multiple wells, the last well in the whitelist is returned.
 203 |     |      **/
 204 |     |     function getBestWellForUsdIn(uint256 usdAmount) external view returns (SwapData memory sd) {
 205 |     |         address[] memory wells = beanstalk.getWhitelistedWellLpTokens();
 206 |     |         for (uint256 i = 0; i < wells.length; i++) {
 207 |     |             SwapData memory wellSwapData = getSwapDataUsdIn(wells[i], usdAmount);
 208 |     |             if (wellSwapData.amountOut > sd.amountOut) {
 209 |     |                 sd = wellSwapData;
 210 |     |             }
 211 |     |         }
 212 |     |         return sd;
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @notice given an amount of USD, return the SwapData struct for all wells.
 217 |     |      * @param usdAmount the amount of USD to consider (6 decimal precision).
 218 |     |      * @return sds the SwapData struct for all wells.
 219 |     |      **/
 220 |     |     function getSwapDataUsdInAll(uint256 usdAmount) external view returns (SwapData[] memory sds) {
 221 |     |         address[] memory wells = beanstalk.getWhitelistedWellLpTokens();
 222 |     |         sds = new SwapData[](wells.length);
 223 |     |         for (uint256 i = 0; i < wells.length; i++) {
 224 |     |             sds[i] = getSwapDataUsdIn(wells[i], usdAmount);
 225 |     |         }
 226 |     |         return sds;
 227 |     |     }
 228 |     | 
 229 |     |     /**
 230 |     |      * @notice given an amount of USD, return the SwapData struct for a given well.
 231 |     |      * @param well the address of the well.
 232 |     |      * @param usdAmount the amount of USD to consider (6 decimal precision).
 233 |     |      * @return sd the SwapData struct.
 234 |     |      **/
 235 |     |     function getSwapDataUsdIn(
 236 |     |         address well,
 237 |     |         uint256 usdAmount
 238 |     |     ) public view returns (SwapData memory sd) {
 239 |     |         (
 240 |     |             IERC20 beanToken,
 241 |     |             IERC20 nonBeanToken,
 242 |     |             uint256 oneToken,
 243 |     |             uint256 nonBeanTokenUsdPrice
 244 |     |         ) = getTokensAndNonBeanTokenData(well);
 245 |     |         // calculate the amount out of the well for the given amount of tokens
 246 |     |         uint256 amountIn = (usdAmount * oneToken) / nonBeanTokenUsdPrice;
 247 |     |         // get the amount of beans out of the well
 248 |     |         uint256 beanAmountOut = IWell(well).getSwapOut(nonBeanToken, beanToken, amountIn);
 249 |     |         sd.well = well;
 250 |     |         sd.token = address(nonBeanToken);
 251 |     |         sd.amountOut = beanAmountOut;
 252 |     |         sd.usdValue = usdAmount;
 253 |     |         return sd;
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @notice returns the beanToken, nonBeanToken,
 258 |     |      * the amount of 1 non bean token and the nonBeanTokenUsdPrice for a given well.
 259 |     |      **/
 260 |     |     function getTokensAndNonBeanTokenData(
 261 |     |         address well
 262 |     |     ) internal view returns (IERC20, IERC20, uint256, uint256) {
 263 |     |         IERC20[] memory tokens = IWell(well).tokens();
 264 |     | 
 265 |     |         uint256 beanIndex = beanstalk.getBeanIndex(tokens);
 266 |     |         uint256 tknIndex = beanIndex == 0 ? 1 : 0;
 267 |     | 
 268 |     |         IERC20 beanToken = tokens[beanIndex];
 269 |     |         IERC20 nonBeanToken = tokens[tknIndex];
 270 |     | 
 271 |     |         uint256 oneToken = (10 ** dec(address(nonBeanToken)).decimals());
 272 |     |         uint256 nonBeanTokenUsdPrice = beanstalk.getTokenUsdPrice(address(nonBeanToken));
 273 |     |         return (beanToken, nonBeanToken, oneToken, nonBeanTokenUsdPrice);
 274 |     |     }
 275 |     | }
 276 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IBean.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title IBean
  9 |     |  * @notice Bean Interface
 10 |     |  */
 11 |     | abstract contract IBean is IERC20 {
 12 |     |     function burn(uint256 amount) public virtual;
 13 |     |     function burnFrom(address account, uint256 amount) public virtual;
 14 |     |     function mint(address account, uint256 amount) public virtual;
 15 |     |     function symbol() public view virtual returns (string memory);
 16 |     | }
 17 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IBeanstalk.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import {AdvancedFarmCall} from "../libraries/LibFarm.sol";
   6 |     | import {LibTransfer} from "../libraries/Token/LibTransfer.sol";
   7 |     | import {LibTractor} from "../libraries/LibTractor.sol";
   8 |     | 
   9 |     | interface IBeanstalk {
  10 |     |     enum GerminationSide {
  11 |     |         ODD,
  12 |     |         EVEN,
  13 |     |         NOT_GERMINATING
  14 |     |     }
  15 |     | 
  16 |     |     enum CounterUpdateType {
  17 |     |         INCREASE,
  18 |     |         DECREASE
  19 |     |     }
  20 |     | 
  21 |     |     struct AssetSettings {
  22 |     |         bytes4 selector;
  23 |     |         uint40 stalkEarnedPerSeason;
  24 |     |         uint48 stalkIssuedPerBdv;
  25 |     |         uint32 milestoneSeason;
  26 |     |         int96 milestoneStem;
  27 |     |         bytes1 encodeType;
  28 |     |         uint40 deltaStalkEarnedPerSeason;
  29 |     |         uint128 gaugePoints;
  30 |     |         uint64 optimalPercentDepositedBdv;
  31 |     |         Implementation gaugePointImplementation;
  32 |     |         Implementation liquidityWeightImplementation;
  33 |     |     }
  34 |     | 
  35 |     |     struct Deposit {
  36 |     |         uint128 amount;
  37 |     |         uint128 bdv;
  38 |     |     }
  39 |     | 
  40 |     |     struct Implementation {
  41 |     |         address target;
  42 |     |         bytes4 selector;
  43 |     |         bytes1 encodeType;
  44 |     |         bytes data;
  45 |     |     }
  46 |     | 
  47 |     |     struct MowStatus {
  48 |     |         int96 lastStem;
  49 |     |         uint128 bdv;
  50 |     |     }
  51 |     | 
  52 |     |     struct Season {
  53 |     |         uint32 current;
  54 |     |         uint32 lastSop;
  55 |     |         uint32 lastSopSeason;
  56 |     |         uint32 rainStart;
  57 |     |         bool raining;
  58 |     |         uint64 sunriseBlock;
  59 |     |         bool abovePeg;
  60 |     |         uint256 start;
  61 |     |         uint256 period;
  62 |     |         uint256 timestamp;
  63 |     |         uint256 standardMintedBeans;
  64 |     |         bytes32[8] _buffer;
  65 |     |     }
  66 |     | 
  67 |     |     struct WhitelistStatus {
  68 |     |         address token;
  69 |     |         bool isWhitelisted;
  70 |     |         bool isWhitelistedLp;
  71 |     |         bool isWhitelistedWell;
  72 |     |         bool isSoppable;
  73 |     |     }
  74 |     | 
  75 |     |     function advancedFarm(
  76 |     |         AdvancedFarmCall[] calldata data
  77 |     |     ) external payable returns (bytes[] memory results);
  78 |     | 
  79 |     |     function balanceOfSeeds(address account) external view returns (uint256);
  80 |     | 
  81 |     |     function balanceOfStalk(address account) external view returns (uint256);
  82 |     | 
  83 |     |     function calculateStemForTokenFromGrownStalk(
  84 |     |         address token,
  85 |     |         uint256 grownStalk,
  86 |     |         uint256 bdvOfDeposit
  87 |     |     ) external view returns (int96 stem, GerminationSide germ);
  88 |     | 
  89 |     |     function calculateDeltaBFromReserves(
  90 |     |         address well,
  91 |     |         uint256[] memory reserves,
  92 |     |         uint256 lookback
  93 |     |     ) external view returns (int256);
  94 |     | 
  95 |     |     function deposit(
  96 |     |         address token,
  97 |     |         uint256 _amount,
  98 |     |         LibTransfer.From mode
  99 |     |     ) external payable returns (uint256 amount, uint256 _bdv, int96 stem);
 100 |     | 
 101 |     |     function getAddressAndStem(uint256 depositId) external pure returns (address token, int96 stem);
 102 |     | 
 103 |     |     function getBeanIndex(IERC20[] calldata tokens) external view returns (uint256);
 104 |     | 
 105 |     |     function getBeanToken() external view returns (address);
 106 |     | 
 107 |     |     function getCounter(address account, bytes32 counterId) external view returns (uint256);
 108 |     | 
 109 |     |     function getCurrentBlueprintHash() external view returns (bytes32);
 110 |     | 
 111 |     |     function getDeposit(
 112 |     |         address account,
 113 |     |         address token,
 114 |     |         uint32 season
 115 |     |     ) external view returns (uint256, uint256);
 116 |     | 
 117 |     |     function getDeposit(
 118 |     |         address account,
 119 |     |         address token,
 120 |     |         int96 stem
 121 |     |     ) external view returns (uint256, uint256);
 122 |     | 
 123 |     |     function getMowStatus(
 124 |     |         address account,
 125 |     |         address[] calldata tokens
 126 |     |     ) external view returns (MowStatus[] memory mowStatuses);
 127 |     | 
 128 |     |     function getNonBeanTokenAndIndexFromWell(address well) external view returns (address, uint256);
 129 |     | 
 130 |     |     function getTokenDepositIdsForAccount(
 131 |     |         address account,
 132 |     |         address token
 133 |     |     ) external view returns (uint256[] memory depositIds);
 134 |     | 
 135 |     |     function getWhitelistedTokens() external view returns (address[] memory);
 136 |     | 
 137 |     |     function maxTemperature() external view returns (uint256);
 138 |     | 
 139 |     |     function operator() external view returns (address);
 140 |     | 
 141 |     |     function plant() external payable returns (uint256);
 142 |     | 
 143 |     |     function sowWithMin(
 144 |     |         uint256 beans,
 145 |     |         uint256 minTemperature,
 146 |     |         uint256 minSoil,
 147 |     |         LibTransfer.From mode
 148 |     |     ) external payable returns (uint256 pods);
 149 |     | 
 150 |     |     function stemTipForToken(address token) external view returns (int96 _stemTip);
 151 |     | 
 152 |     |     function sunriseBlock() external view returns (uint64);
 153 |     | 
 154 |     |     function temperature() external view returns (uint256);
 155 |     | 
 156 |     |     function time() external view returns (Season memory);
 157 |     | 
 158 |     |     function tokenSettings(address token) external view returns (AssetSettings memory);
 159 |     | 
 160 |     |     function totalSoil() external view returns (uint256);
 161 |     | 
 162 |     |     function totalUnharvestable(uint256 fieldId) external view returns (uint256);
 163 |     | 
 164 |     |     function totalUnharvestableForActiveField() external view returns (uint256);
 165 |     | 
 166 |     |     function tractorUser() external view returns (address payable);
 167 |     | 
 168 |     |     function transferDeposits(
 169 |     |         address sender,
 170 |     |         address recipient,
 171 |     |         address token,
 172 |     |         uint32[] calldata seasons,
 173 |     |         uint256[] calldata amounts
 174 |     |     ) external payable returns (uint256[] memory bdvs);
 175 |     | 
 176 |     |     function sendTokenToInternalBalance(
 177 |     |         address token,
 178 |     |         address recipient,
 179 |     |         uint256 amount
 180 |     |     ) external payable;
 181 |     | 
 182 |     |     function transferInternalTokenFrom(
 183 |     |         IERC20 token,
 184 |     |         address from,
 185 |     |         address to,
 186 |     |         uint256 amount,
 187 |     |         LibTransfer.To toMode
 188 |     |     ) external payable;
 189 |     | 
 190 |     |     function transferToken(
 191 |     |         IERC20 token,
 192 |     |         address recipient,
 193 |     |         uint256 amount,
 194 |     |         LibTransfer.From fromMode,
 195 |     |         LibTransfer.To toMode
 196 |     |     ) external payable;
 197 |     | 
 198 |     |     function update(address account) external payable;
 199 |     | 
 200 |     |     function withdrawDeposits(
 201 |     |         address token,
 202 |     |         int96[] calldata stems,
 203 |     |         uint256[] calldata amounts,
 204 |     |         LibTransfer.To mode
 205 |     |     ) external payable;
 206 |     | 
 207 |     |     function updatePublisherCounter(
 208 |     |         bytes32 counterId,
 209 |     |         CounterUpdateType updateType,
 210 |     |         uint256 amount
 211 |     |     ) external payable returns (uint256);
 212 |     | 
 213 |     |     // Price and well-related functions
 214 |     |     function getWhitelistedWellLpTokens() external view returns (address[] memory);
 215 |     |     function getUsdTokenPrice(address token) external view returns (uint256);
 216 |     |     function getTokenUsdPrice(address token) external view returns (uint256);
 217 |     |     function getMillionUsdPrice(address token, uint256 lookback) external view returns (uint256);
 218 |     |     function bdv(address token, uint256 amount) external view returns (uint256);
 219 |     |     function poolCurrentDeltaB(address pool) external view returns (int256 deltaB);
 220 |     | 
 221 |     |     function getWhitelistStatuses()
 222 |     |         external
 223 |     |         view
 224 |     |         returns (WhitelistStatus[] memory _whitelistStatuses);
 225 |     | }
 226 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IBudget.sol
 1 |     | //SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.20;
 3 |     | 
 4 |     | interface IBudget {
 5 |     |     function distribute() external;
 6 |     | }
 7 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IChainlinkAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | interface IChainlinkAggregator {
  5 |     |     function decimals() external view returns (uint8);
  6 |     | 
  7 |     |     function description() external view returns (string memory);
  8 |     | 
  9 |     |     function version() external view returns (uint256);
 10 |     | 
 11 |     |     // getRoundData and latestRoundData should both raise "No data present"
 12 |     |     // if they do not have data to report, instead of returning unset values
 13 |     |     // which could be misinterpreted as actual reported values.
 14 |     |     function getRoundData(
 15 |     |         uint80 _roundId
 16 |     |     )
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             uint80 roundId,
 21 |     |             int256 answer,
 22 |     |             uint256 startedAt,
 23 |     |             uint256 updatedAt,
 24 |     |             uint80 answeredInRound
 25 |     |         );
 26 |     | 
 27 |     |     function latestRoundData()
 28 |     |         external
 29 |     |         view
 30 |     |         returns (
 31 |     |             uint80 roundId,
 32 |     |             int256 answer,
 33 |     |             uint256 startedAt,
 34 |     |             uint256 updatedAt,
 35 |     |             uint80 answeredInRound
 36 |     |         );
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IDiamondCut.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | /******************************************************************************\
  5 |     | * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
  6 |     | /******************************************************************************/
  7 |     | 
  8 |     | interface IDiamondCut {
  9 |     |     enum FacetCutAction {
 10 |     |         Add,
 11 |     |         Replace,
 12 |     |         Remove
 13 |     |     }
 14 |     | 
 15 |     |     struct FacetCut {
 16 |     |         address facetAddress;
 17 |     |         FacetCutAction action;
 18 |     |         bytes4[] functionSelectors;
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Add/replace/remove any number of functions and optionally execute
 22 |     |     ///         a function with delegatecall
 23 |     |     /// @param _diamondCut Contains the facet addresses and function selectors
 24 |     |     /// @param _init The address of the contract or facet to execute _calldata
 25 |     |     /// @param _calldata A function call, including function selector and arguments
 26 |     |     ///                  _calldata is executed with delegatecall on _init
 27 |     |     function diamondCut(
 28 |     |         FacetCut[] calldata _diamondCut,
 29 |     |         address _init,
 30 |     |         bytes calldata _calldata
 31 |     |     ) external;
 32 |     | 
 33 |     |     event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IDiamondLoupe.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | // A loupe is a small magnifying glass used to look at diamonds.
  5 |     | // These functions look at diamonds
  6 |     | interface IDiamondLoupe {
  7 |     |     /// These functions are expected to be called frequently
  8 |     |     /// by tools.
  9 |     | 
 10 |     |     struct Facet {
 11 |     |         address facetAddress;
 12 |     |         bytes4[] functionSelectors;
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Gets all facet addresses and their four byte function selectors.
 16 |     |     /// @return facets_ Facet
 17 |     |     function facets() external view returns (Facet[] memory facets_);
 18 |     | 
 19 |     |     /// @notice Gets all the function selectors supported by a specific facet.
 20 |     |     /// @param _facet The facet address.
 21 |     |     /// @return facetFunctionSelectors_
 22 |     |     function facetFunctionSelectors(
 23 |     |         address _facet
 24 |     |     ) external view returns (bytes4[] memory facetFunctionSelectors_);
 25 |     | 
 26 |     |     /// @notice Get all the facet addresses used by a diamond.
 27 |     |     /// @return facetAddresses_
 28 |     |     function facetAddresses() external view returns (address[] memory facetAddresses_);
 29 |     | 
 30 |     |     /// @notice Gets the facet that supports the given selector.
 31 |     |     /// @dev If facet is not found return address(0).
 32 |     |     /// @param _functionSelector The function selector.
 33 |     |     /// @return facetAddress_ The facet address.
 34 |     |     function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
 35 |     | }
 36 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IERC1155Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  *  @notice Duplicate of OpenZeppelin's IERC1155Receiver with the IERC165 inheritance removed.
  8 |     |  * @dev Interface that must be implemented by smart contracts in order to receive
  9 |     |  * ERC-1155 token transfers.
 10 |     |  */
 11 |     | interface IERC1155Receiver {
 12 |     |     /**
 13 |     |      * @dev Handles the receipt of a single ERC1155 token type. This function is
 14 |     |      * called at the end of a `safeTransferFrom` after the balance has been updated.
 15 |     |      *
 16 |     |      * NOTE: To accept the transfer, this must return
 17 |     |      * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
 18 |     |      * (i.e. 0xf23a6e61, or its own function selector).
 19 |     |      *
 20 |     |      * @param operator The address which initiated the transfer (i.e. msg.sender)
 21 |     |      * @param from The address which previously owned the token
 22 |     |      * @param id The ID of the token being transferred
 23 |     |      * @param value The amount of tokens being transferred
 24 |     |      * @param data Additional data with no specified format
 25 |     |      * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
 26 |     |      */
 27 |     |     function onERC1155Received(
 28 |     |         address operator,
 29 |     |         address from,
 30 |     |         uint256 id,
 31 |     |         uint256 value,
 32 |     |         bytes calldata data
 33 |     |     ) external returns (bytes4);
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Handles the receipt of a multiple ERC1155 token types. This function
 37 |     |      * is called at the end of a `safeBatchTransferFrom` after the balances have
 38 |     |      * been updated.
 39 |     |      *
 40 |     |      * NOTE: To accept the transfer(s), this must return
 41 |     |      * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
 42 |     |      * (i.e. 0xbc197c81, or its own function selector).
 43 |     |      *
 44 |     |      * @param operator The address which initiated the batch transfer (i.e. msg.sender)
 45 |     |      * @param from The address which previously owned the token
 46 |     |      * @param ids An array containing ids of each token being transferred (order and length must match values array)
 47 |     |      * @param values An array containing amounts of each token being transferred (order and length must match ids array)
 48 |     |      * @param data Additional data with no specified format
 49 |     |      * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
 50 |     |      */
 51 |     |     function onERC1155BatchReceived(
 52 |     |         address operator,
 53 |     |         address from,
 54 |     |         uint256[] calldata ids,
 55 |     |         uint256[] calldata values,
 56 |     |         bytes calldata data
 57 |     |     ) external returns (bytes4);
 58 |     | }
 59 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IMockFBeanstalk.sol
    1 |     | /**
    2 |     |  * SPDX-License-Identifier: MIT
    3 |     |  *
    4 |     |  */
    5 |     | pragma solidity ^0.8.4;
    6 |     | 
    7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    8 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
    9 |     | import {GaugeId, Gauge} from "contracts/beanstalk/storage/System.sol";
   10 |     | interface IMockFBeanstalk {
   11 |     |     enum CounterUpdateType {
   12 |     |         INCREASE,
   13 |     |         DECREASE
   14 |     |     }
   15 |     | 
   16 |     |     enum FacetCutAction {
   17 |     |         Add,
   18 |     |         Replace,
   19 |     |         Remove
   20 |     |     }
   21 |     | 
   22 |     |     enum GerminationSide {
   23 |     |         ODD,
   24 |     |         EVEN,
   25 |     |         NOT_GERMINATING
   26 |     |     }
   27 |     | 
   28 |     |     enum ShipmentRecipient {
   29 |     |         NULL,
   30 |     |         SILO,
   31 |     |         FIELD,
   32 |     |         INTERNAL_BALANCE,
   33 |     |         EXTERNAL_BALANCE
   34 |     |     }
   35 |     | 
   36 |     |     struct AccountSeasonOfPlenty {
   37 |     |         uint32 lastRain;
   38 |     |         uint32 lastSop;
   39 |     |         uint256 roots;
   40 |     |         FarmerSops[] farmerSops;
   41 |     |     }
   42 |     | 
   43 |     |     struct AdvancedFarmCall {
   44 |     |         bytes callData;
   45 |     |         bytes clipboard;
   46 |     |     }
   47 |     | 
   48 |     |     struct AdvancedPipeCall {
   49 |     |         address target;
   50 |     |         bytes callData;
   51 |     |         bytes clipboard;
   52 |     |     }
   53 |     | 
   54 |     |     struct AssetSettings {
   55 |     |         bytes4 selector;
   56 |     |         uint40 stalkEarnedPerSeason;
   57 |     |         uint48 stalkIssuedPerBdv;
   58 |     |         uint32 milestoneSeason;
   59 |     |         int96 milestoneStem;
   60 |     |         bytes1 encodeType;
   61 |     |         int40 deltaStalkEarnedPerSeason;
   62 |     |         uint128 gaugePoints;
   63 |     |         uint64 optimalPercentDepositedBdv;
   64 |     |         Implementation gaugePointImplementation;
   65 |     |         Implementation liquidityWeightImplementation;
   66 |     |     }
   67 |     | 
   68 |     |     struct Balance {
   69 |     |         uint128 amount;
   70 |     |         uint128 lastBpf;
   71 |     |     }
   72 |     | 
   73 |     |     struct Blueprint {
   74 |     |         address publisher;
   75 |     |         bytes data;
   76 |     |         bytes32[] operatorPasteInstrs;
   77 |     |         uint256 maxNonce;
   78 |     |         uint256 startTime;
   79 |     |         uint256 endTime;
   80 |     |     }
   81 |     | 
   82 |     |     struct ClaimPlentyData {
   83 |     |         address token;
   84 |     |         uint256 plenty;
   85 |     |     }
   86 |     | 
   87 |     |     struct DeltaBStorage {
   88 |     |         int256 beforeInputTokenDeltaB;
   89 |     |         int256 afterInputTokenDeltaB;
   90 |     |         int256 beforeOutputTokenDeltaB;
   91 |     |         int256 afterOutputTokenDeltaB;
   92 |     |         int256 beforeOverallDeltaB;
   93 |     |         int256 afterOverallDeltaB;
   94 |     |     }
   95 |     | 
   96 |     |     struct Deposit {
   97 |     |         uint128 amount;
   98 |     |         uint128 bdv;
   99 |     |     }
  100 |     | 
  101 |     |     struct EvaluationParameters {
  102 |     |         uint256 maxBeanMaxLpGpPerBdvRatio;
  103 |     |         uint256 minBeanMaxLpGpPerBdvRatio;
  104 |     |         uint256 targetSeasonsToCatchUp;
  105 |     |         uint256 podRateLowerBound;
  106 |     |         uint256 podRateOptimal;
  107 |     |         uint256 podRateUpperBound;
  108 |     |         uint256 deltaPodDemandLowerBound;
  109 |     |         uint256 deltaPodDemandUpperBound;
  110 |     |         uint256 lpToSupplyRatioUpperBound;
  111 |     |         uint256 lpToSupplyRatioOptimal;
  112 |     |         uint256 lpToSupplyRatioLowerBound;
  113 |     |         uint256 excessivePriceThreshold;
  114 |     |         uint256 soilCoefficientHigh;
  115 |     |         uint256 soilCoefficientLow;
  116 |     |         uint256 baseReward;
  117 |     |         uint128 minAvgGsPerBdv;
  118 |     |         uint128 rainingMinBeanMaxLpGpPerBdvRatio;
  119 |     |     }
  120 |     | 
  121 |     |     struct ExtEvaluationParameters {
  122 |     |         uint256 belowPegSoilL2SRScalar;
  123 |     |         uint256 soilCoefficientRelativelyHigh;
  124 |     |         uint256 soilCoefficientRelativelyLow;
  125 |     |         uint256 abovePegDeltaBSoilScalar;
  126 |     |         uint256 soilDistributionPeriod;
  127 |     |         uint256 minSoilIssuance;
  128 |     |         uint256 minSoilSownDemand;
  129 |     |         bytes32[60] buffer;
  130 |     |     }
  131 |     | 
  132 |     |     struct Facet {
  133 |     |         address facetAddress;
  134 |     |         bytes4[] functionSelectors;
  135 |     |     }
  136 |     | 
  137 |     |     struct FacetCut {
  138 |     |         address facetAddress;
  139 |     |         FacetCutAction action;
  140 |     |         bytes4[] functionSelectors;
  141 |     |     }
  142 |     | 
  143 |     |     struct FarmerSops {
  144 |     |         address well;
  145 |     |         PerWellPlenty wellsPlenty;
  146 |     |     }
  147 |     | 
  148 |     |     struct Implementation {
  149 |     |         address target;
  150 |     |         bytes4 selector;
  151 |     |         bytes1 encodeType;
  152 |     |         bytes data;
  153 |     |     }
  154 |     | 
  155 |     |     struct MowStatus {
  156 |     |         int96 lastStem;
  157 |     |         uint128 bdv;
  158 |     |     }
  159 |     | 
  160 |     |     struct PenaltyData {
  161 |     |         uint256 inputToken;
  162 |     |         uint256 outputToken;
  163 |     |         uint256 overall;
  164 |     |     }
  165 |     | 
  166 |     |     struct PerWellPlenty {
  167 |     |         uint256 plentyPerRoot;
  168 |     |         uint256 plenty;
  169 |     |         bytes32[4] _buffer;
  170 |     |     }
  171 |     | 
  172 |     |     struct PipeCall {
  173 |     |         address target;
  174 |     |         bytes data;
  175 |     |     }
  176 |     | 
  177 |     |     struct Plot {
  178 |     |         uint256 index;
  179 |     |         uint256 pods;
  180 |     |     }
  181 |     | 
  182 |     |     struct PodListing {
  183 |     |         address lister;
  184 |     |         uint256 fieldId;
  185 |     |         uint256 index;
  186 |     |         uint256 start;
  187 |     |         uint256 podAmount;
  188 |     |         uint24 pricePerPod;
  189 |     |         uint256 maxHarvestableIndex;
  190 |     |         uint256 minFillAmount;
  191 |     |         uint8 mode;
  192 |     |     }
  193 |     | 
  194 |     |     struct PodOrder {
  195 |     |         address orderer;
  196 |     |         uint256 fieldId;
  197 |     |         uint24 pricePerPod;
  198 |     |         uint256 maxPlaceInLine;
  199 |     |         uint256 minFillAmount;
  200 |     |     }
  201 |     | 
  202 |     |     struct Rain {
  203 |     |         uint256 pods;
  204 |     |         uint256 roots;
  205 |     |         bytes32[4] _buffer;
  206 |     |     }
  207 |     | 
  208 |     |     struct Requisition {
  209 |     |         Blueprint blueprint;
  210 |     |         bytes32 blueprintHash;
  211 |     |         bytes signature;
  212 |     |     }
  213 |     | 
  214 |     |     struct Season {
  215 |     |         uint32 current;
  216 |     |         uint32 lastSop;
  217 |     |         uint32 lastSopSeason;
  218 |     |         uint32 rainStart;
  219 |     |         bool raining;
  220 |     |         uint64 sunriseBlock;
  221 |     |         bool abovePeg;
  222 |     |         uint256 start;
  223 |     |         uint256 period;
  224 |     |         uint256 timestamp;
  225 |     |         uint256 standardMintedBeans;
  226 |     |         bytes32[8] _buffer;
  227 |     |     }
  228 |     | 
  229 |     |     struct SeedGauge {
  230 |     |         uint128 averageGrownStalkPerBdvPerSeason;
  231 |     |         uint128 beanToMaxLpGpPerBdvRatio;
  232 |     |         bytes32[4] _buffer;
  233 |     |     }
  234 |     | 
  235 |     |     struct ShipmentRoute {
  236 |     |         address planContract;
  237 |     |         bytes4 planSelector;
  238 |     |         ShipmentRecipient recipient;
  239 |     |         bytes data;
  240 |     |     }
  241 |     | 
  242 |     |     struct Supply {
  243 |     |         uint128 endBpf;
  244 |     |         uint256 supply;
  245 |     |     }
  246 |     | 
  247 |     |     struct TokenDepositId {
  248 |     |         address token;
  249 |     |         uint256[] depositIds;
  250 |     |         Deposit[] tokenDeposits;
  251 |     |     }
  252 |     | 
  253 |     |     struct Weather {
  254 |     |         uint128 lastDeltaSoil;
  255 |     |         uint32 lastSowTime;
  256 |     |         uint32 thisSowTime;
  257 |     |         uint32 temp;
  258 |     |         bytes32[4] _buffer;
  259 |     |     }
  260 |     | 
  261 |     |     struct WellDeltaB {
  262 |     |         address well;
  263 |     |         int256 deltaB;
  264 |     |     }
  265 |     | 
  266 |     |     struct WhitelistStatus {
  267 |     |         address token;
  268 |     |         bool isWhitelisted;
  269 |     |         bool isWhitelistedLp;
  270 |     |         bool isWhitelistedWell;
  271 |     |         bool isSoppable;
  272 |     |     }
  273 |     | 
  274 |     |     struct D256 {
  275 |     |         uint256 value;
  276 |     |     }
  277 |     | 
  278 |     |     struct BeanstalkState {
  279 |     |         D256 deltaPodDemand;
  280 |     |         D256 lpToSupplyRatio;
  281 |     |         D256 podRate;
  282 |     |         address largestLiqWell;
  283 |     |         bool oracleFailure;
  284 |     |     }
  285 |     | 
  286 |     |     error AddressEmptyCode(address target);
  287 |     |     error AddressInsufficientBalance(address account);
  288 |     |     error ECDSAInvalidSignature();
  289 |     |     error ECDSAInvalidSignatureLength(uint256 length);
  290 |     |     error ECDSAInvalidSignatureS(bytes32 s);
  291 |     |     error FailedInnerCall();
  292 |     |     error PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);
  293 |     |     error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);
  294 |     |     error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
  295 |     |     error SafeCastOverflowedUintToInt(uint256 value);
  296 |     |     error SafeERC20FailedOperation(address token);
  297 |     |     error StringsInsufficientHexLength(uint256 value, uint256 length);
  298 |     |     error T();
  299 |     | 
  300 |     |     event ActiveFieldSet(uint256 fieldId);
  301 |     |     event AddDeposit(
  302 |     |         address indexed account,
  303 |     |         address indexed token,
  304 |     |         int96 stem,
  305 |     |         uint256 amount,
  306 |     |         uint256 bdv
  307 |     |     );
  308 |     |     event AddWhitelistStatus(
  309 |     |         address token,
  310 |     |         uint256 index,
  311 |     |         bool isWhitelisted,
  312 |     |         bool isWhitelistedLp,
  313 |     |         bool isWhitelistedWell,
  314 |     |         bool isSoppable
  315 |     |     );
  316 |     |     event ApprovalForAll(address indexed account, address indexed operator, bool approved);
  317 |     |     event BeanToMaxLpGpPerBdvRatioChange(uint256 indexed season, uint256 caseId, int80 absChange);
  318 |     |     event CancelBlueprint(bytes32 blueprintHash);
  319 |     |     event ClaimPlenty(address indexed account, address token, uint256 plenty);
  320 |     |     event Convert(
  321 |     |         address indexed account,
  322 |     |         address fromToken,
  323 |     |         address toToken,
  324 |     |         uint256 fromAmount,
  325 |     |         uint256 toAmount
  326 |     |     );
  327 |     |     event DeltaB(int256 deltaB);
  328 |     |     event DepositApproval(
  329 |     |         address indexed owner,
  330 |     |         address indexed spender,
  331 |     |         address token,
  332 |     |         uint256 amount
  333 |     |     );
  334 |     |     event DewhitelistToken(address indexed token);
  335 |     |     event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
  336 |     |     event FarmerGerminatingStalkBalanceChanged(
  337 |     |         address indexed account,
  338 |     |         int256 delta,
  339 |     |         GerminationSide germ
  340 |     |     );
  341 |     |     event FieldAdded(uint256 fieldId);
  342 |     |     event GaugePointChange(uint256 indexed season, address indexed token, uint256 gaugePoints);
  343 |     |     event Harvest(address indexed account, uint256 fieldId, uint256[] plots, uint256 beans);
  344 |     |     event Incentivization(address indexed account, uint256 beans);
  345 |     |     event InternalBalanceChanged(address indexed account, address indexed token, int256 delta);
  346 |     |     event MockConvert(uint256 stalkRemoved, uint256 bdvRemoved);
  347 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  348 |     |     event Pause(uint256 timestamp);
  349 |     |     event Pick(address indexed account, address indexed token, uint256 amount);
  350 |     |     event Plant(address indexed account, uint256 beans);
  351 |     |     event PlotTransfer(
  352 |     |         address indexed from,
  353 |     |         address indexed to,
  354 |     |         uint256 fieldId,
  355 |     |         uint256 indexed index,
  356 |     |         uint256 amount
  357 |     |     );
  358 |     |     event PodApproval(
  359 |     |         address indexed owner,
  360 |     |         address indexed spender,
  361 |     |         uint256 fieldId,
  362 |     |         uint256 amount
  363 |     |     );
  364 |     |     event PodListingCancelled(address indexed lister, uint256 fieldId, uint256 index);
  365 |     |     event PodListingCreated(
  366 |     |         address indexed lister,
  367 |     |         uint256 fieldId,
  368 |     |         uint256 index,
  369 |     |         uint256 start,
  370 |     |         uint256 podAmount,
  371 |     |         uint24 pricePerPod,
  372 |     |         uint256 maxHarvestableIndex,
  373 |     |         uint256 minFillAmount,
  374 |     |         uint8 mode
  375 |     |     );
  376 |     |     event PodListingFilled(
  377 |     |         address indexed filler,
  378 |     |         address indexed lister,
  379 |     |         uint256 fieldId,
  380 |     |         uint256 index,
  381 |     |         uint256 start,
  382 |     |         uint256 podAmount,
  383 |     |         uint256 costInBeans
  384 |     |     );
  385 |     |     event PodOrderCancelled(address indexed orderer, bytes32 id);
  386 |     |     event PodOrderCreated(
  387 |     |         address indexed orderer,
  388 |     |         bytes32 id,
  389 |     |         uint256 beanAmount,
  390 |     |         uint256 fieldId,
  391 |     |         uint24 pricePerPod,
  392 |     |         uint256 maxPlaceInLine,
  393 |     |         uint256 minFillAmount
  394 |     |     );
  395 |     |     event PodOrderFilled(
  396 |     |         address indexed filler,
  397 |     |         address indexed orderer,
  398 |     |         bytes32 id,
  399 |     |         uint256 fieldId,
  400 |     |         uint256 index,
  401 |     |         uint256 start,
  402 |     |         uint256 podAmount,
  403 |     |         uint256 costInBeans
  404 |     |     );
  405 |     |     event PublishRequisition(Requisition requisition);
  406 |     |     event Receipt(ShipmentRecipient indexed recipient, uint256 receivedAmount, bytes data);
  407 |     |     event ReceiverApproved(address indexed owner, address receiver);
  408 |     |     event RemoveDeposit(
  409 |     |         address indexed account,
  410 |     |         address indexed token,
  411 |     |         int96 stem,
  412 |     |         uint256 amount,
  413 |     |         uint256 bdv
  414 |     |     );
  415 |     |     event RemoveDeposits(
  416 |     |         address indexed account,
  417 |     |         address indexed token,
  418 |     |         int96[] stems,
  419 |     |         uint256[] amounts,
  420 |     |         uint256 amount,
  421 |     |         uint256[] bdvs
  422 |     |     );
  423 |     |     event RetryableTicketCreated(uint256 indexed ticketId);
  424 |     |     event SeasonOfPlentyField(uint256 toField);
  425 |     |     event SeasonOfPlentyWell(
  426 |     |         uint256 indexed season,
  427 |     |         address well,
  428 |     |         address token,
  429 |     |         uint256 amount,
  430 |     |         uint256 beans
  431 |     |     );
  432 |     |     event ShipmentRoutesSet(ShipmentRoute[] newShipmentRoutes);
  433 |     |     event Soil(uint32 indexed season, uint256 soil);
  434 |     |     event Sow(address indexed account, uint256 fieldId, uint256 index, uint256 beans, uint256 pods);
  435 |     |     event StalkBalanceChanged(address indexed account, int256 delta, int256 deltaRoots);
  436 |     |     event Sunrise(uint256 indexed season);
  437 |     |     event TemperatureChange(
  438 |     |         uint256 indexed season,
  439 |     |         uint256 caseId,
  440 |     |         int32 absChange,
  441 |     |         uint256 fieldId
  442 |     |     );
  443 |     |     event TokenApproval(
  444 |     |         address indexed owner,
  445 |     |         address indexed spender,
  446 |     |         address token,
  447 |     |         uint256 amount
  448 |     |     );
  449 |     |     event TokenTransferred(
  450 |     |         address indexed token,
  451 |     |         address indexed sender,
  452 |     |         address indexed recipient,
  453 |     |         uint256 amount,
  454 |     |         uint8 fromMode,
  455 |     |         uint8 toMode
  456 |     |     );
  457 |     |     event TotalGerminatingBalanceChanged(
  458 |     |         uint256 germinationSeason,
  459 |     |         address indexed token,
  460 |     |         int256 deltaAmount,
  461 |     |         int256 deltaBdv
  462 |     |     );
  463 |     |     event TotalGerminatingStalkChanged(uint256 germinationSeason, int256 deltaGerminatingStalk);
  464 |     |     event TotalStalkChangedFromGermination(int256 deltaStalk, int256 deltaRoots);
  465 |     |     event Tractor(
  466 |     |         address indexed operator,
  467 |     |         address indexed publisher,
  468 |     |         bytes32 indexed blueprintHash,
  469 |     |         uint256 nonce,
  470 |     |         uint256 gasleft
  471 |     |     );
  472 |     |     event TractorExecutionBegan(
  473 |     |         address indexed operator,
  474 |     |         address indexed publisher,
  475 |     |         bytes32 indexed blueprintHash,
  476 |     |         uint256 nonce,
  477 |     |         uint256 gasleft
  478 |     |     );
  479 |     |     event TractorVersionSet(string version);
  480 |     |     event TransferBatch(
  481 |     |         address indexed operator,
  482 |     |         address indexed from,
  483 |     |         address indexed to,
  484 |     |         uint256[] ids,
  485 |     |         uint256[] values
  486 |     |     );
  487 |     |     event TransferSingle(
  488 |     |         address indexed operator,
  489 |     |         address indexed sender,
  490 |     |         address indexed recipient,
  491 |     |         uint256 depositId,
  492 |     |         uint256 amount
  493 |     |     );
  494 |     |     event URI(string _uri, uint256 indexed _id);
  495 |     |     event Unpause(uint256 timestamp, uint256 timePassed);
  496 |     |     event UpdateAverageStalkPerBdvPerSeason(uint256 newStalkPerBdvPerSeason);
  497 |     |     event UpdateGaugeSettings(
  498 |     |         address indexed token,
  499 |     |         bytes4 gpSelector,
  500 |     |         bytes4 lwSelector,
  501 |     |         uint64 optimalPercentDepositedBdv
  502 |     |     );
  503 |     |     event UpdateTWAPs(uint256[2] balances);
  504 |     |     event UpdateWhitelistStatus(
  505 |     |         address token,
  506 |     |         uint256 index,
  507 |     |         bool isWhitelisted,
  508 |     |         bool isWhitelistedLp,
  509 |     |         bool isWhitelistedWell,
  510 |     |         bool isSoppable
  511 |     |     );
  512 |     |     event UpdatedEvaluationParameters(EvaluationParameters);
  513 |     |     event UpdatedGaugePointImplementationForToken(
  514 |     |         address indexed token,
  515 |     |         Implementation gaugePointImplementation
  516 |     |     );
  517 |     |     event UpdatedLiquidityWeightImplementationForToken(
  518 |     |         address indexed token,
  519 |     |         Implementation liquidityWeightImplementation
  520 |     |     );
  521 |     |     event UpdatedOptimalPercentDepositedBdvForToken(
  522 |     |         address indexed token,
  523 |     |         uint64 optimalPercentDepositedBdv
  524 |     |     );
  525 |     |     event UpdatedOracleImplementationForToken(
  526 |     |         address indexed token,
  527 |     |         Implementation oracleImplementation
  528 |     |     );
  529 |     |     event UpdatedStalkPerBdvPerSeason(
  530 |     |         address indexed token,
  531 |     |         uint40 stalkEarnedPerSeason,
  532 |     |         uint32 season
  533 |     |     );
  534 |     |     event WellOracle(uint32 indexed season, address well, int256 deltaB, bytes cumulativeReserves);
  535 |     |     event WhitelistToken(
  536 |     |         address indexed token,
  537 |     |         bytes4 selector,
  538 |     |         uint40 stalkEarnedPerSeason,
  539 |     |         uint256 stalkIssuedPerBdv,
  540 |     |         uint128 gaugePoints,
  541 |     |         uint64 optimalPercentDepositedBdv
  542 |     |     );
  543 |     |     event WhitelistTokenImplementations(
  544 |     |         address indexed token,
  545 |     |         Implementation gpImplementation,
  546 |     |         Implementation lwImplementation
  547 |     |     );
  548 |     | 
  549 |     |     function abovePeg() external view returns (bool);
  550 |     | 
  551 |     |     function activeField() external view returns (uint256);
  552 |     | 
  553 |     |     function addField() external;
  554 |     | 
  555 |     |     function addWhitelistSelector(address token, bytes4 selector) external;
  556 |     | 
  557 |     |     function addWhitelistStatus(
  558 |     |         address token,
  559 |     |         bool isWhitelisted,
  560 |     |         bool isWhitelistedLp,
  561 |     |         bool isWhitelistedWell,
  562 |     |         bool isSoppable
  563 |     |     ) external;
  564 |     | 
  565 |     |     function advancedFarm(
  566 |     |         AdvancedFarmCall[] memory data
  567 |     |     ) external payable returns (bytes[] memory results);
  568 |     | 
  569 |     |     function advancedPipe(
  570 |     |         AdvancedPipeCall[] memory pipes,
  571 |     |         uint256 value
  572 |     |     ) external payable returns (bytes[] memory results);
  573 |     | 
  574 |     |     function allowancePods(
  575 |     |         address owner,
  576 |     |         address spender,
  577 |     |         uint256 fieldId
  578 |     |     ) external view returns (uint256);
  579 |     | 
  580 |     |     function approveDeposit(address spender, address token, uint256 amount) external payable;
  581 |     | 
  582 |     |     function approvePods(address spender, uint256 fieldId, uint256 amount) external payable;
  583 |     | 
  584 |     |     function approveReceiver(address owner, address receiver) external;
  585 |     | 
  586 |     |     function approveToken(address spender, address token, uint256 amount) external payable;
  587 |     | 
  588 |     |     function balanceOf(address account, uint256 depositId) external view returns (uint256 amount);
  589 |     | 
  590 |     |     function balanceOfBatch(
  591 |     |         address[] memory accounts,
  592 |     |         uint256[] memory depositIds
  593 |     |     ) external view returns (uint256[] memory);
  594 |     | 
  595 |     |     function balanceOfDepositedBdv(
  596 |     |         address account,
  597 |     |         address token
  598 |     |     ) external view returns (uint256 depositedBdv);
  599 |     | 
  600 |     |     function balanceOfEarnedBeans(address account) external view returns (uint256 beans);
  601 |     | 
  602 |     |     function balanceOfEarnedStalk(address account) external view returns (uint256);
  603 |     | 
  604 |     |     function balanceOfFinishedGerminatingStalkAndRoots(
  605 |     |         address account
  606 |     |     ) external view returns (uint256 gStalk, uint256 gRoots);
  607 |     | 
  608 |     |     function balanceOfGerminatingStalk(address account) external view returns (uint256);
  609 |     | 
  610 |     |     function balanceOfGrownStalk(address account, address token) external view returns (uint256);
  611 |     | 
  612 |     |     function balanceOfGrownStalkMultiple(
  613 |     |         address account,
  614 |     |         address[] memory tokens
  615 |     |     ) external view returns (uint256[] memory grownStalks);
  616 |     | 
  617 |     |     function balanceOfPlantableSeeds(address account) external view returns (uint256);
  618 |     | 
  619 |     |     function balanceOfPlenty(address account, address well) external view returns (uint256 plenty);
  620 |     | 
  621 |     |     function balanceOfPods(address account, uint256 fieldId) external view returns (uint256 pods);
  622 |     | 
  623 |     |     function balanceOfRainRoots(address account) external view returns (uint256);
  624 |     | 
  625 |     |     function balanceOfRevitalizedStalk(
  626 |     |         address account,
  627 |     |         address[] memory tokens,
  628 |     |         int96[] memory stems,
  629 |     |         uint256[] memory amounts
  630 |     |     ) external view returns (uint256 stalk);
  631 |     | 
  632 |     |     function balanceOfRoots(address account) external view returns (uint256);
  633 |     | 
  634 |     |     function balanceOfSop(address account) external view returns (AccountSeasonOfPlenty memory sop);
  635 |     | 
  636 |     |     function balanceOfStalk(address account) external view returns (uint256);
  637 |     | 
  638 |     |     function balanceOfYoungAndMatureGerminatingStalk(
  639 |     |         address account
  640 |     |     ) external view returns (uint256 matureGerminatingStalk, uint256 youngGerminatingStalk);
  641 |     | 
  642 |     |     function batchTransferERC1155(
  643 |     |         address token,
  644 |     |         address to,
  645 |     |         uint256[] memory ids,
  646 |     |         uint256[] memory values
  647 |     |     ) external payable;
  648 |     | 
  649 |     |     function bdv(address token, uint256 amount) external view returns (uint256 _bdv);
  650 |     | 
  651 |     |     function bdvs(
  652 |     |         address[] memory tokens,
  653 |     |         uint256[] memory amounts
  654 |     |     ) external view returns (uint256 _bdv);
  655 |     | 
  656 |     |     function beanSown() external view returns (uint256);
  657 |     | 
  658 |     |     function beanToBDV(uint256 amount) external pure returns (uint256);
  659 |     | 
  660 |     |     function calcCaseIdE(int256 deltaB, uint128 endSoil) external;
  661 |     | 
  662 |     |     function calcCaseIdWithParams(
  663 |     |         uint256 pods,
  664 |     |         uint256 _lastDeltaSoil,
  665 |     |         uint128 beanSown,
  666 |     |         uint128 endSoil,
  667 |     |         int256 deltaB,
  668 |     |         bool raining,
  669 |     |         bool rainRoots,
  670 |     |         bool aboveQ,
  671 |     |         uint256 L2SRState
  672 |     |     ) external;
  673 |     | 
  674 |     |     function calcGaugePointsWithParams(
  675 |     |         address token,
  676 |     |         uint256 percentOfDepositedBdv
  677 |     |     ) external view returns (uint256);
  678 |     | 
  679 |     |     function calculateConvertCapacityPenaltyE(
  680 |     |         uint256 overallCappedDeltaB,
  681 |     |         uint256 overallAmountInDirectionOfPeg,
  682 |     |         address inputToken,
  683 |     |         uint256 inputTokenAmountInDirectionOfPeg,
  684 |     |         address outputToken,
  685 |     |         uint256 outputTokenAmountInDirectionOfPeg
  686 |     |     ) external view returns (uint256 cumulativePenalty, PenaltyData memory pdCapacity);
  687 |     | 
  688 |     |     function calculateDeltaBFromReserves(
  689 |     |         address well,
  690 |     |         uint256[] memory reserves,
  691 |     |         uint256 lookback
  692 |     |     ) external view returns (int256);
  693 |     | 
  694 |     |     function calculateStalkPenalty(
  695 |     |         DeltaBStorage memory dbs,
  696 |     |         uint256 bdvConverted,
  697 |     |         uint256 overallConvertCapacity,
  698 |     |         address inputToken,
  699 |     |         address outputToken
  700 |     |     )
  701 |     |         external
  702 |     |         view
  703 |     |         returns (
  704 |     |             uint256 stalkPenaltyBdv,
  705 |     |             uint256 overallConvertCapacityUsed,
  706 |     |             uint256 inputTokenAmountUsed,
  707 |     |             uint256 outputTokenAmountUsed
  708 |     |         );
  709 |     | 
  710 |     |     function calculateStemForTokenFromGrownStalk(
  711 |     |         address token,
  712 |     |         uint256 grownStalk,
  713 |     |         uint256 bdvOfDeposit
  714 |     |     ) external view returns (int96 stem, GerminationSide germ);
  715 |     | 
  716 |     |     function calculateCultivationFactorDeltaE(
  717 |     |         BeanstalkState memory bs
  718 |     |     ) external view returns (uint256);
  719 |     | 
  720 |     |     function getGauge(GaugeId gaugeId) external view returns (Gauge memory);
  721 |     | 
  722 |     |     function getGaugeValue(GaugeId gaugeId) external view returns (bytes memory);
  723 |     | 
  724 |     |     function getGaugeData(GaugeId gaugeId) external view returns (bytes memory);
  725 |     | 
  726 |     |     function cancelBlueprint(Requisition memory requisition) external;
  727 |     | 
  728 |     |     function cancelPodListing(uint256 fieldId, uint256 index) external payable;
  729 |     | 
  730 |     |     function cancelPodOrder(PodOrder memory podOrder, uint8 mode) external payable;
  731 |     | 
  732 |     |     function cappedReservesDeltaB(address well) external view returns (int256 deltaB);
  733 |     | 
  734 |     |     function captureE() external returns (int256 deltaB);
  735 |     | 
  736 |     |     function captureWellE(address well) external returns (int256 deltaB);
  737 |     | 
  738 |     |     function captureWellEInstantaneous(address well) external returns (int256 instDeltaB);
  739 |     | 
  740 |     |     function claimAllPlenty(
  741 |     |         uint8 toMode
  742 |     |     ) external payable returns (ClaimPlentyData[] memory allPlenty);
  743 |     | 
  744 |     |     function claimOwnership() external;
  745 |     | 
  746 |     |     function claimPlenty(address well, uint8 toMode) external payable;
  747 |     | 
  748 |     |     function convert(
  749 |     |         bytes memory convertData,
  750 |     |         int96[] memory stems,
  751 |     |         uint256[] memory amounts
  752 |     |     )
  753 |     |         external
  754 |     |         payable
  755 |     |         returns (
  756 |     |             int96 toStem,
  757 |     |             uint256 fromAmount,
  758 |     |             uint256 toAmount,
  759 |     |             uint256 fromBdv,
  760 |     |             uint256 toBdv
  761 |     |         );
  762 |     | 
  763 |     |     function convertInternalE(
  764 |     |         address tokenIn,
  765 |     |         uint256 amountIn,
  766 |     |         bytes memory convertData
  767 |     |     )
  768 |     |         external
  769 |     |         returns (
  770 |     |             address toToken,
  771 |     |             address fromToken,
  772 |     |             uint256 toAmount,
  773 |     |             uint256 fromAmount,
  774 |     |             address account,
  775 |     |             bool decreaseBDV
  776 |     |         );
  777 |     | 
  778 |     |     function createPodListing(PodListing memory podListing) external payable;
  779 |     | 
  780 |     |     function createPodOrder(
  781 |     |         PodOrder memory podOrder,
  782 |     |         uint256 beanAmount,
  783 |     |         uint8 mode
  784 |     |     ) external payable returns (bytes32 id);
  785 |     | 
  786 |     |     function cumulativeCurrentDeltaB(address[] memory pools) external view returns (int256 deltaB);
  787 |     | 
  788 |     |     function decreaseDepositAllowance(
  789 |     |         address spender,
  790 |     |         address token,
  791 |     |         uint256 subtractedValue
  792 |     |     ) external returns (bool);
  793 |     | 
  794 |     |     function decreaseTokenAllowance(
  795 |     |         address spender,
  796 |     |         address token,
  797 |     |         uint256 subtractedValue
  798 |     |     ) external returns (bool);
  799 |     | 
  800 |     |     function defaultGaugePoints(
  801 |     |         uint256 currentGaugePoints,
  802 |     |         uint256 optimalPercentDepositedBdv,
  803 |     |         uint256 percentOfDepositedBdv,
  804 |     |         bytes memory
  805 |     |     ) external pure returns (uint256 newGaugePoints);
  806 |     | 
  807 |     |     function deposit(
  808 |     |         address token,
  809 |     |         uint256 _amount,
  810 |     |         uint8 mode
  811 |     |     ) external payable returns (uint256 amount, uint256 _bdv, int96 stem);
  812 |     | 
  813 |     |     function depositAllowance(
  814 |     |         address owner,
  815 |     |         address spender,
  816 |     |         address token
  817 |     |     ) external view returns (uint256);
  818 |     | 
  819 |     |     function depositForConvertE(
  820 |     |         address token,
  821 |     |         uint256 amount,
  822 |     |         uint256 bdv,
  823 |     |         uint256 grownStalk,
  824 |     |         uint256 deltaRainRoots
  825 |     |     ) external;
  826 |     | 
  827 |     |     function determineReward(uint256 secondsLate) external view returns (uint256);
  828 |     | 
  829 |     |     function dewhitelistToken(address token) external payable;
  830 |     | 
  831 |     |     function diamondCut(
  832 |     |         FacetCut[] memory _diamondCut,
  833 |     |         address _init,
  834 |     |         bytes memory _calldata
  835 |     |     ) external;
  836 |     | 
  837 |     |     function droughtSiloSunrise(uint256 amount) external;
  838 |     | 
  839 |     |     function droughtSunrise() external;
  840 |     | 
  841 |     |     function etherPipe(
  842 |     |         PipeCall memory p,
  843 |     |         uint256 value
  844 |     |     ) external payable returns (bytes memory result);
  845 |     | 
  846 |     |     function exploitPodOrderBeans() external;
  847 |     | 
  848 |     |     function exploitSop() external;
  849 |     | 
  850 |     |     function exploitUserInternalTokenBalance() external;
  851 |     | 
  852 |     |     function exploitUserSendTokenInternal() external;
  853 |     | 
  854 |     |     function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
  855 |     | 
  856 |     |     function facetAddresses() external view returns (address[] memory facetAddresses_);
  857 |     | 
  858 |     |     function facetFunctionSelectors(
  859 |     |         address _facet
  860 |     |     ) external view returns (bytes4[] memory facetFunctionSelectors_);
  861 |     | 
  862 |     |     function facets() external view returns (Facet[] memory facets_);
  863 |     | 
  864 |     |     function farm(bytes[] memory data) external payable returns (bytes[] memory results);
  865 |     | 
  866 |     |     function farmSunrise() external;
  867 |     | 
  868 |     |     function farmSunrises(uint256 number) external;
  869 |     | 
  870 |     |     function fastForward(uint32 _s) external;
  871 |     | 
  872 |     |     function fieldCount() external view returns (uint256);
  873 |     | 
  874 |     |     function fillPodListing(
  875 |     |         PodListing memory podListing,
  876 |     |         uint256 beanAmount,
  877 |     |         uint8 mode
  878 |     |     ) external payable;
  879 |     | 
  880 |     |     function fillPodOrder(
  881 |     |         PodOrder memory podOrder,
  882 |     |         uint256 index,
  883 |     |         uint256 start,
  884 |     |         uint256 amount,
  885 |     |         uint8 mode
  886 |     |     ) external payable;
  887 |     | 
  888 |     |     function floodHarvestablePods() external view returns (uint256);
  889 |     | 
  890 |     |     function forceSunrise() external;
  891 |     | 
  892 |     |     function gaugePointsNoChange(
  893 |     |         uint256 currentGaugePoints,
  894 |     |         uint256,
  895 |     |         uint256
  896 |     |     ) external pure returns (uint256);
  897 |     | 
  898 |     |     function getAbsBeanToMaxLpRatioChangeFromCaseId(
  899 |     |         uint256 caseId
  900 |     |     ) external view returns (uint80 ml);
  901 |     | 
  902 |     |     function getAbsTemperatureChangeFromCaseId(uint256 caseId) external view returns (int32 t);
  903 |     | 
  904 |     |     function getAddressAndStem(uint256 depositId) external pure returns (address token, int96 stem);
  905 |     | 
  906 |     |     function getAllBalance(address account, address token) external view returns (Balance memory b);
  907 |     | 
  908 |     |     function getAllBalances(
  909 |     |         address account,
  910 |     |         address[] memory tokens
  911 |     |     ) external view returns (Balance[] memory balances);
  912 |     | 
  913 |     |     function getAmountOut(
  914 |     |         address tokenIn,
  915 |     |         address tokenOut,
  916 |     |         uint256 amountIn
  917 |     |     ) external view returns (uint256 amountOut);
  918 |     | 
  919 |     |     function getAverageGrownStalkPerBdv() external view returns (uint256);
  920 |     | 
  921 |     |     function getAverageGrownStalkPerBdvPerSeason() external view returns (uint128);
  922 |     | 
  923 |     |     function getBalance(address account, address token) external view returns (uint256 balance);
  924 |     | 
  925 |     |     function getBalances(
  926 |     |         address account,
  927 |     |         address[] memory tokens
  928 |     |     ) external view returns (uint256[] memory balances);
  929 |     | 
  930 |     |     function getBeanGaugePointsPerBdv() external view returns (uint256);
  931 |     | 
  932 |     |     function getBeanToken() external view returns (address);
  933 |     | 
  934 |     |     function getBeanIndex(IERC20[] memory tokens) external view returns (uint256);
  935 |     | 
  936 |     |     function getBeanToMaxLpGpPerBdvRatio() external view returns (uint256);
  937 |     | 
  938 |     |     function getBeanToMaxLpGpPerBdvRatioScaled() external view returns (uint256);
  939 |     | 
  940 |     |     function getBlueprintHash(Blueprint memory blueprint) external view returns (bytes32);
  941 |     | 
  942 |     |     function getBlueprintNonce(bytes32 blueprintHash) external view returns (uint256);
  943 |     | 
  944 |     |     function getCaseData(uint256 caseId) external view returns (bytes32 casesData);
  945 |     | 
  946 |     |     function getCases() external view returns (bytes32[144] memory cases);
  947 |     | 
  948 |     |     function getChangeFromCaseId(
  949 |     |         uint256 caseId
  950 |     |     ) external view returns (uint32, int32, uint80, int80);
  951 |     | 
  952 |     |     function getCounter(address account, bytes32 counterId) external view returns (uint256 count);
  953 |     | 
  954 |     |     function getCurrentBlueprintHash() external view returns (bytes32);
  955 |     | 
  956 |     |     function getCurrentHumidity() external view returns (uint128 humidity);
  957 |     | 
  958 |     |     function getDeltaPodDemand() external view returns (uint256);
  959 |     | 
  960 |     |     function getDeltaPodDemandLowerBound() external view returns (uint256);
  961 |     | 
  962 |     |     function getDeltaPodDemandUpperBound() external view returns (uint256);
  963 |     | 
  964 |     |     function getDeposit(
  965 |     |         address account,
  966 |     |         address token,
  967 |     |         int96 stem
  968 |     |     ) external view returns (uint256, uint256);
  969 |     | 
  970 |     |     function getDepositId(address token, int96 stem) external pure returns (uint256);
  971 |     | 
  972 |     |     function getDepositMerkleRoot() external pure returns (bytes32);
  973 |     | 
  974 |     |     function getDepositsForAccount(
  975 |     |         address account
  976 |     |     ) external view returns (TokenDepositId[] memory deposits);
  977 |     | 
  978 |     |     function getEndBpf() external view returns (uint128 endBpf);
  979 |     | 
  980 |     |     function getEvenGerminating(address token) external view returns (uint256, uint256);
  981 |     | 
  982 |     |     function getExcessivePriceThreshold() external view returns (uint256);
  983 |     | 
  984 |     |     function getExternalBalance(
  985 |     |         address account,
  986 |     |         address token
  987 |     |     ) external view returns (uint256 balance);
  988 |     | 
  989 |     |     function getExternalBalances(
  990 |     |         address account,
  991 |     |         address[] memory tokens
  992 |     |     ) external view returns (uint256[] memory balances);
  993 |     | 
  994 |     |     function getExtremelyFarAbove(uint256 optimalPercentBdv) external pure returns (uint256);
  995 |     | 
  996 |     |     function getExtremelyFarBelow(uint256 optimalPercentBdv) external pure returns (uint256);
  997 |     | 
  998 |     |     function getFirst() external view returns (uint128);
  999 |     | 
 1000 |     |     function getGaugePointImplementationForToken(
 1001 |     |         address token
 1002 |     |     ) external view returns (Implementation memory);
 1003 |     | 
 1004 |     |     function getGaugePoints(address token) external view returns (uint256);
 1005 |     | 
 1006 |     |     function getGaugePointsPerBdvForToken(address token) external view returns (uint256);
 1007 |     | 
 1008 |     |     function getGaugePointsPerBdvForWell(address well) external view returns (uint256);
 1009 |     | 
 1010 |     |     function getGaugePointsWithParams(address token) external view returns (uint256);
 1011 |     | 
 1012 |     |     function getGerminatingRootsForSeason(uint32 season) external view returns (uint256);
 1013 |     | 
 1014 |     |     function getGerminatingStalkAndRootsForSeason(
 1015 |     |         uint32 season
 1016 |     |     ) external view returns (uint256, uint256);
 1017 |     | 
 1018 |     |     function getGerminatingStalkForSeason(uint32 season) external view returns (uint256);
 1019 |     | 
 1020 |     |     function getGerminatingStem(address token) external view returns (int96 germinatingStem);
 1021 |     | 
 1022 |     |     function getHighestNonGerminatingStem(address token) external view returns (int96 stem);
 1023 |     | 
 1024 |     |     function getGerminatingStems(
 1025 |     |         address[] memory tokens
 1026 |     |     ) external view returns (int96[] memory germinatingStems);
 1027 |     | 
 1028 |     |     function getHighestNonGerminatingStems(
 1029 |     |         address[] memory tokens
 1030 |     |     ) external view returns (int96[] memory highestNonGerminatingStems);
 1031 |     | 
 1032 |     |     function getGerminatingTotalDeposited(address token) external view returns (uint256 amount);
 1033 |     | 
 1034 |     |     function getGerminatingTotalDepositedBdv(address token) external view returns (uint256 _bdv);
 1035 |     | 
 1036 |     |     function getGrownStalkIssuedPerGp() external view returns (uint256);
 1037 |     | 
 1038 |     |     function getGrownStalkIssuedPerSeason() external view returns (uint256);
 1039 |     | 
 1040 |     |     function getHumidity(uint128 _s) external pure returns (uint128 humidity);
 1041 |     | 
 1042 |     |     function getIndexForDepositId(
 1043 |     |         address account,
 1044 |     |         address token,
 1045 |     |         uint256 depositId
 1046 |     |     ) external view returns (uint256);
 1047 |     | 
 1048 |     |     function getInternalBalance(
 1049 |     |         address account,
 1050 |     |         address token
 1051 |     |     ) external view returns (uint256 balance);
 1052 |     | 
 1053 |     |     function getInternalBalanceMerkleRoot() external pure returns (bytes32);
 1054 |     | 
 1055 |     |     function getInternalBalances(
 1056 |     |         address account,
 1057 |     |         address[] memory tokens
 1058 |     |     ) external view returns (uint256[] memory balances);
 1059 |     | 
 1060 |     |     function getLargestGpPerBdv() external view returns (uint256);
 1061 |     | 
 1062 |     |     function getLargestLiqWell() external view returns (address);
 1063 |     | 
 1064 |     |     function getLast() external view returns (uint128);
 1065 |     | 
 1066 |     |     function getLastMowedStem(
 1067 |     |         address account,
 1068 |     |         address token
 1069 |     |     ) external view returns (int96 lastStem);
 1070 |     | 
 1071 |     |     function getLiquidityToSupplyRatio() external view returns (uint256);
 1072 |     | 
 1073 |     |     function getLiquidityWeightImplementationForToken(
 1074 |     |         address token
 1075 |     |     ) external view returns (Implementation memory);
 1076 |     | 
 1077 |     |     function getLpToSupplyRatioLowerBound() external view returns (uint256);
 1078 |     | 
 1079 |     |     function getLpToSupplyRatioOptimal() external view returns (uint256);
 1080 |     | 
 1081 |     |     function getLpToSupplyRatioUpperBound() external view returns (uint256);
 1082 |     | 
 1083 |     |     function getMaxAmountIn(
 1084 |     |         address tokenIn,
 1085 |     |         address tokenOut
 1086 |     |     ) external view returns (uint256 amountIn);
 1087 |     | 
 1088 |     |     function getMaxBeanMaxLpGpPerBdvRatio() external view returns (uint256);
 1089 |     | 
 1090 |     |     function getMinBeanMaxLpGpPerBdvRatio() external view returns (uint256);
 1091 |     | 
 1092 |     |     function getMowStatus(
 1093 |     |         address account,
 1094 |     |         address[] memory tokens
 1095 |     |     ) external view returns (MowStatus[] memory mowStatuses);
 1096 |     | 
 1097 |     |     function getNext(uint128 id) external view returns (uint128);
 1098 |     | 
 1099 |     |     function getNextSeasonStart() external view returns (uint256);
 1100 |     | 
 1101 |     |     function getNonBeanTokenAndIndexFromWell(address well) external view returns (address, uint256);
 1102 |     | 
 1103 |     |     function getOddGerminating(address token) external view returns (uint256, uint256);
 1104 |     | 
 1105 |     |     function getOracleImplementationForToken(
 1106 |     |         address token
 1107 |     |     ) external view returns (Implementation memory);
 1108 |     | 
 1109 |     |     function getOrderId(PodOrder memory podOrder) external pure returns (bytes32 id);
 1110 |     | 
 1111 |     |     function getOverallConvertCapacity() external view returns (uint256);
 1112 |     | 
 1113 |     |     function getPlotIndexesFromAccount(
 1114 |     |         address account,
 1115 |     |         uint256 fieldId
 1116 |     |     ) external view returns (uint256[] memory plotIndexes);
 1117 |     | 
 1118 |     |     function getPlotMerkleRoot() external pure returns (bytes32);
 1119 |     | 
 1120 |     |     function getPlotsFromAccount(
 1121 |     |         address account,
 1122 |     |         uint256 fieldId
 1123 |     |     ) external view returns (Plot[] memory plots);
 1124 |     | 
 1125 |     |     function getPodListing(uint256 fieldId, uint256 index) external view returns (bytes32 id);
 1126 |     | 
 1127 |     |     function getPodOrder(bytes32 id) external view returns (uint256);
 1128 |     | 
 1129 |     |     function getPodRate(uint256 fieldId) external view returns (uint256);
 1130 |     | 
 1131 |     |     function getPodRateLowerBound() external view returns (uint256);
 1132 |     | 
 1133 |     |     function getPodRateOptimal() external view returns (uint256);
 1134 |     | 
 1135 |     |     function getPodRateUpperBound() external view returns (uint256);
 1136 |     | 
 1137 |     |     function getPoolDeltaBWithoutCap(address well) external view returns (int256 deltaB);
 1138 |     | 
 1139 |     |     function getPublisherCounter(bytes32 counterId) external view returns (uint256 count);
 1140 |     | 
 1141 |     |     function getReceiver(address owner) external view returns (address);
 1142 |     | 
 1143 |     |     function getRelBeanToMaxLpRatioChangeFromCaseId(uint256 caseId) external view returns (int80 l);
 1144 |     | 
 1145 |     |     function getRelTemperatureChangeFromCaseId(uint256 caseId) external view returns (uint32 mt);
 1146 |     | 
 1147 |     |     function getRelativelyFarAbove(uint256 optimalPercentBdv) external pure returns (uint256);
 1148 |     | 
 1149 |     |     function getRelativelyFarBelow(uint256 optimalPercentBdv) external pure returns (uint256);
 1150 |     | 
 1151 |     |     function getSeasonStart() external view returns (uint256);
 1152 |     | 
 1153 |     |     function getSeasonStruct() external view returns (Season memory);
 1154 |     | 
 1155 |     |     function getSeasonTimestamp() external view returns (uint256);
 1156 |     | 
 1157 |     |     function getSeedGauge() external view returns (SeedGauge memory);
 1158 |     | 
 1159 |     |     function getSeedGaugeSetting() external view returns (EvaluationParameters memory);
 1160 |     | 
 1161 |     |     function getEvaluationParameters() external view returns (EvaluationParameters memory);
 1162 |     | 
 1163 |     |     function getExtEvaluationParameters() external view returns (ExtEvaluationParameters memory);
 1164 |     | 
 1165 |     |     function getShipmentRoutes() external view returns (ShipmentRoute[] memory);
 1166 |     | 
 1167 |     |     function getSiloTokens() external view returns (address[] memory tokens);
 1168 |     | 
 1169 |     |     function getStemTips() external view returns (int96[] memory _stemTips);
 1170 |     | 
 1171 |     |     function getT() external view returns (uint256);
 1172 |     | 
 1173 |     |     function getTargetSeasonsToCatchUp() external view returns (uint256);
 1174 |     | 
 1175 |     |     function getTokenDepositIdsForAccount(
 1176 |     |         address account,
 1177 |     |         address token
 1178 |     |     ) external view returns (uint256[] memory depositIds);
 1179 |     | 
 1180 |     |     function getTokenDepositsForAccount(
 1181 |     |         address account,
 1182 |     |         address token
 1183 |     |     ) external view returns (TokenDepositId memory deposits);
 1184 |     | 
 1185 |     |     function getTokenUsdPrice(address token) external view returns (uint256);
 1186 |     | 
 1187 |     |     function getTokenUsdPriceFromExternal(
 1188 |     |         address token,
 1189 |     |         uint256 lookback
 1190 |     |     ) external view returns (uint256 tokenUsd);
 1191 |     | 
 1192 |     |     function getTokenUsdTwap(address token, uint256 lookback) external view returns (uint256);
 1193 |     | 
 1194 |     |     function getTotalBdv() external view returns (uint256 totalBdv);
 1195 |     | 
 1196 |     |     function getTotalDeposited(address token) external view returns (uint256);
 1197 |     | 
 1198 |     |     function getTotalDepositedBdv(address token) external view returns (uint256);
 1199 |     | 
 1200 |     |     function getTotalGerminatingAmount(address token) external view returns (uint256);
 1201 |     | 
 1202 |     |     function getTotalGerminatingBdv(address token) external view returns (uint256);
 1203 |     | 
 1204 |     |     function getTotalGerminatingStalk() external view returns (uint256);
 1205 |     | 
 1206 |     |     function getTotalRecapDollarsNeeded() external view returns (uint256);
 1207 |     | 
 1208 |     |     function getTotalSiloDeposited() external view returns (uint256[] memory depositedAmounts);
 1209 |     | 
 1210 |     |     function getTotalSiloDepositedBdv() external view returns (uint256[] memory depositedBdvs);
 1211 |     | 
 1212 |     |     function getTotalUsdLiquidity() external view returns (uint256 totalLiquidity);
 1213 |     | 
 1214 |     |     function getTotalWeightedUsdLiquidity() external view returns (uint256 totalWeightedLiquidity);
 1215 |     | 
 1216 |     |     function getTractorVersion() external view returns (string memory);
 1217 |     | 
 1218 |     |     function getTwaLiquidityForWell(address well) external view returns (uint256);
 1219 |     | 
 1220 |     |     function getUsdTokenPrice(address token) external view returns (uint256);
 1221 |     | 
 1222 |     |     function getUsdTokenPriceFromExternal(
 1223 |     |         address token,
 1224 |     |         uint256 lookback
 1225 |     |     ) external view returns (uint256 usdToken);
 1226 |     | 
 1227 |     |     function getUsdTokenTwap(address token, uint256 lookback) external view returns (uint256);
 1228 |     | 
 1229 |     |     function getWeightedTwaLiquidityForWell(address well) external view returns (uint256);
 1230 |     | 
 1231 |     |     function getWellConvertCapacity(address well) external view returns (uint256);
 1232 |     | 
 1233 |     |     function getWellsByDeltaB()
 1234 |     |         external
 1235 |     |         view
 1236 |     |         returns (
 1237 |     |             WellDeltaB[] memory wellDeltaBs,
 1238 |     |             uint256 totalPositiveDeltaB,
 1239 |     |             uint256 totalNegativeDeltaB,
 1240 |     |             uint256 positiveDeltaBCount
 1241 |     |         );
 1242 |     | 
 1243 |     |     function getWhitelistStatus(
 1244 |     |         address token
 1245 |     |     ) external view returns (WhitelistStatus memory _whitelistStatuses);
 1246 |     | 
 1247 |     |     function getWhitelistStatuses()
 1248 |     |         external
 1249 |     |         view
 1250 |     |         returns (WhitelistStatus[] memory _whitelistStatuses);
 1251 |     | 
 1252 |     |     function getWhitelistedLpTokens() external view returns (address[] memory tokens);
 1253 |     | 
 1254 |     |     function getWhitelistedTokens() external view returns (address[] memory tokens);
 1255 |     | 
 1256 |     |     function getWhitelistedWellLpTokens() external view returns (address[] memory tokens);
 1257 |     | 
 1258 |     |     function getYoungAndMatureGerminatingTotalStalk()
 1259 |     |         external
 1260 |     |         view
 1261 |     |         returns (uint256 matureGerminatingStalk, uint256 youngGerminatingStalk);
 1262 |     | 
 1263 |     |     function getCultivationFactor(uint256 fieldId) external view returns (uint256);
 1264 |     | 
 1265 |     |     function getCultivationFactorForActiveField() external view returns (uint256);
 1266 |     | 
 1267 |     |     function gm(address account, uint8 mode) external payable returns (uint256);
 1268 |     | 
 1269 |     |     function grownStalkForDeposit(
 1270 |     |         address account,
 1271 |     |         address token,
 1272 |     |         int96 stem
 1273 |     |     ) external view returns (uint256 grownStalk);
 1274 |     | 
 1275 |     |     function harvest(uint256 fieldId, uint256[] memory plots, uint8 mode) external payable;
 1276 |     | 
 1277 |     |     function harvestableIndex(uint256 fieldId) external view returns (uint256);
 1278 |     | 
 1279 |     |     function imageURI(
 1280 |     |         address token,
 1281 |     |         int96 stem,
 1282 |     |         int96 stemTip
 1283 |     |     ) external view returns (string memory);
 1284 |     | 
 1285 |     |     function increaseDepositAllowance(
 1286 |     |         address spender,
 1287 |     |         address token,
 1288 |     |         uint256 addedValue
 1289 |     |     ) external returns (bool);
 1290 |     | 
 1291 |     |     function increaseTokenAllowance(
 1292 |     |         address spender,
 1293 |     |         address token,
 1294 |     |         uint256 addedValue
 1295 |     |     ) external returns (bool);
 1296 |     | 
 1297 |     |     function incrementTotalHarvestableE(uint256 fieldId, uint256 amount) external;
 1298 |     | 
 1299 |     |     function incrementTotalPodsE(uint256 fieldId, uint256 amount) external;
 1300 |     | 
 1301 |     |     function incrementTotalSoilE(uint128 amount) external;
 1302 |     | 
 1303 |     |     function initialSoil() external view returns (uint256);
 1304 |     | 
 1305 |     |     function initOracleForAllWhitelistedWells() external;
 1306 |     | 
 1307 |     |     function isApprovedForAll(address _owner, address _operator) external view returns (bool);
 1308 |     | 
 1309 |     |     function isHarvesting(uint256 fieldId) external view returns (bool);
 1310 |     | 
 1311 |     |     function lastDeltaSoil() external view returns (uint256);
 1312 |     | 
 1313 |     |     function lastSeasonOfPlenty() external view returns (uint32);
 1314 |     | 
 1315 |     |     function lastSowTime() external view returns (uint256);
 1316 |     | 
 1317 |     |     function lastUpdate(address account) external view returns (uint32);
 1318 |     | 
 1319 |     |     function lightSunrise() external;
 1320 |     | 
 1321 |     |     function maxTemperature() external view returns (uint256);
 1322 |     | 
 1323 |     |     function maxWeight(bytes memory) external pure returns (uint256);
 1324 |     | 
 1325 |     |     function mintBeans(address to, uint256 amount) external;
 1326 |     | 
 1327 |     |     function mockBDV(uint256 amount) external pure returns (uint256);
 1328 |     | 
 1329 |     |     function mockBDVDecrease(uint256 amount) external pure returns (uint256);
 1330 |     | 
 1331 |     |     function mockBDVIncrease(uint256 amount) external pure returns (uint256);
 1332 |     | 
 1333 |     |     function mockcalcCaseIdAndHandleRain(
 1334 |     |         int256 deltaB
 1335 |     |     ) external returns (uint256 caseId, BeanstalkState memory bs);
 1336 |     | 
 1337 |     |     function mockChangeBDVSelector(address token, bytes4 selector) external;
 1338 |     | 
 1339 |     |     function mockEndTotalGerminationForToken(address token) external;
 1340 |     | 
 1341 |     |     function mockGetMorningTemp(
 1342 |     |         uint256 initalTemp,
 1343 |     |         uint256 delta
 1344 |     |     ) external pure returns (uint256 scaledTemperature);
 1345 |     | 
 1346 |     |     function mockIncrementGermination(
 1347 |     |         address account,
 1348 |     |         address token,
 1349 |     |         uint128 amount,
 1350 |     |         uint128 bdv,
 1351 |     |         GerminationSide side
 1352 |     |     ) external;
 1353 |     | 
 1354 |     |     function mockInitState() external;
 1355 |     | 
 1356 |     |     function mockLiquidityWeight() external pure returns (uint256);
 1357 |     | 
 1358 |     |     function mockSetMilestoneStem(address token, int96 stem) external;
 1359 |     | 
 1360 |     |     function mockSetMilestoneSeason(address token, uint32 season) external;
 1361 |     | 
 1362 |     |     function mockSetAverageGrownStalkPerBdvPerSeason(
 1363 |     |         uint128 _averageGrownStalkPerBdvPerSeason
 1364 |     |     ) external;
 1365 |     | 
 1366 |     |     function mockSow(
 1367 |     |         uint256 bean,
 1368 |     |         uint256 _morningTemperature,
 1369 |     |         uint32 maxTemperature,
 1370 |     |         bool abovePeg
 1371 |     |     ) external returns (uint256 pods);
 1372 |     | 
 1373 |     |     function mockStepGauge() external;
 1374 |     | 
 1375 |     |     function mockStepSeason() external returns (uint32 season);
 1376 |     | 
 1377 |     |     function mockStepSilo(uint256 amount) external;
 1378 |     | 
 1379 |     |     function mockUpdateAverageGrownStalkPerBdvPerSeason() external;
 1380 |     | 
 1381 |     |     function mockUpdateAverageStalkPerBdvPerSeason() external;
 1382 |     | 
 1383 |     |     function mockUpdateLiquidityWeight(
 1384 |     |         address token,
 1385 |     |         address newLiquidityWeightImplementation,
 1386 |     |         bytes1 encodeType,
 1387 |     |         bytes4 selector,
 1388 |     |         bytes memory data
 1389 |     |     ) external;
 1390 |     | 
 1391 |     |     function mockWhitelistToken(
 1392 |     |         address token,
 1393 |     |         bytes4 selector,
 1394 |     |         uint48 stalkIssuedPerBdv,
 1395 |     |         uint40 stalkEarnedPerSeason
 1396 |     |     ) external;
 1397 |     | 
 1398 |     |     function mockWhitelistTokenWithGauge(
 1399 |     |         address token,
 1400 |     |         bytes4 selector,
 1401 |     |         uint16 stalkIssuedPerBdv,
 1402 |     |         uint40 stalkEarnedPerSeason,
 1403 |     |         bytes1 encodeType,
 1404 |     |         bytes4 gaugePointSelector,
 1405 |     |         bytes4 liquidityWeightSelector,
 1406 |     |         uint128 gaugePoints,
 1407 |     |         uint64 optimalPercentDepositedBdv
 1408 |     |     ) external;
 1409 |     | 
 1410 |     |     function mockinitializeGaugeForToken(
 1411 |     |         address token,
 1412 |     |         bytes4 gaugePointSelector,
 1413 |     |         bytes4 liquidityWeightSelector,
 1414 |     |         uint96 gaugePoints,
 1415 |     |         uint64 optimalPercentDepositedBdv
 1416 |     |     ) external;
 1417 |     | 
 1418 |     |     function mow(address account, address token) external payable;
 1419 |     | 
 1420 |     |     function mowMultiple(address account, address[] memory tokens) external payable;
 1421 |     | 
 1422 |     |     function multiPipe(PipeCall[] memory pipes) external payable returns (bytes[] memory results);
 1423 |     | 
 1424 |     |     function name() external pure returns (string memory);
 1425 |     | 
 1426 |     |     function newMockBDV() external pure returns (uint256);
 1427 |     | 
 1428 |     |     function newMockBDVDecrease() external pure returns (uint256);
 1429 |     | 
 1430 |     |     function newMockBDVIncrease() external pure returns (uint256);
 1431 |     | 
 1432 |     |     function noWeight(bytes memory) external pure returns (uint256);
 1433 |     | 
 1434 |     |     function onERC1155BatchReceived(
 1435 |     |         address,
 1436 |     |         address,
 1437 |     |         uint256[] memory,
 1438 |     |         uint256[] memory,
 1439 |     |         bytes memory
 1440 |     |     ) external pure returns (bytes4);
 1441 |     | 
 1442 |     |     function onERC1155Received(
 1443 |     |         address,
 1444 |     |         address,
 1445 |     |         uint256,
 1446 |     |         uint256,
 1447 |     |         bytes memory
 1448 |     |     ) external pure returns (bytes4);
 1449 |     | 
 1450 |     |     function overallCappedDeltaB() external view returns (int256 deltaB);
 1451 |     | 
 1452 |     |     function overallCurrentDeltaB() external view returns (int256 deltaB);
 1453 |     | 
 1454 |     |     function owner() external view returns (address owner_);
 1455 |     | 
 1456 |     |     function ownerCandidate() external view returns (address ownerCandidate_);
 1457 |     | 
 1458 |     |     function pause() external payable;
 1459 |     | 
 1460 |     |     function paused() external view returns (bool);
 1461 |     | 
 1462 |     |     function pipe(PipeCall memory p) external payable returns (bytes memory result);
 1463 |     | 
 1464 |     |     function pipelineConvert(
 1465 |     |         address inputToken,
 1466 |     |         int96[] calldata stems,
 1467 |     |         uint256[] calldata amounts,
 1468 |     |         address outputToken,
 1469 |     |         AdvancedPipeCall[] memory advancedPipeCalls
 1470 |     |     )
 1471 |     |         external
 1472 |     |         payable
 1473 |     |         returns (
 1474 |     |             int96 toStem,
 1475 |     |             uint256 fromAmount,
 1476 |     |             uint256 toAmount,
 1477 |     |             uint256 fromBdv,
 1478 |     |             uint256 toBdv
 1479 |     |         );
 1480 |     | 
 1481 |     |     function plant() external payable returns (uint256 beans, int96 stem);
 1482 |     | 
 1483 |     |     function plentyPerRoot(uint32 _season, address well) external view returns (uint256);
 1484 |     | 
 1485 |     |     function plot(address account, uint256 fieldId, uint256 index) external view returns (uint256);
 1486 |     | 
 1487 |     |     function podIndex(uint256 fieldId) external view returns (uint256);
 1488 |     | 
 1489 |     |     function poolCurrentDeltaB(address pool) external view returns (int256 deltaB);
 1490 |     | 
 1491 |     |     function poolCurrentDeltaBMock(address pool) external view returns (int256 deltaB);
 1492 |     | 
 1493 |     |     function poolDeltaB(address pool) external view returns (int256);
 1494 |     | 
 1495 |     |     function publishRequisition(Requisition memory requisition) external;
 1496 |     | 
 1497 |     |     function rain() external view returns (Rain memory);
 1498 |     | 
 1499 |     |     function rainSiloSunrise(uint256 amount) external;
 1500 |     | 
 1501 |     |     function rainSunrise() external;
 1502 |     | 
 1503 |     |     function rainSunrises(uint256 amount) external;
 1504 |     | 
 1505 |     |     function readPipe(PipeCall memory p) external view returns (bytes memory result);
 1506 |     | 
 1507 |     |     function recieveL1Beans(address receiver, uint256 amount, uint8 toMode) external;
 1508 |     | 
 1509 |     |     function reentrancyGuardTest() external;
 1510 |     | 
 1511 |     |     function remainingPods() external view returns (uint256);
 1512 |     | 
 1513 |     |     function remainingRecapitalization() external view returns (uint256);
 1514 |     | 
 1515 |     |     function removeWhitelistSelector(address token) external;
 1516 |     | 
 1517 |     |     function resetPools(address[] memory pools) external;
 1518 |     | 
 1519 |     |     function resetSeasonStart(uint256 amount) external;
 1520 |     | 
 1521 |     |     function resetState() external;
 1522 |     | 
 1523 |     |     function revert_netFlow() external;
 1524 |     | 
 1525 |     |     function revert_oneOutFlow() external;
 1526 |     | 
 1527 |     |     function revert_outFlow() external;
 1528 |     | 
 1529 |     |     function revert_supplyChange() external;
 1530 |     | 
 1531 |     |     function revert_supplyIncrease() external;
 1532 |     | 
 1533 |     |     function rewardSilo(uint256 amount) external;
 1534 |     | 
 1535 |     |     function rewardSunrise(uint256 amount) external;
 1536 |     | 
 1537 |     |     function ripen(uint256 amount) external;
 1538 |     | 
 1539 |     |     function safeBatchTransferFrom(
 1540 |     |         address sender,
 1541 |     |         address recipient,
 1542 |     |         uint256[] memory depositIds,
 1543 |     |         uint256[] memory amounts,
 1544 |     |         bytes memory
 1545 |     |     ) external;
 1546 |     | 
 1547 |     |     function safeTransferFrom(
 1548 |     |         address sender,
 1549 |     |         address recipient,
 1550 |     |         uint256 depositId,
 1551 |     |         uint256 amount,
 1552 |     |         bytes memory
 1553 |     |     ) external;
 1554 |     | 
 1555 |     |     function scaledDeltaB(
 1556 |     |         uint256 beforeLpTokenSupply,
 1557 |     |         uint256 afterLpTokenSupply,
 1558 |     |         int256 deltaB
 1559 |     |     ) external pure returns (int256);
 1560 |     | 
 1561 |     |     function season() external view returns (uint32);
 1562 |     | 
 1563 |     |     function seasonTime() external view returns (uint64);
 1564 |     | 
 1565 |     |     function seedGaugeSunSunrise(int256 deltaB, uint256 caseId, bool oracleFailure) external;
 1566 |     | 
 1567 |     |     function setAbovePegE(bool peg) external;
 1568 |     | 
 1569 |     |     function setActiveField(uint256 fieldId, uint32 _temperature) external;
 1570 |     | 
 1571 |     |     function setApprovalForAll(address spender, bool approved) external;
 1572 |     | 
 1573 |     |     function setBeanToMaxLpGpPerBdvRatio(uint128 percent) external;
 1574 |     | 
 1575 |     |     function setBeanstalkState(
 1576 |     |         uint256 price,
 1577 |     |         uint256 podRate,
 1578 |     |         uint256 changeInSoilDemand,
 1579 |     |         uint256 liquidityToSupplyRatio,
 1580 |     |         address targetWell
 1581 |     |     ) external returns (int256 deltaB);
 1582 |     | 
 1583 |     |     function setBpf(uint128 bpf) external;
 1584 |     | 
 1585 |     |     function setChangeInSoilDemand(uint256 changeInSoilDemand) external;
 1586 |     | 
 1587 |     |     function setCurrentSeasonE(uint32 _season) external;
 1588 |     | 
 1589 |     |     function setL2SR(uint256 liquidityToSupplyRatio, address targetWell) external;
 1590 |     | 
 1591 |     |     function setLastDSoilE(uint128 number) external;
 1592 |     | 
 1593 |     |     function setLastSowTimeE(uint32 number) external;
 1594 |     | 
 1595 |     |     function setMaxTemp(uint32 t) external;
 1596 |     | 
 1597 |     |     function setMaxTempE(uint32 number) external;
 1598 |     | 
 1599 |     |     function setNextSowTimeE(uint32 _time) external;
 1600 |     | 
 1601 |     |     function setPodRate(uint256 podRate) external;
 1602 |     | 
 1603 |     |     function setPrice(uint256 price, address targetWell) external returns (int256 deltaB);
 1604 |     | 
 1605 |     |     function setShipmentRoutes(ShipmentRoute[] memory shipmentRoutes) external;
 1606 |     | 
 1607 |     |     function setSoilE(uint256 amount) external;
 1608 |     | 
 1609 |     |     function setStalkAndRoots(address account, uint128 stalk, uint256 roots) external;
 1610 |     | 
 1611 |     |     function setSunriseBlock(uint256 _block) external;
 1612 |     | 
 1613 |     |     function setUnharvestable(uint256 amount) external;
 1614 |     | 
 1615 |     |     function setUsdEthPrice(uint256 price) external;
 1616 |     | 
 1617 |     |     function setYieldE(uint256 t) external;
 1618 |     | 
 1619 |     |     function setCultivationFactor(uint256 cultivationFactor) external;
 1620 |     | 
 1621 |     |     function siloSunrise(uint256 amount) external;
 1622 |     | 
 1623 |     |     function getGaugeResult(
 1624 |     |         Gauge memory gauge,
 1625 |     |         bytes memory systemData
 1626 |     |     ) external returns (bytes memory);
 1627 |     | 
 1628 |     |     function getGaugeIdResult(
 1629 |     |         GaugeId gaugeId,
 1630 |     |         bytes memory systemData
 1631 |     |     ) external returns (bytes memory);
 1632 |     | 
 1633 |     |     function sow(
 1634 |     |         uint256 bean,
 1635 |     |         uint256 minTemperature,
 1636 |     |         uint8 mode
 1637 |     |     ) external payable returns (uint256 pods);
 1638 |     | 
 1639 |     |     function sowWithMin(
 1640 |     |         uint256 bean,
 1641 |     |         uint256 minTemperature,
 1642 |     |         uint256 minSoil,
 1643 |     |         uint8 mode
 1644 |     |     ) external payable returns (uint256 pods);
 1645 |     | 
 1646 |     |     function stalkEarnedPerSeason(
 1647 |     |         address[] memory tokens
 1648 |     |     ) external view returns (uint256[] memory stalkEarnedPerSeasons);
 1649 |     | 
 1650 |     |     function stealBeans(uint256 amount) external;
 1651 |     | 
 1652 |     |     function stemTipForToken(address token) external view returns (int96 _stemTip);
 1653 |     | 
 1654 |     |     function stepGauge() external;
 1655 |     | 
 1656 |     |     function sunSunrise(int256 deltaB, uint256 caseId, BeanstalkState memory bs) external;
 1657 |     | 
 1658 |     |     function sunTemperatureSunrise(int256 deltaB, uint256 caseId, uint32 t) external;
 1659 |     | 
 1660 |     |     function sunrise() external payable returns (uint256);
 1661 |     | 
 1662 |     |     function sunriseBlock() external view returns (uint64);
 1663 |     | 
 1664 |     |     function supportsInterface(bytes4 _interfaceId) external view returns (bool);
 1665 |     | 
 1666 |     |     function symbol() external pure returns (string memory);
 1667 |     | 
 1668 |     |     function teleportSunrise(uint32 _s) external;
 1669 |     | 
 1670 |     |     function temperature() external view returns (uint256);
 1671 |     | 
 1672 |     |     function thisSowTime() external view returns (uint256);
 1673 |     | 
 1674 |     |     function time() external view returns (Season memory);
 1675 |     | 
 1676 |     |     function tokenAllowance(
 1677 |     |         address account,
 1678 |     |         address spender,
 1679 |     |         address token
 1680 |     |     ) external view returns (uint256);
 1681 |     | 
 1682 |     |     function tokenSettings(address token) external view returns (AssetSettings memory);
 1683 |     | 
 1684 |     |     function totalDeltaB() external view returns (int256 deltaB);
 1685 |     | 
 1686 |     |     function totalInstantaneousDeltaB() external view returns (int256);
 1687 |     | 
 1688 |     |     function totalEarnedBeans() external view returns (uint256);
 1689 |     | 
 1690 |     |     function totalHarvestable(uint256 fieldId) external view returns (uint256);
 1691 |     | 
 1692 |     |     function totalHarvestableForActiveField() external view returns (uint256);
 1693 |     | 
 1694 |     |     function totalHarvested(uint256 fieldId) external view returns (uint256);
 1695 |     | 
 1696 |     |     function totalPods(uint256 fieldId) external view returns (uint256);
 1697 |     | 
 1698 |     |     function totalRainRoots() external view returns (uint256);
 1699 |     | 
 1700 |     |     function totalRealSoil() external view returns (uint256);
 1701 |     | 
 1702 |     |     function totalRoots() external view returns (uint256);
 1703 |     | 
 1704 |     |     function totalSoil() external view returns (uint256);
 1705 |     | 
 1706 |     |     function totalSoilAtMorningTemp(
 1707 |     |         uint256 morningTemperature
 1708 |     |     ) external view returns (uint256 totalSoil);
 1709 |     | 
 1710 |     |     function totalStalk() external view returns (uint256);
 1711 |     | 
 1712 |     |     function totalUnharvestable(uint256 fieldId) external view returns (uint256);
 1713 |     | 
 1714 |     |     function tractor(
 1715 |     |         Requisition memory requisition,
 1716 |     |         bytes memory operatorData
 1717 |     |     ) external payable returns (bytes[] memory results);
 1718 |     | 
 1719 |     |     function transferDeposit(
 1720 |     |         address sender,
 1721 |     |         address recipient,
 1722 |     |         address token,
 1723 |     |         int96 stem,
 1724 |     |         uint256 amount
 1725 |     |     ) external payable returns (uint256 _bdv);
 1726 |     | 
 1727 |     |     function transferDeposits(
 1728 |     |         address sender,
 1729 |     |         address recipient,
 1730 |     |         address token,
 1731 |     |         int96[] memory stem,
 1732 |     |         uint256[] memory amounts
 1733 |     |     ) external payable returns (uint256[] memory bdvs);
 1734 |     | 
 1735 |     |     function transferERC1155(address token, address to, uint256 id, uint256 value) external payable;
 1736 |     | 
 1737 |     |     function transferERC721(address token, address to, uint256 id) external payable;
 1738 |     | 
 1739 |     |     function sendTokenToInternalBalance(
 1740 |     |         address token,
 1741 |     |         address recipient,
 1742 |     |         uint256 amount
 1743 |     |     ) external payable;
 1744 |     | 
 1745 |     |     function transferInternalTokenFrom(
 1746 |     |         address token,
 1747 |     |         address sender,
 1748 |     |         address recipient,
 1749 |     |         uint256 amount,
 1750 |     |         uint8 toMode
 1751 |     |     ) external payable;
 1752 |     | 
 1753 |     |     function transferOwnership(address _newOwner) external;
 1754 |     | 
 1755 |     |     function transferPlot(
 1756 |     |         address sender,
 1757 |     |         address recipient,
 1758 |     |         uint256 fieldId,
 1759 |     |         uint256 index,
 1760 |     |         uint256 start,
 1761 |     |         uint256 end
 1762 |     |     ) external payable;
 1763 |     | 
 1764 |     |     function transferPlots(
 1765 |     |         address sender,
 1766 |     |         address recipient,
 1767 |     |         uint256 fieldId,
 1768 |     |         uint256[] memory ids,
 1769 |     |         uint256[] memory starts,
 1770 |     |         uint256[] memory ends
 1771 |     |     ) external payable;
 1772 |     | 
 1773 |     |     function transferToken(
 1774 |     |         address token,
 1775 |     |         address recipient,
 1776 |     |         uint256 amount,
 1777 |     |         uint8 fromMode,
 1778 |     |         uint8 toMode
 1779 |     |     ) external payable;
 1780 |     | 
 1781 |     |     function unpause() external payable;
 1782 |     | 
 1783 |     |     function unwrapEth(uint256 amount, uint8 mode) external payable;
 1784 |     | 
 1785 |     |     function updateGaugeForToken(
 1786 |     |         address token,
 1787 |     |         uint64 optimalPercentDepositedBdv,
 1788 |     |         Implementation memory gpImplementation,
 1789 |     |         Implementation memory lwImplementation
 1790 |     |     ) external payable;
 1791 |     | 
 1792 |     |     function updateGaugePointImplementationForToken(
 1793 |     |         address token,
 1794 |     |         Implementation memory impl
 1795 |     |     ) external payable;
 1796 |     | 
 1797 |     |     function updateLiquidityWeightImplementationForToken(
 1798 |     |         address token,
 1799 |     |         Implementation memory impl
 1800 |     |     ) external payable;
 1801 |     | 
 1802 |     |     function updateOracleImplementationForToken(
 1803 |     |         address token,
 1804 |     |         Implementation memory impl
 1805 |     |     ) external payable;
 1806 |     | 
 1807 |     |     function updatePublisherCounter(
 1808 |     |         bytes32 counterId,
 1809 |     |         CounterUpdateType updateType,
 1810 |     |         uint256 amount
 1811 |     |     ) external returns (uint256 count);
 1812 |     | 
 1813 |     |     function updateSeedGaugeSettings(EvaluationParameters memory updatedSeedGaugeSettings) external;
 1814 |     | 
 1815 |     |     function updateSortedDepositIds(
 1816 |     |         address account,
 1817 |     |         address token,
 1818 |     |         uint256[] calldata sortedDepositIds
 1819 |     |     ) external payable;
 1820 |     | 
 1821 |     |     function updateStalkPerBdvPerSeasonForToken(
 1822 |     |         address token,
 1823 |     |         uint40 stalkEarnedPerSeason
 1824 |     |     ) external payable;
 1825 |     | 
 1826 |     |     function updateStems() external;
 1827 |     | 
 1828 |     |     function updateTractorVersion(string memory version) external;
 1829 |     | 
 1830 |     |     function updateWhitelistStatus(
 1831 |     |         address token,
 1832 |     |         bool isWhitelisted,
 1833 |     |         bool isWhitelistedLp,
 1834 |     |         bool isWhitelistedWell,
 1835 |     |         bool isSoppable
 1836 |     |     ) external;
 1837 |     | 
 1838 |     |     function uri(uint256 depositId) external view returns (string memory);
 1839 |     | 
 1840 |     |     function weather() external view returns (Weather memory);
 1841 |     | 
 1842 |     |     function wellBdv(address token, uint256 amount) external view returns (uint256);
 1843 |     | 
 1844 |     |     function wellOracleSnapshot(address well) external view returns (bytes memory snapshot);
 1845 |     | 
 1846 |     |     function whitelistToken(
 1847 |     |         address token,
 1848 |     |         bytes4 selector,
 1849 |     |         uint48 stalkIssuedPerBdv,
 1850 |     |         uint40 stalkEarnedPerSeason,
 1851 |     |         bytes1 encodeType,
 1852 |     |         uint128 gaugePoints,
 1853 |     |         uint64 optimalPercentDepositedBdv,
 1854 |     |         Implementation memory oracleImplementation,
 1855 |     |         Implementation memory gaugePointImplementation,
 1856 |     |         Implementation memory liquidityWeightImplementation
 1857 |     |     ) external payable;
 1858 |     | 
 1859 |     |     function withdrawDeposit(
 1860 |     |         address token,
 1861 |     |         int96 stem,
 1862 |     |         uint256 amount,
 1863 |     |         uint8 mode
 1864 |     |     ) external payable;
 1865 |     | 
 1866 |     |     function withdrawDeposits(
 1867 |     |         address token,
 1868 |     |         int96[] memory stems,
 1869 |     |         uint256[] memory amounts,
 1870 |     |         uint8 mode
 1871 |     |     ) external payable;
 1872 |     | 
 1873 |     |     function withdrawForConvertE(
 1874 |     |         address token,
 1875 |     |         int96[] memory stems,
 1876 |     |         uint256[] memory amounts,
 1877 |     |         uint256 maxTokens
 1878 |     |     ) external;
 1879 |     | 
 1880 |     |     function woohoo() external pure returns (uint256);
 1881 |     | 
 1882 |     |     function wrapEth(uint256 amount, uint8 mode) external payable;
 1883 |     | 
 1884 |     |     function downPenalizedGrownStalk(
 1885 |     |         address well,
 1886 |     |         uint256 bdvToConvert,
 1887 |     |         uint256 grownStalkToConvert
 1888 |     |     ) external view returns (uint256 newGrownStalk, uint256 grownStalkLost);
 1889 |     | 
 1890 |     |     function setLastSeasonAndThisSeasonBeanSown(
 1891 |     |         uint128 lastSeasonBeanSown,
 1892 |     |         uint128 thisSeasonBeanSown
 1893 |     |     ) external;
 1894 |     | 
 1895 |     |     function setMinSoilSownDemand(uint256 minSoilSownDemand) external;
 1896 |     | }
 1897 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IMorphoOracle.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title IOracle
  5 |     | /// @author Morpho Labs
  6 |     | /// @custom:contact security@morpho.org
  7 |     | /// @notice Interface that oracles used by Morpho must implement.
  8 |     | /// @dev It is the user's responsibility to select markets with safe oracles.
  9 |     | interface IMorphoOracle {
 10 |     |     /// @notice Returns the price of 1 asset of collateral token quoted in 1 asset of loan token, scaled by 1e36.
 11 |     |     /// @dev It corresponds to the price of 10**(collateral token decimals) assets of collateral token quoted in
 12 |     |     /// 10**(loan token decimals) assets of loan token with `36 + loan token decimals - collateral token decimals`
 13 |     |     /// decimals of precision.
 14 |     |     function price() external view returns (uint256);
 15 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IPayback.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | interface IPayback {
  5 |     |     // The amount of Bean remaining to pay back silo.
  6 |     |     function siloRemaining() external view returns (uint256);
  7 |     | 
  8 |     |     // The amount of Bean remaining to pay back barn.
  9 |     |     function barnRemaining() external view returns (uint256);
 10 |     | }
 11 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IPipeline.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | /**
  5 |     |  * @title IPipeline
  6 |     |  * @notice Pipeline Interface – Pipeline creates a sandbox to execute any series of function calls on any series of protocols through \term{Pipe} functions.
  7 |     |  * Any assets left in Pipeline between transactions can be transferred out by any account.
  8 |     |  * Users Pipe a series of PipeCalls that each execute a function call to another protocol through Pipeline.
  9 |     |  **/
 10 |     | 
 11 |     | // PipeCalls specify a function call to be executed by Pipeline.
 12 |     | // Pipeline supports 2 types of PipeCalls: PipeCall and AdvancedPipeCall.
 13 |     | 
 14 |     | // PipeCall makes a function call with a static target address and callData.
 15 |     | struct PipeCall {
 16 |     |     address target;
 17 |     |     bytes data;
 18 |     | }
 19 |     | 
 20 |     | // AdvancedPipeCall makes a function call with a static target address and both static and dynamic callData.
 21 |     | // AdvancedPipeCalls support sending Ether in calls.
 22 |     | // [ PipeCall Type | Send Ether Flag | PipeCall Type data | Ether Value (only if flag == 1)]
 23 |     | // [ 1 byte        | 1 byte          | n bytes        | 0 or 32 bytes                      ]
 24 |     | // See LibClipboard.useClipboard for more details.
 25 |     | struct AdvancedPipeCall {
 26 |     |     address target;
 27 |     |     bytes callData;
 28 |     |     bytes clipboard;
 29 |     | }
 30 |     | 
 31 |     | interface IPipeline {
 32 |     |     function pipe(PipeCall calldata p) external payable returns (bytes memory result);
 33 |     | 
 34 |     |     function multiPipe(PipeCall[] calldata pipes) external payable returns (bytes[] memory results);
 35 |     | 
 36 |     |     function advancedPipe(
 37 |     |         AdvancedPipeCall[] calldata pipes
 38 |     |     ) external payable returns (bytes[] memory results);
 39 |     | }
 40 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IProxyAdmin.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | 
 3 |     | pragma solidity ^0.8.20;
 4 |     | interface IProxyAdmin {
 5 |     |     function upgrade(address proxy, address implementation) external;
 6 |     | }
 7 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IShipmentPlanner.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {ShipmentPlan} from "contracts/ecosystem/ShipmentPlanner.sol";
  6 |     | 
  7 |     | interface IShipmentPlanner {
  8 |     |     function getFieldPlan(
  9 |     |         bytes memory data
 10 |     |     ) external view returns (ShipmentPlan memory shipmentPlan);
 11 |     | 
 12 |     |     function getSiloPlan(bytes memory) external pure returns (ShipmentPlan memory shipmentPlan);
 13 |     | 
 14 |     |     function getBudgetPlan(bytes memory) external view returns (ShipmentPlan memory shipmentPlan);
 15 |     | 
 16 |     |     function getPaybackFieldPlan(
 17 |     |         bytes memory data
 18 |     |     ) external pure returns (ShipmentPlan memory shipmentPlan);
 19 |     | 
 20 |     |     function getPaybackPlan(
 21 |     |         bytes memory data
 22 |     |     ) external view returns (ShipmentPlan memory shipmentPlan);
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/ISiloedPinto.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | struct SiloDeposit {
   5 |     |     int96 stem;
   6 |     |     uint160 amount;
   7 |     | }
   8 |     | 
   9 |     | interface ISiloedPinto {
  10 |     |     type From is uint8;
  11 |     |     type To is uint8;
  12 |     | 
  13 |     |     error DepositNotInserted();
  14 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  15 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  16 |     |     error ERC20InvalidApprover(address approver);
  17 |     |     error ERC20InvalidReceiver(address receiver);
  18 |     |     error ERC20InvalidSender(address sender);
  19 |     |     error ERC20InvalidSpender(address spender);
  20 |     |     error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);
  21 |     |     error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);
  22 |     |     error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);
  23 |     |     error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);
  24 |     |     error InsufficientDepositAmount();
  25 |     |     error InvalidInitialization();
  26 |     |     error InvalidMode();
  27 |     |     error InvalidToken();
  28 |     |     error MinPdvViolation();
  29 |     |     error NotInitializing();
  30 |     |     error OwnableInvalidOwner(address owner);
  31 |     |     error OwnableUnauthorizedAccount(address account);
  32 |     |     error PdvDecrease();
  33 |     |     error ReentrancyGuardReentrantCall();
  34 |     |     error SafeERC20FailedOperation(address token);
  35 |     |     error StemsAmountMismatch();
  36 |     |     error ZeroAssets();
  37 |     |     error ZeroShares();
  38 |     | 
  39 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  40 |     |     event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
  41 |     |     event Initialized(uint64 version);
  42 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  43 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  44 |     |     event Update(uint256 totalAssets, uint256 totalShares);
  45 |     |     event Withdraw(
  46 |     |         address indexed sender,
  47 |     |         address indexed receiver,
  48 |     |         address indexed owner,
  49 |     |         uint256 assets,
  50 |     |         uint256 shares
  51 |     |     );
  52 |     | 
  53 |     |     function allowance(address owner, address spender) external view returns (uint256);
  54 |     |     function approve(address spender, uint256 value) external returns (bool);
  55 |     |     function asset() external view returns (address);
  56 |     |     function balanceOf(address account) external view returns (uint256);
  57 |     |     function claim() external;
  58 |     |     function convertToAssets(uint256 shares) external view returns (uint256);
  59 |     |     function convertToShares(uint256 assets) external view returns (uint256);
  60 |     |     function decimals() external view returns (uint8);
  61 |     |     function deposit(uint256 assets, address receiver) external returns (uint256 shares);
  62 |     |     function depositAdvanced(
  63 |     |         uint256 assets,
  64 |     |         address receiver,
  65 |     |         From fromMode,
  66 |     |         To toMode
  67 |     |     ) external returns (uint256 shares);
  68 |     |     function depositFromSilo(
  69 |     |         int96[] memory stems,
  70 |     |         uint256[] memory amounts,
  71 |     |         address receiver,
  72 |     |         To toMode
  73 |     |     ) external returns (uint256 shares);
  74 |     |     function deposits(uint256) external view returns (int96 stem, uint160 amount);
  75 |     |     function floodAssetsPresent() external view returns (bool);
  76 |     |     function floodTranchRatio() external view returns (uint256);
  77 |     |     function germinatingDeposits(uint256) external view returns (SiloDeposit memory);
  78 |     |     function getDeposit(uint256 index) external view returns (SiloDeposit memory);
  79 |     |     function getDepositsLength() external view returns (uint256);
  80 |     |     function getGerminatingDepositsLength() external view returns (uint256);
  81 |     |     function getMaxRedeem(address owner, From fromMode) external view returns (uint256);
  82 |     |     function getMaxWithdraw(address owner, From fromMode) external view returns (uint256);
  83 |     |     function initialize(
  84 |     |         uint256 _maxTriggerPrice,
  85 |     |         uint256 _slippageRatio,
  86 |     |         uint256 _floodTranchRatio,
  87 |     |         uint256 _vestingPeriod,
  88 |     |         uint256 _minSize,
  89 |     |         uint256 _targetMinSize
  90 |     |     ) external;
  91 |     |     function lastEarnedTimestamp() external view returns (uint256);
  92 |     |     function maxDeposit(address) external view returns (uint256);
  93 |     |     function maxMint(address) external view returns (uint256);
  94 |     |     function maxRedeem(address owner) external view returns (uint256);
  95 |     |     function maxTriggerPrice() external view returns (uint256);
  96 |     |     function maxWithdraw(address owner) external view returns (uint256);
  97 |     |     function minSize() external view returns (uint256);
  98 |     |     function mint(uint256 shares, address receiver) external returns (uint256 assets);
  99 |     |     function mintAdvanced(
 100 |     |         uint256 shares,
 101 |     |         address receiver,
 102 |     |         From fromMode,
 103 |     |         To toMode
 104 |     |     ) external returns (uint256 assets);
 105 |     |     function name() external view returns (string memory);
 106 |     |     function owner() external view returns (address);
 107 |     |     function previewDeposit(uint256 assets) external view returns (uint256 shares);
 108 |     |     function previewMint(uint256 shares) external view returns (uint256 assets);
 109 |     |     function previewRedeem(uint256 shares) external view returns (uint256 assets);
 110 |     |     function previewWithdraw(uint256 assets) external view returns (uint256 shares);
 111 |     |     function redeem(
 112 |     |         uint256 shares,
 113 |     |         address receiver,
 114 |     |         address owner
 115 |     |     ) external returns (uint256 assets);
 116 |     |     function redeemAdvanced(
 117 |     |         uint256 shares,
 118 |     |         address receiver,
 119 |     |         address owner,
 120 |     |         From fromMode,
 121 |     |         To toMode
 122 |     |     ) external returns (uint256 assets);
 123 |     |     function redeemToSilo(
 124 |     |         uint256 shares,
 125 |     |         address receiver,
 126 |     |         address owner,
 127 |     |         From fromMode
 128 |     |     ) external returns (int96[] memory stems, uint256[] memory amounts);
 129 |     |     function renounceOwnership() external;
 130 |     |     function rescueTokens(address token, uint256 amount, address to) external;
 131 |     |     function setFloodTranchRatio(uint256 _floodTranchRatio) external;
 132 |     |     function setMaxTriggerPrice(uint256 _maxTriggerPrice) external;
 133 |     |     function setMinSize(uint256 _minSize) external;
 134 |     |     function setSlippageRatio(uint256 _slippageRatio) external;
 135 |     |     function setVestingPeriod(uint256 _vestingPeriod) external;
 136 |     |     function slippageRatio() external view returns (uint256);
 137 |     |     function symbol() external view returns (string memory);
 138 |     |     function totalAssets() external view returns (uint256 totalManagedAssets);
 139 |     |     function totalSupply() external view returns (uint256);
 140 |     |     function trancheSizes(address) external view returns (uint256);
 141 |     |     function transfer(address to, uint256 value) external returns (bool);
 142 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 143 |     |     function transferOwnership(address newOwner) external;
 144 |     |     function underlyingPdv() external view returns (uint256);
 145 |     |     function unvestedAssets() external view returns (uint256 assets);
 146 |     |     function version() external pure returns (string memory);
 147 |     |     function vestingPeriod() external view returns (uint256);
 148 |     |     function vestingPinto() external view returns (uint256);
 149 |     |     function withdraw(
 150 |     |         uint256 assets,
 151 |     |         address receiver,
 152 |     |         address owner
 153 |     |     ) external returns (uint256 shares);
 154 |     |     function withdrawAdvanced(
 155 |     |         uint256 assets,
 156 |     |         address receiver,
 157 |     |         address owner,
 158 |     |         From fromMode,
 159 |     |         To toMode
 160 |     |     ) external returns (uint256 shares);
 161 |     |     function withdrawToSilo(
 162 |     |         uint256 assets,
 163 |     |         address receiver,
 164 |     |         address owner,
 165 |     |         From fromMode
 166 |     |     ) external returns (int96[] memory stems, uint256[] memory amounts);
 167 |     | }
 168 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IUSDC.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title WETH Interface
 11 |     |  **/
 12 |     | 
 13 |     | interface IUSDC is IERC20 {
 14 |     |     function masterMinter() external view returns (address);
 15 |     |     function mint(address _to, uint256 _amount) external;
 16 |     | }
 17 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/IWETH.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title WETH Interface
 11 |     |  **/
 12 |     | interface IWETH is IERC20 {
 13 |     |     function deposit() external payable;
 14 |     |     function withdraw(uint) external;
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/IAquifer.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  6 |     | import {IWell, Call} from "./IWell.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title IAquifer
 10 |     |  * @notice Interface for the Aquifer, a permissionless Well deployer and registry.
 11 |     |  */
 12 |     | interface IAquifer {
 13 |     |     /**
 14 |     |      * @notice Emitted when a Well is deployed.
 15 |     |      * @param well The address of the new Well
 16 |     |      * @param implementation The Well implementation address
 17 |     |      * @param tokens The tokens in the Well
 18 |     |      * @param wellFunction The Well function
 19 |     |      * @param pumps The pumps to bore in the Well
 20 |     |      * @param wellData The Well data to implement into the Well
 21 |     |      */
 22 |     |     event BoreWell(
 23 |     |         address well,
 24 |     |         address implementation,
 25 |     |         IERC20[] tokens,
 26 |     |         Call wellFunction,
 27 |     |         Call[] pumps,
 28 |     |         bytes wellData
 29 |     |     );
 30 |     | 
 31 |     |     /**
 32 |     |      * @notice Deploys a Well.
 33 |     |      * @param implementation The Well implementation to clone.
 34 |     |      * @param immutableData The data to append to the bytecode of the contract.
 35 |     |      * @param initFunctionCall The function call to initialize the Well. Set to empty bytes for no call.
 36 |     |      * @param salt The salt to deploy the Well with (`bytes32(0)` for none). See {LibClone}.
 37 |     |      * @return wellAddress The address of the new Well
 38 |     |      */
 39 |     |     function boreWell(
 40 |     |         address implementation,
 41 |     |         bytes calldata immutableData,
 42 |     |         bytes calldata initFunctionCall,
 43 |     |         bytes32 salt
 44 |     |     ) external returns (address wellAddress);
 45 |     | 
 46 |     |     /**
 47 |     |      * @notice Returns the implementation that a given Well was deployed with.
 48 |     |      * @param well The Well to get the implementation of
 49 |     |      * @return implementation The address of the implementation of a Well.
 50 |     |      * @dev Always verify that a Well was deployed by a trusted Aquifer using a trusted implementation before using.
 51 |     |      * If `wellImplementation == address(0)`, then the Aquifer did not deploy the Well.
 52 |     |      */
 53 |     |     function wellImplementation(address well) external view returns (address implementation);
 54 |     | }
 55 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/IBeanstalkWellFunction.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IWellFunction} from "./IWellFunction.sol";
  6 |     | import {IMultiFlowPumpWellFunction} from "./pumps/IMultiFlowPumpWellFunction.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title IBeanstalkWellFunction
 10 |     |  * @notice Defines all necessary functions for Beanstalk to support a Well Function in addition to functions defined in the primary interface.
 11 |     |  * This includes 2 functions to solve for a given reserve value suc that the average price between
 12 |     |  * the given reserve and all other reserves equals the average of the input ratios.
 13 |     |  * `calcReserveAtRatioSwap` assumes the target ratios are reached through executing a swap.
 14 |     |  * `calcReserveAtRatioLiquidity` assumes the target ratios are reached through adding/removing liquidity.
 15 |     |  */
 16 |     | interface IBeanstalkWellFunction is IMultiFlowPumpWellFunction {
 17 |     |     /**
 18 |     |      * @notice Calculates the `j` reserve such that `π_{i | i != j} (d reserves_j / d reserves_i) = π_{i | i != j}(ratios_j / ratios_i)`.
 19 |     |      * assumes that reserve_j is being added or removed in exchange for LP Tokens.
 20 |     |      * @dev used by Beanstalk to calculate the max deltaB that can be converted in/out of a Well.
 21 |     |      * @param reserves The reserves of the Well
 22 |     |      * @param j The index of the reserve to solve for
 23 |     |      * @param ratios The ratios of reserves to solve for
 24 |     |      * @param data Well function data provided on every call
 25 |     |      * @return reserve The resulting reserve at the jth index
 26 |     |      */
 27 |     |     function calcReserveAtRatioLiquidity(
 28 |     |         uint[] calldata reserves,
 29 |     |         uint j,
 30 |     |         uint[] calldata ratios,
 31 |     |         bytes calldata data
 32 |     |     ) external pure returns (uint reserve);
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/IMultiFlowPump.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | interface IMultiFlowPump {
  6 |     |     /**
  7 |     |      * @dev Reads the capped reserves from the Pump updated to the current block using the current reserves of `well`.
  8 |     |      */
  9 |     |     function readCappedReserves(
 10 |     |         address well,
 11 |     |         bytes memory data
 12 |     |     ) external view returns (uint256[] memory cappedReserves);
 13 |     | 
 14 |     |     /**
 15 |     |      * @notice Reads instantaneous reserves from the Pump
 16 |     |      * @param well The address of the Well
 17 |     |      * @return reserves The instantaneous balanecs tracked by the Pump
 18 |     |      */
 19 |     |     function readInstantaneousReserves(
 20 |     |         address well,
 21 |     |         bytes memory data
 22 |     |     ) external view returns (uint256[] memory reserves);
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/IWell.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title Call is the struct that contains the target address and extra calldata of a generic call.
   9 |     |  */
  10 |     | struct Call {
  11 |     |     address target; // The address the call is executed on.
  12 |     |     bytes data; // Extra calldata to be passed during the call
  13 |     | }
  14 |     | 
  15 |     | /**
  16 |     |  * @title IWell is the interface for the Well contract.
  17 |     |  *
  18 |     |  * In order for a Well to be verified using a permissionless on-chain registry, a Well Implementation should:
  19 |     |  * - Not be able to self-destruct (Aquifer's registry would be vulnerable to a metamorphic contract attack)
  20 |     |  * - Not be able to change its tokens, Well Function, Pumps and Well Data
  21 |     |  */
  22 |     | interface IWell {
  23 |     |     /**
  24 |     |      * @notice Emitted when a Swap occurs.
  25 |     |      * @param fromToken The token swapped from
  26 |     |      * @param toToken The token swapped to
  27 |     |      * @param amountIn The amount of `fromToken` transferred into the Well
  28 |     |      * @param amountOut The amount of `toToken` transferred out of the Well
  29 |     |      * @param recipient The address that received `toToken`
  30 |     |      */
  31 |     |     event Swap(
  32 |     |         IERC20 fromToken,
  33 |     |         IERC20 toToken,
  34 |     |         uint256 amountIn,
  35 |     |         uint256 amountOut,
  36 |     |         address recipient
  37 |     |     );
  38 |     | 
  39 |     |     /**
  40 |     |      * @notice Emitted when liquidity is added to the Well.
  41 |     |      * @param tokenAmountsIn The amount of each token added to the Well
  42 |     |      * @param lpAmountOut The amount of LP tokens minted
  43 |     |      * @param recipient The address that received the LP tokens
  44 |     |      */
  45 |     |     event AddLiquidity(uint256[] tokenAmountsIn, uint256 lpAmountOut, address recipient);
  46 |     | 
  47 |     |     /**
  48 |     |      * @notice Emitted when liquidity is removed from the Well as multiple underlying tokens.
  49 |     |      * @param lpAmountIn The amount of LP tokens burned
  50 |     |      * @param tokenAmountsOut The amount of each underlying token removed
  51 |     |      * @param recipient The address that received the underlying tokens
  52 |     |      * @dev Gas cost scales with `n` tokens.
  53 |     |      */
  54 |     |     event RemoveLiquidity(uint256 lpAmountIn, uint256[] tokenAmountsOut, address recipient);
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Emitted when liquidity is removed from the Well as a single underlying token.
  58 |     |      * @param lpAmountIn The amount of LP tokens burned
  59 |     |      * @param tokenOut The underlying token removed
  60 |     |      * @param tokenAmountOut The amount of `tokenOut` removed
  61 |     |      * @param recipient The address that received the underlying tokens
  62 |     |      * @dev Emitting a separate event when removing liquidity as a single token
  63 |     |      * saves gas, since `tokenAmountsOut` in {RemoveLiquidity} must emit a value
  64 |     |      * for each token in the Well.
  65 |     |      */
  66 |     |     event RemoveLiquidityOneToken(
  67 |     |         uint256 lpAmountIn,
  68 |     |         IERC20 tokenOut,
  69 |     |         uint256 tokenAmountOut,
  70 |     |         address recipient
  71 |     |     );
  72 |     | 
  73 |     |     /**
  74 |     |      * @notice Emitted when a Shift occurs.
  75 |     |      * @param reserves The ending reserves after a shift
  76 |     |      * @param toToken The token swapped to
  77 |     |      * @param amountOut The amount of `toToken` transferred out of the Well
  78 |     |      * @param recipient The address that received `toToken`
  79 |     |      */
  80 |     |     event Shift(uint256[] reserves, IERC20 toToken, uint256 amountOut, address recipient);
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Emitted when a Sync occurs.
  84 |     |      * @param reserves The ending reserves after a sync
  85 |     |      * @param lpAmountOut The amount of LP tokens received from the sync.
  86 |     |      * @param recipient The address that received the LP tokens
  87 |     |      */
  88 |     |     event Sync(uint256[] reserves, uint256 lpAmountOut, address recipient);
  89 |     | 
  90 |     |     //////////////////// WELL DEFINITION ////////////////////
  91 |     | 
  92 |     |     /**
  93 |     |      * @notice Returns a list of ERC20 tokens supported by the Well.
  94 |     |      */
  95 |     |     function tokens() external view returns (IERC20[] memory);
  96 |     | 
  97 |     |     /**
  98 |     |      * @notice Returns the Well function as a Call struct.
  99 |     |      * @dev Contains the address of the Well function contract and extra data to
 100 |     |      * pass during calls.
 101 |     |      *
 102 |     |      * **Well functions** define a relationship between the reserves of the
 103 |     |      * tokens in the Well and the number of LP tokens.
 104 |     |      *
 105 |     |      * A Well function MUST implement {IWellFunction}.
 106 |     |      */
 107 |     |     function wellFunction() external view returns (Call memory);
 108 |     | 
 109 |     |     /**
 110 |     |      * @notice Returns the Pumps attached to the Well as Call structs.
 111 |     |      * @dev Contains the addresses of the Pumps contract and extra data to pass
 112 |     |      * during calls.
 113 |     |      *
 114 |     |      * **Pumps** are on-chain oracles that are updated every time the Well is
 115 |     |      * interacted with.
 116 |     |      *
 117 |     |      * A Pump is not required for Well operation. For Wells without a Pump:
 118 |     |      * `pumps().length = 0`.
 119 |     |      *
 120 |     |      * An attached Pump MUST implement {IPump}.
 121 |     |      */
 122 |     |     function pumps() external view returns (Call[] memory);
 123 |     | 
 124 |     |     /**
 125 |     |      * @notice Returns the Well data that the Well was bored with.
 126 |     |      * @dev The existence and signature of Well data is determined by each individual implementation.
 127 |     |      */
 128 |     |     function wellData() external view returns (bytes memory);
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice Returns the Aquifer that created this Well.
 132 |     |      * @dev Wells can be permissionlessly bored in an Aquifer.
 133 |     |      *
 134 |     |      * Aquifers stores the implementation that was used to bore the Well.
 135 |     |      */
 136 |     |     function aquifer() external view returns (address);
 137 |     | 
 138 |     |     /**
 139 |     |      * @notice Returns the tokens, Well Function, Pumps and Well Data associated
 140 |     |      * with the Well as well as the Aquifer that deployed the Well.
 141 |     |      */
 142 |     |     function well()
 143 |     |         external
 144 |     |         view
 145 |     |         returns (
 146 |     |             IERC20[] memory _tokens,
 147 |     |             Call memory _wellFunction,
 148 |     |             Call[] memory _pumps,
 149 |     |             bytes memory _wellData,
 150 |     |             address _aquifer
 151 |     |         );
 152 |     | 
 153 |     |     //////////////////// SWAP: FROM ////////////////////
 154 |     | 
 155 |     |     /**
 156 |     |      * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken`.
 157 |     |      * @param fromToken The token to swap from
 158 |     |      * @param toToken The token to swap to
 159 |     |      * @param amountIn The amount of `fromToken` to spend
 160 |     |      * @param minAmountOut The minimum amount of `toToken` to receive
 161 |     |      * @param recipient The address to receive `toToken`
 162 |     |      * @param deadline The timestamp after which this operation is invalid
 163 |     |      * @return amountOut The amount of `toToken` received
 164 |     |      */
 165 |     |     function swapFrom(
 166 |     |         IERC20 fromToken,
 167 |     |         IERC20 toToken,
 168 |     |         uint256 amountIn,
 169 |     |         uint256 minAmountOut,
 170 |     |         address recipient,
 171 |     |         uint256 deadline
 172 |     |     ) external returns (uint256 amountOut);
 173 |     | 
 174 |     |     /**
 175 |     |      * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken` and supports fee on transfer tokens.
 176 |     |      * @param fromToken The token to swap from
 177 |     |      * @param toToken The token to swap to
 178 |     |      * @param amountIn The amount of `fromToken` to spend
 179 |     |      * @param minAmountOut The minimum amount of `toToken` to take from the Well. Note that if `toToken` charges a fee on transfer, `recipient` will receive less than this amount.
 180 |     |      * @param recipient The address to receive `toToken`
 181 |     |      * @param deadline The timestamp after which this operation is invalid
 182 |     |      * @return amountOut The amount of `toToken` transferred from the Well. Note that if `toToken` charges a fee on transfer, `recipient` may receive less than this amount.
 183 |     |      * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.
 184 |     |      */
 185 |     |     function swapFromFeeOnTransfer(
 186 |     |         IERC20 fromToken,
 187 |     |         IERC20 toToken,
 188 |     |         uint256 amountIn,
 189 |     |         uint256 minAmountOut,
 190 |     |         address recipient,
 191 |     |         uint256 deadline
 192 |     |     ) external returns (uint256 amountOut);
 193 |     | 
 194 |     |     /**
 195 |     |      * @notice Gets the amount of one token received for swapping an amount of another token.
 196 |     |      * @param fromToken The token to swap from
 197 |     |      * @param toToken The token to swap to
 198 |     |      * @param amountIn The amount of `fromToken` to spend
 199 |     |      * @return amountOut The amount of `toToken` to receive
 200 |     |      */
 201 |     |     function getSwapOut(
 202 |     |         IERC20 fromToken,
 203 |     |         IERC20 toToken,
 204 |     |         uint256 amountIn
 205 |     |     ) external view returns (uint256 amountOut);
 206 |     | 
 207 |     |     //////////////////// SWAP: TO ////////////////////
 208 |     | 
 209 |     |     /**
 210 |     |      * @notice Swaps from a maximum amount of `fromToken` to an exact amount of `toToken`.
 211 |     |      * @param fromToken The token to swap from
 212 |     |      * @param toToken The token to swap to
 213 |     |      * @param maxAmountIn The maximum amount of `fromToken` to spend
 214 |     |      * @param amountOut The amount of `toToken` to receive
 215 |     |      * @param recipient The address to receive `toToken`
 216 |     |      * @param deadline The timestamp after which this operation is invalid
 217 |     |      * @return amountIn The amount of `toToken` received
 218 |     |      */
 219 |     |     function swapTo(
 220 |     |         IERC20 fromToken,
 221 |     |         IERC20 toToken,
 222 |     |         uint256 maxAmountIn,
 223 |     |         uint256 amountOut,
 224 |     |         address recipient,
 225 |     |         uint256 deadline
 226 |     |     ) external returns (uint256 amountIn);
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice Gets the amount of one token that must be spent to receive an amount of another token during a swap.
 230 |     |      * @param fromToken The token to swap from
 231 |     |      * @param toToken The token to swap to
 232 |     |      * @param amountOut The amount of `toToken` desired
 233 |     |      * @return amountIn The amount of `fromToken` that must be spent
 234 |     |      */
 235 |     |     function getSwapIn(
 236 |     |         IERC20 fromToken,
 237 |     |         IERC20 toToken,
 238 |     |         uint256 amountOut
 239 |     |     ) external view returns (uint256 amountIn);
 240 |     | 
 241 |     |     //////////////////// SHIFT ////////////////////
 242 |     | 
 243 |     |     /**
 244 |     |      * @notice Shifts at least `minAmountOut` excess tokens held by the Well into `tokenOut` and delivers to `recipient`.
 245 |     |      * @param tokenOut The token to shift into
 246 |     |      * @param minAmountOut The minimum amount of `tokenOut` to receive
 247 |     |      * @param recipient The address to receive the token
 248 |     |      * @return amountOut The amount of `tokenOut` received
 249 |     |      * @dev Can be used in a multicall using a contract like Pipeline to perform gas efficient swaps.
 250 |     |      * No deadline is needed since this function does not use the user's assets. If adding liquidity in a multicall,
 251 |     |      * then a deadline check can be added to the multicall.
 252 |     |      */
 253 |     |     function shift(
 254 |     |         IERC20 tokenOut,
 255 |     |         uint256 minAmountOut,
 256 |     |         address recipient
 257 |     |     ) external returns (uint256 amountOut);
 258 |     | 
 259 |     |     /**
 260 |     |      * @notice Calculates the amount of the token out received from shifting excess tokens held by the Well.
 261 |     |      * @param tokenOut The token to shift into
 262 |     |      * @return amountOut The amount of `tokenOut` received
 263 |     |      */
 264 |     |     function getShiftOut(IERC20 tokenOut) external returns (uint256 amountOut);
 265 |     | 
 266 |     |     //////////////////// ADD LIQUIDITY ////////////////////
 267 |     | 
 268 |     |     /**
 269 |     |      * @notice Adds liquidity to the Well as multiple tokens in any ratio.
 270 |     |      * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}
 271 |     |      * @param minLpAmountOut The minimum amount of LP tokens to receive
 272 |     |      * @param recipient The address to receive the LP tokens
 273 |     |      * @param deadline The timestamp after which this operation is invalid
 274 |     |      * @return lpAmountOut The amount of LP tokens received
 275 |     |      */
 276 |     |     function addLiquidity(
 277 |     |         uint256[] memory tokenAmountsIn,
 278 |     |         uint256 minLpAmountOut,
 279 |     |         address recipient,
 280 |     |         uint256 deadline
 281 |     |     ) external returns (uint256 lpAmountOut);
 282 |     | 
 283 |     |     /**
 284 |     |      * @notice Adds liquidity to the Well as multiple tokens in any ratio and supports
 285 |     |      * fee on transfer tokens.
 286 |     |      * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}
 287 |     |      * @param minLpAmountOut The minimum amount of LP tokens to receive
 288 |     |      * @param recipient The address to receive the LP tokens
 289 |     |      * @param deadline The timestamp after which this operation is invalid
 290 |     |      * @return lpAmountOut The amount of LP tokens received
 291 |     |      * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.
 292 |     |      */
 293 |     |     function addLiquidityFeeOnTransfer(
 294 |     |         uint256[] memory tokenAmountsIn,
 295 |     |         uint256 minLpAmountOut,
 296 |     |         address recipient,
 297 |     |         uint256 deadline
 298 |     |     ) external returns (uint256 lpAmountOut);
 299 |     | 
 300 |     |     /**
 301 |     |      * @notice Gets the amount of LP tokens received from adding liquidity as multiple tokens in any ratio.
 302 |     |      * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}
 303 |     |      * @return lpAmountOut The amount of LP tokens received
 304 |     |      */
 305 |     |     function getAddLiquidityOut(
 306 |     |         uint256[] memory tokenAmountsIn
 307 |     |     ) external view returns (uint256 lpAmountOut);
 308 |     | 
 309 |     |     //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////
 310 |     | 
 311 |     |     /**
 312 |     |      * @notice Removes liquidity from the Well as all underlying tokens in a balanced ratio.
 313 |     |      * @param lpAmountIn The amount of LP tokens to burn
 314 |     |      * @param minTokenAmountsOut The minimum amount of each underlying token to receive; MUST match the indexing of {Well.tokens}
 315 |     |      * @param recipient The address to receive the underlying tokens
 316 |     |      * @param deadline The timestamp after which this operation is invalid
 317 |     |      * @return tokenAmountsOut The amount of each underlying token received
 318 |     |      */
 319 |     |     function removeLiquidity(
 320 |     |         uint256 lpAmountIn,
 321 |     |         uint256[] calldata minTokenAmountsOut,
 322 |     |         address recipient,
 323 |     |         uint256 deadline
 324 |     |     ) external returns (uint256[] memory tokenAmountsOut);
 325 |     | 
 326 |     |     /**
 327 |     |      * @notice Gets the amount of each underlying token received from removing liquidity in a balanced ratio.
 328 |     |      * @param lpAmountIn The amount of LP tokens to burn
 329 |     |      * @return tokenAmountsOut The amount of each underlying token received
 330 |     |      */
 331 |     |     function getRemoveLiquidityOut(
 332 |     |         uint256 lpAmountIn
 333 |     |     ) external view returns (uint256[] memory tokenAmountsOut);
 334 |     | 
 335 |     |     //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////
 336 |     | 
 337 |     |     /**
 338 |     |      * @notice Removes liquidity from the Well as a single underlying token.
 339 |     |      * @param lpAmountIn The amount of LP tokens to burn
 340 |     |      * @param tokenOut The underlying token to receive
 341 |     |      * @param minTokenAmountOut The minimum amount of `tokenOut` to receive
 342 |     |      * @param recipient The address to receive the underlying tokens
 343 |     |      * @param deadline The timestamp after which this operation is invalid
 344 |     |      * @return tokenAmountOut The amount of `tokenOut` received
 345 |     |      */
 346 |     |     function removeLiquidityOneToken(
 347 |     |         uint256 lpAmountIn,
 348 |     |         IERC20 tokenOut,
 349 |     |         uint256 minTokenAmountOut,
 350 |     |         address recipient,
 351 |     |         uint256 deadline
 352 |     |     ) external returns (uint256 tokenAmountOut);
 353 |     | 
 354 |     |     /**
 355 |     |      * @notice Gets the amount received from removing liquidity from the Well as a single underlying token.
 356 |     |      * @param lpAmountIn The amount of LP tokens to burn
 357 |     |      * @param tokenOut The underlying token to receive
 358 |     |      * @return tokenAmountOut The amount of `tokenOut` received
 359 |     |      *
 360 |     |      */
 361 |     |     function getRemoveLiquidityOneTokenOut(
 362 |     |         uint256 lpAmountIn,
 363 |     |         IERC20 tokenOut
 364 |     |     ) external view returns (uint256 tokenAmountOut);
 365 |     | 
 366 |     |     //////////////////// REMOVE LIQUIDITY: IMBALANCED ////////////////////
 367 |     | 
 368 |     |     /**
 369 |     |      * @notice Removes liquidity from the Well as multiple underlying tokens in any ratio.
 370 |     |      * @param maxLpAmountIn The maximum amount of LP tokens to burn
 371 |     |      * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}
 372 |     |      * @param recipient The address to receive the underlying tokens
 373 |     |      * @return lpAmountIn The amount of LP tokens burned
 374 |     |      */
 375 |     |     function removeLiquidityImbalanced(
 376 |     |         uint256 maxLpAmountIn,
 377 |     |         uint256[] calldata tokenAmountsOut,
 378 |     |         address recipient,
 379 |     |         uint256 deadline
 380 |     |     ) external returns (uint256 lpAmountIn);
 381 |     | 
 382 |     |     /**
 383 |     |      * @notice Gets the amount of LP tokens to burn from removing liquidity as multiple underlying tokens in any ratio.
 384 |     |      * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}
 385 |     |      * @return lpAmountIn The amount of LP tokens burned
 386 |     |      */
 387 |     |     function getRemoveLiquidityImbalancedIn(
 388 |     |         uint256[] calldata tokenAmountsOut
 389 |     |     ) external view returns (uint256 lpAmountIn);
 390 |     | 
 391 |     |     //////////////////// RESERVES ////////////////////
 392 |     | 
 393 |     |     /**
 394 |     |      * @notice Syncs the Well's reserves with the Well's balances of underlying tokens. If the reserves
 395 |     |      * increase, mints at least `minLpAmountOut` LP Tokens to `recipient`.
 396 |     |      * @param recipient The address to receive the LP tokens
 397 |     |      * @param minLpAmountOut The minimum amount of LP tokens to receive
 398 |     |      * @return lpAmountOut The amount of LP tokens received
 399 |     |      * @dev Can be used in a multicall using a contract like Pipeline to perform gas efficient additions of liquidity.
 400 |     |      * No deadline is needed since this function does not use the user's assets. If adding liquidity in a multicall,
 401 |     |      * then a deadline check can be added to the multicall.
 402 |     |      * If `sync` decreases the Well's reserves, then no LP tokens are minted and `lpAmountOut` must be 0.
 403 |     |      */
 404 |     |     function sync(address recipient, uint256 minLpAmountOut) external returns (uint256 lpAmountOut);
 405 |     | 
 406 |     |     /**
 407 |     |      * @notice Calculates the amount of LP Tokens received from syncing the Well's reserves with the Well's balances.
 408 |     |      * @return lpAmountOut The amount of LP tokens received
 409 |     |      */
 410 |     |     function getSyncOut() external view returns (uint256 lpAmountOut);
 411 |     | 
 412 |     |     /**
 413 |     |      * @notice Sends excess tokens held by the Well to the `recipient`.
 414 |     |      * @param recipient The address to send the tokens
 415 |     |      * @return skimAmounts The amount of each token skimmed
 416 |     |      * @dev No deadline is needed since this function does not use the user's assets.
 417 |     |      */
 418 |     |     function skim(address recipient) external returns (uint256[] memory skimAmounts);
 419 |     | 
 420 |     |     /**
 421 |     |      * @notice Gets the reserves of each token held by the Well.
 422 |     |      */
 423 |     |     function getReserves() external view returns (uint256[] memory reserves);
 424 |     | 
 425 |     |     /**
 426 |     |      * @notice Returns whether or not the Well is initialized if it requires initialization.
 427 |     |      * If a Well does not require initialization, it should always return `true`.
 428 |     |      */
 429 |     |     function isInitialized() external view returns (bool);
 430 |     | }
 431 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/IWellFunction.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title IWellFunction
  7 |     |  * @notice Defines a relationship between token reserves and LP token supply.
  8 |     |  * @dev Well Functions can contain arbitrary logic, but should be deterministic
  9 |     |  * if expected to be used alongside a Pump. When interacing with a Well or
 10 |     |  * Well Function, always verify that the Well Function is valid.
 11 |     |  */
 12 |     | interface IWellFunction {
 13 |     |     /**
 14 |     |      * @notice Calculates the `j`th reserve given a list of `reserves` and `lpTokenSupply`.
 15 |     |      * @param reserves A list of token reserves. The jth reserve will be ignored, but a placeholder must be provided.
 16 |     |      * @param j The index of the reserve to solve for
 17 |     |      * @param lpTokenSupply The supply of LP tokens
 18 |     |      * @param data Extra Well function data provided on every call
 19 |     |      * @return reserve The resulting reserve at the jth index
 20 |     |      * @dev Should round up to ensure that Well reserves are marginally higher to enforce calcLpTokenSupply(...) >= totalSupply()
 21 |     |      */
 22 |     |     function calcReserve(
 23 |     |         uint[] memory reserves,
 24 |     |         uint j,
 25 |     |         uint lpTokenSupply,
 26 |     |         bytes calldata data
 27 |     |     ) external view returns (uint reserve);
 28 |     | 
 29 |     |     /**
 30 |     |      * @notice Gets the LP token supply given a list of reserves.
 31 |     |      * @param reserves A list of token reserves
 32 |     |      * @param data Extra Well function data provided on every call
 33 |     |      * @return lpTokenSupply The resulting supply of LP tokens
 34 |     |      * @dev Should round down to ensure so that the Well Token supply is marignally lower to enforce calcLpTokenSupply(...) >= totalSupply()
 35 |     |      */
 36 |     |     function calcLpTokenSupply(
 37 |     |         uint[] memory reserves,
 38 |     |         bytes calldata data
 39 |     |     ) external view returns (uint lpTokenSupply);
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Calculates the amount of each reserve token underlying a given amount of LP tokens.
 43 |     |      * @param lpTokenAmount An amount of LP tokens
 44 |     |      * @param reserves A list of token reserves
 45 |     |      * @param lpTokenSupply The current supply of LP tokens
 46 |     |      * @param data Extra Well function data provided on every call
 47 |     |      * @return underlyingAmounts The amount of each reserve token that underlies the LP tokens
 48 |     |      * @dev The constraint totalSupply() <= calcLPTokenSupply(...) must be held in the case where
 49 |     |      * `lpTokenAmount` LP tokens are burned in exchanged for `underlyingAmounts`. If the constraint
 50 |     |      * does not hold, then the Well Function is invalid.
 51 |     |      */
 52 |     |     function calcLPTokenUnderlying(
 53 |     |         uint lpTokenAmount,
 54 |     |         uint[] memory reserves,
 55 |     |         uint lpTokenSupply,
 56 |     |         bytes calldata data
 57 |     |     ) external view returns (uint[] memory underlyingAmounts);
 58 |     | 
 59 |     |     /**
 60 |     |      * @notice Returns the name of the Well function.
 61 |     |      */
 62 |     |     function name() external view returns (string memory);
 63 |     | 
 64 |     |     /**
 65 |     |      * @notice Returns the symbol of the Well function.
 66 |     |      */
 67 |     |     function symbol() external view returns (string memory);
 68 |     | }
 69 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/pumps/ICappedReservesPump.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ICappedReservesPump
  8 |     |  * @notice Provides an interface for Pumps which capped
  9 |     |  * reserves through the use of a cumulative reserve.
 10 |     |  */
 11 |     | interface ICappedReservesPump {
 12 |     |     function readCappedReserves(
 13 |     |         address well,
 14 |     |         bytes memory data
 15 |     |     ) external view returns (uint256[] memory cappedReserves);
 16 |     | }
 17 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/pumps/ICumulativePump.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title ICumulativePump
  7 |     |  * @notice Provides an interface for Pumps which calculate time-weighted average
  8 |     |  * reserves through the use of a cumulative reserve.
  9 |     |  */
 10 |     | interface ICumulativePump {
 11 |     |     /**
 12 |     |      * @notice Reads the current cumulative reserves from the Pump
 13 |     |      * @param well The address of the Well
 14 |     |      * @param data data specific to the Well
 15 |     |      * @return cumulativeReserves The cumulative reserves from the Pump
 16 |     |      */
 17 |     |     function readCumulativeReserves(
 18 |     |         address well,
 19 |     |         bytes memory data
 20 |     |     ) external view returns (bytes memory cumulativeReserves);
 21 |     | 
 22 |     |     /**
 23 |     |      * @notice Reads the current cumulative reserves from the Pump
 24 |     |      * @param well The address of the Well
 25 |     |      * @param startCumulativeReserves The cumulative reserves to start the TWA from
 26 |     |      * @param startTimestamp The timestamp to start the TWA from
 27 |     |      * @param data data specific to the Well
 28 |     |      * @return twaReserves The time weighted average reserves from start timestamp to now
 29 |     |      * @return cumulativeReserves The current cumulative reserves from the Pump at the current timestamp
 30 |     |      */
 31 |     |     function readTwaReserves(
 32 |     |         address well,
 33 |     |         bytes calldata startCumulativeReserves,
 34 |     |         uint startTimestamp,
 35 |     |         bytes memory data
 36 |     |     ) external view returns (uint[] memory twaReserves, bytes memory cumulativeReserves);
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/pumps/IInstantaneousPump.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title Instantaneous Pumps provide an Oracle for instantaneous reserves.
  7 |     |  */
  8 |     | interface IInstantaneousPump {
  9 |     |     /**
 10 |     |      * @notice Reads instantaneous reserves from the Pump
 11 |     |      * @param well The address of the Well
 12 |     |      * @return reserves The instantaneous balanecs tracked by the Pump
 13 |     |      */
 14 |     |     function readInstantaneousReserves(
 15 |     |         address well,
 16 |     |         bytes memory data
 17 |     |     ) external view returns (uint[] memory reserves);
 18 |     | }
 19 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/interfaces/basin/pumps/IMultiFlowPumpWellFunction.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IWellFunction} from "../IWellFunction.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title IMultiFlowPumpWellFunction
  9 |     |  * @dev A Well Function must implement IMultiFlowPumpWellFunction to be supported by
 10 |     |  * the Multi Flow Pump.
 11 |     |  */
 12 |     | interface IMultiFlowPumpWellFunction is IWellFunction {
 13 |     |     /**
 14 |     |      * @notice Calculates the `j` reserve such that `π_{i | i != j} (d reserves_j / d reserves_i) = π_{i | i != j}(ratios_j / ratios_i)`.
 15 |     |      * assumes that reserve_j is being swapped for other reserves in the Well.
 16 |     |      * @dev used by Beanstalk to calculate the deltaB every Season
 17 |     |      * @param reserves The reserves of the Well
 18 |     |      * @param j The index of the reserve to solve for
 19 |     |      * @param ratios The ratios of reserves to solve for
 20 |     |      * @param data Well function data provided on every call
 21 |     |      * @return reserve The resulting reserve at the jth index
 22 |     |      */
 23 |     |     function calcReserveAtRatioSwap(
 24 |     |         uint256[] calldata reserves,
 25 |     |         uint256 j,
 26 |     |         uint256[] calldata ratios,
 27 |     |         bytes calldata data
 28 |     |     ) external view returns (uint256 reserve);
 29 |     | 
 30 |     |     /**
 31 |     |      * @notice Calculates the rate at which j can be exchanged for i.
 32 |     |      * @param reserves The reserves of the Well
 33 |     |      * @param i The index of the token for which the output is being calculated
 34 |     |      * @param j The index of the token for which 1 token is being exchanged
 35 |     |      * @param data Well function data provided on every call
 36 |     |      * @return rate The rate at which j can be exchanged for i
 37 |     |      * @dev should return with 36 decimal precision
 38 |     |      */
 39 |     |     function calcRate(
 40 |     |         uint256[] calldata reserves,
 41 |     |         uint256 i,
 42 |     |         uint256 j,
 43 |     |         bytes calldata data
 44 |     |     ) external view returns (uint256 rate);
 45 |     | }
 46 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Convert/LibConvert.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   6 |     | import {LibLambdaConvert} from "./LibLambdaConvert.sol";
   7 |     | import {LibConvertData} from "./LibConvertData.sol";
   8 |     | import {LibWellConvert} from "./LibWellConvert.sol";
   9 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  10 |     | import {AppStorage, LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
  11 |     | import {LibWellMinting} from "contracts/libraries/Minting/LibWellMinting.sol";
  12 |     | import {C} from "contracts/C.sol";
  13 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  14 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  15 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  16 |     | import {LibDeltaB} from "contracts/libraries/Oracle/LibDeltaB.sol";
  17 |     | import {ConvertCapacity} from "contracts/beanstalk/storage/System.sol";
  18 |     | import {LibSilo} from "contracts/libraries/Silo/LibSilo.sol";
  19 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  20 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  21 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  22 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  23 |     | import {GerminationSide, GaugeId} from "contracts/beanstalk/storage/System.sol";
  24 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  25 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  26 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
  27 |     | import {IBeanstalkWellFunction} from "contracts/interfaces/basin/IBeanstalkWellFunction.sol";
  28 |     | import {IWell, Call} from "contracts/interfaces/basin/IWell.sol";
  29 |     | import {LibPRBMathRoundable} from "contracts/libraries/Math/LibPRBMathRoundable.sol";
  30 |     | 
  31 |     | /**
  32 |     |  * @title LibConvert
  33 |     |  */
  34 | *   | library LibConvert {
  35 |     |     using LibRedundantMath256 for uint256;
  36 |     |     using LibConvertData for bytes;
  37 |     |     using LibWell for address;
  38 |     |     using LibRedundantMathSigned256 for int256;
  39 |     |     using SafeCast for uint256;
  40 |     | 
  41 |     |     event ConvertDownPenalty(address account, uint256 grownStalkLost, uint256 grownStalkKept);
  42 |     | 
  43 |     |     struct AssetsRemovedConvert {
  44 |     |         LibSilo.Removed active;
  45 |     |         uint256[] bdvsRemoved;
  46 |     |         uint256[] stalksRemoved;
  47 |     |         uint256[] depositIds;
  48 |     |     }
  49 |     | 
  50 |     |     struct DeltaBStorage {
  51 |     |         int256 beforeInputTokenDeltaB;
  52 |     |         int256 afterInputTokenDeltaB;
  53 |     |         int256 beforeOutputTokenDeltaB;
  54 |     |         int256 afterOutputTokenDeltaB;
  55 |     |         int256 beforeOverallDeltaB;
  56 |     |         int256 afterOverallDeltaB;
  57 |     |     }
  58 |     | 
  59 |     |     struct PenaltyData {
  60 |     |         uint256 inputToken;
  61 |     |         uint256 outputToken;
  62 |     |         uint256 overall;
  63 |     |     }
  64 |     | 
  65 |     |     struct StalkPenaltyData {
  66 |     |         PenaltyData directionOfPeg;
  67 |     |         PenaltyData againstPeg;
  68 |     |         PenaltyData capacity;
  69 |     |         uint256 higherAmountAgainstPeg;
  70 |     |         uint256 convertCapacityPenalty;
  71 |     |     }
  72 |     | 
  73 |     |     struct ConvertParams {
  74 |     |         address toToken;
  75 |     |         address fromToken;
  76 |     |         uint256 fromAmount;
  77 |     |         uint256 toAmount;
  78 |     |         address account;
  79 |     |         bool decreaseBDV;
  80 |     |         bool shouldNotGerminate;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @notice Takes in bytes object that has convert input data encoded into it for a particular convert for
  85 |     |      * a specified pool and returns the in and out convert amounts and token addresses and bdv
  86 |     |      * @param convertData Contains convert input parameters for a specified convert
  87 |     |      * note account and decreaseBDV variables are initialized at the start
  88 |     |      * as address(0) and false respectively and remain that way if a convert is not anti-lambda-lambda
  89 |     |      * If it is anti-lambda, account is the address of the account to update the deposit
  90 |     |      * and decreaseBDV is true
  91 |     |      */
  92 |     |     function convert(bytes calldata convertData) external returns (ConvertParams memory cp) {
  93 |     |         LibConvertData.ConvertKind kind = convertData.convertKind();
  94 |     | 
  95 |     |         if (kind == LibConvertData.ConvertKind.BEANS_TO_WELL_LP) {
  96 |     |             (cp.toToken, cp.fromToken, cp.toAmount, cp.fromAmount) = LibWellConvert
  97 |     |                 .convertBeansToLP(convertData);
  98 |     |             cp.shouldNotGerminate = true;
  99 |     |         } else if (kind == LibConvertData.ConvertKind.WELL_LP_TO_BEANS) {
 100 |     |             (cp.toToken, cp.fromToken, cp.toAmount, cp.fromAmount) = LibWellConvert
 101 |     |                 .convertLPToBeans(convertData);
 102 |     |             cp.shouldNotGerminate = true;
 103 |     |         } else if (kind == LibConvertData.ConvertKind.LAMBDA_LAMBDA) {
 104 |     |             (cp.toToken, cp.fromToken, cp.toAmount, cp.fromAmount) = LibLambdaConvert.convert(
 105 |     |                 convertData
 106 |     |             );
 107 |     |         } else if (kind == LibConvertData.ConvertKind.ANTI_LAMBDA_LAMBDA) {
 108 |     |             (
 109 |     |                 cp.toToken,
 110 |     |                 cp.fromToken,
 111 |     |                 cp.toAmount,
 112 |     |                 cp.fromAmount,
 113 |     |                 cp.account,
 114 |     |                 cp.decreaseBDV
 115 |     |             ) = LibLambdaConvert.antiConvert(convertData);
 116 |     |         } else {
 117 |     |             revert("Convert: Invalid payload");
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 |     |     function getMaxAmountIn(address fromToken, address toToken) internal view returns (uint256) {
 122 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 123 |     |         // Lambda -> Lambda &
 124 |     |         // Anti-Lambda -> Lambda
 125 |     |         if (fromToken == toToken) return type(uint256).max;
 126 |     | 
 127 |     |         // Bean -> Well LP Token
 128 |     |         if (fromToken == s.sys.bean && toToken.isWell()) return LibWellConvert.beansToPeg(toToken);
 129 |     | 
 130 |     |         // Well LP Token -> Bean
 131 |     |         if (fromToken.isWell() && toToken == s.sys.bean) return LibWellConvert.lpToPeg(fromToken);
 132 |     | 
 133 |     |         revert("Convert: Tokens not supported");
 134 |     |     }
 135 |     | 
 136 |     |     function getAmountOut(
 137 |     |         address fromToken,
 138 |     |         address toToken,
 139 |     |         uint256 fromAmount
 140 |     |     ) internal view returns (uint256) {
 141 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 142 |     | 
 143 |     |         // Lambda -> Lambda &
 144 |     |         // Anti-Lambda -> Lambda
 145 |     |         if (fromToken == toToken) return fromAmount;
 146 |     | 
 147 |     |         // Bean -> Well LP Token
 148 |     |         if (fromToken == s.sys.bean && toToken.isWell()) {
 149 |     |             return LibWellConvert.getLPAmountOut(toToken, fromAmount);
 150 |     |         }
 151 |     | 
 152 |     |         // Well LP Token -> Bean
 153 |     |         if (fromToken.isWell() && toToken == s.sys.bean) {
 154 |     |             return LibWellConvert.getBeanAmountOut(fromToken, fromAmount);
 155 |     |         }
 156 |     | 
 157 |     |         revert("Convert: Tokens not supported");
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @notice applies the stalk penalty and updates convert capacity.
 162 |     |      */
 163 |     |     function applyStalkPenalty(
 164 |     |         DeltaBStorage memory dbs,
 165 |     |         uint256 bdvConverted,
 166 |     |         uint256 overallConvertCapacity,
 167 |     |         address inputToken,
 168 |     |         address outputToken
 169 |     |     ) internal returns (uint256 stalkPenaltyBdv) {
 170 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 171 |     |         uint256 overallConvertCapacityUsed;
 172 |     |         uint256 inputTokenAmountUsed;
 173 |     |         uint256 outputTokenAmountUsed;
 174 |     | 
 175 |     |         (
 176 |     |             stalkPenaltyBdv,
 177 |     |             overallConvertCapacityUsed,
 178 |     |             inputTokenAmountUsed,
 179 |     |             outputTokenAmountUsed
 180 |     |         ) = calculateStalkPenalty(
 181 |     |             dbs,
 182 |     |             bdvConverted,
 183 |     |             overallConvertCapacity,
 184 |     |             inputToken,
 185 |     |             outputToken
 186 |     |         );
 187 |     | 
 188 |     |         // Update penalties in storage.
 189 |     |         ConvertCapacity storage convertCap = s.sys.convertCapacity[block.number];
 190 |     |         convertCap.overallConvertCapacityUsed = convertCap.overallConvertCapacityUsed.add(
 191 |     |             overallConvertCapacityUsed
 192 |     |         );
 193 |     |         convertCap.wellConvertCapacityUsed[inputToken] = convertCap
 194 |     |             .wellConvertCapacityUsed[inputToken]
 195 |     |             .add(inputTokenAmountUsed);
 196 |     |         convertCap.wellConvertCapacityUsed[outputToken] = convertCap
 197 |     |             .wellConvertCapacityUsed[outputToken]
 198 |     |             .add(outputTokenAmountUsed);
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @notice Calculates the percentStalkPenalty for a given convert.
 203 |     |      */
 204 |     |     function calculateStalkPenalty(
 205 |     |         DeltaBStorage memory dbs,
 206 |     |         uint256 bdvConverted,
 207 |     |         uint256 overallConvertCapacity,
 208 |     |         address inputToken,
 209 |     |         address outputToken
 210 |     |     )
 211 |     |         internal
 212 |     |         view
 213 |     |         returns (
 214 |     |             uint256 stalkPenaltyBdv,
 215 |     |             uint256 overallConvertCapacityUsed,
 216 |     |             uint256 inputTokenAmountUsed,
 217 |     |             uint256 outputTokenAmountUsed
 218 |     |         )
 219 |     |     {
 220 |     |         StalkPenaltyData memory spd;
 221 |     | 
 222 |     |         spd.directionOfPeg = calculateConvertedTowardsPeg(dbs);
 223 |     |         spd.againstPeg = calculateAmountAgainstPeg(dbs);
 224 |     | 
 225 |     |         spd.higherAmountAgainstPeg = max(
 226 |     |             spd.againstPeg.overall,
 227 |     |             spd.againstPeg.inputToken.add(spd.againstPeg.outputToken)
 228 |     |         );
 229 |     | 
 230 |     |         (spd.convertCapacityPenalty, spd.capacity) = calculateConvertCapacityPenalty(
 231 |     |             overallConvertCapacity,
 232 |     |             spd.directionOfPeg.overall,
 233 |     |             inputToken,
 234 |     |             spd.directionOfPeg.inputToken,
 235 |     |             outputToken,
 236 |     |             spd.directionOfPeg.outputToken
 237 |     |         );
 238 |     | 
 239 |     |         // Cap amount of bdv penalized at amount of bdv converted (no penalty should be over 100%)
 240 |     |         stalkPenaltyBdv = min(
 241 |     |             spd.higherAmountAgainstPeg.add(spd.convertCapacityPenalty),
 242 |     |             bdvConverted
 243 |     |         );
 244 |     | 
 245 |     |         return (
 246 |     |             stalkPenaltyBdv,
 247 |     |             spd.capacity.overall,
 248 |     |             spd.capacity.inputToken,
 249 |     |             spd.capacity.outputToken
 250 |     |         );
 251 |     |     }
 252 |     | 
 253 |     |     /**
 254 |     |      * @param overallCappedDeltaB The capped overall deltaB for all wells
 255 |     |      * @param overallAmountInDirectionOfPeg The amount deltaB was converted towards peg
 256 |     |      * @param inputToken Address of the input well
 257 |     |      * @param inputTokenAmountInDirectionOfPeg The amount deltaB was converted towards peg for the input well
 258 |     |      * @param outputToken Address of the output well
 259 |     |      * @param outputTokenAmountInDirectionOfPeg The amount deltaB was converted towards peg for the output well
 260 |     |      * @return cumulativePenalty The total Convert Capacity penalty, note it can return greater than the BDV converted
 261 |     |      */
 262 |     |     function calculateConvertCapacityPenalty(
 263 |     |         uint256 overallCappedDeltaB,
 264 |     |         uint256 overallAmountInDirectionOfPeg,
 265 |     |         address inputToken,
 266 |     |         uint256 inputTokenAmountInDirectionOfPeg,
 267 |     |         address outputToken,
 268 |     |         uint256 outputTokenAmountInDirectionOfPeg
 269 |     |     ) internal view returns (uint256 cumulativePenalty, PenaltyData memory pdCapacity) {
 270 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 271 |     | 
 272 |     |         ConvertCapacity storage convertCap = s.sys.convertCapacity[block.number];
 273 |     | 
 274 |     |         // first check overall convert capacity, if none remaining then full penalty for amount in direction of peg
 275 |     |         if (convertCap.overallConvertCapacityUsed >= overallCappedDeltaB) {
 276 |     |             cumulativePenalty = overallAmountInDirectionOfPeg;
 277 |     |         } else if (
 278 |     |             overallAmountInDirectionOfPeg >
 279 |     |             overallCappedDeltaB.sub(convertCap.overallConvertCapacityUsed)
 280 |     |         ) {
 281 |     |             cumulativePenalty =
 282 |     |                 overallAmountInDirectionOfPeg -
 283 |     |                 overallCappedDeltaB.sub(convertCap.overallConvertCapacityUsed);
 284 |     |         }
 285 |     | 
 286 |     |         // update overall remaining convert capacity
 287 |     |         pdCapacity.overall = convertCap.overallConvertCapacityUsed.add(
 288 |     |             overallAmountInDirectionOfPeg
 289 |     |         );
 290 |     | 
 291 |     |         // update per-well convert capacity
 292 |     | 
 293 |     |         if (inputToken != s.sys.bean && inputTokenAmountInDirectionOfPeg > 0) {
 294 |     |             (cumulativePenalty, pdCapacity.inputToken) = calculatePerWellCapacity(
 295 |     |                 inputToken,
 296 |     |                 inputTokenAmountInDirectionOfPeg,
 297 |     |                 cumulativePenalty,
 298 |     |                 convertCap,
 299 |     |                 pdCapacity.inputToken
 300 |     |             );
 301 |     |         }
 302 |     | 
 303 |     |         if (outputToken != s.sys.bean && outputTokenAmountInDirectionOfPeg > 0) {
 304 |     |             (cumulativePenalty, pdCapacity.outputToken) = calculatePerWellCapacity(
 305 |     |                 outputToken,
 306 |     |                 outputTokenAmountInDirectionOfPeg,
 307 |     |                 cumulativePenalty,
 308 |     |                 convertCap,
 309 |     |                 pdCapacity.outputToken
 310 |     |             );
 311 |     |         }
 312 |     |     }
 313 |     | 
 314 |     |     function calculatePerWellCapacity(
 315 |     |         address wellToken,
 316 |     |         uint256 amountInDirectionOfPeg,
 317 |     |         uint256 cumulativePenalty,
 318 |     |         ConvertCapacity storage convertCap,
 319 |     |         uint256 pdCapacityToken
 320 |     |     ) internal view returns (uint256, uint256) {
 321 |     |         uint256 tokenWellCapacity = abs(LibDeltaB.cappedReservesDeltaB(wellToken));
 322 |     |         pdCapacityToken = convertCap.wellConvertCapacityUsed[wellToken].add(amountInDirectionOfPeg);
 323 |     |         if (pdCapacityToken > tokenWellCapacity) {
 324 |     |             cumulativePenalty = cumulativePenalty.add(pdCapacityToken.sub(tokenWellCapacity));
 325 |     |         }
 326 |     | 
 327 |     |         return (cumulativePenalty, pdCapacityToken);
 328 |     |     }
 329 |     | 
 330 |     |     /**
 331 |     |      * @notice Performs `calculateAgainstPeg` for the overall, input token, and output token deltaB's.
 332 |     |      */
 333 |     |     function calculateAmountAgainstPeg(
 334 |     |         DeltaBStorage memory dbs
 335 |     |     ) internal pure returns (PenaltyData memory pd) {
 336 |     |         pd.overall = calculateAgainstPeg(dbs.beforeOverallDeltaB, dbs.afterOverallDeltaB);
 337 |     |         pd.inputToken = calculateAgainstPeg(dbs.beforeInputTokenDeltaB, dbs.afterInputTokenDeltaB);
 338 |     |         pd.outputToken = calculateAgainstPeg(
 339 |     |             dbs.beforeOutputTokenDeltaB,
 340 |     |             dbs.afterOutputTokenDeltaB
 341 |     |         );
 342 |     |     }
 343 |     | 
 344 |     |     /**
 345 |     |      * @notice Takes before/after deltaB's and calculates how much was converted against peg.
 346 |     |      */
 347 |     |     function calculateAgainstPeg(
 348 |     |         int256 beforeDeltaB,
 349 |     |         int256 afterDeltaB
 350 |     |     ) internal pure returns (uint256 amountAgainstPeg) {
 351 |     |         // Check if the signs of beforeDeltaB and afterDeltaB are different,
 352 |     |         // indicating that deltaB has crossed zero
 353 |     |         if ((beforeDeltaB > 0 && afterDeltaB < 0) || (beforeDeltaB < 0 && afterDeltaB > 0)) {
 354 |     |             amountAgainstPeg = abs(afterDeltaB);
 355 |     |         } else {
 356 |     |             if (
 357 |     |                 (afterDeltaB <= 0 && beforeDeltaB <= 0) || (afterDeltaB >= 0 && beforeDeltaB >= 0)
 358 |     |             ) {
 359 |     |                 if (abs(beforeDeltaB) < abs(afterDeltaB)) {
 360 |     |                     amountAgainstPeg = abs(afterDeltaB).sub(abs(beforeDeltaB));
 361 |     |                 }
 362 |     |             }
 363 |     |         }
 364 |     |     }
 365 |     | 
 366 |     |     /**
 367 |     |      * @notice Performs `calculateTowardsPeg` for the overall, input token, and output token deltaB's.
 368 |     |      */
 369 |     |     function calculateConvertedTowardsPeg(
 370 |     |         DeltaBStorage memory dbs
 371 |     |     ) internal pure returns (PenaltyData memory pd) {
 372 |     |         pd.overall = calculateTowardsPeg(dbs.beforeOverallDeltaB, dbs.afterOverallDeltaB);
 373 |     |         pd.inputToken = calculateTowardsPeg(dbs.beforeInputTokenDeltaB, dbs.afterInputTokenDeltaB);
 374 |     |         pd.outputToken = calculateTowardsPeg(
 375 |     |             dbs.beforeOutputTokenDeltaB,
 376 |     |             dbs.afterOutputTokenDeltaB
 377 |     |         );
 378 |     |     }
 379 |     | 
 380 |     |     /**
 381 |     |      * @notice Takes before/after deltaB's and calculates how much was converted towards, but not past, peg.
 382 |     |      */
 383 |     |     function calculateTowardsPeg(
 384 |     |         int256 beforeTokenDeltaB,
 385 |     |         int256 afterTokenDeltaB
 386 |     |     ) internal pure returns (uint256) {
 387 |     |         // Calculate absolute values of beforeInputTokenDeltaB and afterInputTokenDeltaB using the abs() function
 388 |     |         uint256 beforeDeltaAbs = abs(beforeTokenDeltaB);
 389 |     |         uint256 afterDeltaAbs = abs(afterTokenDeltaB);
 390 |     | 
 391 |     |         // Check if afterInputTokenDeltaB and beforeInputTokenDeltaB have the same sign
 392 |     |         if (
 393 |     |             (beforeTokenDeltaB >= 0 && afterTokenDeltaB >= 0) ||
 394 |     |             (beforeTokenDeltaB < 0 && afterTokenDeltaB < 0)
 395 |     |         ) {
 396 |     |             // If they have the same sign, compare the absolute values
 397 |     |             if (afterDeltaAbs < beforeDeltaAbs) {
 398 |     |                 // Return the difference between beforeDeltaAbs and afterDeltaAbs
 399 |     |                 return beforeDeltaAbs.sub(afterDeltaAbs);
 400 |     |             } else {
 401 |     |                 // If afterInputTokenDeltaB is further from or equal to zero, return zero
 402 |     |                 return 0;
 403 |     |             }
 404 |     |         } else {
 405 |     |             // This means it crossed peg, return how far it went towards peg, which is the abs of input token deltaB
 406 |     |             return beforeDeltaAbs;
 407 |     |         }
 408 |     |     }
 409 |     | 
 410 |     |     /**
 411 |     |      * @notice checks for potential germination. if the deposit is germinating,
 412 |     |      * issue additional grown stalk such that the deposit is no longer germinating.
 413 |     |      */
 414 |     |     function calculateGrownStalkWithNonGerminatingMin(
 415 |     |         address token,
 416 |     |         uint256 grownStalk,
 417 |     |         uint256 bdv
 418 |     |     ) internal view returns (uint256 newGrownStalk) {
 419 |     |         (, GerminationSide side) = LibTokenSilo.calculateStemForTokenFromGrownStalk(
 420 |     |             token,
 421 |     |             grownStalk,
 422 |     |             bdv
 423 |     |         );
 424 |     |         // if the side is not `NOT_GERMINATING`, calculate the grown stalk needed to
 425 |     |         // make the deposit non-germinating.
 426 |     |         if (side != GerminationSide.NOT_GERMINATING) {
 427 |     |             newGrownStalk = LibTokenSilo.calculateGrownStalkAtNonGerminatingStem(token, bdv);
 428 |     |         } else {
 429 |     |             newGrownStalk = grownStalk;
 430 |     |         }
 431 |     |     }
 432 |     | 
 433 |     |     /**
 434 |     |      * @notice removes the deposits from user and returns the
 435 |     |      * grown stalk and bdv removed.
 436 |     |      *
 437 |     |      * @dev if a user inputs a stem of a deposit that is `germinating`,
 438 |     |      * the function will omit that deposit. This is due to the fact that
 439 |     |      * germinating deposits can be manipulated and skip the germination process.
 440 |     |      */
 441 |     |     function _withdrawTokens(
 442 |     |         address token,
 443 |     |         int96[] memory stems,
 444 |     |         uint256[] memory amounts,
 445 |     |         uint256 maxTokens,
 446 |     |         address user
 447 |     |     ) internal returns (uint256, uint256, uint256) {
 448 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 449 |     |         require(stems.length == amounts.length, "Convert: stems, amounts are diff lengths.");
 450 |     | 
 451 |     |         AssetsRemovedConvert memory a;
 452 |     |         uint256 i = 0;
 453 |     |         uint256 stalkIssuedPerBdv;
 454 |     | 
 455 |     |         // a bracket is included here to avoid the "stack too deep" error.
 456 |     |         {
 457 |     |             a.bdvsRemoved = new uint256[](stems.length);
 458 |     |             a.stalksRemoved = new uint256[](stems.length);
 459 |     |             a.depositIds = new uint256[](stems.length);
 460 |     | 
 461 |     |             // calculated here to avoid stack too deep error.
 462 |     |             stalkIssuedPerBdv = LibTokenSilo.stalkIssuedPerBdv(token);
 463 |     | 
 464 |     |             // get germinating stem and stemTip for the token
 465 |     |             LibGerminate.GermStem memory germStem = LibGerminate.getGerminatingStem(token);
 466 |     | 
 467 |     |             while ((i < stems.length) && (a.active.tokens < maxTokens)) {
 468 |     |                 // skip any stems that are germinating, due to the ability to
 469 |     |                 // circumvent the germination process.
 470 |     |                 if (germStem.germinatingStem <= stems[i]) {
 471 |     |                     i++;
 472 |     |                     continue;
 473 |     |                 }
 474 |     | 
 475 |     |                 if (a.active.tokens.add(amounts[i]) >= maxTokens) {
 476 |     |                     amounts[i] = maxTokens.sub(a.active.tokens);
 477 |     |                 }
 478 |     | 
 479 |     |                 a.bdvsRemoved[i] = LibTokenSilo.removeDepositFromAccount(
 480 |     |                     user,
 481 |     |                     token,
 482 |     |                     stems[i],
 483 |     |                     amounts[i]
 484 |     |                 );
 485 |     | 
 486 |     |                 a.stalksRemoved[i] = LibSilo.stalkReward(
 487 |     |                     stems[i],
 488 |     |                     germStem.stemTip,
 489 |     |                     a.bdvsRemoved[i].toUint128()
 490 |     |                 );
 491 |     |                 a.active.stalk = a.active.stalk.add(a.stalksRemoved[i]);
 492 |     | 
 493 |     |                 a.active.tokens = a.active.tokens.add(amounts[i]);
 494 |     |                 a.active.bdv = a.active.bdv.add(a.bdvsRemoved[i]);
 495 |     | 
 496 |     |                 a.depositIds[i] = uint256(LibBytes.packAddressAndStem(token, stems[i]));
 497 |     |                 i++;
 498 |     |             }
 499 |     |             for (i; i < stems.length; ++i) {
 500 |     |                 amounts[i] = 0;
 501 |     |             }
 502 |     | 
 503 |     |             emit LibSilo.RemoveDeposits(
 504 |     |                 user,
 505 |     |                 token,
 506 |     |                 stems,
 507 |     |                 amounts,
 508 |     |                 a.active.tokens,
 509 |     |                 a.bdvsRemoved
 510 |     |             );
 511 |     | 
 512 |     |             emit LibTokenSilo.TransferBatch(user, user, address(0), a.depositIds, amounts);
 513 |     |         }
 514 |     | 
 515 |     |         require(a.active.tokens == maxTokens, "Convert: Not enough tokens removed.");
 516 |     |         LibTokenSilo.decrementTotalDeposited(token, a.active.tokens, a.active.bdv);
 517 |     | 
 518 |     |         // all deposits converted are not germinating.
 519 |     |         (, uint256 deltaRainRoots) = LibSilo.burnActiveStalk(
 520 |     |             user,
 521 |     |             a.active.stalk.add(a.active.bdv.mul(stalkIssuedPerBdv))
 522 |     |         );
 523 |     | 
 524 |     |         return (a.active.stalk, a.active.bdv, deltaRainRoots);
 525 |     |     }
 526 |     | 
 527 |     |     function _depositTokensForConvert(
 528 |     |         address token,
 529 |     |         uint256 amount,
 530 |     |         uint256 bdv,
 531 |     |         uint256 grownStalk,
 532 |     |         uint256 deltaRainRoots,
 533 |     |         address user
 534 |     |     ) internal returns (int96 stem) {
 535 |     |         require(bdv > 0 && amount > 0, "Convert: BDV or amount is 0.");
 536 |     | 
 537 |     |         GerminationSide side;
 538 |     | 
 539 |     |         // calculate the stem and germination state for the new deposit.
 540 |     |         (stem, side) = LibTokenSilo.calculateStemForTokenFromGrownStalk(token, grownStalk, bdv);
 541 |     | 
 542 |     |         // increment totals based on germination state,
 543 |     |         // as well as issue stalk to the user.
 544 |     |         // if the deposit is germinating, only the initial stalk of the deposit is germinating.
 545 |     |         // the rest is active stalk.
 546 |     |         if (side == GerminationSide.NOT_GERMINATING) {
 547 |     |             LibTokenSilo.incrementTotalDeposited(token, amount, bdv);
 548 |     |             LibSilo.mintActiveStalk(
 549 |     |                 user,
 550 |     |                 bdv.mul(LibTokenSilo.stalkIssuedPerBdv(token)).add(grownStalk)
 551 |     |             );
 552 |     |             // if needed, credit previously burned rain roots from withdrawal to the user.
 553 |     |             if (deltaRainRoots > 0) LibSilo.mintRainRoots(user, deltaRainRoots);
 554 |     |         } else {
 555 |     |             LibTokenSilo.incrementTotalGerminating(token, amount, bdv, side);
 556 |     |             // safeCast not needed as stalk is <= max(uint128)
 557 |     |             LibSilo.mintGerminatingStalk(
 558 |     |                 user,
 559 |     |                 uint128(bdv.mul(LibTokenSilo.stalkIssuedPerBdv(token))),
 560 |     |                 side
 561 |     |             );
 562 |     |             LibSilo.mintActiveStalk(user, grownStalk);
 563 |     |         }
 564 |     |         LibTokenSilo.addDepositToAccount(
 565 |     |             user,
 566 |     |             token,
 567 |     |             stem,
 568 |     |             amount,
 569 |     |             bdv,
 570 |     |             LibTokenSilo.Transfer.emitTransferSingle
 571 |     |         );
 572 |     |     }
 573 |     | 
 574 |     |     /**
 575 |     |      * @notice Computes new grown stalk after downward convert penalty.
 576 |     |      * No penalty if P > Q or grown stalk below germination threshold.
 577 |     |      * @dev Inbound must not be germinating, will return germinating amount of grown stalk.
 578 |     |      * @return newGrownStalk Amount of grown stalk to assign the deposit.
 579 |     |      * @return grownStalkLost Amount of grown stalk lost to penalty.
 580 |     |      */
 581 |     |     function downPenalizedGrownStalk(
 582 |     |         address well,
 583 |     |         uint256 bdv,
 584 |     |         uint256 grownStalk
 585 |     |     ) internal view returns (uint256 newGrownStalk, uint256 grownStalkLost) {
 586 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 587 |     | 
 588 |     |         // No penalty if output deposit germinating.
 589 |     |         uint256 minGrownStalk = LibTokenSilo.calculateGrownStalkAtNonGerminatingStem(well, bdv);
 590 |     |         if (grownStalk < minGrownStalk) {
 591 |     |             return (grownStalk, 0);
 592 |     |         }
 593 |     | 
 594 |     |         // No penalty if P > Q.
 595 |     |         if (pGreaterThanQ(well)) {
 596 |     |             return (grownStalk, 0);
 597 |     |         }
 598 |     | 
 599 |     |         // Get penalty ratio from gauge.
 600 |     |         (uint256 penaltyRatio, ) = abi.decode(
 601 |     |             s.sys.gaugeData.gauges[GaugeId.CONVERT_DOWN_PENALTY].value,
 602 |     |             (uint256, uint256)
 603 |     |         );
 604 |     |         newGrownStalk = max(
 605 |     |             grownStalk -
 606 |     |                 LibPRBMathRoundable.mulDiv(
 607 |     |                     grownStalk,
 608 |     |                     penaltyRatio,
 609 |     |                     C.PRECISION,
 610 |     |                     LibPRBMathRoundable.Rounding.Up
 611 |     |                 ),
 612 |     |             minGrownStalk
 613 |     |         );
 614 |     |         grownStalkLost = grownStalk - newGrownStalk;
 615 |     |     }
 616 |     | 
 617 |     |     function pGreaterThanQ(address well) internal view returns (bool) {
 618 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 619 |     | 
 620 |     |         // No penalty if P > Q.
 621 |     |         (uint256[] memory ratios, uint256 beanIndex, bool success) = LibWell.getRatiosAndBeanIndex(
 622 |     |             IWell(well).tokens(),
 623 |     |             0
 624 |     |         );
 625 |     |         require(success, "Convert: USD Oracle failed");
 626 |     | 
 627 |     |         // Scale ratio by Q.
 628 |     |         ratios[beanIndex] =
 629 |     |             (ratios[beanIndex] * 1e6) /
 630 |     |             s.sys.evaluationParameters.excessivePriceThreshold;
 631 |     | 
 632 |     |         uint256[] memory instantReserves = LibDeltaB.instantReserves(well);
 633 |     |         Call memory wellFunction = IWell(well).wellFunction();
 634 |     |         uint256 beansAtQ = IBeanstalkWellFunction(wellFunction.target).calcReserveAtRatioSwap(
 635 |     |             instantReserves,
 636 |     |             beanIndex,
 637 |     |             ratios,
 638 |     |             wellFunction.data
 639 |     |         );
 640 |     |         // Fewer Beans indicates a higher Bean price.
 641 |     |         if (instantReserves[beanIndex] < beansAtQ) {
 642 |     |             return true;
 643 |     |         }
 644 |     |         return false;
 645 |     |     }
 646 |     | 
 647 |     |     function abs(int256 a) internal pure returns (uint256) {
 648 |     |         return a >= 0 ? uint256(a) : uint256(-a);
 649 |     |     }
 650 |     | 
 651 |     |     /**
 652 |     |      * @dev Returns the largest of two numbers.
 653 |     |      */
 654 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
 655 |     |         return a > b ? a : b;
 656 |     |     }
 657 |     | 
 658 |     |     /**
 659 |     |      * @dev Returns the smallest of two numbers.
 660 |     |      */
 661 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 662 |     |         return a < b ? a : b;
 663 |     |     }
 664 |     | }
 665 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Convert/LibConvertData.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibConvertData
  7 |     |  */
  8 | *   | library LibConvertData {
  9 |     |     // In order to preserve backwards compatibility, make sure new kinds are added at the end of the enum.
 10 |     |     enum ConvertKind {
 11 |     |         LAMBDA_LAMBDA,
 12 |     |         BEANS_TO_WELL_LP,
 13 |     |         WELL_LP_TO_BEANS,
 14 |     |         ANTI_LAMBDA_LAMBDA
 15 |     |     }
 16 |     | 
 17 |     |     /// @notice Decoder for the Convert Enum
 18 |     |     function convertKind(bytes memory self) internal pure returns (ConvertKind) {
 19 |     |         return abi.decode(self, (ConvertKind));
 20 |     |     }
 21 |     | 
 22 |     |     /// @notice Decoder for the addLPInBeans Convert
 23 |     |     function basicConvert(
 24 |     |         bytes memory self
 25 |     |     ) internal pure returns (uint256 amountIn, uint256 minAmontOut) {
 26 |     |         (, amountIn, minAmontOut) = abi.decode(self, (ConvertKind, uint256, uint256));
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Decoder for the addLPInBeans Convert
 30 |     |     function convertWithAddress(
 31 |     |         bytes memory self
 32 |     |     ) internal pure returns (uint256 amountIn, uint256 minAmontOut, address token) {
 33 |     |         (, amountIn, minAmontOut, token) = abi.decode(
 34 |     |             self,
 35 |     |             (ConvertKind, uint256, uint256, address)
 36 |     |         );
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Decoder for the lambdaConvert
 40 |     |     function lambdaConvert(
 41 |     |         bytes memory self
 42 |     |     ) internal pure returns (uint256 amount, address token) {
 43 |     |         (, amount, token) = abi.decode(self, (ConvertKind, uint256, address));
 44 |     |     }
 45 |     | 
 46 |     |     /// @notice Decoder for the antiLambdaConvert
 47 |     |     /// @dev contains an additional address parameter for the account to update the deposit
 48 |     |     /// and a bool to indicate whether to decrease the bdv
 49 |     |     function antiLambdaConvert(
 50 |     |         bytes memory self
 51 |     |     ) internal pure returns (uint256 amount, address token, address account, bool decreaseBDV) {
 52 |     |         (, amount, token, account) = abi.decode(self, (ConvertKind, uint256, address, address));
 53 |     |         decreaseBDV = true;
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Convert/LibLambdaConvert.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {LibConvertData} from "./LibConvertData.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title LibLambdaConvert
  9 |     |  */
 10 | *   | library LibLambdaConvert {
 11 |     |     using LibConvertData for bytes;
 12 |     | 
 13 |     |     /**
 14 |     |      * @notice This function returns the full input for use in lambda convert
 15 |     |      * In lambda convert, the account converts from and to the same token.
 16 |     |      */
 17 |     |     function convert(
 18 |     |         bytes memory convertData
 19 |     |     )
 20 |     |         internal
 21 |     |         pure
 22 |     |         returns (address tokenOut, address tokenIn, uint256 amountOut, uint256 amountIn)
 23 |     |     {
 24 |     |         (amountIn, tokenIn) = convertData.lambdaConvert();
 25 |     |         tokenOut = tokenIn;
 26 |     |         amountOut = amountIn;
 27 |     |     }
 28 |     | 
 29 |     |     /**
 30 |     |      * @notice This function returns the full input for use in anti-lamda convert
 31 |     |      * In anti lamda convert, any user can convert on behalf of an account
 32 |     |      * to update a deposit's bdv.
 33 |     |      * This is why the additional 'account' parameter is returned.
 34 |     |      */
 35 |     |     function antiConvert(
 36 |     |         bytes memory convertData
 37 |     |     )
 38 |     |         internal
 39 |     |         pure
 40 |     |         returns (
 41 |     |             address tokenOut,
 42 |     |             address tokenIn,
 43 |     |             uint256 amountOut,
 44 |     |             uint256 amountIn,
 45 |     |             address account,
 46 |     |             bool decreaseBDV
 47 |     |         )
 48 |     |     {
 49 |     |         (amountIn, tokenIn, account, decreaseBDV) = convertData.antiLambdaConvert();
 50 |     |         tokenOut = tokenIn;
 51 |     |         amountOut = amountIn;
 52 |     |     }
 53 |     | }
 54 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Convert/LibPipelineConvert.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {C} from "contracts/C.sol";
   6 |     | import {LibConvert} from "./LibConvert.sol";
   7 |     | import {AdvancedPipeCall} from "contracts/interfaces/IPipeline.sol";
   8 |     | import {LibWell} from "../Well/LibWell.sol";
   9 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  10 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  11 |     | import {LibDeltaB} from "contracts/libraries/Oracle/LibDeltaB.sol";
  12 |     | import {IPipeline, PipeCall} from "contracts/interfaces/IPipeline.sol";
  13 |     | import {LibConvertData} from "contracts/libraries/Convert/LibConvertData.sol";
  14 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  15 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title LibPipelineConvert
  19 |     |  */
  20 | *   | library LibPipelineConvert {
  21 |     |     using LibConvertData for bytes;
  22 |     |     /**
  23 |     |      * @notice contains data for a convert that uses Pipeline.
  24 |     |      */
  25 |     |     struct PipelineConvertData {
  26 |     |         uint256 grownStalk;
  27 |     |         LibConvert.DeltaBStorage deltaB;
  28 |     |         uint256 inputAmount;
  29 |     |         uint256 overallConvertCapacity;
  30 |     |         uint256 stalkPenaltyBdv;
  31 |     |         address user;
  32 |     |         uint256 newBdv;
  33 |     |         uint256[] initialLpSupply;
  34 |     |     }
  35 |     | 
  36 |     |     function executePipelineConvert(
  37 |     |         address inputToken,
  38 |     |         address outputToken,
  39 |     |         uint256 fromAmount,
  40 |     |         uint256 fromBdv,
  41 |     |         uint256 initialGrownStalk,
  42 |     |         AdvancedPipeCall[] memory advancedPipeCalls
  43 |     |     ) external returns (uint256 toAmount, uint256 newGrownStalk, uint256 newBdv) {
  44 |     |         PipelineConvertData memory pipeData = LibPipelineConvert.populatePipelineConvertData(
  45 |     |             inputToken,
  46 |     |             outputToken
  47 |     |         );
  48 |     | 
  49 |     |         // Store the capped overall deltaB, this limits the overall convert power for the block
  50 |     |         pipeData.overallConvertCapacity = LibConvert.abs(LibDeltaB.overallCappedDeltaB());
  51 |     | 
  52 |     |         IERC20(inputToken).transfer(C.PIPELINE, fromAmount);
  53 |     |         IPipeline(C.PIPELINE).advancedPipe(advancedPipeCalls);
  54 |     | 
  55 |     |         // user MUST leave final assets in pipeline, allowing us to verify that the farm has been called successfully.
  56 |     |         // this also let's us know how many assets to attempt to pull out of the final type
  57 |     |         toAmount = transferTokensFromPipeline(outputToken);
  58 |     | 
  59 |     |         newBdv = LibTokenSilo.beanDenominatedValue(outputToken, toAmount);
  60 |     | 
  61 |     |         // Calculate stalk penalty using start/finish deltaB of pools, and the capped deltaB is
  62 |     |         // passed in to setup max convert power.
  63 |     |         pipeData.stalkPenaltyBdv = prepareStalkPenaltyCalculation(
  64 |     |             inputToken,
  65 |     |             outputToken,
  66 |     |             pipeData.deltaB,
  67 |     |             pipeData.overallConvertCapacity,
  68 |     |             newBdv,
  69 |     |             pipeData.initialLpSupply
  70 |     |         );
  71 |     | 
  72 |     |         // scale initial grown stalk proportionally to the bdv lost (if any)
  73 |     |         if (newBdv < fromBdv) {
  74 |     |             initialGrownStalk = (initialGrownStalk * newBdv) / fromBdv;
  75 |     |         }
  76 |     | 
  77 |     |         // Update grownStalk amount with penalty applied
  78 |     |         newGrownStalk = (initialGrownStalk * (newBdv - pipeData.stalkPenaltyBdv)) / newBdv;
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Calculates the stalk penalty for a convert. Updates convert capacity used.
  83 |     |      */
  84 |     |     function prepareStalkPenaltyCalculation(
  85 |     |         address inputToken,
  86 |     |         address outputToken,
  87 |     |         LibConvert.DeltaBStorage memory dbs,
  88 |     |         uint256 overallConvertCapacity,
  89 |     |         uint256 fromBdv,
  90 |     |         uint256[] memory initialLpSupply
  91 |     |     ) public returns (uint256) {
  92 |     |         dbs.afterOverallDeltaB = LibDeltaB.scaledOverallCurrentDeltaB(initialLpSupply);
  93 |     | 
  94 |     |         // modify afterInputTokenDeltaB and afterOutputTokenDeltaB to scale using before/after LP amounts
  95 |     |         if (LibWell.isWell(inputToken)) {
  96 |     |             uint256 i = LibWhitelistedTokens.getIndexFromWhitelistedWellLpTokens(inputToken);
  97 |     |             dbs.afterInputTokenDeltaB = LibDeltaB.scaledDeltaB(
  98 |     |                 initialLpSupply[i],
  99 |     |                 IERC20(inputToken).totalSupply(),
 100 |     |                 LibDeltaB.getCurrentDeltaB(inputToken)
 101 |     |             );
 102 |     |         }
 103 |     | 
 104 |     |         if (LibWell.isWell(outputToken)) {
 105 |     |             uint256 i = LibWhitelistedTokens.getIndexFromWhitelistedWellLpTokens(outputToken);
 106 |     |             dbs.afterOutputTokenDeltaB = LibDeltaB.scaledDeltaB(
 107 |     |                 initialLpSupply[i],
 108 |     |                 IERC20(outputToken).totalSupply(),
 109 |     |                 LibDeltaB.getCurrentDeltaB(outputToken)
 110 |     |             );
 111 |     |         }
 112 |     | 
 113 |     |         return
 114 |     |             LibConvert.applyStalkPenalty(
 115 |     |                 dbs,
 116 |     |                 fromBdv,
 117 |     |                 overallConvertCapacity,
 118 |     |                 inputToken,
 119 |     |                 outputToken
 120 |     |             );
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Determines input token amount left in pipeline and returns to Beanstalk
 125 |     |      * @param tokenOut The token to pull out of pipeline
 126 |     |      */
 127 |     |     function transferTokensFromPipeline(address tokenOut) internal returns (uint256 amountOut) {
 128 |     |         amountOut = IERC20(tokenOut).balanceOf(C.PIPELINE);
 129 |     |         require(amountOut > 0, "Convert: No output tokens left in pipeline");
 130 |     | 
 131 |     |         PipeCall memory p;
 132 |     |         p.target = address(tokenOut);
 133 |     |         p.data = abi.encodeWithSelector(IERC20.transfer.selector, address(this), amountOut);
 134 |     |         C.pipeline().pipe(p);
 135 |     |     }
 136 |     | 
 137 |     |     function populatePipelineConvertData(
 138 |     |         address fromToken,
 139 |     |         address toToken
 140 |     |     ) internal view returns (PipelineConvertData memory pipeData) {
 141 |     |         pipeData.deltaB.beforeOverallDeltaB = LibDeltaB.overallCurrentDeltaB();
 142 |     |         pipeData.deltaB.beforeInputTokenDeltaB = LibDeltaB.getCurrentDeltaB(fromToken);
 143 |     |         pipeData.deltaB.beforeOutputTokenDeltaB = LibDeltaB.getCurrentDeltaB(toToken);
 144 |     |         pipeData.initialLpSupply = LibDeltaB.getLpSupply();
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Determines the convert state and populates pipeline data if necessary
 149 |     |      */
 150 |     |     function getConvertState(
 151 |     |         bytes calldata convertData
 152 |     |     ) public view returns (PipelineConvertData memory pipeData) {
 153 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 154 |     |         LibConvertData.ConvertKind kind = convertData.convertKind();
 155 |     |         address toToken;
 156 |     |         address fromToken;
 157 |     |         if (
 158 |     |             kind == LibConvertData.ConvertKind.BEANS_TO_WELL_LP ||
 159 |     |             kind == LibConvertData.ConvertKind.WELL_LP_TO_BEANS
 160 |     |         ) {
 161 |     |             if (kind == LibConvertData.ConvertKind.BEANS_TO_WELL_LP) {
 162 |     |                 (, , toToken) = convertData.convertWithAddress();
 163 |     |                 fromToken = s.sys.bean;
 164 |     |                 require(LibWell.isWell(toToken), "Convert: Invalid Well");
 165 |     |             } else {
 166 |     |                 (, , fromToken) = convertData.convertWithAddress();
 167 |     |                 toToken = s.sys.bean;
 168 |     |                 require(LibWell.isWell(fromToken), "Convert: Invalid Well");
 169 |     |             }
 170 |     | 
 171 |     |             pipeData = populatePipelineConvertData(fromToken, toToken);
 172 |     |         }
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @notice reverts if the convert would be penalized.
 177 |     |      * @dev used in {ConvertFacet.convert}
 178 |     |      */
 179 |     |     function checkForValidConvertAndUpdateConvertCapacity(
 180 |     |         PipelineConvertData memory pipeData,
 181 |     |         bytes calldata convertData,
 182 |     |         address fromToken,
 183 |     |         address toToken,
 184 |     |         uint256 fromBdv
 185 |     |     ) public {
 186 |     |         LibConvertData.ConvertKind kind = convertData.convertKind();
 187 |     |         if (
 188 |     |             kind == LibConvertData.ConvertKind.BEANS_TO_WELL_LP ||
 189 |     |             kind == LibConvertData.ConvertKind.WELL_LP_TO_BEANS
 190 |     |         ) {
 191 |     |             pipeData.overallConvertCapacity = LibConvert.abs(LibDeltaB.overallCappedDeltaB());
 192 |     | 
 193 |     |             pipeData.stalkPenaltyBdv = prepareStalkPenaltyCalculation(
 194 |     |                 fromToken,
 195 |     |                 toToken,
 196 |     |                 pipeData.deltaB,
 197 |     |                 pipeData.overallConvertCapacity,
 198 |     |                 fromBdv,
 199 |     |                 pipeData.initialLpSupply
 200 |     |             );
 201 |     | 
 202 |     |             require(pipeData.stalkPenaltyBdv == 0, "Convert: Non-zero Stalk Penalty");
 203 |     |         }
 204 |     |     }
 205 |     | }
 206 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Convert/LibWellConvert.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   8 |     | import {LibConvertData} from "contracts/libraries/Convert/LibConvertData.sol";
   9 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  10 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  11 |     | import {Call, IWell} from "contracts/interfaces/basin/IWell.sol";
  12 |     | import {IBeanstalkWellFunction} from "contracts/interfaces/basin/IBeanstalkWellFunction.sol";
  13 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
  14 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title Well Convert Library
  18 |     |  * @notice Contains Functions to convert from/to Well LP tokens to/from Beans
  19 |     |  * in the direction of the Peg.
  20 |     |  **/
  21 | *   | library LibWellConvert {
  22 |     |     using LibRedundantMath256 for uint256;
  23 |     |     using LibConvertData for bytes;
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Calculates the maximum amount of Beans that can be
  27 |     |      * convert to the LP Token of a given `well` while maintaining a delta B >= 0.
  28 |     |      */
  29 |     |     function beansToPeg(address well) internal view returns (uint256 beans) {
  30 |     |         (beans, ) = _beansToPeg(well);
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * An internal version of `beansToPeg` that always returns the
  35 |     |      * index of the Bean token in a given `well`.
  36 |     |      */
  37 |     |     function _beansToPeg(address well) internal view returns (uint256 beans, uint256 beanIndex) {
  38 |     |         IERC20[] memory tokens = IWell(well).tokens();
  39 |     |         uint256[] memory reserves = IWell(well).getReserves();
  40 |     |         Call memory wellFunction = IWell(well).wellFunction();
  41 |     |         uint256[] memory ratios;
  42 |     |         bool success;
  43 |     |         (ratios, beanIndex, success) = LibWell.getRatiosAndBeanIndex(tokens);
  44 |     |         // If the USD Oracle oracle call fails, the convert should not be allowed.
  45 |     |         require(success, "Convert: USD Oracle failed");
  46 |     | 
  47 |     |         uint256 beansAtPeg = IBeanstalkWellFunction(wellFunction.target)
  48 |     |             .calcReserveAtRatioLiquidity(reserves, beanIndex, ratios, wellFunction.data);
  49 |     | 
  50 |     |         if (beansAtPeg <= reserves[beanIndex]) return (0, beanIndex);
  51 |     |         beans = beansAtPeg - reserves[beanIndex];
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev Calculates the maximum amount of LP Tokens of a given `well` that can be
  56 |     |      * converted to Beans while maintaining a delta B <= 0.
  57 |     |      */
  58 |     |     function lpToPeg(address well) internal view returns (uint256 lp) {
  59 |     |         IERC20[] memory tokens = IWell(well).tokens();
  60 |     |         uint256[] memory reserves = IWell(well).getReserves();
  61 |     |         Call memory wellFunction = IWell(well).wellFunction();
  62 |     |         (uint256[] memory ratios, uint256 beanIndex, bool success) = LibWell.getRatiosAndBeanIndex(
  63 |     |             tokens
  64 |     |         );
  65 |     |         // If the USD Oracle oracle call fails, the convert should not be allowed.
  66 |     |         require(success, "Convert: USD Oracle failed");
  67 |     | 
  68 |     |         uint256 beansAtPeg = IBeanstalkWellFunction(wellFunction.target)
  69 |     |             .calcReserveAtRatioLiquidity(reserves, beanIndex, ratios, wellFunction.data);
  70 |     | 
  71 |     |         if (reserves[beanIndex] <= beansAtPeg) return 0;
  72 |     | 
  73 |     |         uint256 lpSupplyNow = IBeanstalkWellFunction(wellFunction.target).calcLpTokenSupply(
  74 |     |             reserves,
  75 |     |             wellFunction.data
  76 |     |         );
  77 |     | 
  78 |     |         reserves[beanIndex] = beansAtPeg;
  79 |     |         return
  80 |     |             lpSupplyNow.sub(
  81 |     |                 IBeanstalkWellFunction(wellFunction.target).calcLpTokenSupply(
  82 |     |                     reserves,
  83 |     |                     wellFunction.data
  84 |     |                 )
  85 |     |             );
  86 |     |     }
  87 |     | 
  88 |     |     /**
  89 |     |      * @dev Calculates the amount of Beans recieved from converting
  90 |     |      * `amountIn` LP Tokens of a given `well`.
  91 |     |      */
  92 |     |     function getBeanAmountOut(
  93 |     |         address well,
  94 |     |         uint256 amountIn
  95 |     |     ) internal view returns (uint256 beans) {
  96 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  97 |     |         beans = IWell(well).getRemoveLiquidityOneTokenOut(amountIn, IERC20(s.sys.bean));
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Calculates the amount of LP Tokens of a given `well` recieved from converting
 102 |     |      * `amountIn` Beans.
 103 |     |      */
 104 |     |     function getLPAmountOut(address well, uint256 amountIn) internal view returns (uint256 lp) {
 105 |     |         IERC20[] memory tokens = IWell(well).tokens();
 106 |     |         uint256[] memory amounts = new uint256[](tokens.length);
 107 |     |         amounts[LibWell.getBeanIndex(tokens)] = amountIn;
 108 |     |         lp = IWell(well).getAddLiquidityOut(amounts);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Converts `lp` LP Tokens of a given `well` into at least `minBeans` Beans
 113 |     |      * while ensuring that delta B <= 0 in the Well.
 114 |     |      * @param convertData Contains the encoding of `lp`, `minBeans` and `well`.
 115 |     |      * @return tokenOut The token to convert to.
 116 |     |      * @return tokenIn The token to convert from
 117 |     |      * @return amountOut The number of `tokenOut` convert to
 118 |     |      * @return amountIn The number of `tokenIn` converted from
 119 |     |      */
 120 |     |     function convertLPToBeans(
 121 |     |         bytes memory convertData
 122 |     |     ) internal returns (address tokenOut, address tokenIn, uint256 amountOut, uint256 amountIn) {
 123 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 124 |     |         (uint256 lp, uint256 minBeans, address well) = convertData.convertWithAddress();
 125 |     | 
 126 |     |         require(LibWell.isWell(well), "Convert: Invalid Well");
 127 |     | 
 128 |     |         tokenOut = s.sys.bean;
 129 |     |         tokenIn = well;
 130 |     | 
 131 |     |         (amountOut, amountIn) = _wellRemoveLiquidityTowardsPeg(lp, minBeans, well);
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @dev Removes Liquidity as Beans with the constraint that delta B <= 0.
 136 |     |      */
 137 |     |     function _wellRemoveLiquidityTowardsPeg(
 138 |     |         uint256 lp,
 139 |     |         uint256 minBeans,
 140 |     |         address well
 141 |     |     ) internal returns (uint256 beans, uint256 lpConverted) {
 142 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 143 |     |         uint256 maxLp = lpToPeg(well);
 144 |     |         require(maxLp > 0, "Convert: P must be < 1.");
 145 |     |         lpConverted = lp > maxLp ? maxLp : lp;
 146 |     |         beans = IWell(well).removeLiquidityOneToken(
 147 |     |             lpConverted,
 148 |     |             BeanstalkERC20(s.sys.bean),
 149 |     |             minBeans,
 150 |     |             address(this),
 151 |     |             block.timestamp
 152 |     |         );
 153 |     |     }
 154 |     | 
 155 |     |     /**
 156 |     |      * @notice Converts `beans` Beans into at least `minLP` LP Tokens of a given `well`
 157 |     |      * while ensuring that delta B >= 0 in the Well.
 158 |     |      * @param convertData Contains the encoding of `beans`, `minLp` and `well`.
 159 |     |      * @return tokenOut The token to convert to.
 160 |     |      * @return tokenIn The token to convert from
 161 |     |      * @return amountOut The number of `tokenOut` convert to
 162 |     |      * @return amountIn The number of `tokenIn` converted from
 163 |     |      */
 164 |     |     function convertBeansToLP(
 165 |     |         bytes memory convertData
 166 |     |     ) internal returns (address tokenOut, address tokenIn, uint256 amountOut, uint256 amountIn) {
 167 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 168 |     |         (uint256 beans, uint256 minLP, address well) = convertData.convertWithAddress();
 169 |     | 
 170 |     |         require(LibWell.isWell(well), "Convert: Invalid Well");
 171 |     | 
 172 |     |         tokenOut = well;
 173 |     |         tokenIn = s.sys.bean;
 174 |     | 
 175 |     |         (amountOut, amountIn) = _wellAddLiquidityTowardsPeg(beans, minLP, well);
 176 |     |     }
 177 |     | 
 178 |     |     /**
 179 |     |      * @dev Adds as Beans Liquidity with the constraint that delta B >= 0.
 180 |     |      */
 181 |     |     function _wellAddLiquidityTowardsPeg(
 182 |     |         uint256 beans,
 183 |     |         uint256 minLP,
 184 |     |         address well
 185 |     |     ) internal returns (uint256 lp, uint256 beansConverted) {
 186 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 187 |     |         (uint256 maxBeans, ) = _beansToPeg(well);
 188 |     |         require(maxBeans > 0, "Convert: P must be >= 1.");
 189 |     |         beansConverted = beans > maxBeans ? maxBeans : beans;
 190 |     |         BeanstalkERC20(s.sys.bean).transfer(well, beansConverted);
 191 |     |         lp = IWell(well).sync(address(this), minLP);
 192 |     |     }
 193 |     | }
 194 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Decimal.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title Decimal
  11 |     |  *
  12 |     |  * Library that defines a fixed-point number with 18 decimal places.
  13 |     |  */
  14 | *   | library Decimal {
  15 |     |     using LibRedundantMath256 for uint256;
  16 |     | 
  17 |     |     // ============ Constants ============
  18 |     | 
  19 |     |     uint256 constant BASE = 10 ** 18;
  20 |     | 
  21 |     |     // ============ Structs ============
  22 |     | 
  23 |     |     struct D256 {
  24 |     |         uint256 value;
  25 |     |     }
  26 |     | 
  27 |     |     // ============ Static Functions ============
  28 |     | 
  29 |     |     function zero() internal pure returns (D256 memory) {
  30 |     |         return D256({value: 0});
  31 |     |     }
  32 |     | 
  33 |     |     function one() internal pure returns (D256 memory) {
  34 |     |         return D256({value: BASE});
  35 |     |     }
  36 |     | 
  37 |     |     function from(uint256 a) internal pure returns (D256 memory) {
  38 |     |         return D256({value: a.mul(BASE)});
  39 |     |     }
  40 |     | 
  41 |     |     function ratio(uint256 a, uint256 b) internal pure returns (D256 memory) {
  42 |     |         return D256({value: getPartial(a, BASE, b)});
  43 |     |     }
  44 |     | 
  45 |     |     // ============ Self Functions ============
  46 |     | 
  47 |     |     function add(D256 memory self, uint256 b) internal pure returns (D256 memory) {
  48 |     |         return D256({value: self.value.add(b.mul(BASE))});
  49 |     |     }
  50 |     | 
  51 |     |     function sub(D256 memory self, uint256 b) internal pure returns (D256 memory) {
  52 |     |         return D256({value: self.value.sub(b.mul(BASE))});
  53 |     |     }
  54 |     | 
  55 |     |     function sub(
  56 |     |         D256 memory self,
  57 |     |         uint256 b,
  58 |     |         string memory reason
  59 |     |     ) internal pure returns (D256 memory) {
  60 |     |         if (b.mul(BASE) > self.value) {
  61 |     |             revert(reason);
  62 |     |         }
  63 |     |         return D256({value: self.value.sub(b.mul(BASE))});
  64 |     |     }
  65 |     | 
  66 |     |     function mul(D256 memory self, uint256 b) internal pure returns (D256 memory) {
  67 |     |         return D256({value: self.value.mul(b)});
  68 |     |     }
  69 |     | 
  70 |     |     function div(D256 memory self, uint256 b) internal pure returns (D256 memory) {
  71 |     |         return D256({value: self.value.div(b)});
  72 |     |     }
  73 |     | 
  74 |     |     function pow(D256 memory self, uint256 b) internal pure returns (D256 memory) {
  75 |     |         if (b == 0) {
  76 |     |             return one();
  77 |     |         }
  78 |     | 
  79 |     |         D256 memory temp = D256({value: self.value});
  80 |     |         for (uint256 i = 1; i < b; ++i) {
  81 |     |             temp = mul(temp, self);
  82 |     |         }
  83 |     | 
  84 |     |         return temp;
  85 |     |     }
  86 |     | 
  87 |     |     function add(D256 memory self, D256 memory b) internal pure returns (D256 memory) {
  88 |     |         return D256({value: self.value.add(b.value)});
  89 |     |     }
  90 |     | 
  91 |     |     function sub(D256 memory self, D256 memory b) internal pure returns (D256 memory) {
  92 |     |         return D256({value: self.value.sub(b.value)});
  93 |     |     }
  94 |     | 
  95 |     |     function sub(
  96 |     |         D256 memory self,
  97 |     |         D256 memory b,
  98 |     |         string memory reason
  99 |     |     ) internal pure returns (D256 memory) {
 100 |     |         if (greaterThan(b, self)) {
 101 |     |             revert(reason);
 102 |     |         }
 103 |     |         return D256({value: self.value.sub(b.value)});
 104 |     |     }
 105 |     | 
 106 |     |     function mul(D256 memory self, D256 memory b) internal pure returns (D256 memory) {
 107 |     |         return D256({value: getPartial(self.value, b.value, BASE)});
 108 |     |     }
 109 |     | 
 110 |     |     function div(D256 memory self, D256 memory b) internal pure returns (D256 memory) {
 111 |     |         return D256({value: getPartial(self.value, BASE, b.value)});
 112 |     |     }
 113 |     | 
 114 |     |     function equals(D256 memory self, D256 memory b) internal pure returns (bool) {
 115 |     |         return self.value == b.value;
 116 |     |     }
 117 |     | 
 118 |     |     function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {
 119 |     |         return compareTo(self, b) == 2;
 120 |     |     }
 121 |     | 
 122 |     |     function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {
 123 |     |         return compareTo(self, b) == 0;
 124 |     |     }
 125 |     | 
 126 |     |     function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
 127 |     |         return compareTo(self, b) > 0;
 128 |     |     }
 129 |     | 
 130 |     |     function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {
 131 |     |         return compareTo(self, b) < 2;
 132 |     |     }
 133 |     | 
 134 |     |     function isZero(D256 memory self) internal pure returns (bool) {
 135 |     |         return self.value == 0;
 136 |     |     }
 137 |     | 
 138 |     |     function asUint256(D256 memory self) internal pure returns (uint256) {
 139 |     |         return self.value.div(BASE);
 140 |     |     }
 141 |     | 
 142 |     |     // ============ Core Methods ============
 143 |     | 
 144 |     |     function getPartial(
 145 |     |         uint256 target,
 146 |     |         uint256 numerator,
 147 |     |         uint256 denominator
 148 |     |     ) private pure returns (uint256) {
 149 |     |         return target.mul(numerator).div(denominator);
 150 |     |     }
 151 |     | 
 152 |     |     function compareTo(D256 memory a, D256 memory b) private pure returns (uint256) {
 153 |     |         if (a.value == b.value) {
 154 |     |             return 1;
 155 |     |         }
 156 |     |         return a.value > b.value ? 2 : 0;
 157 |     |     }
 158 |     | }
 159 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibAppStorage.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | // Import all of AppStorage to give importers of LibAppStorage access to {Account}, etc.
  6 |     | import {AppStorage} from "../beanstalk/storage/AppStorage.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title LibAppStorage
 10 |     |  * @notice Allows libaries to access Beanstalk's state.
 11 |     |  */
 12 | *   | library LibAppStorage {
 13 | *   |     function diamondStorage() internal pure returns (AppStorage storage ds) {
 14 |     |         assembly {
 15 |     |             ds.slot := 0
 16 |     |         }
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibBytes.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {LibTractor} from "./LibTractor.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title LibBytes
  12 |     |  * @notice LibBytes offers utility functions for managing data at the Byte level.
  13 |     |  */
  14 | *   | library LibBytes {
  15 |     |     /*
  16 |     |      * @notice From Solidity Bytes Arrays Utils
  17 |     |      */
  18 |     |     function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
  19 |     |         require(_start + 1 >= _start, "toUint8_overflow");
  20 |     |         require(_bytes.length >= _start + 1, "toUint8_outOfBounds");
  21 |     |         uint8 tempUint;
  22 |     | 
  23 |     |         assembly {
  24 |     |             tempUint := mload(add(add(_bytes, 0x1), _start))
  25 |     |         }
  26 |     | 
  27 |     |         return tempUint;
  28 |     |     }
  29 |     | 
  30 |     |     /*
  31 |     |      * @notice From Solidity Bytes Arrays Utils
  32 |     |      */
  33 |     |     function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
  34 |     |         require(_start + 4 >= _start, "toUint32_overflow");
  35 |     |         require(_bytes.length >= _start + 4, "toUint32_outOfBounds");
  36 |     |         uint32 tempUint;
  37 |     | 
  38 |     |         assembly {
  39 |     |             tempUint := mload(add(add(_bytes, 0x4), _start))
  40 |     |         }
  41 |     | 
  42 |     |         return tempUint;
  43 |     |     }
  44 |     | 
  45 |     |     function toUint80(bytes memory _bytes, uint256 _start) internal pure returns (uint80) {
  46 |     |         require(_start + 10 >= _start, "toUint32_overflow");
  47 |     |         require(_bytes.length >= _start + 10, "toUint32_outOfBounds");
  48 |     |         uint80 tempUint;
  49 |     | 
  50 |     |         assembly {
  51 |     |             tempUint := mload(add(add(_bytes, 0xA), _start))
  52 |     |         }
  53 |     | 
  54 |     |         return tempUint;
  55 |     |     }
  56 |     | 
  57 |     |     /*
  58 |     |      * @notice From Solidity Bytes Arrays Utils
  59 |     |      */
  60 |     |     function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
  61 |     |         require(_start + 32 >= _start, "toUint256_overflow");
  62 |     |         require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
  63 |     |         uint256 tempUint;
  64 |     | 
  65 |     |         assembly {
  66 |     |             tempUint := mload(add(add(_bytes, 0x20), _start))
  67 |     |         }
  68 |     | 
  69 |     |         return tempUint;
  70 |     |     }
  71 |     | 
  72 |     |     function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
  73 |     |         require(_start + 32 >= _start, "toBytes32_overflow");
  74 |     |         require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");
  75 |     |         bytes32 tempBytes32;
  76 |     | 
  77 |     |         assembly {
  78 |     |             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
  79 |     |         }
  80 |     | 
  81 |     |         return tempBytes32;
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice slices bytes memory
  86 |     |      * @param b The memory bytes array to load from
  87 |     |      * @param start The start of the slice
  88 |     |      * @return sliced bytes
  89 |     |      */
  90 |     |     function sliceFrom(bytes memory b, uint256 start) internal pure returns (bytes memory) {
  91 |     |         uint256 length = b.length - start;
  92 |     |         bytes memory memBytes = new bytes(length);
  93 |     |         for (uint256 i = 0; i < length; ++i) {
  94 |     |             memBytes[i] = b[start + i];
  95 |     |         }
  96 |     |         return memBytes;
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @notice Loads a slice of a calldata bytes array into memory
 101 |     |      * @param b The calldata bytes array to load from
 102 |     |      * @param start The start of the slice
 103 |     |      * @param length The length of the slice
 104 |     |      */
 105 |     |     function sliceToMemory(
 106 |     |         bytes calldata b,
 107 |     |         uint256 start,
 108 |     |         uint256 length
 109 |     |     ) internal pure returns (bytes memory) {
 110 |     |         bytes memory memBytes = new bytes(length);
 111 |     |         for (uint256 i = 0; i < length; ++i) {
 112 |     |             memBytes[i] = b[start + i];
 113 |     |         }
 114 |     |         return memBytes;
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @notice Copy 32 Bytes from copyFromData at copyIndex and paste into pasteToData at pasteIndex
 119 |     |      * @param copyFromData The data bytes to copy from
 120 |     |      * @param pasteToData The data bytes to paste into
 121 |     |      * @param copyIndex The index in copyFromData to copying from
 122 |     |      * @param pasteIndex The index in pasteToData to paste into
 123 |     |      **/
 124 |     |     function paste32Bytes(
 125 |     |         bytes memory copyFromData,
 126 |     |         bytes memory pasteToData,
 127 |     |         uint256 copyIndex,
 128 |     |         uint256 pasteIndex
 129 |     |     ) internal pure {
 130 |     |         assembly {
 131 |     |             mstore(add(pasteToData, pasteIndex), mload(add(copyFromData, copyIndex)))
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     ///////// DEPOSIT ID /////////
 136 |     | 
 137 | *   |     function packAddressAndStem(address _address, int96 stem) internal pure returns (uint256) {
 138 | *   |         return (uint256(uint160(_address)) << 96) | uint96(stem);
 139 |     |     }
 140 |     | 
 141 | *   |     function unpackAddressAndStem(uint256 data) internal pure returns (address, int96) {
 142 | *   |         return (address(uint160(data >> 96)), int96(int256(data)));
 143 |     |     }
 144 |     | 
 145 |     |     /////// CLIPBOARD ///////
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Paste bytes using clipboard parameters.
 149 |     |      * @dev Reverts if `getCopyReturnIndex` returns an
 150 |     |      * invalid index (i.e < `copyFromDataSet.length`)
 151 |     |      */
 152 |     |     function pasteBytesClipboard(
 153 |     |         bytes32 returnPasteParam, // Copy/paste instructions.
 154 |     |         bytes[] memory copyFromDataSet, // data to copy from.
 155 |     |         bytes memory pasteToData // Paste destination.
 156 |     |     ) internal pure {
 157 |     |         (uint256 copyReturnIndex, uint256 copyByteIndex, uint256 pasteByteIndex) = decode(
 158 |     |             returnPasteParam
 159 |     |         );
 160 |     |         bytes memory copyFromData = copyFromDataSet[copyReturnIndex];
 161 |     | 
 162 |     |         // Verify that the copyFromData and pasteToData are valid.
 163 |     |         verifyCopyByteIndex(copyByteIndex, copyFromData);
 164 |     |         verifyPasteByteIndex(pasteByteIndex, pasteToData);
 165 |     | 
 166 |     |         // Copy 32 bytes from copyFromData at copyByteIndex and
 167 |     |         // paste into pasteToData at pasteByteIndex.
 168 |     |         paste32Bytes(copyFromData, pasteToData, copyByteIndex, pasteByteIndex);
 169 |     |     }
 170 |     | 
 171 |     |     /////// TRACTOR ///////
 172 |     | 
 173 |     |     /**
 174 |     |      * @notice Paste bytes using tractor parameters.
 175 |     |      *
 176 |     |      *  OperatorPasteInstrs: Copy bytes32 from operator data into calldata
 177 |     |      *       [ Padding     | copyByteIndex | pasteCallIndex | pasteByteIndex ]
 178 |     |      *       [ 2 bytes     | 10 bytes      | 10 bytes       | 10 bytes       ]
 179 |     |      */
 180 |     |     function pasteBytesTractor(
 181 |     |         bytes32 operatorPasteInstr,
 182 |     |         bytes memory copyFromData,
 183 |     |         bytes memory pasteToData
 184 |     |     ) internal view {
 185 |     |         // Decode operatorPasteInstr.
 186 |     |         (uint80 copyByteIndex, , uint80 pasteByteIndex) = decode(operatorPasteInstr);
 187 |     | 
 188 |     |         // if copyByteIndex matches the publisher or operator index,
 189 |     |         // replace data with the publisher/operator address.
 190 |     |         if (copyByteIndex == C.PUBLISHER_COPY_INDEX) {
 191 |     |             copyFromData = abi.encodePacked(
 192 |     |                 uint256(uint160(address(LibTractor._tractorStorage().activePublisher)))
 193 |     |             );
 194 |     |             copyByteIndex = C.SLOT_SIZE;
 195 |     |         } else if (copyByteIndex == C.OPERATOR_COPY_INDEX) {
 196 |     |             copyFromData = abi.encodePacked(uint256(uint160(msg.sender)));
 197 |     |             copyByteIndex = C.SLOT_SIZE;
 198 |     |         }
 199 |     | 
 200 |     |         // Verify that the copyFromData and pasteToData are valid.
 201 |     |         verifyCopyByteIndex(copyByteIndex, copyFromData);
 202 |     |         verifyPasteByteIndex(pasteByteIndex, pasteToData);
 203 |     | 
 204 |     |         // Copy 32 bytes from copyFromData at copyByteIndex and
 205 |     |         // paste into pasteToData at pasteByteIndex.
 206 |     |         paste32Bytes(copyFromData, pasteToData, copyByteIndex, pasteByteIndex);
 207 |     |     }
 208 |     | 
 209 |     |     /////// BYTES32 ENCODED INDICES ///////
 210 |     | 
 211 |     |     /**
 212 |     |      * @notice Verifies that the byte index of the copy data is within bounds.
 213 |     |      */
 214 |     |     function verifyCopyByteIndex(uint256 copyByteIndex, bytes memory copyFromData) internal pure {
 215 |     |         require(C.SLOT_SIZE <= copyByteIndex, "LibBytes: copyByteIndex too small");
 216 |     |         require(copyByteIndex <= copyFromData.length, "LibBytes: copyByteIndex too large");
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @notice Verifies that the paste index of the copy data is within bounds.
 221 |     |      */
 222 |     |     function verifyPasteByteIndex(uint256 pasteByteIndex, bytes memory pasteToData) internal pure {
 223 |     |         require(C.SLOT_SIZE <= pasteByteIndex, "LibBytes: pasteByteIndex too small");
 224 |     |         require(pasteByteIndex <= pasteToData.length, "LibBytes: pasteByteIndex too large");
 225 |     |     }
 226 |     | 
 227 |     |     /**
 228 |     |      * @notice Encodes an tractor blueprint operator paste or
 229 |     |      * a clipboard paste param instruction.
 230 |     |      * @dev If returnPasteParam, values are (copyReturnIndex, copyByteIndex, pasteByteIndex).
 231 |     |      * @dev If operatorPasteInstr, values are (copyByteIndex, pasteCallIndex, pasteByteIndex).
 232 |     |      */
 233 |     |     function encode(
 234 |     |         uint80 _index0,
 235 |     |         uint80 _index1,
 236 |     |         uint80 _index2
 237 |     |     ) internal pure returns (bytes32) {
 238 |     |         return toBytes32(abi.encodePacked(bytes2(0), _index0, _index1, _index2), 0);
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @notice Decodes a copyPasteInstruction into the
 243 |     |      * copy return index, copy byte index, and paste byte index.
 244 |     |      * @dev If returnPasteParam, the return is (copyReturnIndex, copyByteIndex, pasteByteIndex).
 245 |     |      * @dev If operatorPasteInstr, the return is (copyByteIndex, pasteCallIndex, pasteByteIndex).
 246 |     |      */
 247 |     |     function decode(bytes32 indices) internal pure returns (uint80, uint80, uint80) {
 248 |     |         return (getIndex0(indices), getIndex1(indices), getIndex2(indices));
 249 |     |     }
 250 |     | 
 251 |     |     /**
 252 |     |      * @notice Returns the index at position 0 in a bytes32 encoded set of indices. Either the copy return index or the paste call index.
 253 |     |      * @dev Used in `pasteBytesClipboard` to choose which return parameter to copy from.
 254 |     |      * @dev returnPasteParam.copyReturnIndex OR operatorPasteInstr.copyByteIndex.
 255 |     |      */
 256 |     |     function getIndex0(bytes32 indices) internal pure returns (uint80) {
 257 |     |         return uint80(bytes10(indices << 16));
 258 |     |     }
 259 |     | 
 260 |     |     /**
 261 |     |      * @notice Returns the index at position 1 in a bytes32 encoded set of indices. The copy byte index.
 262 |     |      * @dev Used to determine what byte index to start copying 32 bytes from.
 263 |     |      * @dev returnPasteParam.copyByteIndex OR operatorPasteInstr.pasteCallIndex.
 264 |     |      */
 265 |     |     function getIndex1(bytes32 indices) internal pure returns (uint80) {
 266 |     |         return uint80(bytes10(indices << 96));
 267 |     |     }
 268 |     | 
 269 |     |     /**
 270 |     |      * @notice Returns the index at position 2 in a bytes32 encoded set of indices. The paste byte index.
 271 |     |      * @dev Used to determine what byte index to paste in data at.
 272 |     |      * @dev returnPasteParam.pasteByteIndex OR operatorPasteInstr.pasteByteIndex.
 273 |     |      */
 274 |     |     function getIndex2(bytes32 indices) internal pure returns (uint80) {
 275 |     |         return uint80(bytes10(indices << 176));
 276 |     |     }
 277 |     | }
 278 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibBytes64.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Provides a set of functions to operate with Base64 strings.
  7 |     |  * @title Base64 is a 0.7.6 variation of Open Zeppelin's Base64.
  8 |     |  *
  9 |     |  */
 10 | *   | library LibBytes64 {
 11 |     |     /**
 12 |     |      * @dev Base64 Encoding/Decoding Table
 13 |     |      */
 14 |     |     string internal constant _TABLE =
 15 |     |         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Converts a `bytes` to its Bytes64 `string` representation.
 19 |     |      */
 20 |     |     function encode(bytes memory data) internal pure returns (string memory) {
 21 |     |         /**
 22 |     |          * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence
 23 |     |          * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol
 24 |     |          */
 25 |     |         if (data.length == 0) return "";
 26 |     | 
 27 |     |         // Loads the table into memory
 28 |     |         string memory table = _TABLE;
 29 |     | 
 30 |     |         // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter
 31 |     |         // and split into 4 numbers of 6 bits.
 32 |     |         // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up
 33 |     |         // - `data.length + 2`  -> Round up
 34 |     |         // - `/ 3`              -> Number of 3-bytes chunks
 35 |     |         // - `4 *`              -> 4 characters for each chunk
 36 |     |         string memory result = new string(4 * ((data.length + 2) / 3));
 37 |     | 
 38 |     |         assembly {
 39 |     |             // Prepare the lookup table (skip the first "length" byte)
 40 |     |             let tablePtr := add(table, 1)
 41 |     | 
 42 |     |             // Prepare result pointer, jump over length
 43 |     |             let resultPtr := add(result, 32)
 44 |     | 
 45 |     |             // Run over the input, 3 bytes at a time
 46 |     |             for {
 47 |     |                 let dataPtr := data
 48 |     |                 let endPtr := add(data, mload(data))
 49 |     |             } lt(dataPtr, endPtr) {} {
 50 |     |                 // Advance 3 bytes
 51 |     |                 dataPtr := add(dataPtr, 3)
 52 |     |                 let input := mload(dataPtr)
 53 |     | 
 54 |     |                 // To write each character, shift the 3 bytes (18 bits) chunk
 55 |     |                 // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
 56 |     |                 // and apply logical AND with 0x3F which is the number of
 57 |     |                 // the previous character in the ASCII table prior to the Base64 Table
 58 |     |                 // The result is then added to the table to get the character to write,
 59 |     |                 // and finally write it in the result pointer but with a left shift
 60 |     |                 // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits
 61 |     | 
 62 |     |                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
 63 |     |                 resultPtr := add(resultPtr, 1) // Advance
 64 |     | 
 65 |     |                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
 66 |     |                 resultPtr := add(resultPtr, 1) // Advance
 67 |     | 
 68 |     |                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
 69 |     |                 resultPtr := add(resultPtr, 1) // Advance
 70 |     | 
 71 |     |                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
 72 |     |                 resultPtr := add(resultPtr, 1) // Advance
 73 |     |             }
 74 |     | 
 75 |     |             // When data `bytes` is not exactly 3 bytes long
 76 |     |             // it is padded with `=` characters at the end
 77 |     |             switch mod(mload(data), 3)
 78 |     |             case 1 {
 79 |     |                 mstore8(sub(resultPtr, 1), 0x3d)
 80 |     |                 mstore8(sub(resultPtr, 2), 0x3d)
 81 |     |             }
 82 |     |             case 2 {
 83 |     |                 mstore8(sub(resultPtr, 1), 0x3d)
 84 |     |             }
 85 |     |         }
 86 |     | 
 87 |     |         return result;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibCases.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | import {LibAppStorage, AppStorage} from "./LibAppStorage.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * @title LibCases handles the cases for beanstalk.
   8 |     |  *
   9 |     |  * @dev Cases are used to determine the change in
  10 |     |  * temperature and Bean to maxLP gaugePoint per BDV ratio.
  11 |     |  *
  12 |     |  *  Data format:
  13 |     |  *
  14 |     |  * mT: 4 Bytes (1% = 1e6)
  15 |     |  * bT: 4 Bytes (1% = 1e6)
  16 |     |  * mL: 10 Bytes (1% = 1e18)
  17 |     |  * bL: 10 Bytes (1% = 1e18)
  18 |     |  * 4 bytes are left for future use.
  19 |     |  *
  20 |     |  * mT: Relative Temperature change.
  21 |     |  * bT: Absolute Temperature change.
  22 |     |  * mL: Relative Grown Stalk to Liquidity change.
  23 |     |  * bL: Absolute Grown Stalk to Liquidity change.
  24 |     |  *
  25 |     |  * Temperature and Bean and maxLP gaugePoint per BDV ratio is updated as such:
  26 |     |  * T_n = mT * T_n-1 + bT
  27 |     |  * L_n = mL * L_n-1 + bL
  28 |     |  *
  29 |     |  * In total, there are 144 cases (4 * 3 * 3 * 4)
  30 |     |  *
  31 |     |  * Temperature is stored in AppStorage with 6 decimal precision (1% = 1e6),
  32 |     |  * which is why bT has 6 decimal precision.
  33 |     |  * The following bytes correspond to the current absolute temperature changes:
  34 |     |  *
  35 |     |  * +0.5%: 0007A120 = 0.5e6
  36 |     |  * +1%:   000F4240 = 1e6
  37 |     |  * +2%:   001E8480 = 2e6
  38 |     |  * +3%:   002DC6C0 = 3e6
  39 |     |  * -0.5%: FFF85EE0 = -0.5e6
  40 |     |  * -1%:   FFF0BDC0 = -1e6
  41 |     |  * -2%:   FFE17B80 = -2e6
  42 |     |  * -3%:   FFD23940 = -3e6
  43 |     |  * 
  44 |     |  * The following bytes correspond to the absolute Bean to maxLP gaugePoint per BDV ratio changes:
  45 |     |  * -50: FFFD4A1C50E94E780000 = -50e18
  46 |     |  * +1:  FFFA9438A1D29CF00000 = 1e18
  47 |     |  * +2:  FFF7DE54F2BBF1680000 = 2e18
  48 |     |  *
  49 |     |  * The following bytes correspond to the relative Bean to maxLP gaugePoint per BDV ratio changes:
  50 |     |  * 100%: 00056BC75E2D63100000 = 100e18
  51 |     |  * The following bytes correspond to the relative temperature changes:
  52 |     |  * 100%: 05F5E100 = 100e6
  53 |     |  */
  54 |     | 
  55 | *   | library LibCases {
  56 |     |     struct CaseData {
  57 |     |         uint32 mT;
  58 |     |         int32 bT;
  59 |     |         uint80 mL;
  60 |     |         int80 bL;
  61 |     |     }
  62 |     | 
  63 |     |     // constants are used for reability purposes,
  64 |     |     // given that multiple cases use the same values.
  65 |     |     //
  66 |     |     // Naming Convention:
  67 |     |     // PLUS: increment by X (y_i = y_1 + X)
  68 |     |     // MINUS decrement by X (y_i = y_1 - X)
  69 |     |     // INCR: scale up by X (y_i = y_1 * X)
  70 |     |     // DECR: scale down by X (y_i = y_1 * (1-X))
  71 |     |     // T: Temperature, L: Bean to max LP gauge point per BDV ratio
  72 |     |     // Example: T_PLUS_2_L_MINUS_FIFTY-> Temperature is incremented 2%,
  73 |     |     // BeantoMaxLPGaugePointPerBdvRatio is decrement by 50%.
  74 |     | 
  75 |     |     //////////////////////////////////////////////////////////     [  mT  ][  bT  ][       mL         ][       BL         ][ null ]
  76 | *   |     bytes32 internal constant T_PLUS_2_L_MINUS_FIFTY =   bytes32(0x05F5E100001E848000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature increased by 2%,   Bean2maxLpGpPerBdv decreased by 50.
  77 | *   |     bytes32 internal constant T_PLUS_1_L_MINUS_FIFTY =   bytes32(0x05F5E100000F424000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature increased by 1%,   Bean2maxLpGpPerBdv decreased by 50.
  78 | *   |     bytes32 internal constant T_PLUS_05_L_MINUS_FIFTY =  bytes32(0x05F5E1000007A12000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature increased by 0.5%, Bean2maxLpGpPerBdv decreased by 50.
  79 | *   |     bytes32 internal constant T_PLUS_0_L_MINUS_FIFTY =   bytes32(0x05F5E1000000000000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature increased by 0%,   Bean2maxLpGpPerBdv decreased by 50.
  80 | *   |     bytes32 internal constant T_MINUS_05_L_MINUS_FIFTY = bytes32(0x05F5E100FFF85EE000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature decreased by 0.5%, Bean2maxLpGpPerBdv decreased by 50.
  81 | *   |     bytes32 internal constant T_MINUS_1_L_MINUS_FIFTY =  bytes32(0x05F5E100FFF0BDC000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature decreased by 1%,   Bean2maxLpGpPerBdv decreased by 50.
  82 | *   |     bytes32 internal constant T_MINUS_3_L_MINUS_FIFTY =  bytes32(0x05F5E100FFD2394000056BC75E2D63100000FFFD4A1C50E94E78000000000000); // temperature decreased by 3%,   Bean2maxLpGpPerBdv decreased by 50.
  83 |     |     //////////////////////////////////////////////////////////  [  mT  ][  bT  ][       mL         ][       BL         ][ null ]
  84 | *   |     bytes32 internal constant T_PLUS_2_L_PLUS_ONE =   bytes32(0x05F5E100001E848000056BC75E2D6310000000000DE0B6B3A764000000000000); // temperature increased by 2%, Bean2maxLpGpPerBdv increased by 1.
  85 | *   |     bytes32 internal constant T_PLUS_1_L_PLUS_ONE =   bytes32(0x05F5E100000F424000056BC75E2D6310000000000DE0B6B3A764000000000000); // temperature increased by 1%, Bean2maxLpGpPerBdv increased by 1.
  86 | *   |     bytes32 internal constant T_PLUS_05_L_PLUS_ONE =  bytes32(0x05F5E1000007A12000056BC75E2D6310000000000DE0B6B3A764000000000000); // temperature increased by 0.5%, Bean2maxLpGpPerBdv increased by 1.
  87 | *   |     bytes32 internal constant T_PLUS_0_L_PLUS_ONE =   bytes32(0x05F5E1000000000000056BC75E2D6310000000000DE0B6B3A764000000000000); // temperature increased by 0%, Bean2maxLpGpPerBdv increased by 1.
  88 | *   |     bytes32 internal constant T_MINUS_05_L_PLUS_ONE = bytes32(0x05F5E100FFF85EE000056BC75E2D6310000000000DE0B6B3A764000000000000); // temperature decreased by 0.5%, Bean2maxLpGpPerBdv increased by 1.
  89 |     |     //////////////////////////////////////////////////////////  [  mT  ][  bT  ][       mL         ][       BL         ][ null ]
  90 | *   |     bytes32 internal constant T_PLUS_1_L_PLUS_TWO =   bytes32(0x05F5E100000F424000056BC75E2D6310000000001BC16D674EC8000000000000); // temperature increased by 1%, Bean2maxLpGpPerBdv increased by 2.
  91 | *   |     bytes32 internal constant T_PLUS_05_L_PLUS_TWO =  bytes32(0x05F5E1000007A12000056BC75E2D6310000000001BC16D674EC8000000000000); // temperature increased by 0.5%, Bean2maxLpGpPerBdv increased by 2.
  92 | *   |     bytes32 internal constant T_MINUS_05_L_PLUS_TWO = bytes32(0x05F5E100FFF85EE000056BC75E2D6310000000001BC16D674EC8000000000000); // temperature decreased by 0.5%, Bean2maxLpGpPerBdv increased by 2.
  93 |     |     //////////////////////////////////////////////////////////  [  mT  ][  bT  ][       mL         ][       BL         ][ null ]
  94 | *   |     bytes32 internal constant T_PLUS_0_L_MINUS_ONE =  bytes32(0x05F5E1000000000000056BC75E2D63100000FFFFF21F494C589C000000000000); // temperature increased by 0%, Bean2maxLpGpPerBdv decreased by 1.
  95 | *   |     bytes32 internal constant T_MINUS_1_L_MINUS_ONE = bytes32(0x05F5E100FFF0BDC000056BC75E2D63100000FFFFF21F494C589C000000000000); // temperature decreased by 1%, Bean2maxLpGpPerBdv decreased by 1.
  96 | *   |     bytes32 internal constant T_MINUS_3_L_MINUS_ONE = bytes32(0x05F5E100FFD2394000056BC75E2D63100000FFFFF21F494C589C000000000000); // temperature decreased by 3%, Bean2maxLpGpPerBdv decreased by 1.
  97 |     |     //////////////////////////////////////////////////////////  [  mT  ][  bT  ][       mL         ][       BL         ][ null ]
  98 | *   |     bytes32 internal constant T_PLUS_0_L_MINUS_TWO =  bytes32(0x05F5E1000000000000056BC75E2D63100000FFFFE43E9298B138000000000000); // temperature increased by 0%,   Bean2maxLpGpPerBdv decreased by 2.
  99 | *   |     bytes32 internal constant T_MINUS_1_L_MINUS_TWO = bytes32(0x05F5E100FFF0BDC000056BC75E2D63100000FFFFE43E9298B138000000000000); // temperature decreased by 1%,   Bean2maxLpGpPerBdv decreased by 2.
 100 | *   |     bytes32 internal constant T_MINUS_3_L_MINUS_TWO = bytes32(0x05F5E100FFD2394000056BC75E2D63100000FFFFE43E9298B138000000000000); // temperature decreased by 3%,   Bean2maxLpGpPerBdv decreased by 2.
 101 |     | 
 102 |     |     /**
 103 |     |      * @notice given a caseID (0-144), return the caseData.
 104 |     |      *
 105 |     |      * CaseV2 allows developers to change both the absolute
 106 |     |      * and relative change in temperature and bean to maxLP gaugePoint to BDV ratio,
 107 |     |      * with greater precision than CaseV1.
 108 |     |      *
 109 |     |      */
 110 |     |     function getDataFromCase(uint256 caseId) internal view returns (bytes32 caseData) {
 111 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 112 |     |         return s.sys.casesV2[caseId];
 113 |     |     }
 114 |     | 
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice given a caseID (0-144), return the data associated.
 118 |     |      * @dev * Each case outputs 4 variables:
 119 |     |      * mT: Relative Temperature change. (1% = 1e6)
 120 |     |      * bT: Absolute Temperature change. (1% = 1e6)
 121 |     |      * mL: Relative Grown Stalk to Liquidity change. (1% = 1e18)
 122 |     |      * bL: Absolute Grown Stalk to Liquidity change. (1% = 1e18)
 123 |     |      */
 124 |     |     function decodeCaseData(uint256 caseId) internal view returns (CaseData memory cd) {
 125 |     |         bytes32 _caseData = getDataFromCase(caseId);
 126 |     |         // cd.mT = uint32(bytes4(_caseData)); Uncomment if you want to use mT
 127 |     |         cd.bT = int32(uint32(bytes4(_caseData << 32)));
 128 |     |         // cd.mL = uint80(bytes10(_caseData << 64)); Uncomment if you want to use mL
 129 |     |         cd.bL = int80(uint80(bytes10(_caseData << 144)));
 130 |     |     }
 131 |     | 
 132 | *   |     function setCasesV2() internal {
 133 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 134 | *   |         s.sys.casesV2 = [
 135 |     |             //               Dsc soil demand,       Steady soil demand,         Inc soil demand,      Debt level
 136 |     |                     /////////////////////// Extremely Low L2SR ///////////////////////
 137 |     |             bytes32(T_PLUS_2_L_MINUS_FIFTY),    T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_1_L_MINUS_FIFTY, // Exs Low: P < 1
 138 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > 1
 139 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 140 |     |                      T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_0_L_MINUS_FIFTY, // Rea Low: P < 1
 141 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > 1
 142 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 143 |     |                      T_PLUS_1_L_MINUS_FIFTY,   T_PLUS_05_L_MINUS_FIFTY,  T_MINUS_05_L_MINUS_FIFTY, // Rea Hgh: P < 1
 144 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > 1
 145 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 146 |     |                      T_PLUS_1_L_MINUS_FIFTY,   T_PLUS_05_L_MINUS_FIFTY,  T_MINUS_05_L_MINUS_FIFTY, // Exs Hgh: P < 1
 147 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > 1
 148 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 149 |     |                     /////////////////////// Reasonably Low L2SR ///////////////////////
 150 |     |                      T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_1_L_MINUS_FIFTY, // Exs Low: P < 1
 151 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > 1
 152 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 153 |     |                      T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_2_L_MINUS_FIFTY,    T_PLUS_0_L_MINUS_FIFTY, // Rea Low: P < 1
 154 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > 1
 155 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 156 |     |                         T_PLUS_1_L_PLUS_ONE,      T_PLUS_05_L_PLUS_ONE,     T_MINUS_05_L_PLUS_ONE, // Rea Hgh: P < 1
 157 |     |                        T_PLUS_0_L_MINUS_TWO,     T_MINUS_1_L_MINUS_TWO,     T_MINUS_3_L_MINUS_TWO, //          P > 1
 158 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 159 |     |                         T_PLUS_1_L_PLUS_ONE,      T_PLUS_05_L_PLUS_ONE,     T_MINUS_05_L_PLUS_ONE, // Exs Hgh: P < 1
 160 |     |                        T_PLUS_0_L_MINUS_TWO,     T_MINUS_1_L_MINUS_TWO,     T_MINUS_3_L_MINUS_TWO, //          P > 1
 161 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 162 |     |                     /////////////////////// Reasonably High L2SR ///////////////////////
 163 |     |                         T_PLUS_2_L_PLUS_ONE,       T_PLUS_2_L_PLUS_ONE,       T_PLUS_1_L_PLUS_ONE, // Exs Low: P < 1
 164 |     |                       T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 165 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 166 |     |                         T_PLUS_2_L_PLUS_ONE,       T_PLUS_2_L_PLUS_ONE,       T_PLUS_0_L_PLUS_ONE, // Rea Low: P < 1
 167 |     |                       T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 168 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 169 |     |                         T_PLUS_1_L_PLUS_ONE,      T_PLUS_05_L_PLUS_ONE,     T_MINUS_05_L_PLUS_ONE, // Rea Hgh: P < 1
 170 |     |                        T_PLUS_0_L_MINUS_ONE,     T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 171 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 172 |     |                         T_PLUS_1_L_PLUS_ONE,      T_PLUS_05_L_PLUS_ONE,     T_MINUS_05_L_PLUS_ONE, // Exs Hgh: P < 1
 173 |     |                        T_PLUS_0_L_MINUS_ONE,     T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 174 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 175 |     |                     /////////////////////// Extremely High L2SR ///////////////////////
 176 |     |                         T_PLUS_2_L_PLUS_ONE,       T_PLUS_2_L_PLUS_ONE,       T_PLUS_1_L_PLUS_ONE, // Exs Low: P < 1
 177 |     |                       T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 178 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 179 |     |                         T_PLUS_2_L_PLUS_ONE,       T_PLUS_2_L_PLUS_ONE,       T_PLUS_0_L_PLUS_ONE, // Rea Low: P < 1
 180 |     |                       T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 181 |     |                     T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 182 |     |                         T_PLUS_1_L_PLUS_TWO,      T_PLUS_05_L_PLUS_TWO,     T_MINUS_05_L_PLUS_TWO, // Rea Hgh: P < 1
 183 |     |                        T_PLUS_0_L_MINUS_ONE,     T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 184 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY, //          P > Q
 185 |     |                         T_PLUS_1_L_PLUS_TWO,      T_PLUS_05_L_PLUS_TWO,     T_MINUS_05_L_PLUS_TWO, // Exs Hgh: P < 1
 186 |     |                        T_PLUS_0_L_MINUS_ONE,     T_MINUS_1_L_MINUS_ONE,     T_MINUS_3_L_MINUS_ONE, //          P > 1
 187 |     |                      T_PLUS_0_L_MINUS_FIFTY,   T_MINUS_1_L_MINUS_FIFTY,   T_MINUS_3_L_MINUS_FIFTY  //          P > Q
 188 |     |         ];
 189 |     |     }
 190 |     | }
 191 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibClipboard.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {LibBytes} from "./LibBytes.sol";
   8 |     | import {LibTractor} from "./LibTractor.sol";
   9 |     | import {LibFunction} from "./LibFunction.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @title LibClipboard
  13 |     |  * @notice LibClipboard offers utility functions for managing Pipeline clipboards.
  14 |     |  */
  15 | *   | library LibClipboard {
  16 |     |     using LibBytes for bytes;
  17 |     | 
  18 |     |     /**
  19 |     |      * @notice Encode a clipboard for a set of calls. Automatically determines type and useEther flag.
  20 |     |      * @dev Not the most gas efficient. Many small calls to encodePacked.
  21 |     |      * @param etherValue Ether value to send with call. If 0, useEther flag is set to 0.
  22 |     |      * @param returnPasteParams Array of returnPasteParam encoded as bytes32 objects.
  23 |     |      * @return clipboard Encoded clipboard, adhering to https://evmpipeline.org/pipeline.pdf, Figure 2.
  24 |     |      */
  25 |     |     function encode(
  26 |     |         uint256 etherValue,
  27 |     |         bytes32[] memory returnPasteParams
  28 |     |     ) internal pure returns (bytes memory clipboard) {
  29 |     |         uint8 useEther = etherValue == 0 ? 0 : 1;
  30 |     | 
  31 |     |         if (returnPasteParams.length == 0) {
  32 |     |             clipboard = abi.encodePacked(uint8(0), useEther);
  33 |     |         } else if (returnPasteParams.length == 1) {
  34 |     |             clipboard = abi.encodePacked(
  35 |     |                 uint8(1),
  36 |     |                 useEther,
  37 |     |                 uint240(uint256(returnPasteParams[0])) // remove padding
  38 |     |             );
  39 |     |         } else {
  40 |     |             clipboard = abi.encode(
  41 |     |                 (uint256(0x02) << 248) | (uint256(useEther) << 240), // type + ether
  42 |     |                 returnPasteParams
  43 |     |             );
  44 |     |         }
  45 |     | 
  46 |     |         if (useEther == 1) {
  47 |     |             clipboard = abi.encodePacked(clipboard, etherValue);
  48 |     |         }
  49 |     | 
  50 |     |         return clipboard;
  51 |     |     }
  52 |     | 
  53 |     |     function decode(
  54 |     |         bytes memory clipboard
  55 |     |     )
  56 |     |         internal
  57 |     |         pure
  58 |     |         returns (bytes1 typeId, uint256 etherValue, bytes32[] memory returnPasteParams)
  59 |     |     {
  60 |     |         typeId = clipboard[0];
  61 |     |         if (typeId == 0x01) {
  62 |     |             returnPasteParams = new bytes32[](1);
  63 |     |             returnPasteParams[0] = abi.decode(clipboard, (bytes32));
  64 |     |         } else if (typeId == 0x02) {
  65 |     |             (, returnPasteParams) = abi.decode(clipboard, (bytes2, bytes32[]));
  66 |     |         }
  67 |     | 
  68 |     |         bytes1 useEther = clipboard[1];
  69 |     |         if (useEther == 0x01) {
  70 |     |             etherValue = clipboard.toUint256(clipboard.length - 32);
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /** @notice Use a Clipboard on callData to copy return values stored as returnData from any Advanced Calls
  75 |     |      * that have already been executed and paste them into the callData of the next Advanced Call, in a customizable manner
  76 |     |      * https://evmpipeline.org/pipeline.pdf, Figure 2
  77 |     |      * @param callData The callData bytes of next Advanced Call to paste onto
  78 |     |      * @param clipboard 0, 1 or n encoded paste operations and encoded ether value if using Pipeline
  79 |     |      * -------------------------------------------------------------------------------------
  80 |     |      * Clipboard stores the bytes:
  81 |     |      * [ Type   | Use Ether Flag*  | Type data      | Ether Value (only if flag == 1)*]
  82 |     |      * [ 1 byte | 1 byte           | n bytes        | 0 or 32 bytes                   ]
  83 |     |      * * Use Ether Flag and Ether Value are processed in Pipeline.sol (Not used in Farm). See Pipeline.getEthValue for ussage.
  84 |     |      * Type: 0x00, 0x01 or 0x02
  85 |     |      *  - 0x00: 0 Paste Operations (Logic in Pipeline.sol and FarmFacet.sol)
  86 |     |      *  - 0x01: 1 Paste Operation
  87 |     |      *  - 0x02: n Paste Operations
  88 |     |      * Type Data: There are two types with type data: 0x01, 0x02
  89 |     |      *  Type 1 (0x01): Copy 1 bytes32 from a previous function return value
  90 |     |      *       [ pasteParams ]
  91 |     |      *       [ 32 bytes ]
  92 |     |      *      Note: Should be encoded with ['bytes2', 'uint80', 'uint80', 'uint80']  where the first two bytes are Type and Send Ether Flag if using Pipeline
  93 |     |      *  Type 2 (0x02): Copy n bytes32 from a previous function return value
  94 |     |      *       [ Padding      | pasteParams[] ]
  95 |     |      *       [ 32 bytes     | 64 + 32 * n   ]
  96 |     |      *        * The first 32 bytes are the location of data, the next 32 bytes are the length of the array.
  97 |     |      * -------------------------------------------------------------------------------------
  98 |     |      * @param returnData A list of return values from previously executed Advanced Calls
  99 |     |      * @return data The function call return datas
 100 |     |      **/
 101 |     |     function useClipboard(
 102 |     |         bytes memory callData,
 103 |     |         bytes memory clipboard,
 104 |     |         bytes[] memory returnData
 105 |     |     ) internal pure returns (bytes memory data) {
 106 |     |         (bytes1 typeId, , bytes32[] memory returnPasteParams) = decode(clipboard);
 107 |     |         require(typeId == 0x01 || typeId == 0x02, "Clipboard: Type not supported");
 108 |     |         data = callData;
 109 |     |         for (uint256 i; i < returnPasteParams.length; i++) {
 110 |     |             LibBytes.pasteBytesClipboard(returnPasteParams[i], returnData, data);
 111 |     |         }
 112 |     |     }
 113 |     | }
 114 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibDiamond.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | /**
   7 |     |  * \
   8 |     |  * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
   9 |     |  * EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535
  10 |     |  * /*****************************************************************************
  11 |     |  */
  12 |     | 
  13 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  14 |     | import {IDiamondCut} from "../interfaces/IDiamondCut.sol";
  15 |     | import {IDiamondLoupe} from "../interfaces/IDiamondLoupe.sol";
  16 |     | 
  17 | *   | library LibDiamond {
  18 | *   |     bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("diamond.standard.diamond.storage");
  19 |     | 
  20 |     |     struct FacetAddressAndPosition {
  21 |     |         address facetAddress;
  22 |     |         uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
  23 |     |     }
  24 |     | 
  25 |     |     struct FacetFunctionSelectors {
  26 |     |         bytes4[] functionSelectors;
  27 |     |         uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
  28 |     |     }
  29 |     | 
  30 |     |     struct DiamondStorage {
  31 |     |         // maps function selector to the facet address and
  32 |     |         // the position of the selector in the facetFunctionSelectors.selectors array
  33 |     |         mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
  34 |     |         // maps facet addresses to function selectors
  35 |     |         mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
  36 |     |         // facet addresses
  37 |     |         address[] facetAddresses;
  38 |     |         // Used to query if a contract implements an interface.
  39 |     |         // Used to implement ERC-165.
  40 |     |         mapping(bytes4 => bool) supportedInterfaces;
  41 |     |         // owner of the contract
  42 |     |         address contractOwner;
  43 |     |     }
  44 |     | 
  45 | *   |     function diamondStorage() internal pure returns (DiamondStorage storage ds) {
  46 | *   |         bytes32 position = DIAMOND_STORAGE_POSITION;
  47 | *   |         assembly {
  48 | *   |             ds.slot := position
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  53 |     | 
  54 | *   |     function setContractOwner(address _newOwner) internal {
  55 | *   |         DiamondStorage storage ds = diamondStorage();
  56 | *   |         address previousOwner = ds.contractOwner;
  57 | *   |         ds.contractOwner = _newOwner;
  58 | *   |         emit OwnershipTransferred(previousOwner, _newOwner);
  59 |     |     }
  60 |     | 
  61 |     |     function contractOwner() internal view returns (address contractOwner_) {
  62 |     |         contractOwner_ = diamondStorage().contractOwner;
  63 |     |     }
  64 |     | 
  65 | *   |     function enforceIsOwnerOrContract() internal view {
  66 | *   |         require(
  67 | *   |             msg.sender == diamondStorage().contractOwner || msg.sender == address(this),
  68 |     |             "LibDiamond: Must be contract or owner"
  69 |     |         );
  70 |     |     }
  71 |     | 
  72 | *   |     function enforceIsContractOwner() internal view {
  73 | *   |         require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner");
  74 |     |     }
  75 |     | 
  76 | *   |     function addDiamondFunctions(address _diamondCutFacet, address _diamondLoupeFacet) internal {
  77 | *   |         IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](2);
  78 | *   |         bytes4[] memory functionSelectors = new bytes4[](1);
  79 | *   |         functionSelectors[0] = IDiamondCut.diamondCut.selector;
  80 | *   |         cut[0] = IDiamondCut.FacetCut({
  81 | *   |             facetAddress: _diamondCutFacet,
  82 | *   |             action: IDiamondCut.FacetCutAction.Add,
  83 | *   |             functionSelectors: functionSelectors
  84 |     |         });
  85 | *   |         functionSelectors = new bytes4[](5);
  86 | *   |         functionSelectors[0] = IDiamondLoupe.facets.selector;
  87 | *   |         functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;
  88 | *   |         functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;
  89 | *   |         functionSelectors[3] = IDiamondLoupe.facetAddress.selector;
  90 | *   |         functionSelectors[4] = IERC165.supportsInterface.selector;
  91 | *   |         cut[1] = IDiamondCut.FacetCut({
  92 | *   |             facetAddress: _diamondLoupeFacet,
  93 | *   |             action: IDiamondCut.FacetCutAction.Add,
  94 | *   |             functionSelectors: functionSelectors
  95 |     |         });
  96 | *   |         diamondCut(cut, address(0), "");
  97 |     |     }
  98 |     | 
  99 |     |     // Internal function version of diamondCut
 100 | *   |     function diamondCut(
 101 |     |         IDiamondCut.FacetCut[] memory _diamondCut,
 102 |     |         address _init,
 103 |     |         bytes memory _calldata
 104 |     |     ) internal {
 105 | *   |         for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {
 106 | *   |             IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
 107 | *   |             if (action == IDiamondCut.FacetCutAction.Add) {
 108 | *   |                 addFunctions(
 109 | *   |                     _diamondCut[facetIndex].facetAddress,
 110 | *   |                     _diamondCut[facetIndex].functionSelectors
 111 |     |                 );
 112 |     |             } else if (action == IDiamondCut.FacetCutAction.Replace) {
 113 |     |                 replaceFunctions(
 114 |     |                     _diamondCut[facetIndex].facetAddress,
 115 |     |                     _diamondCut[facetIndex].functionSelectors
 116 |     |                 );
 117 |     |             } else if (action == IDiamondCut.FacetCutAction.Remove) {
 118 |     |                 removeFunctions(
 119 |     |                     _diamondCut[facetIndex].facetAddress,
 120 |     |                     _diamondCut[facetIndex].functionSelectors
 121 |     |                 );
 122 |     |             } else {
 123 |     |                 revert("LibDiamondCut: Incorrect FacetCutAction");
 124 |     |             }
 125 |     |         }
 126 | *   |         emit IDiamondCut.DiamondCut(_diamondCut, _init, _calldata);
 127 | *   |         initializeDiamondCut(_init, _calldata);
 128 |     |     }
 129 |     | 
 130 | *   |     function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
 131 | *   |         require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
 132 | *   |         DiamondStorage storage ds = diamondStorage();
 133 | *   |         require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)");
 134 | *   |         uint96 selectorPosition = uint96(
 135 | *   |             ds.facetFunctionSelectors[_facetAddress].functionSelectors.length
 136 |     |         );
 137 |     |         // add new facet address if it does not exist
 138 | *   |         if (selectorPosition == 0) {
 139 | *   |             addFacet(ds, _facetAddress);
 140 |     |         }
 141 | *   |         for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
 142 | *   |             bytes4 selector = _functionSelectors[selectorIndex];
 143 | *   |             address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
 144 | *   |             require(
 145 | *   |                 oldFacetAddress == address(0),
 146 |     |                 "LibDiamondCut: Can't add function that already exists"
 147 |     |             );
 148 | *   |             addFunction(ds, selector, selectorPosition, _facetAddress);
 149 | *   |             selectorPosition++;
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
 154 |     |         require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
 155 |     |         DiamondStorage storage ds = diamondStorage();
 156 |     |         require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)");
 157 |     |         uint96 selectorPosition = uint96(
 158 |     |             ds.facetFunctionSelectors[_facetAddress].functionSelectors.length
 159 |     |         );
 160 |     |         // add new facet address if it does not exist
 161 |     |         if (selectorPosition == 0) {
 162 |     |             addFacet(ds, _facetAddress);
 163 |     |         }
 164 |     |         for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
 165 |     |             bytes4 selector = _functionSelectors[selectorIndex];
 166 |     |             address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
 167 |     |             require(
 168 |     |                 oldFacetAddress != _facetAddress,
 169 |     |                 "LibDiamondCut: Can't replace function with same function"
 170 |     |             );
 171 |     |             removeFunction(ds, oldFacetAddress, selector);
 172 |     |             addFunction(ds, selector, selectorPosition, _facetAddress);
 173 |     |             selectorPosition++;
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
 178 |     |         require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
 179 |     |         DiamondStorage storage ds = diamondStorage();
 180 |     |         // if function does not exist then do nothing and return
 181 |     |         require(
 182 |     |             _facetAddress == address(0),
 183 |     |             "LibDiamondCut: Remove facet address must be address(0)"
 184 |     |         );
 185 |     |         for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
 186 |     |             bytes4 selector = _functionSelectors[selectorIndex];
 187 |     |             address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
 188 |     |             removeFunction(ds, oldFacetAddress, selector);
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 | *   |     function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
 193 | *   |         enforceHasContractCode(_facetAddress, "LibDiamondCut: New facet has no code");
 194 | *   |         ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
 195 | *   |         ds.facetAddresses.push(_facetAddress);
 196 |     |     }
 197 |     | 
 198 | *   |     function addFunction(
 199 |     |         DiamondStorage storage ds,
 200 |     |         bytes4 _selector,
 201 |     |         uint96 _selectorPosition,
 202 |     |         address _facetAddress
 203 |     |     ) internal {
 204 | *   |         ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
 205 | *   |         ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
 206 | *   |         ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
 207 |     |     }
 208 |     | 
 209 |     |     function removeFunction(
 210 |     |         DiamondStorage storage ds,
 211 |     |         address _facetAddress,
 212 |     |         bytes4 _selector
 213 |     |     ) internal {
 214 |     |         require(
 215 |     |             _facetAddress != address(0),
 216 |     |             "LibDiamondCut: Can't remove function that doesn't exist"
 217 |     |         );
 218 |     |         // an immutable function is a function defined directly in a diamond
 219 |     |         require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function");
 220 |     |         // replace selector with last selector, then delete last selector
 221 |     |         uint256 selectorPosition = ds
 222 |     |             .selectorToFacetAndPosition[_selector]
 223 |     |             .functionSelectorPosition;
 224 |     |         uint256 lastSelectorPosition = ds
 225 |     |             .facetFunctionSelectors[_facetAddress]
 226 |     |             .functionSelectors
 227 |     |             .length - 1;
 228 |     |         // if not the same then replace _selector with lastSelector
 229 |     |         if (selectorPosition != lastSelectorPosition) {
 230 |     |             bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[
 231 |     |                 lastSelectorPosition
 232 |     |             ];
 233 |     |             ds.facetFunctionSelectors[_facetAddress].functionSelectors[
 234 |     |                 selectorPosition
 235 |     |             ] = lastSelector;
 236 |     |             ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(
 237 |     |                 selectorPosition
 238 |     |             );
 239 |     |         }
 240 |     |         // delete the last selector
 241 |     |         ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
 242 |     |         delete ds.selectorToFacetAndPosition[_selector];
 243 |     | 
 244 |     |         // if no more selectors for facet address then delete the facet address
 245 |     |         if (lastSelectorPosition == 0) {
 246 |     |             // replace facet address with last facet address and delete last facet address
 247 |     |             uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
 248 |     |             uint256 facetAddressPosition = ds
 249 |     |                 .facetFunctionSelectors[_facetAddress]
 250 |     |                 .facetAddressPosition;
 251 |     |             if (facetAddressPosition != lastFacetAddressPosition) {
 252 |     |                 address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
 253 |     |                 ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
 254 |     |                 ds
 255 |     |                     .facetFunctionSelectors[lastFacetAddress]
 256 |     |                     .facetAddressPosition = facetAddressPosition;
 257 |     |             }
 258 |     |             ds.facetAddresses.pop();
 259 |     |             delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
 260 |     |         }
 261 |     |     }
 262 |     | 
 263 | *   |     function initializeDiamondCut(address _init, bytes memory _calldata) internal {
 264 | *   |         if (_init == address(0)) {
 265 | *   |             require(
 266 | *   |                 _calldata.length == 0,
 267 |     |                 "LibDiamondCut: _init is address(0) but_calldata is not empty"
 268 |     |             );
 269 | *   |         } else {
 270 | *   |             require(
 271 | *   |                 _calldata.length > 0,
 272 |     |                 "LibDiamondCut: _calldata is empty but _init is not address(0)"
 273 |     |             );
 274 | *   |             if (_init != address(this)) {
 275 | *   |                 enforceHasContractCode(_init, "LibDiamondCut: _init address has no code");
 276 |     |             }
 277 | *   |             (bool success, bytes memory error) = _init.delegatecall(_calldata);
 278 | *   |             if (!success) {
 279 |     |                 if (error.length > 0) {
 280 |     |                     // bubble up the error
 281 |     |                     revert(string(error));
 282 |     |                 } else {
 283 |     |                     revert("LibDiamondCut: _init function reverted");
 284 |     |                 }
 285 |     |             }
 286 |     |         }
 287 |     |     }
 288 |     | 
 289 | *   |     function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
 290 | *   |         uint256 contractSize;
 291 |     |         assembly {
 292 | *   |             contractSize := extcodesize(_contract)
 293 |     |         }
 294 | *   |         require(contractSize > 0, _errorMessage);
 295 |     |     }
 296 |     | }
 297 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibDibbler.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
   6 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   7 |     | import {PRBMath} from "@prb/math/contracts/PRBMath.sol";
   8 |     | import {LibPRBMathRoundable} from "contracts/libraries/Math/LibPRBMathRoundable.sol";
   9 |     | import {LibAppStorage, AppStorage} from "./LibAppStorage.sol";
  10 |     | import {Account, Field} from "contracts/beanstalk/storage/Account.sol";
  11 |     | import {LibRedundantMath128} from "./Math/LibRedundantMath128.sol";
  12 |     | import {LibRedundantMath32} from "./Math/LibRedundantMath32.sol";
  13 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  14 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  15 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  16 |     | import {IBean} from "contracts/interfaces/IBean.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @title LibDibbler
  20 |     |  * @notice Calculates the amount of Pods received for Sowing under certain conditions.
  21 |     |  * Provides functions to calculate the instantaneous Temperature, which is adjusted by the
  22 |     |  * Morning Auction functionality. Provides additional functionality used by field/market.
  23 |     |  */
  24 | *   | library LibDibbler {
  25 |     |     using PRBMath for uint256;
  26 |     |     using LibPRBMathRoundable for uint256;
  27 |     |     using LibRedundantMath256 for uint256;
  28 |     |     using LibRedundantMath32 for uint32;
  29 |     |     using LibRedundantMath128 for uint128;
  30 |     | 
  31 |     |     /// @dev The precision of s.sys.weather.temp
  32 |     |     uint256 internal constant TEMPERATURE_PRECISION = 1e6;
  33 |     |     
  34 |     |     /// @dev The divisor of s.sys.weather.temp in the morning auction
  35 |     |     uint256 internal constant TEMPERATURE_DIVISOR = 1e12;
  36 |     | 
  37 |     |     /// @dev Simplifies conversion of Beans to Pods:
  38 |     |     /// `pods = beans * (1 + temperature)`
  39 |     |     /// `pods = beans * (100% + temperature) / 100%`
  40 |     |     uint256 internal constant ONE_HUNDRED_TEMP = 100 * TEMPERATURE_PRECISION;
  41 |     | 
  42 |     |     /// @dev If less than `SOIL_SOLD_OUT_THRESHOLD` Soil is left, consider
  43 |     |     /// Soil to be "sold out"; affects how Temperature is adjusted.
  44 |     |     uint256 private constant SOIL_SOLD_OUT_THRESHOLD = 1e6;
  45 |     | 
  46 |     |     uint256 private constant L1_BLOCK_TIME = 1200;
  47 |     |     uint256 private constant L2_BLOCK_TIME = 200;
  48 |     | 
  49 |     |     /**
  50 |     |      * @notice Emitted from {LibDibbler.sow} when an `account` creates a plot.
  51 |     |      * A Plot is a set of Pods created in from a single {sow} or {fund} call.
  52 |     |      * @param account The account that sowed Bean for Pods
  53 |     |      * @param index The place in line of the Plot
  54 |     |      * @param beans The amount of Bean burnt to create the Plot
  55 |     |      * @param pods The amount of Pods assocated with the created Plot
  56 |     |      */
  57 |     |     event Sow(address indexed account, uint256 fieldId, uint256 index, uint256 beans, uint256 pods);
  58 |     | 
  59 |     |     //////////////////// SOW ////////////////////
  60 |     | 
  61 |     |     function sowWithMin(
  62 |     |         uint256 beans,
  63 |     |         uint256 minTemperature,
  64 |     |         uint256 minSoil,
  65 |     |         LibTransfer.From mode
  66 |     |     ) internal returns (uint256 pods) {
  67 |     |         // `soil` is the remaining Soil
  68 |     |         (uint256 soil, uint256 _morningTemperature, bool abovePeg) = _totalSoilAndTemperature();
  69 |     | 
  70 |     |         require(soil >= minSoil && beans >= minSoil, "Field: Soil Slippage");
  71 |     |         require(_morningTemperature >= minTemperature, "Field: Temperature Slippage");
  72 |     | 
  73 |     |         // If beans >= soil, Sow all of the remaining Soil
  74 |     |         if (beans < soil) {
  75 |     |             soil = beans;
  76 |     |         }
  77 |     | 
  78 |     |         // 1 Bean is Sown in 1 Soil, i.e. soil = beans
  79 |     |         pods = _sow(soil, _morningTemperature, abovePeg, mode);
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Burn Beans, Sows at the provided `_morningTemperature`, increments the total
  84 |     |      * number of `beanSown`.
  85 |     |      */
  86 |     |     function _sow(
  87 |     |         uint256 beans,
  88 |     |         uint256 _morningTemperature,
  89 |     |         bool peg,
  90 |     |         LibTransfer.From mode
  91 |     |     ) internal returns (uint256 pods) {
  92 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  93 |     |         beans = LibTransfer.burnToken(IBean(s.sys.bean), beans, LibTractor._user(), mode);
  94 |     |         pods = sow(beans, _morningTemperature, LibTractor._user(), peg);
  95 |     |         s.sys.beanSown += SafeCast.toUint128(beans);
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @param beans The number of Beans to Sow
 100 |     |      * @param _morningTemperature Pre-calculated {morningTemperature()}
 101 |     |      * @param account The account sowing Beans
 102 |     |      * @param abovePeg Whether the TWA deltaB of the previous season was positive (true) or negative (false)
 103 |     |      * @dev
 104 |     |      *
 105 |     |      * ## Above Peg
 106 |     |      *
 107 |     |      * | t   | Max pods  | s.sys.soil            | soil                    | temperature              | maxTemperature |
 108 |     |      * |-----|-----------|-----------------------|-------------------------|--------------------------|----------------|
 109 |     |      * | 0   | 500e6     | ~37e6 500e6/(1+1250%) | ~495e6 500e6/(1+1%))    | 1e6 (1%)                 | 1250 (1250%)   |
 110 |     |      * | 12  | 500e6     | ~37e6                 | ~111e6 500e6/(1+348%))  | 348.75e6 (27.9% * 1250)  | 1250           |
 111 |     |      * | 300 | 500e6     | ~37e6                 |  ~37e6 500e6/(1+1250%)  | 1250e6                   | 1250           |
 112 |     |      *
 113 |     |      * ## Below Peg
 114 |     |      *
 115 |     |      * | t   | Max pods                        | soil  | temperature                   | maxTemperature     |
 116 |     |      * |-----|---------------------------------|-------|-------------------------------|--------------------|
 117 |     |      * | 0   | 505e6 (500e6 * (1+1%))          | 500e6 | 1e6 (1%)                      | 1250 (1250%)       |
 118 |     |      * | 12  | 2243.75e6 (500e6 * (1+348.75%)) | 500e6 | 348.75e6 (27.9% * 1250 * 1e6) | 1250               |
 119 |     |      * | 300 | 6750e6 (500e6 * (1+1250%))      | 500e6 | 1250e6                        | 1250               |
 120 |     |      */
 121 |     |     function sow(
 122 |     |         uint256 beans,
 123 |     |         uint256 _morningTemperature,
 124 |     |         address account,
 125 |     |         bool abovePeg
 126 |     |     ) internal returns (uint256) {
 127 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 128 |     |         uint256 activeField = s.sys.activeField;
 129 |     | 
 130 |     |         uint256 pods;
 131 |     |         uint256 soilUsed;
 132 |     |         if (abovePeg) {
 133 |     |             uint256 maxTemperature = uint256(s.sys.weather.temp);
 134 |     |             // amount sown is rounded up, because
 135 |     |             // 1: temperature is rounded down.
 136 |     |             // 2: pods are rounded down.
 137 |     |             soilUsed = scaleSoilDown(beans, _morningTemperature, maxTemperature);
 138 |     |             pods = beansToPods(soilUsed, maxTemperature);
 139 |     |         } else {
 140 |     |             // below peg, beans are used directly.
 141 |     |             soilUsed = beans;
 142 |     |             pods = beansToPods(soilUsed, _morningTemperature);
 143 |     |         }
 144 |     | 
 145 |     |         require(pods > 0, "Pods must be greater than 0");
 146 |     | 
 147 |     |         // In the case of an overflow, its equivalent to having no soil left.
 148 |     |         if (s.sys.soil < soilUsed) {
 149 |     |             s.sys.soil = 0;
 150 |     |         } else {
 151 |     |             s.sys.soil = s.sys.soil.sub(uint128(soilUsed));
 152 |     |         }
 153 |     | 
 154 |     |         uint256 index = s.sys.fields[activeField].pods;
 155 |     | 
 156 |     |         s.accts[account].fields[activeField].plots[index] = pods;
 157 |     |         s.accts[account].fields[activeField].plotIndexes.push(index);
 158 |     |         s.accts[account].fields[activeField].piIndex[index] =
 159 |     |             s.accts[account].fields[activeField].plotIndexes.length -
 160 |     |             1;
 161 |     |         emit Sow(account, activeField, index, beans, pods);
 162 |     | 
 163 |     |         s.sys.fields[activeField].pods += pods;
 164 |     |         _saveSowTime();
 165 |     |         return pods;
 166 |     |     }
 167 |     | 
 168 |     |     /**
 169 |     |      * @dev Stores the time elapsed from the start of the Season to the time
 170 |     |      * at which Soil is "sold out", i.e. the remaining Soil is less than a
 171 |     |      * threshold `SOIL_SOLD_OUT_THRESHOLD`.
 172 |     |      *
 173 |     |      * RATIONALE: Beanstalk utilizes the time elapsed for Soil to "sell out" to
 174 |     |      * gauge demand for Soil, which affects how the Temperature is adjusted. For
 175 |     |      * example, if all Soil is Sown in 1 second vs. 1 hour, Beanstalk assumes
 176 |     |      * that the former shows more demand than the latter.
 177 |     |      *
 178 |     |      * `thisSowTime` represents the target time of the first Sow for the *next*
 179 |     |      * Season to be considered increasing in demand.
 180 |     |      *
 181 |     |      * `thisSowTime` should only be updated if:
 182 |     |      *  (a) there is less than 1 Soil available after this Sow, and
 183 |     |      *  (b) it has not yet been updated this Season.
 184 |     |      *
 185 |     |      * Note that:
 186 |     |      *  - `s.soil` was decremented in the upstream {sow} function.
 187 |     |      *  - `s.weather.thisSowTime` is set to `type(uint32).max` during {sunrise}.
 188 |     |      */
 189 |     |     function _saveSowTime() private {
 190 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 191 |     | 
 192 |     |         // s.sys.soil is now the soil remaining after this Sow.
 193 |     |         if (s.sys.soil > SOIL_SOLD_OUT_THRESHOLD || s.sys.weather.thisSowTime < type(uint32).max) {
 194 |     |             // haven't sold enough soil, or already set thisSowTime for this Season.
 195 |     |             return;
 196 |     |         }
 197 |     | 
 198 |     |         s.sys.weather.thisSowTime = uint32(block.timestamp.sub(s.sys.season.timestamp));
 199 |     |     }
 200 |     | 
 201 |     |     /**
 202 |     |      * @dev Gets the current `soil`, `_morningTemperature` and `abovePeg`. Provided as a gas
 203 |     |      * optimization to prevent recalculation of {LibDibbler.morningTemperature} for
 204 |     |      * upstream functions.
 205 |     |      * Note: the `soil` return value is symmetric with `totalSoil`.
 206 |     |      */
 207 |     |     function _totalSoilAndTemperature()
 208 |     |         private
 209 |     |         view
 210 |     |         returns (uint256 soil, uint256 _morningTemperature, bool abovePeg)
 211 |     |     {
 212 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 213 |     |         _morningTemperature = LibDibbler.morningTemperature();
 214 |     |         abovePeg = s.sys.season.abovePeg;
 215 |     | 
 216 |     |         // Below peg: Soil is fixed to the amount set during {calcCaseId}.
 217 |     |         // Morning Temperature is dynamic, starting small and logarithmically
 218 |     |         // increasing to `s.weather.t` across the first 25 blocks of the Season.
 219 |     |         if (!abovePeg) {
 220 |     |             soil = uint256(s.sys.soil);
 221 |     |         } else {
 222 |     |             // Above peg: the maximum amount of Pods that Beanstalk is willing to mint
 223 |     |             // stays fixed; since {morningTemperature} is scaled down when `delta < 25`, we
 224 |     |             // need to scale up the amount of Soil to hold Pods constant.
 225 |     |             soil = LibDibbler.scaleSoilUp(
 226 |     |                 uint256(s.sys.soil), // max soil offered this Season, reached when `t >= 25`
 227 |     |                 uint256(s.sys.weather.temp), // max temperature (1e6 precision)
 228 |     |                 _morningTemperature // temperature adjusted by number of blocks since Sunrise
 229 |     |             );
 230 |     |         }
 231 |     |     }
 232 |     | 
 233 |     |     //////////////////// TEMPERATURE ////////////////////
 234 |     | 
 235 |     |     /**
 236 |     |      * @dev Returns the temperature `s.sys.weather.temp` scaled down based on the block delta.
 237 |     |      * Precision level 1e6, as soil has 1e6 precision (1% = 1e6)
 238 |     |      * the formula `log3.5(A * MAX_BLOCK_ELAPSED + 1)` is applied, where:
 239 |     |      * `A = 0.1`
 240 |     |      * `MAX_BLOCK_ELAPSED = 25`
 241 |     |      * @dev L2 block times are signifncatly shorter than L1. To adjust for this,
 242 |     |      * `delta` is scaled down by the ratio of L2 block time to L1 block time.
 243 |     |      */
 244 |     |     function morningTemperature() internal view returns (uint256) {
 245 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 246 |     |         uint256 delta = block
 247 |     |             .number
 248 |     |             .sub(s.sys.season.sunriseBlock)
 249 |     |             .mul(L2_BLOCK_TIME)
 250 |     |             .div(L1_BLOCK_TIME)
 251 |     |             .div(2); // dividing by 2 increases the morning auction time from 25 to 50 L1 blocks (5 min -> 10 min)
 252 |     | 
 253 |     |         // check most likely case first
 254 |     |         if (delta > 24) {
 255 |     |             return uint256(s.sys.weather.temp);
 256 |     |         }
 257 |     | 
 258 |     |         // Binary Search
 259 |     |         if (delta < 13) {
 260 |     |             if (delta < 7) {
 261 |     |                 if (delta < 4) {
 262 |     |                     if (delta < 2) {
 263 |     |                         if (delta < 1) {
 264 |     |                             // delta == 0, same block as sunrise
 265 |     |                             return _scaleTemperature(10000000000);
 266 |     |                         } else {
 267 |     |                             // delta == 1
 268 |     |                             return _scaleTemperature(76079978576);
 269 |     |                         }
 270 |     |                     } else {
 271 |     |                         if (delta == 2) {
 272 |     |                             return _scaleTemperature(145535557307);
 273 |     |                         } else {
 274 |     |                             // delta == 3
 275 |     |                             return _scaleTemperature(209428496104);
 276 |     |                         }
 277 |     |                     }
 278 |     |                 } else {
 279 |     |                     if (delta < 6) {
 280 |     |                         if (delta == 4) {
 281 |     |                             return _scaleTemperature(268584117732);
 282 |     |                         } else {
 283 |     |                             // delta == 5
 284 |     |                             return _scaleTemperature(323656683909);
 285 |     |                         }
 286 |     |                     } else {
 287 |     |                         // delta == 6
 288 |     |                         return _scaleTemperature(375173629062);
 289 |     |                     }
 290 |     |                 }
 291 |     |             } else {
 292 |     |                 if (delta < 10) {
 293 |     |                     if (delta < 9) {
 294 |     |                         if (delta == 7) {
 295 |     |                             return _scaleTemperature(423566360442);
 296 |     |                         } else {
 297 |     |                             // delta == 8
 298 |     |                             return _scaleTemperature(469192241217);
 299 |     |                         }
 300 |     |                     } else {
 301 |     |                         // delta == 9
 302 |     |                         return _scaleTemperature(512350622036);
 303 |     |                     }
 304 |     |                 } else {
 305 |     |                     if (delta < 12) {
 306 |     |                         if (delta == 10) {
 307 |     |                             return _scaleTemperature(553294755665);
 308 |     |                         } else {
 309 |     |                             // delta == 11
 310 |     |                             return _scaleTemperature(592240801642);
 311 |     |                         }
 312 |     |                     } else {
 313 |     |                         // delta == 12
 314 |     |                         return _scaleTemperature(629374734241);
 315 |     |                     }
 316 |     |                 }
 317 |     |             }
 318 |     |         } else {
 319 |     |             if (delta < 19) {
 320 |     |                 if (delta < 16) {
 321 |     |                     if (delta < 15) {
 322 |     |                         if (delta == 13) {
 323 |     |                             return _scaleTemperature(664857713614);
 324 |     |                         } else {
 325 |     |                             // delta == 14
 326 |     |                             return _scaleTemperature(698830312972);
 327 |     |                         }
 328 |     |                     } else {
 329 |     |                         // delta == 15
 330 |     |                         return _scaleTemperature(731415882267);
 331 |     |                     }
 332 |     |                 } else {
 333 |     |                     if (delta < 18) {
 334 |     |                         if (delta == 16) {
 335 |     |                             return _scaleTemperature(762723251769);
 336 |     |                         } else {
 337 |     |                             // delta == 17
 338 |     |                             return _scaleTemperature(792848925126);
 339 |     |                         }
 340 |     |                     } else {
 341 |     |                         // delta == 18
 342 |     |                         return _scaleTemperature(821878873397);
 343 |     |                     }
 344 |     |                 }
 345 |     |             } else {
 346 |     |                 if (delta < 22) {
 347 |     |                     if (delta < 21) {
 348 |     |                         if (delta == 19) {
 349 |     |                             return _scaleTemperature(849890014127);
 350 |     |                         } else {
 351 |     |                             // delta == 20
 352 |     |                             return _scaleTemperature(876951439574);
 353 |     |                         }
 354 |     |                     } else {
 355 |     |                         // delta == 21
 356 |     |                         return _scaleTemperature(903125443474);
 357 |     |                     }
 358 |     |                 } else {
 359 |     |                     if (delta <= 23) {
 360 |     |                         if (delta == 22) {
 361 |     |                             return _scaleTemperature(928468384727);
 362 |     |                         } else {
 363 |     |                             // delta == 23
 364 |     |                             return _scaleTemperature(953031418151);
 365 |     |                         }
 366 |     |                     } else {
 367 |     |                         // delta == 24
 368 |     |                         return _scaleTemperature(976861116107);
 369 |     |                     }
 370 |     |                 }
 371 |     |             }
 372 |     |         }
 373 |     |     }
 374 |     | 
 375 |     |     /**
 376 |     |      * @param pct The percentage to scale down by, measured to 1e12.
 377 |     |      * @return scaledTemperature The scaled temperature, measured to 1e6 = 1% = 1.
 378 |     |      * @dev Scales down `s.sys.weather.temp` and imposes a minimum of 1e6 (1%) unless
 379 |     |      * `s.sys.weather.temp` is 0%.
 380 |     |      */
 381 |     |     function _scaleTemperature(uint256 pct) private view returns (uint256 scaledTemperature) {
 382 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 383 |     | 
 384 |     |         uint256 maxTemperature = s.sys.weather.temp;
 385 |     |         if (maxTemperature == 0) return 0;
 386 |     | 
 387 |     |         // To save gas, `pct` is pre-calculated to 12 digits. Here we
 388 |     |         // perform the following transformation:
 389 |     |         // (1e6)    maxTemperature
 390 |     |         // (1e12)    * pct
 391 |     |         // (1e12)    / TEMPERATURE_DIVISOR
 392 |     |         // (1e6)     = scaledYield
 393 |     |         scaledTemperature = maxTemperature.mulDiv(
 394 |     |             pct,
 395 |     |             TEMPERATURE_DIVISOR,
 396 |     |             LibPRBMathRoundable.Rounding.Up
 397 |     |         );
 398 |     |     }
 399 |     | 
 400 |     |     /**
 401 |     |      * @param beans The number of Beans to convert to Pods.
 402 |     |      * @param _morningTemperature The current Temperature, measured to 1e8.
 403 |     |      * @dev Converts Beans to Pods based on `_morningTemperature`.
 404 |     |      *
 405 |     |      * `pods = beans * (100e6 + _morningTemperature) / 100e6`
 406 |     |      * `pods = beans * (1 + _morningTemperature / 100e6)`
 407 |     |      *
 408 |     |      * Beans and Pods are measured to 6 decimals.
 409 |     |      *
 410 |     |      * 1e8 = 100e6 = 100% = 1.
 411 |     |      */
 412 |     |     function beansToPods(
 413 |     |         uint256 beans,
 414 |     |         uint256 _morningTemperature
 415 |     |     ) internal pure returns (uint256 pods) {
 416 |     |         pods = beans.mulDiv(_morningTemperature.add(ONE_HUNDRED_TEMP), ONE_HUNDRED_TEMP);
 417 |     |     }
 418 |     | 
 419 |     |     /**
 420 |     |      * @dev Scales Soil up when Beanstalk is above peg.
 421 |     |      * `(1 + maxTemperature) / (1 + morningTemperature)`
 422 |     |      */
 423 |     |     function scaleSoilUp(
 424 |     |         uint256 soil,
 425 |     |         uint256 maxTemperature,
 426 |     |         uint256 _morningTemperature
 427 |     |     ) internal pure returns (uint256) {
 428 |     |         return
 429 |     |             soil.mulDiv(
 430 |     |                 maxTemperature.add(ONE_HUNDRED_TEMP),
 431 |     |                 _morningTemperature.add(ONE_HUNDRED_TEMP)
 432 |     |             );
 433 |     |     }
 434 |     | 
 435 |     |     /**
 436 |     |      * @dev Scales Soil down when Beanstalk is above peg.
 437 |     |      *
 438 |     |      * When Beanstalk is above peg, the Soil issued changes. Example:
 439 |     |      *
 440 |     |      * If 500 Soil is issued when `s.weather.temp = 100e6 = 100%`
 441 |     |      * At delta = 0:
 442 |     |      *  morningTemperature() = 1%
 443 |     |      *  Soil = `500*(100 + 100%)/(100 + 1%)` = 990.09901 soil
 444 |     |      *
 445 |     |      * If someone sow'd ~495 soil, it's equilivant to sowing 250 soil at t > 25.
 446 |     |      * Thus when someone sows during this time, the amount subtracted from s.sys.soil
 447 |     |      * should be scaled down.
 448 |     |      *
 449 |     |      * Note: param ordering matches the mulDiv operation
 450 |     |      */
 451 |     |     function scaleSoilDown(
 452 |     |         uint256 soil,
 453 |     |         uint256 _morningTemperature,
 454 |     |         uint256 maxTemperature
 455 |     |     ) internal pure returns (uint256) {
 456 |     |         return
 457 |     |             soil.mulDiv(
 458 |     |                 _morningTemperature.add(ONE_HUNDRED_TEMP),
 459 |     |                 maxTemperature.add(ONE_HUNDRED_TEMP),
 460 |     |                 LibPRBMathRoundable.Rounding.Up
 461 |     |             );
 462 |     |     }
 463 |     | 
 464 |     |     /**
 465 |     |      * @notice Returns the remaining Pods that could be issued this Season.
 466 |     |      */
 467 |     |     function remainingPods() internal view returns (uint256) {
 468 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 469 |     | 
 470 |     |         // Above peg: number of Pods is fixed, Soil adjusts
 471 |     |         if (s.sys.season.abovePeg) {
 472 |     |             return
 473 |     |                 beansToPods(
 474 |     |                     s.sys.soil, // 1 bean = 1 soil
 475 |     |                     uint256(s.sys.weather.temp)
 476 |     |                 );
 477 |     |         } else {
 478 |     |             // Below peg: amount of Soil is fixed, temperature adjusts
 479 |     |             return
 480 |     |                 beansToPods(
 481 |     |                     s.sys.soil, // 1 bean = 1 soil
 482 |     |                     morningTemperature()
 483 |     |                 );
 484 |     |         }
 485 |     |     }
 486 |     | 
 487 |     |     /**
 488 |     |      * @notice removes a plot index from an accounts plotIndex list.
 489 |     |      */
 490 |     |     function removePlotIndexFromAccount(
 491 |     |         address account,
 492 |     |         uint256 fieldId,
 493 |     |         uint256 plotIndex
 494 |     |     ) internal {
 495 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 496 |     |         uint256 i = findPlotIndexForAccount(account, fieldId, plotIndex);
 497 |     |         Field storage field = s.accts[account].fields[fieldId];
 498 |     |         field.plotIndexes[i] = field.plotIndexes[field.plotIndexes.length - 1];
 499 |     |         field.piIndex[field.plotIndexes[i]] = i;
 500 |     |         field.piIndex[plotIndex] = type(uint256).max;
 501 |     |         field.plotIndexes.pop();
 502 |     |     }
 503 |     | 
 504 |     |     /**
 505 |     |      * @notice finds the index of a plot in an accounts plotIndex list.
 506 |     |      */
 507 |     |     function findPlotIndexForAccount(
 508 |     |         address account,
 509 |     |         uint256 fieldId,
 510 |     |         uint256 plotIndex
 511 |     |     ) internal view returns (uint256 i) {
 512 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 513 |     |         return s.accts[account].fields[fieldId].piIndex[plotIndex];
 514 |     |     }
 515 |     | }
 516 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibEvaluate.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
   6 |     | import {LibWhitelistedTokens, C} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
   9 |     | import {LibWell, IERC20Decimals} from "contracts/libraries/Well/LibWell.sol";
  10 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  11 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  12 |     | import {LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
  13 |     | import {Implementation} from "contracts/beanstalk/storage/System.sol";
  14 |     | import {System, EvaluationParameters, Weather} from "contracts/beanstalk/storage/System.sol";
  15 |     | import {ILiquidityWeightFacet} from "contracts/beanstalk/facets/sun/LiquidityWeightFacet.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title LibEvaluate calculates the caseId based on the state of Beanstalk.
  19 |     |  * @dev the current parameters that beanstalk uses to evaluate its state are:
  20 |     |  * - DeltaB, the amount of Beans needed to be bought/sold to reach peg.
  21 |     |  * - PodRate, the ratio of Pods outstanding against the bean supply.
  22 |     |  * - Delta Soil demand, the change in demand of Soil between the current and previous Season.
  23 |     |  * - LpToSupplyRatio (L2SR), the ratio of liquidity to the circulating Bean supply.
  24 |     |  *
  25 |     |  * based on the caseId, Beanstalk adjusts:
  26 |     |  * - the Temperature
  27 |     |  * - the ratio of the gaugePoints per BDV of bean and the largest GpPerBdv for a given LP token.
  28 |     |  */
  29 |     | 
  30 | *   | library DecimalExtended {
  31 |     |     uint256 private constant PERCENT_BASE = 1e18;
  32 |     | 
  33 |     |     function toDecimal(uint256 a) internal pure returns (Decimal.D256 memory) {
  34 |     |         return Decimal.D256({value: a});
  35 |     |     }
  36 |     | }
  37 |     | 
  38 | *   | library LibEvaluate {
  39 |     |     using LibRedundantMath256 for uint256;
  40 |     |     using DecimalExtended for uint256;
  41 |     |     using Decimal for Decimal.D256;
  42 |     |     using LibRedundantMath32 for uint32;
  43 |     | 
  44 |     |     /// @dev If all Soil is Sown faster than this, Beanstalk considers demand for Soil to be increasing.
  45 |     |     uint256 internal constant SOW_TIME_DEMAND_INCR = 1200; // seconds
  46 |     |     uint32 internal constant SOW_TIME_STEADY_LOWER = 300; // seconds, lower means closer to the bottom of the hour
  47 |     |     uint32 internal constant SOW_TIME_STEADY_UPPER = 300; // seconds, upper means closer to the top of the hour
  48 |     |     uint256 internal constant LIQUIDITY_PRECISION = 1e12;
  49 |     |     uint256 internal constant HIGH_DEMAND_THRESHOLD = 1e18;
  50 |     | 
  51 |     |     struct BeanstalkState {
  52 |     |         Decimal.D256 deltaPodDemand;
  53 |     |         Decimal.D256 lpToSupplyRatio;
  54 |     |         Decimal.D256 podRate;
  55 |     |         address largestLiqWell;
  56 |     |         bool oracleFailure;
  57 |     |         uint256 largestLiquidWellTwapBeanPrice;
  58 |     |         int256 twaDeltaB;
  59 |     |     }
  60 |     | 
  61 |     |     event SeasonMetrics(
  62 |     |         uint256 indexed season,
  63 |     |         uint256 deltaPodDemand,
  64 |     |         uint256 lpToSupplyRatio,
  65 |     |         uint256 podRate,
  66 |     |         uint256 thisSowTime,
  67 |     |         uint256 lastSowTime
  68 |     |     );
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice evaluates the pod rate and returns the caseId
  72 |     |      * @param podRate the length of the podline (debt), divided by the bean supply.
  73 |     |      */
  74 |     |     function evalPodRate(Decimal.D256 memory podRate) internal view returns (uint256 caseId) {
  75 |     |         EvaluationParameters storage ep = LibAppStorage.diamondStorage().sys.evaluationParameters;
  76 |     |         if (podRate.greaterThanOrEqualTo(ep.podRateUpperBound.toDecimal())) {
  77 |     |             caseId = 27;
  78 |     |         } else if (podRate.greaterThanOrEqualTo(ep.podRateOptimal.toDecimal())) {
  79 |     |             caseId = 18;
  80 |     |         } else if (podRate.greaterThanOrEqualTo(ep.podRateLowerBound.toDecimal())) {
  81 |     |             caseId = 9;
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice updates the caseId based on the price of bean (deltaB)
  87 |     |      * @param deltaB the amount of beans needed to be sold or bought to get bean to peg.
  88 |     |      * @param beanUsdPrice the price of bean in USD.
  89 |     |      */
  90 |     |     function evalPrice(int256 deltaB, uint256 beanUsdPrice) internal view returns (uint256 caseId) {
  91 |     |         EvaluationParameters storage ep = LibAppStorage.diamondStorage().sys.evaluationParameters;
  92 |     |         if (deltaB > 0) {
  93 |     |             if (beanUsdPrice > ep.excessivePriceThreshold) {
  94 |     |                 // p > excessivePriceThreshold
  95 |     |                 return caseId = 6;
  96 |     |             }
  97 |     | 
  98 |     |             caseId = 3;
  99 |     |         }
 100 |     |         // p < 1 (caseId = 0)
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Updates the caseId based on the change in Soil demand.
 105 |     |      * @param deltaPodDemand The change in Soil demand from the previous Season.
 106 |     |      */
 107 |     |     function evalDeltaPodDemand(
 108 |     |         Decimal.D256 memory deltaPodDemand
 109 |     |     ) internal view returns (uint256 caseId) {
 110 |     |         EvaluationParameters storage ep = LibAppStorage.diamondStorage().sys.evaluationParameters;
 111 |     |         // increasing
 112 |     |         if (deltaPodDemand.greaterThanOrEqualTo(ep.deltaPodDemandUpperBound.toDecimal())) {
 113 |     |             caseId = 2;
 114 |     |             // steady
 115 |     |         } else if (deltaPodDemand.greaterThanOrEqualTo(ep.deltaPodDemandLowerBound.toDecimal())) {
 116 |     |             caseId = 1;
 117 |     |         }
 118 |     |         // decreasing (caseId = 0)
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @notice Evaluates the lp to supply ratio and returns the caseId.
 123 |     |      * @param lpToSupplyRatio The ratio of liquidity to supply.
 124 |     |      *
 125 |     |      * @dev 'liquidity' is definied as the non-bean value in a pool that trades beans.
 126 |     |      */
 127 |     |     function evalLpToSupplyRatio(
 128 |     |         Decimal.D256 memory lpToSupplyRatio
 129 |     |     ) internal view returns (uint256 caseId) {
 130 |     |         EvaluationParameters storage ep = LibAppStorage.diamondStorage().sys.evaluationParameters;
 131 |     |         // Extremely High
 132 |     |         if (lpToSupplyRatio.greaterThanOrEqualTo(ep.lpToSupplyRatioUpperBound.toDecimal())) {
 133 |     |             caseId = 108;
 134 |     |             // Reasonably High
 135 |     |         } else if (lpToSupplyRatio.greaterThanOrEqualTo(ep.lpToSupplyRatioOptimal.toDecimal())) {
 136 |     |             caseId = 72;
 137 |     |             // Reasonably Low
 138 |     |         } else if (lpToSupplyRatio.greaterThanOrEqualTo(ep.lpToSupplyRatioLowerBound.toDecimal())) {
 139 |     |             caseId = 36;
 140 |     |         }
 141 |     |         // excessively low (caseId = 0)
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Calculates the change in soil demand from the previous season.
 146 |     |      * @param dsoil The amount of soil sown this season.
 147 |     |      */
 148 |     |     function calcDeltaPodDemand(
 149 |     |         uint256 dsoil
 150 |     |     )
 151 |     |         internal
 152 |     |         view
 153 |     |         returns (Decimal.D256 memory deltaPodDemand, uint32 lastSowTime, uint32 thisSowTime)
 154 |     |     {
 155 |     |         Weather storage w = LibAppStorage.diamondStorage().sys.weather;
 156 |     |         // not enough soil sown, consider demand to be decreasing, reset sow times.
 157 |     |         if (dsoil < LibAppStorage.diamondStorage().sys.extEvaluationParameters.minSoilSownDemand) {
 158 |     |             return (Decimal.zero(), w.thisSowTime, type(uint32).max);
 159 |     |         }
 160 |     | 
 161 |     |         deltaPodDemand = getDemand(dsoil, w.lastDeltaSoil);
 162 |     | 
 163 |     |         // `s.weather.thisSowTime` is set to the number of seconds in it took for
 164 |     |         // Soil to sell out during the current Season. If Soil didn't sell out,
 165 |     |         // it remains `type(uint32).max`.
 166 |     |         if (w.thisSowTime < type(uint32).max) {
 167 |     |             if (
 168 |     |                 w.lastSowTime == type(uint32).max || // Didn't Sow all last Season
 169 |     |                 w.thisSowTime < SOW_TIME_DEMAND_INCR || // Sow'd all instantly this Season
 170 |     |                 (w.lastSowTime > SOW_TIME_STEADY_UPPER &&
 171 |     |                     w.thisSowTime < w.lastSowTime.sub(SOW_TIME_STEADY_LOWER)) // Sow'd all faster
 172 |     |             ) {
 173 |     |                 deltaPodDemand = Decimal.from(HIGH_DEMAND_THRESHOLD);
 174 |     |             } else if (w.thisSowTime <= w.lastSowTime.add(SOW_TIME_STEADY_UPPER)) {
 175 |     |                 // Soil sold out in the same time.
 176 |     |                 // set a floor for demand to be steady (i.e, demand can either be steady or increasing)
 177 |     |                 if (deltaPodDemand.lessThan(Decimal.one())) {
 178 |     |                     deltaPodDemand = Decimal.one();
 179 |     |                 }
 180 |     |             }
 181 |     |         }
 182 |     |         // if the soil didn't sell out, or sold out slower than the previous season,
 183 |     |         // demand for soil is a function of the amount of soil sown this season.
 184 |     | 
 185 |     |         lastSowTime = w.thisSowTime; // Overwrite last Season
 186 |     |         thisSowTime = type(uint32).max; // Reset for next Season
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @notice Calculates the change in soil demand from the previous season.
 191 |     |      * @param soilSownThisSeason The amount of soil sown this season.
 192 |     |      * @param soilSownLastSeason The amount of soil sown in the previous season.
 193 |     |      */
 194 |     |     function getDemand(
 195 |     |         uint256 soilSownThisSeason,
 196 |     |         uint256 soilSownLastSeason
 197 |     |     ) internal view returns (Decimal.D256 memory deltaPodDemand) {
 198 |     |         if (soilSownThisSeason == 0) {
 199 |     |             deltaPodDemand = Decimal.zero(); // If no one Sow'd this season, ∆ demand is 0.
 200 |     |         } else if (soilSownLastSeason == 0) {
 201 |     |             deltaPodDemand = Decimal.from(HIGH_DEMAND_THRESHOLD); // If no one Sow'd last Season, ∆ demand is infinite.
 202 |     |         } else {
 203 |     |             // If both seasons had some soil sown, ∆ demand is the ratio of this season's soil sown to last season's soil sown.
 204 |     |             deltaPodDemand = Decimal.ratio(soilSownThisSeason, soilSownLastSeason);
 205 |     |         }
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @notice Calculates the liquidity to supply ratio, where liquidity is measured in USD.
 210 |     |      * @param beanSupply The total supply of Beans.
 211 |     |      * corresponding to the well addresses in the whitelist.
 212 |     |      * @dev No support for non-well AMMs at this time.
 213 |     |      */
 214 |     |     function calcLPToSupplyRatio(
 215 |     |         uint256 beanSupply
 216 |     |     )
 217 |     |         internal
 218 |     |         view
 219 |     |         returns (Decimal.D256 memory lpToSupplyRatio, address largestLiqWell, bool oracleFailure)
 220 |     |     {
 221 |     |         // prevent infinite L2SR
 222 |     |         if (beanSupply == 0) return (Decimal.zero(), address(0), true);
 223 |     | 
 224 |     |         address[] memory pools = LibWhitelistedTokens.getWhitelistedLpTokens();
 225 |     |         uint256[] memory twaReserves;
 226 |     |         uint256 totalUsdLiquidity;
 227 |     |         uint256 largestLiq;
 228 |     |         uint256 wellLiquidity;
 229 |     |         for (uint256 i; i < pools.length; i++) {
 230 |     |             // get the non-bean value in an LP.
 231 |     |             twaReserves = LibWell.getTwaReservesFromStorageOrBeanstalkPump(pools[i]);
 232 |     |             // if the twaReserves are 0, the well has no liquidity and thus can be skipped
 233 |     |             if (twaReserves[0] == 0 && twaReserves[1] == 0) continue;
 234 |     |             // calculate the non-bean usd liquidity value.
 235 |     |             uint256 usdLiquidity = LibWell.getWellTwaUsdLiquidityFromReserves(
 236 |     |                 pools[i],
 237 |     |                 twaReserves
 238 |     |             );
 239 |     | 
 240 |     |             // if the usdliquidity is 0, beanstalk assumes oracle failure.
 241 |     |             if (usdLiquidity == 0) {
 242 |     |                 oracleFailure = true;
 243 |     |             }
 244 |     | 
 245 |     |             // calculate the scaled, non-bean liquidity in the pool.
 246 |     |             wellLiquidity = getLiquidityWeight(pools[i]).mul(usdLiquidity).div(1e18);
 247 |     | 
 248 |     |             // if the liquidity is the largest, update `largestLiqWell`,
 249 |     |             // and add the liquidity to the total.
 250 |     |             // `largestLiqWell` is only used to initialize `s.sopWell` upon a sop,
 251 |     |             // but a hot storage load to skip the block below
 252 |     |             // is significantly more expensive than performing the logic on every sunrise.
 253 |     |             if (wellLiquidity > largestLiq) {
 254 |     |                 largestLiq = wellLiquidity;
 255 |     |                 largestLiqWell = pools[i];
 256 |     |             }
 257 |     | 
 258 |     |             totalUsdLiquidity = totalUsdLiquidity.add(wellLiquidity);
 259 |     | 
 260 |     |             // If a new non-Well LP is added, functionality to calculate the USD value of the
 261 |     |             // liquidity should be added here.
 262 |     |         }
 263 |     | 
 264 |     |         // if there is no liquidity,
 265 |     |         // return 0 to save gas.
 266 |     |         if (totalUsdLiquidity == 0) return (Decimal.zero(), address(0), true);
 267 |     | 
 268 |     |         // USD liquidity is scaled down from 1e18 to match Bean precision (1e6).
 269 |     |         lpToSupplyRatio = Decimal.ratio(totalUsdLiquidity.div(LIQUIDITY_PRECISION), beanSupply);
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @notice Get the deltaPodDemand, lpToSupplyRatio, and podRate, and update soil demand
 274 |     |      * parameters.
 275 |     |      */
 276 |     |     function updateAndGetBeanstalkState(
 277 |     |         uint256 beanSupply
 278 |     |     ) internal returns (BeanstalkState memory bs) {
 279 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 280 |     |         // Calculate Delta Soil Demand
 281 |     |         uint256 dsoil = s.sys.beanSown;
 282 |     |         s.sys.beanSown = 0;
 283 |     |         (
 284 |     |             bs.deltaPodDemand,
 285 |     |             s.sys.weather.lastSowTime,
 286 |     |             s.sys.weather.thisSowTime
 287 |     |         ) = calcDeltaPodDemand(dsoil);
 288 |     |         s.sys.weather.lastDeltaSoil = uint128(dsoil); // SafeCast not necessary as `s.beanSown` is uint128.
 289 |     | 
 290 |     |         // Calculate Lp To Supply Ratio, fetching the twaReserves in storage:
 291 |     |         (bs.lpToSupplyRatio, bs.largestLiqWell, bs.oracleFailure) = calcLPToSupplyRatio(beanSupply);
 292 |     | 
 293 |     |         // Calculate PodRate
 294 |     |         bs.podRate = Decimal.ratio(
 295 |     |             s.sys.fields[s.sys.activeField].pods.sub(s.sys.fields[s.sys.activeField].harvestable),
 296 |     |             beanSupply
 297 |     |         ); // Pod Rate
 298 |     | 
 299 |     |         // Get Token:Bean Price using largest liquidity well
 300 |     |         bs.largestLiquidWellTwapBeanPrice = LibWell.getBeanUsdPriceForWell(bs.largestLiqWell);
 301 |     | 
 302 |     |         emit SeasonMetrics(
 303 |     |             s.sys.season.current,
 304 |     |             bs.deltaPodDemand.value,
 305 |     |             bs.lpToSupplyRatio.value,
 306 |     |             bs.podRate.value,
 307 |     |             s.sys.weather.thisSowTime,
 308 |     |             s.sys.weather.lastSowTime
 309 |     |         );
 310 |     |     }
 311 |     | 
 312 |     |     /**
 313 |     |      * @notice Evaluates beanstalk based on deltaB, podRate, deltaPodDemand and lpToSupplyRatio.
 314 |     |      * and returns the associated caseId.
 315 |     |      */
 316 |     |     function evaluateBeanstalk(
 317 |     |         int256 deltaB,
 318 |     |         uint256 beanSupply
 319 |     |     ) external returns (uint256, BeanstalkState memory) {
 320 |     |         BeanstalkState memory bs = updateAndGetBeanstalkState(beanSupply);
 321 |     |         bs.twaDeltaB = deltaB;
 322 |     |         uint256 caseId = evalPodRate(bs.podRate) // Evaluate Pod Rate
 323 |     |             .add(evalPrice(deltaB, bs.largestLiquidWellTwapBeanPrice))
 324 |     |             .add(evalDeltaPodDemand(bs.deltaPodDemand))
 325 |     |             .add(evalLpToSupplyRatio(bs.lpToSupplyRatio)); // Evaluate Price // Evaluate Delta Soil Demand // Evaluate LP to Supply Ratio
 326 |     |         return (caseId, bs);
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @notice calculates the liquidity weight of a token.
 331 |     |      * @dev the liquidity weight determines the percentage of
 332 |     |      * liquidity that is used in evaluating the liquidity of bean.
 333 |     |      * At 0, no liquidity is added. at 1e18, all liquidity is added.
 334 |     |      * The function must be a non state, viewable function that returns a uint256.
 335 |     |      * if failure, returns 0 (no liquidity is considered) instead of reverting.
 336 |     |      * if the pool does not have a target, uses address(this).
 337 |     |      */
 338 |     |     function getLiquidityWeight(address pool) internal view returns (uint256 liquidityWeight) {
 339 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 340 |     |         Implementation memory lw = s.sys.silo.assetSettings[pool].liquidityWeightImplementation;
 341 |     | 
 342 |     |         // if the target is 0, use address(this).
 343 |     |         address target = lw.target;
 344 |     |         if (target == address(0)) target = address(this);
 345 |     | 
 346 |     |         (bool success, bytes memory data) = target.staticcall(
 347 |     |             abi.encodeWithSelector(lw.selector, lw.data)
 348 |     |         );
 349 |     | 
 350 |     |         if (!success) return 0;
 351 |     |         assembly {
 352 |     |             liquidityWeight := mload(add(data, add(0x20, 0)))
 353 |     |         }
 354 |     |     }
 355 |     | }
 356 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibFarm.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {LibFunction} from "./LibFunction.sol";
  8 |     | import {LibClipboard} from "./LibClipboard.sol";
  9 |     | import {AppStorage, LibAppStorage} from "./LibAppStorage.sol";
 10 |     | import {C} from "contracts/C.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title Farm Lib
 14 |     |  * @notice Perform multiple Beanstalk functions calls in a single transaction using Farm calls.
 15 |     |  * Any function stored in Beanstalk's EIP-2535 DiamondStorage can be called as a Farm call. (https://eips.ethereum.org/EIPS/eip-2535)
 16 |     |  **/
 17 |     | 
 18 |     | // AdvancedFarmCall is a Farm call that can use a Clipboard.
 19 |     | // See LibFunction.useClipboard for details
 20 |     | struct AdvancedFarmCall {
 21 |     |     bytes callData;
 22 |     |     bytes clipboard;
 23 |     | }
 24 |     | 
 25 | *   | library LibFarm {
 26 |     |     /**
 27 |     |      * @notice Delegatecall an external facing Beanstalk function, optionally using a clipboard.
 28 |     |      * @param data The calldata of the call.
 29 |     |      * @param returnData The return data of all previous calls.
 30 |     |      */
 31 |     |     function _advancedFarm(
 32 |     |         AdvancedFarmCall memory data,
 33 |     |         bytes[] memory returnData
 34 |     |     ) internal returns (bytes memory result) {
 35 |     |         bytes1 pipeType = data.clipboard.length == 0 ? bytes1(0) : data.clipboard[0];
 36 |     |         // 0x00 -> Static Call - Execute static call
 37 |     |         // else > Advanced Call - Use clipboard on and execute call.
 38 |     |         if (pipeType == 0x00) {
 39 |     |             result = _farm(data.callData);
 40 |     |         } else {
 41 |     |             bytes memory callData = LibClipboard.useClipboard(
 42 |     |                 data.callData,
 43 |     |                 data.clipboard,
 44 |     |                 returnData
 45 |     |             );
 46 |     |             result = _farm(callData);
 47 |     |         }
 48 |     |     }
 49 |     | 
 50 |     |     /**
 51 |     |      * @notice Delegatecall an external facing Beanstalk function.
 52 |     |      * @param data The calldata of the call.
 53 |     |      */
 54 |     |     function _farm(bytes memory data) internal returns (bytes memory result) {
 55 |     |         bytes4 selector;
 56 |     |         bool success;
 57 |     |         assembly {
 58 |     |             selector := mload(add(data, 32))
 59 |     |         }
 60 |     |         address facet = LibFunction.facetForSelector(selector);
 61 |     |         (success, result) = _beanstalkCall(facet, data);
 62 |     |         LibFunction.checkReturn(success, result);
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @notice Swap reentrancy locks, such that standard reentrant is unlocked and farming is locked.
 67 |     |      * @dev All Beanstalk write functions should be nonReentrant, immediately returning reentrant status to entered.
 68 |     |      * @dev This logic pertains to ReentrancyGuard, but Solidity limitations require it to be be placed here.
 69 |     |      * @param facet The address of the facet containing the function to call.
 70 |     |      * @param data The calldata of the call.
 71 |     |      */
 72 |     |     function _beanstalkCall(
 73 |     |         address facet,
 74 |     |         bytes memory data
 75 |     |     ) private returns (bool success, bytes memory result) {
 76 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 77 |     | 
 78 |     |         // Verify that farm reentrancy is already protected.
 79 |     |         require(s.sys.farmingStatus == C.ENTERED, "Unprotected farm call");
 80 |     | 
 81 |     |         // Temporarily unlock non-farming reentrancy to allow a single Beanstalk call.
 82 |     |         s.sys.reentrantStatus = C.NOT_ENTERED;
 83 |     |         (success, result) = facet.delegatecall(data);
 84 |     |         s.sys.reentrantStatus = C.ENTERED;
 85 |     |     }
 86 |     | }
 87 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibFunction.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {LibDiamond} from "./LibDiamond.sol";
  8 |     | import {AdvancedFarmCall} from "./LibFarm.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title Lib Function
 12 |     |  **/
 13 |     | 
 14 | *   | library LibFunction {
 15 |     |     /**
 16 |     |      * @notice Checks The return value of a any function call for success, if not returns the error returned in `results`
 17 |     |      * @param success Whether the corresponding function call succeeded
 18 |     |      * @param result The return data of the corresponding function call
 19 |     |      **/
 20 |     |     function checkReturn(bool success, bytes memory result) internal pure {
 21 |     |         if (!success) {
 22 |     |             // Next 5 lines from https://ethereum.stackexchange.com/a/83577
 23 |     |             // Also, used in Uniswap V3 https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol#L17
 24 |     |             if (result.length < 68) revert();
 25 |     |             assembly {
 26 |     |                 result := add(result, 0x04)
 27 |     |             }
 28 |     |             revert(abi.decode(result, (string)));
 29 |     |         }
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Gets the facet address for a given selector
 34 |     |      * @param selector The function selector to fetch the facet address for
 35 |     |      * @dev Fails if no set facet address
 36 |     |      * @return facet The facet address
 37 |     |      **/
 38 |     |     function facetForSelector(bytes4 selector) internal view returns (address facet) {
 39 |     |         LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
 40 |     |         facet = ds.selectorToFacetAndPosition[selector].facetAddress;
 41 |     |         require(facet != address(0), "Diamond: Function does not exist");
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibGauge.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {LibAppStorage} from "./LibAppStorage.sol";
   8 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   9 |     | import {AssetSettings} from "contracts/beanstalk/storage/System.sol";
  10 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  11 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  12 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  13 |     | import {LibWhitelist} from "contracts/libraries/Silo/LibWhitelist.sol";
  14 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  15 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  16 |     | import {IGaugeFacet} from "contracts/beanstalk/facets/sun/GaugeFacet.sol";
  17 |     | /**
  18 |     |  * @title LibGauge
  19 |     |  * @notice LibGauge handles functionality related to the seed gauge system.
  20 |     |  */
  21 | *   | library LibGauge {
  22 |     |     using SafeCast for uint256;
  23 |     |     using LibRedundantMath256 for uint256;
  24 |     |     using LibRedundantMath32 for uint32;
  25 |     | 
  26 |     |     uint256 internal constant BDV_PRECISION = 1e6;
  27 |     |     uint256 internal constant GP_PRECISION = 1e18;
  28 |     |     uint256 internal constant GROWN_STALK_PER_GP_PRECISION = 1e6;
  29 |     |     uint256 internal constant OPTIMAL_DEPOSITED_BDV_PERCENT = 100e6;
  30 |     | 
  31 |     |     // The maximum value of beanToMaxLpGpPerBdvRatio.
  32 |     |     uint256 internal constant ONE_HUNDRED_PERCENT = 100e18;
  33 |     | 
  34 |     |     // 24 * 30 * 6
  35 |     |     // uint256 internal constant TARGET_SEASONS_TO_CATCHUP = 4320; //state
  36 |     |     uint256 internal constant STALK_BDV_PRECISION = 1e10;
  37 |     | 
  38 |     |     /**
  39 |     |      * @notice Emitted when the AverageGrownStalkPerBdvPerSeason Updates.
  40 |     |      */
  41 |     |     event UpdateAverageStalkPerBdvPerSeason(uint256 newStalkPerBdvPerSeason);
  42 |     | 
  43 |     |     struct LpGaugePointData {
  44 |     |         address lpToken;
  45 |     |         uint256 gpPerBdv;
  46 |     |     }
  47 |     |     /**
  48 |     |      * @notice Emitted when the gaugePoints for an LP silo token changes.
  49 |     |      * @param season The current Season
  50 |     |      * @param token The LP silo token whose gaugePoints was updated.
  51 |     |      * @param gaugePoints The new gaugePoints for the LP silo token.
  52 |     |      */
  53 |     |     event GaugePointChange(uint256 indexed season, address indexed token, uint256 gaugePoints);
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Updates the seed gauge system.
  57 |     |      * @dev Updates the GaugePoints for LP assets (if applicable)
  58 |     |      * and the distribution of grown Stalk to silo assets.
  59 |     |      *
  60 |     |      * If any of the LP price oracle failed,
  61 |     |      * then the gauge system should be skipped, as a valid
  62 |     |      * usd liquidity value cannot be computed.
  63 |     |      */
  64 |     |     function stepGauge() external {
  65 |     |         (
  66 |     |             uint256 maxLpGpPerBdv,
  67 |     |             LpGaugePointData[] memory lpGpData,
  68 |     |             uint256 totalGaugePoints,
  69 |     |             uint256 totalLpBdv
  70 |     |         ) = updateGaugePoints();
  71 |     | 
  72 |     |         // If totalLpBdv is max, it means that the gauge points has failed,
  73 |     |         // and the gauge system should be skipped.
  74 |     |         if (totalLpBdv == type(uint256).max) return;
  75 |     | 
  76 |     |         updateGrownStalkEarnedPerSeason(maxLpGpPerBdv, lpGpData, totalGaugePoints, totalLpBdv);
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @notice Evaluate the gauge points of each LP asset.
  81 |     |      * @dev `totalLpBdv` is returned as type(uint256).max when an Oracle failure occurs.
  82 |     |      */
  83 |     |     function updateGaugePoints()
  84 |     |         internal
  85 |     |         returns (
  86 |     |             uint256 maxLpGpPerBdv,
  87 |     |             LpGaugePointData[] memory lpGpData,
  88 |     |             uint256 totalGaugePoints,
  89 |     |             uint256 totalLpBdv
  90 |     |         )
  91 |     |     {
  92 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  93 |     |         address[] memory whitelistedLpTokens = LibWhitelistedTokens.getWhitelistedLpTokens();
  94 |     |         lpGpData = new LpGaugePointData[](whitelistedLpTokens.length);
  95 |     |         // If there is only one pool, there is no need to update the gauge points.
  96 |     |         if (whitelistedLpTokens.length == 1) {
  97 |     |             // If the usd price oracle failed, skip gauge point update.
  98 |     |             // Assumes that only Wells use USD price oracles.
  99 |     |             if (
 100 |     |                 LibWell.isWell(whitelistedLpTokens[0]) &&
 101 |     |                 s.sys.usdTokenPrice[whitelistedLpTokens[0]] == 0
 102 |     |             ) {
 103 |     |                 return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);
 104 |     |             }
 105 |     |             uint256 gaugePoints = s.sys.silo.assetSettings[whitelistedLpTokens[0]].gaugePoints;
 106 |     | 
 107 |     |             lpGpData[0].lpToken = whitelistedLpTokens[0];
 108 |     |             // If nothing has been deposited, skip gauge point update.
 109 |     |             uint128 depositedBdv = s.sys.silo.balances[whitelistedLpTokens[0]].depositedBdv;
 110 |     |             if (depositedBdv == 0)
 111 |     |                 return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);
 112 |     |             lpGpData[0].gpPerBdv = gaugePoints.mul(BDV_PRECISION).div(
 113 |     |                 s.sys.silo.balances[whitelistedLpTokens[0]].depositedBdv
 114 |     |             );
 115 |     |             return (
 116 |     |                 lpGpData[0].gpPerBdv,
 117 |     |                 lpGpData,
 118 |     |                 gaugePoints,
 119 |     |                 s.sys.silo.balances[whitelistedLpTokens[0]].depositedBdv
 120 |     |             );
 121 |     |         }
 122 |     | 
 123 |     |         // Summate total deposited BDV across all whitelisted LP tokens.
 124 |     |         uint256 totalOptimalDepositedBdvPercent;
 125 |     |         for (uint256 i; i < whitelistedLpTokens.length; ++i) {
 126 |     |             // Assumes that only Wells use USD price oracles.
 127 |     |             if (
 128 |     |                 LibWell.isWell(whitelistedLpTokens[i]) &&
 129 |     |                 s.sys.usdTokenPrice[whitelistedLpTokens[i]] == 0
 130 |     |             ) {
 131 |     |                 return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);
 132 |     |             }
 133 |     |             uint256 depositedBdv = s.sys.silo.balances[whitelistedLpTokens[i]].depositedBdv;
 134 |     |             if (depositedBdv > 0) {
 135 |     |                 AssetSettings storage ss = s.sys.silo.assetSettings[whitelistedLpTokens[i]];
 136 |     |                 totalLpBdv = totalLpBdv.add(depositedBdv);
 137 |     |                 totalOptimalDepositedBdvPercent = totalOptimalDepositedBdvPercent.add(
 138 |     |                     ss.optimalPercentDepositedBdv
 139 |     |                 );
 140 |     |             }
 141 |     |         }
 142 |     | 
 143 |     |         // If nothing has been deposited, skip gauge point update.
 144 |     |         if (totalLpBdv == 0) return (maxLpGpPerBdv, lpGpData, totalGaugePoints, type(uint256).max);
 145 |     |         // Calculate and update the gauge points for each LP.
 146 |     |         // If the depositedBdv is 0, then the gauge points are not included in the total.
 147 |     |         for (uint256 i; i < whitelistedLpTokens.length; ++i) {
 148 |     |             AssetSettings storage ss = s.sys.silo.assetSettings[whitelistedLpTokens[i]];
 149 |     |             uint256 depositedBdv = s.sys.silo.balances[whitelistedLpTokens[i]].depositedBdv;
 150 |     | 
 151 |     |             // 1e6 = 1%
 152 |     |             uint256 percentDepositedBdv = depositedBdv.mul(100e6).div(totalLpBdv);
 153 |     | 
 154 |     |             uint256 gpPerBdv;
 155 |     |             uint256 newGaugePoints = ss.gaugePoints;
 156 |     |             // If the token does not have any deposited BDV, the gauge points are not updated.
 157 |     |             if (depositedBdv > 0) {
 158 |     |                 // Calculate the new gauge points of the token.
 159 |     |                 newGaugePoints = calcGaugePoints(
 160 |     |                     ss,
 161 |     |                     percentDepositedBdv,
 162 |     |                     totalOptimalDepositedBdvPercent
 163 |     |                 );
 164 |     |                 // Increment totalGaugePoints and calculate the gaugePoints per BDV:
 165 |     |                 totalGaugePoints = totalGaugePoints.add(newGaugePoints);
 166 |     |                 gpPerBdv = newGaugePoints.mul(BDV_PRECISION).div(depositedBdv);
 167 |     |             }
 168 |     | 
 169 |     |             // Gauge points has 18 decimal precision (GP_PRECISION = 1%)
 170 |     |             // Deposited BDV has 6 decimal precision (1e6 = 1 unit of BDV)
 171 |     |             // gpPerBdv has 18 decimal precision.
 172 |     |             if (gpPerBdv > maxLpGpPerBdv) maxLpGpPerBdv = gpPerBdv;
 173 |     |             lpGpData[i] = LpGaugePointData({lpToken: whitelistedLpTokens[i], gpPerBdv: gpPerBdv});
 174 |     | 
 175 |     |             ss.gaugePoints = newGaugePoints.toUint128();
 176 |     |             emit GaugePointChange(s.sys.season.current, whitelistedLpTokens[i], newGaugePoints);
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     /**
 181 |     |      * @notice calculates the new gauge points, given the silo settings and the percent deposited BDV.
 182 |     |      * @param ss siloSettings of the token.
 183 |     |      * @param percentDepositedBdv the current percentage of the total LP deposited BDV for the token.
 184 |     |      * @param totalOptimalDepositedBdvPercent the total optimal deposited BDV percent for all LP tokens.
 185 |     |      */
 186 |     |     function calcGaugePoints(
 187 |     |         AssetSettings memory ss,
 188 |     |         uint256 percentDepositedBdv,
 189 |     |         uint256 totalOptimalDepositedBdvPercent
 190 |     |     ) internal view returns (uint256 newGaugePoints) {
 191 |     |         // if the target is 0, use address(this).
 192 |     |         address target = ss.gaugePointImplementation.target;
 193 |     |         if (target == address(0)) {
 194 |     |             target = address(this);
 195 |     |         }
 196 |     |         // if no selector is provided, use defaultGaugePoints
 197 |     |         bytes4 selector = ss.gaugePointImplementation.selector;
 198 |     |         if (selector == bytes4(0)) {
 199 |     |             selector = IGaugeFacet.defaultGaugePoints.selector;
 200 |     |         }
 201 |     | 
 202 |     |         uint256 optimalPercentDepositedBdv = (ss.optimalPercentDepositedBdv *
 203 |     |             OPTIMAL_DEPOSITED_BDV_PERCENT) / totalOptimalDepositedBdvPercent;
 204 |     |         (bool success, bytes memory data) = target.staticcall(
 205 |     |             abi.encodeWithSelector(
 206 |     |                 selector,
 207 |     |                 ss.gaugePoints,
 208 |     |                 optimalPercentDepositedBdv,
 209 |     |                 percentDepositedBdv,
 210 |     |                 ss.gaugePointImplementation.data
 211 |     |             )
 212 |     |         );
 213 |     | 
 214 |     |         if (!success) return ss.gaugePoints;
 215 |     |         assembly {
 216 |     |             newGaugePoints := mload(add(data, add(0x20, 0)))
 217 |     |         }
 218 |     |     }
 219 |     | 
 220 |     |     /**
 221 |     |      * @notice Updates the average grown stalk per BDV per Season for whitelisted Beanstalk assets.
 222 |     |      * @dev Called at the end of each Season.
 223 |     |      * The gauge system considers the total BDV of all whitelisted silo tokens.
 224 |     |      */
 225 |     |     function updateGrownStalkEarnedPerSeason(
 226 |     |         uint256 maxLpGpPerBdv,
 227 |     |         LpGaugePointData[] memory lpGpData,
 228 |     |         uint256 totalGaugePoints,
 229 |     |         uint256 totalLpBdv
 230 |     |     ) internal {
 231 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 232 |     |         uint256 beanDepositedBdv = s.sys.silo.balances[s.sys.bean].depositedBdv;
 233 |     |         uint256 totalGaugeBdv = totalLpBdv.add(beanDepositedBdv);
 234 |     | 
 235 |     |         // If nothing has been deposited, skip grown stalk update.
 236 |     |         if (totalGaugeBdv == 0) return;
 237 |     | 
 238 |     |         // Calculate the ratio between the bean and the max LP gauge points per BDV.
 239 |     |         // 18 decimal precision.
 240 |     |         uint256 beanToMaxLpGpPerBdvRatio = getBeanToMaxLpGpPerBdvRatioScaled(
 241 |     |             s.sys.seedGauge.beanToMaxLpGpPerBdvRatio
 242 |     |         );
 243 |     | 
 244 |     |         // Get the GaugePoints and GPperBDV for bean
 245 |     |         // BeanGpPerBdv and beanToMaxLpGpPerBdvRatio has 18 decimal precision.
 246 |     |         uint256 beanGpPerBdv = maxLpGpPerBdv.mul(beanToMaxLpGpPerBdvRatio).div(100e18);
 247 |     | 
 248 |     |         totalGaugePoints = totalGaugePoints.add(
 249 |     |             beanGpPerBdv.mul(beanDepositedBdv).div(BDV_PRECISION)
 250 |     |         );
 251 |     | 
 252 |     |         // update the average grown stalk per BDV per Season.
 253 |     |         updateAverageStalkPerBdvPerSeason();
 254 |     | 
 255 |     |         // Calculate grown stalk issued this season and GrownStalk Per GaugePoint.
 256 |     |         uint256 newGrownStalk = uint256(s.sys.seedGauge.averageGrownStalkPerBdvPerSeason)
 257 |     |             .mul(totalGaugeBdv)
 258 |     |             .div(BDV_PRECISION);
 259 |     | 
 260 |     |         // Gauge points has 18 decimal precision.
 261 |     |         uint256 newGrownStalkPerGp = newGrownStalk.mul(GP_PRECISION).div(totalGaugePoints);
 262 |     | 
 263 |     |         // Update stalkPerBdvPerSeason for bean.
 264 |     |         issueGrownStalkPerBdv(s.sys.bean, newGrownStalkPerGp, beanGpPerBdv);
 265 |     | 
 266 |     |         // Update stalkPerBdvPerSeason for LP
 267 |     |         // If there is only one pool, then no need to read gauge points.
 268 |     |         if (lpGpData.length == 1) {
 269 |     |             issueGrownStalkPerBdv(lpGpData[0].lpToken, newGrownStalkPerGp, lpGpData[0].gpPerBdv);
 270 |     |         } else {
 271 |     |             for (uint256 i; i < lpGpData.length; i++) {
 272 |     |                 issueGrownStalkPerBdv(
 273 |     |                     lpGpData[i].lpToken,
 274 |     |                     newGrownStalkPerGp,
 275 |     |                     lpGpData[i].gpPerBdv
 276 |     |                 );
 277 |     |             }
 278 |     |         }
 279 |     |     }
 280 |     | 
 281 |     |     /**
 282 |     |      * @notice issues the grown stalk per BDV for the given token.
 283 |     |      * @param token the token to issue the grown stalk for.
 284 |     |      * @param grownStalkPerGp the number of GrownStalk Per Gauge Point.
 285 |     |      * @param gpPerBdv the amount of GaugePoints per BDV the token has.
 286 |     |      */
 287 |     |     function issueGrownStalkPerBdv(
 288 |     |         address token,
 289 |     |         uint256 grownStalkPerGp,
 290 |     |         uint256 gpPerBdv
 291 |     |     ) internal {
 292 |     |         uint256 stalkEarnedPerSeason = grownStalkPerGp.mul(gpPerBdv).div(
 293 |     |             GP_PRECISION * GROWN_STALK_PER_GP_PRECISION
 294 |     |         );
 295 |     |         // cap the stalkEarnedPerSeason to the max value of a int40,
 296 |     |         // as deltaStalkEarnedPerSeason is an int40.
 297 |     |         if (stalkEarnedPerSeason > uint40(type(int40).max)) {
 298 |     |             stalkEarnedPerSeason = uint40(type(int40).max);
 299 |     |         }
 300 |     |         LibWhitelist.updateStalkPerBdvPerSeasonForToken(token, uint40(stalkEarnedPerSeason));
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @notice Updates the UpdateAverageStalkPerBdvPerSeason in the seed gauge.
 305 |     |      * @dev The function updates the targetGrownStalkPerBdvPerSeason such that
 306 |     |      * it will take 6 months for the average new depositer to catch up to the
 307 |     |      * current average grown stalk per BDV.
 308 |     |      *
 309 |     |      * When a new Beanstalk is deployed, the `avgGsPerBdvFlag` is set to false,
 310 |     |      * due to the fact that there is no data to calculate the average.
 311 |     |      * Once the averageGsPerBdv exceeds the initial value set during deployment,
 312 |     |      * `avgGsPerBdvFlag` is set to true, and the averageStalkPerBdvPerSeason is
 313 |     |      * updated moving forward.
 314 |     |      *
 315 |     |      * The averageStalkPerBdvPerSeason has a minimum value to prevent the
 316 |     |      * opportunity cost of Withdrawing from the Silo from being too low.
 317 |     |      */
 318 |     |     function updateAverageStalkPerBdvPerSeason() internal {
 319 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 320 |     |         // Will overflow if the average grown stalk per BDV exceeds 1.4e36,
 321 |     |         // which is highly improbable assuming consistent new deposits.
 322 |     |         // Thus, safeCast was determined is to be unnecessary.
 323 |     |         uint128 avgGsPerBdvPerSeason = uint128(
 324 |     |             getAverageGrownStalkPerBdv().mul(BDV_PRECISION).div(
 325 |     |                 s.sys.evaluationParameters.targetSeasonsToCatchUp
 326 |     |             )
 327 |     |         );
 328 |     | 
 329 |     |         // if the flag is not set, check if the new average is greater than the initial value.
 330 |     |         // if it is, set the flag to true, and update the average.
 331 |     |         // otherwise, return early.
 332 |     |         if (!s.sys.seedGauge.avgGsPerBdvFlag) {
 333 |     |             if (avgGsPerBdvPerSeason > s.sys.seedGauge.averageGrownStalkPerBdvPerSeason) {
 334 |     |                 s.sys.seedGauge.avgGsPerBdvFlag = true;
 335 |     |             } else {
 336 |     |                 return;
 337 |     |             }
 338 |     |         }
 339 |     | 
 340 |     |         // If the new average is less than the minimum, set it to the minimum.
 341 |     |         if (avgGsPerBdvPerSeason < s.sys.evaluationParameters.minAvgGsPerBdv) {
 342 |     |             avgGsPerBdvPerSeason = s.sys.evaluationParameters.minAvgGsPerBdv;
 343 |     |         }
 344 |     |         s.sys.seedGauge.averageGrownStalkPerBdvPerSeason = avgGsPerBdvPerSeason;
 345 |     |         emit UpdateAverageStalkPerBdvPerSeason(s.sys.seedGauge.averageGrownStalkPerBdvPerSeason);
 346 |     |     }
 347 |     | 
 348 |     |     /**
 349 |     |      * @notice Returns the total BDV in beanstalk.
 350 |     |      * @dev The total BDV may differ from the instaneous BDV,
 351 |     |      * as BDV is asyncronous.
 352 |     |      * Note We get the silo Tokens, not the whitelisted tokens
 353 |     |      * to account for grown stalk from dewhitelisted tokens.
 354 |     |      */
 355 |     |     function getTotalBdv() internal view returns (uint256 totalBdv) {
 356 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 357 |     |         address[] memory siloTokens = LibWhitelistedTokens.getSiloTokens();
 358 |     |         for (uint256 i; i < siloTokens.length; ++i) {
 359 |     |             totalBdv = totalBdv.add(s.sys.silo.balances[siloTokens[i]].depositedBdv);
 360 |     |         }
 361 |     |     }
 362 |     | 
 363 |     |     /**
 364 |     |      * @notice Returns the average grown stalk per BDV.
 365 |     |      * @dev `totalBDV` refers to the total BDV deposited in the silo.
 366 |     |      */
 367 |     |     function getAverageGrownStalkPerBdv() internal view returns (uint256) {
 368 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 369 |     |         uint256 totalBdv = getTotalBdv();
 370 |     |         if (totalBdv == 0) return 0;
 371 |     |         return s.sys.silo.stalk.div(totalBdv).sub(STALK_BDV_PRECISION);
 372 |     |     }
 373 |     | 
 374 |     |     /**
 375 |     |      * @notice Returns the ratio between the bean and
 376 |     |      * the max LP gauge points per BDV.
 377 |     |      * @dev s.sys.seedGauge.beanToMaxLpGpPerBdvRatio is a number between 0 and 100e18,
 378 |     |      * where f(0) = MIN_BEAN_MAX_LPGP_RATIO and f(100e18) = MAX_BEAN_MAX_LPGP_RATIO.
 379 |     |      * At the minimum value (0), beans should have half of the
 380 |     |      * largest gauge points per BDV out of the LPs.
 381 |     |      * At the maximum value (100e18), beans should have the same amount of
 382 |     |      * gauge points per BDV as the largest out of the LPs.
 383 |     |      *
 384 |     |      * If the system is raining, use `rainingMinBeanMaxLpGpPerBdvRatio` instead of
 385 |     |      * `minBeanMaxLpGpPerBdvRatio`.
 386 |     |      */
 387 |     |     function getBeanToMaxLpGpPerBdvRatioScaled(
 388 |     |         uint256 beanToMaxLpGpPerBdvRatio
 389 |     |     ) internal view returns (uint256) {
 390 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 391 |     |         uint256 minBeanMaxLpGpPerBdvRatio = s.sys.evaluationParameters.minBeanMaxLpGpPerBdvRatio;
 392 |     |         if (s.sys.season.raining) {
 393 |     |             minBeanMaxLpGpPerBdvRatio = s.sys.evaluationParameters.rainingMinBeanMaxLpGpPerBdvRatio;
 394 |     |         }
 395 |     |         uint256 beanMaxLpGpRatioRange = s.sys.evaluationParameters.maxBeanMaxLpGpPerBdvRatio -
 396 |     |             minBeanMaxLpGpPerBdvRatio;
 397 |     |         return
 398 |     |             beanToMaxLpGpPerBdvRatio.mul(beanMaxLpGpRatioRange).div(ONE_HUNDRED_PERCENT).add(
 399 |     |                 minBeanMaxLpGpPerBdvRatio
 400 |     |             );
 401 |     |     }
 402 |     | }
 403 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibGaugeHelpers.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | import {Gauge, GaugeId} from "../beanstalk/storage/System.sol";
   4 |     | import {LibAppStorage} from "./LibAppStorage.sol";
   5 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title LibGaugeHelpers
   9 |     |  * @notice Helper Library for Gauges.
  10 |     |  */
  11 | *   | library LibGaugeHelpers {
  12 |     |     // Gauge events
  13 |     | 
  14 |     |     /**
  15 |     |      * @notice Emitted when a Gauge is engaged (i.e. its value is updated).
  16 |     |      * @param gaugeId The id of the Gauge that was engaged.
  17 |     |      * @param value The value of the Gauge after it was engaged.
  18 |     |      */
  19 |     |     event Engaged(GaugeId gaugeId, bytes value);
  20 |     | 
  21 |     |     /**
  22 |     |      * @notice Emitted when a Gauge is added.
  23 |     |      * @param gaugeId The id of the Gauge that was added.
  24 |     |      * @param gauge The Gauge that was added.
  25 |     |      */
  26 |     |     event AddedGauge(GaugeId gaugeId, Gauge gauge);
  27 |     | 
  28 |     |     /**
  29 |     |      * @notice Emitted when a Gauge is removed.
  30 |     |      * @param gaugeId The id of the Gauge that was removed.
  31 |     |      */
  32 |     |     event RemovedGauge(GaugeId gaugeId);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Emitted when a Gauge is updated.
  36 |     |      * @param gaugeId The id of the Gauge that was updated.
  37 |     |      * @param gauge The Gauge that was updated.
  38 |     |      */
  39 |     |     event UpdatedGauge(GaugeId gaugeId, Gauge gauge);
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Calls all generalized Gauges, and updates their values.
  43 |     |      * @param systemData The system data to pass to the Gauges.
  44 |     |      */
  45 |     |     function engage(bytes memory systemData) internal {
  46 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  47 |     |         for (uint256 i = 0; i < s.sys.gaugeData.gaugeIds.length; i++) {
  48 |     |             callGaugeId(s.sys.gaugeData.gaugeIds[i], systemData);
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Calls a Gauge by its id, and updates the Gauge's value.
  54 |     |      * @dev Returns g.value if the call fails.
  55 |     |      */
  56 |     |     function callGaugeId(GaugeId gaugeId, bytes memory systemData) internal {
  57 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  58 |     |         Gauge memory g = s.sys.gaugeData.gauges[gaugeId];
  59 |     |         (
  60 |     |             s.sys.gaugeData.gauges[gaugeId].value,
  61 |     |             s.sys.gaugeData.gauges[gaugeId].data
  62 |     |         ) = getGaugeResult(g, systemData);
  63 |     | 
  64 |     |         // emit change in gauge value
  65 |     |         emit Engaged(gaugeId, s.sys.gaugeData.gauges[gaugeId].value);
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @notice Calls a Gauge.
  70 |     |      * @dev Returns the original value of the Gauge if the call fails.
  71 |     |      */
  72 |     |     function getGaugeResult(
  73 |     |         Gauge memory g,
  74 |     |         bytes memory systemData
  75 |     |     ) internal view returns (bytes memory, bytes memory) {
  76 |     |         // if the Gauge does not have a target, assume the target is address(this)
  77 |     |         if (g.target == address(0)) {
  78 |     |             g.target = address(this);
  79 |     |         }
  80 |     | 
  81 |     |         // if the Gauge does not have a selector, return original value
  82 |     |         if (g.selector == bytes4(0)) {
  83 |     |             return (g.value, g.data);
  84 |     |         }
  85 |     | 
  86 |     |         (bool success, bytes memory returnData) = g.target.staticcall(
  87 |     |             abi.encodeWithSelector(g.selector, g.value, systemData, g.data)
  88 |     |         );
  89 |     |         if (!success) {
  90 |     |             return (g.value, g.data); // In case of failure, return value unadjusted
  91 |     |         }
  92 |     | 
  93 |     |         return abi.decode(returnData, (bytes, bytes));
  94 |     |     }
  95 |     | 
  96 | *   |     function addGauge(GaugeId gaugeId, Gauge memory g) internal {
  97 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
  98 |     |         // verify that the gaugeId is not already in the array
  99 | *   |         for (uint256 i = 0; i < s.sys.gaugeData.gaugeIds.length; i++) {
 100 | *   |             if (s.sys.gaugeData.gaugeIds[i] == gaugeId) {
 101 |     |                 revert("GaugeId already exists");
 102 |     |             }
 103 |     |         }
 104 | *   |         s.sys.gaugeData.gaugeIds.push(gaugeId);
 105 | *   |         s.sys.gaugeData.gauges[gaugeId] = g;
 106 |     | 
 107 | *   |         emit AddedGauge(gaugeId, g);
 108 |     |     }
 109 |     | 
 110 |     |     function updateGauge(GaugeId gaugeId, Gauge memory g) internal {
 111 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 112 |     |         s.sys.gaugeData.gauges[gaugeId] = g;
 113 |     | 
 114 |     |         emit UpdatedGauge(gaugeId, g);
 115 |     |     }
 116 |     | 
 117 |     |     function removeGauge(GaugeId gaugeId) internal {
 118 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 119 |     |         // remove the gauge from the array
 120 |     |         uint256 index = findGaugeIndex(gaugeId);
 121 |     |         s.sys.gaugeData.gaugeIds[index] = s.sys.gaugeData.gaugeIds[
 122 |     |             s.sys.gaugeData.gaugeIds.length - 1
 123 |     |         ];
 124 |     |         s.sys.gaugeData.gaugeIds.pop();
 125 |     |         delete s.sys.gaugeData.gauges[gaugeId];
 126 |     | 
 127 |     |         emit RemovedGauge(gaugeId);
 128 |     |     }
 129 |     | 
 130 |     |     function findGaugeIndex(GaugeId gaugeId) internal view returns (uint256) {
 131 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 132 |     |         for (uint256 i = 0; i < s.sys.gaugeData.gaugeIds.length; i++) {
 133 |     |             if (s.sys.gaugeData.gaugeIds[i] == gaugeId) {
 134 |     |                 return i;
 135 |     |             }
 136 |     |         }
 137 |     |         revert("Gauge not found");
 138 |     |     }
 139 |     | 
 140 |     |     function getGaugeValue(GaugeId gaugeId) internal view returns (bytes memory) {
 141 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 142 |     |         return s.sys.gaugeData.gauges[gaugeId].value;
 143 |     |     }
 144 |     | 
 145 |     |     /// GAUGE BLOCKS ///
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice linear is a implementation that adds or
 149 |     |      * subtracts an absolute value, as a function of
 150 |     |      * the current value, the amount, and the max and min values.
 151 |     |      */
 152 |     |     function linear(
 153 |     |         int256 currentValue,
 154 |     |         bool increase,
 155 |     |         uint256 amount,
 156 |     |         int256 minValue,
 157 |     |         int256 maxValue
 158 |     |     ) internal pure returns (int256) {
 159 |     |         if (increase) {
 160 |     |             if (maxValue - currentValue < int256(amount)) {
 161 |     |                 currentValue = maxValue;
 162 |     |             } else {
 163 |     |                 currentValue += int256(amount);
 164 |     |             }
 165 |     |         } else {
 166 |     |             if (currentValue - minValue < int256(amount)) {
 167 |     |                 currentValue = minValue;
 168 |     |             } else {
 169 |     |                 currentValue -= int256(amount);
 170 |     |             }
 171 |     |         }
 172 |     | 
 173 |     |         return currentValue;
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @notice linearInterpolation is a function that interpolates a value between two points.
 178 |     |      * clamps x to the x1 and x2.
 179 |     |      * @dev https://www.cuemath.com/linear-interpolation-formula/
 180 |     |      */
 181 |     |     function linearInterpolation(
 182 |     |         uint256 x,
 183 |     |         bool proportional,
 184 |     |         uint256 x1,
 185 |     |         uint256 x2,
 186 |     |         uint256 y1,
 187 |     |         uint256 y2
 188 |     |     ) internal pure returns (uint256) {
 189 |     |         // verify that x1 is less than x2.
 190 |     |         // verify that y1 is less than y2.
 191 |     |         if (x1 > x2 || y1 > y2 || x1 == x2 || y1 == y2) {
 192 |     |             revert("invalid values");
 193 |     |         }
 194 |     | 
 195 |     |         // if the current value is greater than the max value, return y2 or y1, depending on proportional.
 196 |     |         if (x > x2) {
 197 |     |             if (proportional) {
 198 |     |                 return y2;
 199 |     |             } else {
 200 |     |                 return y1;
 201 |     |             }
 202 |     |         } else if (x < x1) {
 203 |     |             if (proportional) {
 204 |     |                 return y1;
 205 |     |             } else {
 206 |     |                 return y2;
 207 |     |             }
 208 |     |         }
 209 |     | 
 210 |     |         // scale the value to the range [y1, y2]
 211 |     |         uint256 dy = ((x - x1) * (y2 - y1)) / (x2 - x1);
 212 |     | 
 213 |     |         // if proportional, y should increase with an increase in x.
 214 |     |         // (i.e y = y1 + ((x - x1) * (y2 - y1)) / (x2 - x1))
 215 |     |         if (proportional) {
 216 |     |             return y1 + dy;
 217 |     |         } else {
 218 |     |             // if inversely proportional, y should decrease with an increase in x.
 219 |     |             // (i.e y = y2 - ((x - x1) * (y2 - y1)) / (x2 - x1))
 220 |     |             return y2 - dy;
 221 |     |         }
 222 |     |     }
 223 |     | }
 224 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibIncentive.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   6 |     | import "@openzeppelin/contracts/utils/math/Math.sol";
   7 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title LibIncentive
  11 |     |  * @notice Calculates the reward offered for calling Sunrise, adjusts for current gas & ETH prices,
  12 |     |  * and scales the reward up when the Sunrise is called late.
  13 |     |  */
  14 | *   | library LibIncentive {
  15 |     |     using LibRedundantMath256 for uint256;
  16 |     | 
  17 |     |     /**
  18 |     |      * @notice Emitted when Beanstalk pays `beans` to `account` as a reward for calling `sunrise()`.
  19 |     |      * @param account The address to which the reward Beans were sent
  20 |     |      * @param beans The amount of Beans paid as a reward
  21 |     |      */
  22 |     |     event Incentivization(address indexed account, uint256 beans);
  23 |     | 
  24 |     |     /// @dev The Sunrise reward reaches its maximum after this many seconds elapse.
  25 |     |     uint256 internal constant MAX_SECONDS_LATE = 300;
  26 |     | 
  27 |     |     /// @dev `sunriseReward` is precomputed in {fracExp} using this precision.
  28 |     |     uint256 private constant FRAC_EXP_PRECISION = 1e6;
  29 |     | 
  30 |     |     //////////////////// CALCULATE REWARD ////////////////////
  31 |     | 
  32 |     |     /**
  33 |     |      * @param secondsLate The number of seconds late that {sunrise()} was called.
  34 |     |      */
  35 |     |     function determineReward(uint256 secondsLate) external view returns (uint256) {
  36 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  37 |     |         // Cap the maximum number of seconds late. If the sunrise is later than
  38 |     |         // this, Beanstalk will pay the same amount. Prevents unbounded return value.
  39 |     |         if (secondsLate > MAX_SECONDS_LATE) {
  40 |     |             secondsLate = MAX_SECONDS_LATE;
  41 |     |         }
  42 |     | 
  43 |     |         // Scale the reward up as the number of seconds after expected sunrise increases.
  44 |     |         // `sunriseReward * (1 + 1/100)^(seconds late)`
  45 |     |         // NOTE: 1.01^(300) = 19.78, This is the maximum multiplier.
  46 |     |         return fracExp(s.sys.evaluationParameters.baseReward, secondsLate);
  47 |     |     }
  48 |     | 
  49 |     |     //////////////////// MATH UTILITIES ////////////////////
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev fraxExp scales up the bean reward based on the seconds late.
  53 |     |      * the formula is beans * (1.01)^(seconds late).
  54 |     |      */
  55 |     |     function fracExp(
  56 |     |         uint256 beans,
  57 |     |         uint256 secondsLate
  58 |     |     ) internal pure returns (uint256 scaledSunriseReward) {
  59 |     |         // check most likely case first
  60 |     |         if (secondsLate == 0) {
  61 |     |             return beans;
  62 |     |         }
  63 |     | 
  64 |     |         // use an if ladder to determine the scaling factor. If ladder is used over binary search
  65 |     |         // due to simplicity. Checked every 2 seconds to reduce bytecode size. SecondsLate is rounded up given that beanstalk
  66 |     |         // would rather incentivize slightly more to call sunrise earlier than to incentivize slightly less for a later sunrise.
  67 |     |         // repeat until 300 seconds:
  68 |     |         if (secondsLate <= 30) {
  69 |     |             if (secondsLate == 0) {
  70 |     |                 return _scaleReward(beans, 1_000_000);
  71 |     |             }
  72 |     |             if (secondsLate <= 2) {
  73 |     |                 return _scaleReward(beans, 1_020_100);
  74 |     |             }
  75 |     |             if (secondsLate <= 4) {
  76 |     |                 return _scaleReward(beans, 1_040_604);
  77 |     |             }
  78 |     |             if (secondsLate <= 6) {
  79 |     |                 return _scaleReward(beans, 1_061_520);
  80 |     |             }
  81 |     |             if (secondsLate <= 8) {
  82 |     |                 return _scaleReward(beans, 1_082_857);
  83 |     |             }
  84 |     |             if (secondsLate <= 10) {
  85 |     |                 return _scaleReward(beans, 1_104_622);
  86 |     |             }
  87 |     |             if (secondsLate <= 12) {
  88 |     |                 return _scaleReward(beans, 1_126_825);
  89 |     |             }
  90 |     |             if (secondsLate <= 14) {
  91 |     |                 return _scaleReward(beans, 1_149_474);
  92 |     |             }
  93 |     |             if (secondsLate <= 16) {
  94 |     |                 return _scaleReward(beans, 1_172_579);
  95 |     |             }
  96 |     |             if (secondsLate <= 18) {
  97 |     |                 return _scaleReward(beans, 1_196_147);
  98 |     |             }
  99 |     |             if (secondsLate <= 20) {
 100 |     |                 return _scaleReward(beans, 1_220_190);
 101 |     |             }
 102 |     |             if (secondsLate <= 22) {
 103 |     |                 return _scaleReward(beans, 1_244_716);
 104 |     |             }
 105 |     |             if (secondsLate <= 24) {
 106 |     |                 return _scaleReward(beans, 1_269_735);
 107 |     |             }
 108 |     |             if (secondsLate <= 26) {
 109 |     |                 return _scaleReward(beans, 1_295_256);
 110 |     |             }
 111 |     |             if (secondsLate <= 28) {
 112 |     |                 return _scaleReward(beans, 1_321_291);
 113 |     |             }
 114 |     |             if (secondsLate <= 30) {
 115 |     |                 return _scaleReward(beans, 1_347_849);
 116 |     |             }
 117 |     |         } else if (secondsLate <= 60) {
 118 |     |             if (secondsLate <= 32) {
 119 |     |                 return _scaleReward(beans, 1_374_941);
 120 |     |             }
 121 |     |             if (secondsLate <= 34) {
 122 |     |                 return _scaleReward(beans, 1_402_577);
 123 |     |             }
 124 |     |             if (secondsLate <= 36) {
 125 |     |                 return _scaleReward(beans, 1_430_769);
 126 |     |             }
 127 |     |             if (secondsLate <= 38) {
 128 |     |                 return _scaleReward(beans, 1_459_527);
 129 |     |             }
 130 |     |             if (secondsLate <= 40) {
 131 |     |                 return _scaleReward(beans, 1_488_864);
 132 |     |             }
 133 |     |             if (secondsLate <= 42) {
 134 |     |                 return _scaleReward(beans, 1_518_790);
 135 |     |             }
 136 |     |             if (secondsLate <= 44) {
 137 |     |                 return _scaleReward(beans, 1_549_318);
 138 |     |             }
 139 |     |             if (secondsLate <= 46) {
 140 |     |                 return _scaleReward(beans, 1_580_459);
 141 |     |             }
 142 |     |             if (secondsLate <= 48) {
 143 |     |                 return _scaleReward(beans, 1_612_226);
 144 |     |             }
 145 |     |             if (secondsLate <= 50) {
 146 |     |                 return _scaleReward(beans, 1_644_632);
 147 |     |             }
 148 |     |             if (secondsLate <= 52) {
 149 |     |                 return _scaleReward(beans, 1_677_689);
 150 |     |             }
 151 |     |             if (secondsLate <= 54) {
 152 |     |                 return _scaleReward(beans, 1_711_410);
 153 |     |             }
 154 |     |             if (secondsLate <= 56) {
 155 |     |                 return _scaleReward(beans, 1_745_810);
 156 |     |             }
 157 |     |             if (secondsLate <= 58) {
 158 |     |                 return _scaleReward(beans, 1_780_901);
 159 |     |             }
 160 |     |             if (secondsLate <= 60) {
 161 |     |                 return _scaleReward(beans, 1_816_697);
 162 |     |             }
 163 |     |         } else if (secondsLate <= 90) {
 164 |     |             if (secondsLate <= 62) {
 165 |     |                 return _scaleReward(beans, 1_853_212);
 166 |     |             }
 167 |     |             if (secondsLate <= 64) {
 168 |     |                 return _scaleReward(beans, 1_890_462);
 169 |     |             }
 170 |     |             if (secondsLate <= 66) {
 171 |     |                 return _scaleReward(beans, 1_928_460);
 172 |     |             }
 173 |     |             if (secondsLate <= 68) {
 174 |     |                 return _scaleReward(beans, 1_967_222);
 175 |     |             }
 176 |     |             if (secondsLate <= 70) {
 177 |     |                 return _scaleReward(beans, 2_006_763);
 178 |     |             }
 179 |     |             if (secondsLate <= 72) {
 180 |     |                 return _scaleReward(beans, 2_047_099);
 181 |     |             }
 182 |     |             if (secondsLate <= 74) {
 183 |     |                 return _scaleReward(beans, 2_088_246);
 184 |     |             }
 185 |     |             if (secondsLate <= 76) {
 186 |     |                 return _scaleReward(beans, 2_130_220);
 187 |     |             }
 188 |     |             if (secondsLate <= 78) {
 189 |     |                 return _scaleReward(beans, 2_173_037);
 190 |     |             }
 191 |     |             if (secondsLate <= 80) {
 192 |     |                 return _scaleReward(beans, 2_216_715);
 193 |     |             }
 194 |     |             if (secondsLate <= 82) {
 195 |     |                 return _scaleReward(beans, 2_261_271);
 196 |     |             }
 197 |     |             if (secondsLate <= 84) {
 198 |     |                 return _scaleReward(beans, 2_306_723);
 199 |     |             }
 200 |     |             if (secondsLate <= 86) {
 201 |     |                 return _scaleReward(beans, 2_353_088);
 202 |     |             }
 203 |     |             if (secondsLate <= 88) {
 204 |     |                 return _scaleReward(beans, 2_400_385);
 205 |     |             }
 206 |     |             if (secondsLate <= 90) {
 207 |     |                 return _scaleReward(beans, 2_448_633);
 208 |     |             }
 209 |     |         } else if (secondsLate <= 120) {
 210 |     |             if (secondsLate <= 92) {
 211 |     |                 return _scaleReward(beans, 2_497_850);
 212 |     |             }
 213 |     |             if (secondsLate <= 94) {
 214 |     |                 return _scaleReward(beans, 2_548_057);
 215 |     |             }
 216 |     |             if (secondsLate <= 96) {
 217 |     |                 return _scaleReward(beans, 2_599_273);
 218 |     |             }
 219 |     |             if (secondsLate <= 98) {
 220 |     |                 return _scaleReward(beans, 2_651_518);
 221 |     |             }
 222 |     |             if (secondsLate <= 100) {
 223 |     |                 return _scaleReward(beans, 2_704_814);
 224 |     |             }
 225 |     |             if (secondsLate <= 102) {
 226 |     |                 return _scaleReward(beans, 2_759_181);
 227 |     |             }
 228 |     |             if (secondsLate <= 104) {
 229 |     |                 return _scaleReward(beans, 2_814_640);
 230 |     |             }
 231 |     |             if (secondsLate <= 106) {
 232 |     |                 return _scaleReward(beans, 2_871_214);
 233 |     |             }
 234 |     |             if (secondsLate <= 108) {
 235 |     |                 return _scaleReward(beans, 2_928_926);
 236 |     |             }
 237 |     |             if (secondsLate <= 110) {
 238 |     |                 return _scaleReward(beans, 2_987_797);
 239 |     |             }
 240 |     |             if (secondsLate <= 112) {
 241 |     |                 return _scaleReward(beans, 3_047_852);
 242 |     |             }
 243 |     |             if (secondsLate <= 114) {
 244 |     |                 return _scaleReward(beans, 3_109_114);
 245 |     |             }
 246 |     |             if (secondsLate <= 116) {
 247 |     |                 return _scaleReward(beans, 3_171_607);
 248 |     |             }
 249 |     |             if (secondsLate <= 118) {
 250 |     |                 return _scaleReward(beans, 3_235_356);
 251 |     |             }
 252 |     |             if (secondsLate <= 120) {
 253 |     |                 return _scaleReward(beans, 3_300_387);
 254 |     |             }
 255 |     |         } else if (secondsLate <= 150) {
 256 |     |             if (secondsLate <= 122) {
 257 |     |                 return _scaleReward(beans, 3_366_725);
 258 |     |             }
 259 |     |             if (secondsLate <= 124) {
 260 |     |                 return _scaleReward(beans, 3_434_396);
 261 |     |             }
 262 |     |             if (secondsLate <= 126) {
 263 |     |                 return _scaleReward(beans, 3_503_427);
 264 |     |             }
 265 |     |             if (secondsLate <= 128) {
 266 |     |                 return _scaleReward(beans, 3_573_846);
 267 |     |             }
 268 |     |             if (secondsLate <= 130) {
 269 |     |                 return _scaleReward(beans, 3_645_680);
 270 |     |             }
 271 |     |             if (secondsLate <= 132) {
 272 |     |                 return _scaleReward(beans, 3_718_959);
 273 |     |             }
 274 |     |             if (secondsLate <= 134) {
 275 |     |                 return _scaleReward(beans, 3_793_710);
 276 |     |             }
 277 |     |             if (secondsLate <= 136) {
 278 |     |                 return _scaleReward(beans, 3_869_963);
 279 |     |             }
 280 |     |             if (secondsLate <= 138) {
 281 |     |                 return _scaleReward(beans, 3_947_749);
 282 |     |             }
 283 |     |             if (secondsLate <= 140) {
 284 |     |                 return _scaleReward(beans, 4_027_099);
 285 |     |             }
 286 |     |             if (secondsLate <= 142) {
 287 |     |                 return _scaleReward(beans, 4_108_044);
 288 |     |             }
 289 |     |             if (secondsLate <= 144) {
 290 |     |                 return _scaleReward(beans, 4_190_616);
 291 |     |             }
 292 |     |             if (secondsLate <= 146) {
 293 |     |                 return _scaleReward(beans, 4_274_847);
 294 |     |             }
 295 |     |             if (secondsLate <= 148) {
 296 |     |                 return _scaleReward(beans, 4_360_771);
 297 |     |             }
 298 |     |             if (secondsLate <= 150) {
 299 |     |                 return _scaleReward(beans, 4_448_423);
 300 |     |             }
 301 |     |         } else if (secondsLate <= 180) {
 302 |     |             if (secondsLate <= 152) {
 303 |     |                 return _scaleReward(beans, 4_537_836);
 304 |     |             }
 305 |     |             if (secondsLate <= 154) {
 306 |     |                 return _scaleReward(beans, 4_629_047);
 307 |     |             }
 308 |     |             if (secondsLate <= 156) {
 309 |     |                 return _scaleReward(beans, 4_722_091);
 310 |     |             }
 311 |     |             if (secondsLate <= 158) {
 312 |     |                 return _scaleReward(beans, 4_817_005);
 313 |     |             }
 314 |     |             if (secondsLate <= 160) {
 315 |     |                 return _scaleReward(beans, 4_913_826);
 316 |     |             }
 317 |     |             if (secondsLate <= 162) {
 318 |     |                 return _scaleReward(beans, 5_012_594);
 319 |     |             }
 320 |     |             if (secondsLate <= 164) {
 321 |     |                 return _scaleReward(beans, 5_113_347);
 322 |     |             }
 323 |     |             if (secondsLate <= 166) {
 324 |     |                 return _scaleReward(beans, 5_216_126);
 325 |     |             }
 326 |     |             if (secondsLate <= 168) {
 327 |     |                 return _scaleReward(beans, 5_320_970);
 328 |     |             }
 329 |     |             if (secondsLate <= 170) {
 330 |     |                 return _scaleReward(beans, 5_427_921);
 331 |     |             }
 332 |     |             if (secondsLate <= 172) {
 333 |     |                 return _scaleReward(beans, 5_537_023);
 334 |     |             }
 335 |     |             if (secondsLate <= 174) {
 336 |     |                 return _scaleReward(beans, 5_648_317);
 337 |     |             }
 338 |     |             if (secondsLate <= 176) {
 339 |     |                 return _scaleReward(beans, 5_761_848);
 340 |     |             }
 341 |     |             if (secondsLate <= 178) {
 342 |     |                 return _scaleReward(beans, 5_877_661);
 343 |     |             }
 344 |     |             if (secondsLate <= 180) {
 345 |     |                 return _scaleReward(beans, 5_995_802);
 346 |     |             }
 347 |     |         } else if (secondsLate <= 210) {
 348 |     |             if (secondsLate <= 182) {
 349 |     |                 return _scaleReward(beans, 6_116_318);
 350 |     |             }
 351 |     |             if (secondsLate <= 184) {
 352 |     |                 return _scaleReward(beans, 6_239_256);
 353 |     |             }
 354 |     |             if (secondsLate <= 186) {
 355 |     |                 return _scaleReward(beans, 6_364_665);
 356 |     |             }
 357 |     |             if (secondsLate <= 188) {
 358 |     |                 return _scaleReward(beans, 6_492_594);
 359 |     |             }
 360 |     |             if (secondsLate <= 190) {
 361 |     |                 return _scaleReward(beans, 6_623_096);
 362 |     |             }
 363 |     |             if (secondsLate <= 192) {
 364 |     |                 return _scaleReward(beans, 6_756_220);
 365 |     |             }
 366 |     |             if (secondsLate <= 194) {
 367 |     |                 return _scaleReward(beans, 6_892_020);
 368 |     |             }
 369 |     |             if (secondsLate <= 196) {
 370 |     |                 return _scaleReward(beans, 7_030_549);
 371 |     |             }
 372 |     |             if (secondsLate <= 198) {
 373 |     |                 return _scaleReward(beans, 7_171_863);
 374 |     |             }
 375 |     |             if (secondsLate <= 200) {
 376 |     |                 return _scaleReward(beans, 7_316_018);
 377 |     |             }
 378 |     |             if (secondsLate <= 202) {
 379 |     |                 return _scaleReward(beans, 7_463_070);
 380 |     |             }
 381 |     |             if (secondsLate <= 204) {
 382 |     |                 return _scaleReward(beans, 7_613_078);
 383 |     |             }
 384 |     |             if (secondsLate <= 206) {
 385 |     |                 return _scaleReward(beans, 7_766_100);
 386 |     |             }
 387 |     |             if (secondsLate <= 208) {
 388 |     |                 return _scaleReward(beans, 7_922_199);
 389 |     |             }
 390 |     |             if (secondsLate <= 210) {
 391 |     |                 return _scaleReward(beans, 8_081_435);
 392 |     |             }
 393 |     |         } else if (secondsLate <= 238) {
 394 |     |             if (secondsLate <= 212) {
 395 |     |                 return _scaleReward(beans, 8_243_872);
 396 |     |             }
 397 |     |             if (secondsLate <= 214) {
 398 |     |                 return _scaleReward(beans, 8_409_574);
 399 |     |             }
 400 |     |             if (secondsLate <= 216) {
 401 |     |                 return _scaleReward(beans, 8_578_606);
 402 |     |             }
 403 |     |             if (secondsLate <= 218) {
 404 |     |                 return _scaleReward(beans, 8_751_036);
 405 |     |             }
 406 |     |             if (secondsLate <= 220) {
 407 |     |                 return _scaleReward(beans, 8_926_932);
 408 |     |             }
 409 |     |             if (secondsLate <= 222) {
 410 |     |                 return _scaleReward(beans, 9_106_363);
 411 |     |             }
 412 |     |             if (secondsLate <= 224) {
 413 |     |                 return _scaleReward(beans, 9_289_401);
 414 |     |             }
 415 |     |             if (secondsLate <= 226) {
 416 |     |                 return _scaleReward(beans, 9_476_118);
 417 |     |             }
 418 |     |             if (secondsLate <= 228) {
 419 |     |                 return _scaleReward(beans, 9_666_588);
 420 |     |             }
 421 |     |             if (secondsLate <= 230) {
 422 |     |                 return _scaleReward(beans, 9_860_887);
 423 |     |             }
 424 |     |             if (secondsLate <= 232) {
 425 |     |                 return _scaleReward(beans, 10_059_091);
 426 |     |             }
 427 |     |             if (secondsLate <= 234) {
 428 |     |                 return _scaleReward(beans, 10_261_278);
 429 |     |             }
 430 |     |             if (secondsLate <= 236) {
 431 |     |                 return _scaleReward(beans, 10_467_530);
 432 |     |             }
 433 |     |             if (secondsLate <= 238) {
 434 |     |                 return _scaleReward(beans, 10_677_927);
 435 |     |             }
 436 |     |         } else if (secondsLate <= 270) {
 437 |     |             if (secondsLate <= 240) {
 438 |     |                 return _scaleReward(beans, 10_892_553);
 439 |     |             }
 440 |     |             if (secondsLate <= 242) {
 441 |     |                 return _scaleReward(beans, 11_111_494);
 442 |     |             }
 443 |     |             if (secondsLate <= 244) {
 444 |     |                 return _scaleReward(beans, 11_334_835);
 445 |     |             }
 446 |     |             if (secondsLate <= 246) {
 447 |     |                 return _scaleReward(beans, 11_562_665);
 448 |     |             }
 449 |     |             if (secondsLate <= 248) {
 450 |     |                 return _scaleReward(beans, 11_795_075);
 451 |     |             }
 452 |     |             if (secondsLate <= 250) {
 453 |     |                 return _scaleReward(beans, 12_032_156);
 454 |     |             }
 455 |     |             if (secondsLate <= 252) {
 456 |     |                 return _scaleReward(beans, 12_274_002);
 457 |     |             }
 458 |     |             if (secondsLate <= 254) {
 459 |     |                 return _scaleReward(beans, 12_520_710);
 460 |     |             }
 461 |     |             if (secondsLate <= 256) {
 462 |     |                 return _scaleReward(beans, 12_772_376);
 463 |     |             }
 464 |     |             if (secondsLate <= 258) {
 465 |     |                 return _scaleReward(beans, 13_029_101);
 466 |     |             }
 467 |     |             if (secondsLate <= 260) {
 468 |     |                 return _scaleReward(beans, 13_290_985);
 469 |     |             }
 470 |     |             if (secondsLate <= 262) {
 471 |     |                 return _scaleReward(beans, 13_558_134);
 472 |     |             }
 473 |     |             if (secondsLate <= 264) {
 474 |     |                 return _scaleReward(beans, 13_830_653);
 475 |     |             }
 476 |     |             if (secondsLate <= 266) {
 477 |     |                 return _scaleReward(beans, 14_108_649);
 478 |     |             }
 479 |     |             if (secondsLate <= 268) {
 480 |     |                 return _scaleReward(beans, 14_392_233);
 481 |     |             }
 482 |     |             if (secondsLate <= 270) {
 483 |     |                 return _scaleReward(beans, 14_681_517);
 484 |     |             }
 485 |     |         } else if (secondsLate <= 300) {
 486 |     |             if (secondsLate <= 272) {
 487 |     |                 return _scaleReward(beans, 14_976_615);
 488 |     |             }
 489 |     |             if (secondsLate <= 274) {
 490 |     |                 return _scaleReward(beans, 15_277_645);
 491 |     |             }
 492 |     |             if (secondsLate <= 276) {
 493 |     |                 return _scaleReward(beans, 15_584_726);
 494 |     |             }
 495 |     |             if (secondsLate <= 278) {
 496 |     |                 return _scaleReward(beans, 15_897_979);
 497 |     |             }
 498 |     |             if (secondsLate <= 280) {
 499 |     |                 return _scaleReward(beans, 16_217_528);
 500 |     |             }
 501 |     |             if (secondsLate <= 282) {
 502 |     |                 return _scaleReward(beans, 16_543_500);
 503 |     |             }
 504 |     |             if (secondsLate <= 284) {
 505 |     |                 return _scaleReward(beans, 16_876_025);
 506 |     |             }
 507 |     |             if (secondsLate <= 286) {
 508 |     |                 return _scaleReward(beans, 17_215_233);
 509 |     |             }
 510 |     |             if (secondsLate <= 288) {
 511 |     |                 return _scaleReward(beans, 17_561_259);
 512 |     |             }
 513 |     |             if (secondsLate <= 290) {
 514 |     |                 return _scaleReward(beans, 17_914_240);
 515 |     |             }
 516 |     |             if (secondsLate <= 292) {
 517 |     |                 return _scaleReward(beans, 18_274_317);
 518 |     |             }
 519 |     |             if (secondsLate <= 294) {
 520 |     |                 return _scaleReward(beans, 18_641_630);
 521 |     |             }
 522 |     |             if (secondsLate <= 296) {
 523 |     |                 return _scaleReward(beans, 19_016_327);
 524 |     |             }
 525 |     |             if (secondsLate <= 298) {
 526 |     |                 return _scaleReward(beans, 19_398_555);
 527 |     |             }
 528 |     |             if (secondsLate <= 300) {
 529 |     |                 return _scaleReward(beans, 19_788_466);
 530 |     |             }
 531 |     |         } else {
 532 |     |             return _scaleReward(beans, 20_000_000);
 533 |     |         }
 534 |     |     }
 535 |     | 
 536 |     |     function _scaleReward(uint256 beans, uint256 scaler) private pure returns (uint256) {
 537 |     |         return beans.mul(scaler).div(FRAC_EXP_PRECISION);
 538 |     |     }
 539 |     | }
 540 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibMarket.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {LibAppStorage, AppStorage} from "./LibAppStorage.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title LibMarket
 11 |     |  * @notice LibMarket handles Market functionality that is needed in multiple Facets.
 12 |     |  */
 13 | *   | library LibMarket {
 14 |     |     event PodListingCancelled(address indexed lister, uint256 fieldId, uint256 index);
 15 |     | 
 16 |     |     function _cancelPodListing(address lister, uint256 fieldId, uint256 index) internal {
 17 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 18 |     |         require(
 19 |     |             s.accts[lister].fields[fieldId].plots[index] > 0,
 20 |     |             "Marketplace: Listing not owned by sender."
 21 |     |         );
 22 |     | 
 23 |     |         delete s.sys.podListings[fieldId][index];
 24 |     | 
 25 |     |         emit PodListingCancelled(lister, fieldId, index);
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibReceiving.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {AppStorage, LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
   9 |     | import {ShipmentRecipient} from "contracts/beanstalk/storage/System.sol";
  10 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @title LibReceiving
  14 |     |  * @notice Holds the logic responsible for receiving Bean shipments after mints. These
  15 |     |  *  functions must be delegatecalled from inside of the Beanstalk Diamond. If new receiving components
  16 |     |  *  are needed, this library and its calling Facet will need to be updated.
  17 |     |  * @dev An alternative design could remove the need for the generalized receive() entry function
  18 |     |  *  and instead require the shipping route to define the selector of its own corresponding receive
  19 |     |  *  function. However, both designs will require a Facet cut if a new receive function is needed,
  20 |     |  *  so this design was chosen for additional clarity.
  21 |     |  * @dev Functions are internal, but only pulled into LibShipping. Reduces the size of facet.
  22 |     |  */
  23 | *   | library LibReceiving {
  24 |     |     using SafeCast for uint256;
  25 |     | 
  26 |     |     /**
  27 |     |      * @notice Emitted during Sunrise when Bean mints are shipped through active routes.
  28 |     |      * @param recipient The receiver.
  29 |     |      * @param receivedAmount The amount of Bean successfully received and processed.
  30 |     |      * @param data The data the Bean were received with. Optional.
  31 |     |      */
  32 |     |     event Receipt(ShipmentRecipient indexed recipient, uint256 receivedAmount, bytes data);
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice General entry point to receive Bean at a given component of the system.
  36 |     |      * @param recipient The Beanstalk component that will receive the Bean.
  37 |     |      * @param shipmentAmount The amount of Bean to receive.
  38 |     |      * @param data Additional data to pass to the receiving function.
  39 |     |      */
  40 |     |     function receiveShipment(
  41 |     |         ShipmentRecipient recipient,
  42 |     |         uint256 shipmentAmount,
  43 |     |         bytes memory data
  44 |     |     ) internal {
  45 |     |         if (recipient == ShipmentRecipient.SILO) {
  46 |     |             siloReceive(shipmentAmount, data);
  47 |     |         } else if (recipient == ShipmentRecipient.FIELD) {
  48 |     |             fieldReceive(shipmentAmount, data);
  49 |     |         } else if (recipient == ShipmentRecipient.INTERNAL_BALANCE) {
  50 |     |             internalBalanceReceive(shipmentAmount, data);
  51 |     |         } else if (recipient == ShipmentRecipient.EXTERNAL_BALANCE) {
  52 |     |             externalBalanceReceive(shipmentAmount, data);
  53 |     |         }
  54 |     |         // New receiveShipment enum values should have a corresponding function call here.
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice Receive Bean at the Silo, distributing Stalk & Earned Bean.
  59 |     |      * @dev Data param not used.
  60 |     |      * @param shipmentAmount Amount of Bean to receive.
  61 |     |      */
  62 |     |     function siloReceive(uint256 shipmentAmount, bytes memory) private {
  63 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  64 |     | 
  65 |     |         // `s.earnedBeans` is an accounting mechanism that tracks the total number
  66 |     |         // of Earned Bean that are claimable by Stalkholders. When claimed via `plant()`,
  67 |     |         // it is decremented. See {Silo.sol:_plant} for more details.
  68 |     |         s.sys.silo.earnedBeans += shipmentAmount.toUint128();
  69 |     | 
  70 |     |         // Mint Stalk (as Earned Stalk).
  71 |     |         // Stalk is created here because only Bean that are allocated to the Silo receive Stalk.
  72 |     |         s.sys.silo.stalk += (shipmentAmount * C.STALK_PER_BEAN);
  73 |     | 
  74 |     |         // SafeCast unnecessary here because of prior safe cast.
  75 |     |         s.sys.silo.balances[s.sys.bean].deposited += uint128(shipmentAmount);
  76 |     |         s.sys.silo.balances[s.sys.bean].depositedBdv += uint128(shipmentAmount);
  77 |     | 
  78 |     |         // Confirm successful receipt.
  79 |     |         emit Receipt(ShipmentRecipient.SILO, shipmentAmount, abi.encode(""));
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Receive Bean at the Field. The next `shipmentAmount` Pods become harvestable.
  84 |     |      * @dev Amount should never exceed the number of Pods that are not yet Harvestable.
  85 |     |      * @param shipmentAmount Amount of Bean to receive.
  86 |     |      * @param data Encoded uint256 containing the index of the Field to receive the Bean.
  87 |     |      */
  88 |     |     function fieldReceive(uint256 shipmentAmount, bytes memory data) private {
  89 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  90 |     | 
  91 |     |         uint256 fieldId = abi.decode(data, (uint256));
  92 |     |         require(fieldId < s.sys.fieldCount, "Field does not exist");
  93 |     |         s.sys.fields[fieldId].harvestable += shipmentAmount;
  94 |     | 
  95 |     |         // Confirm successful receipt.
  96 |     |         emit Receipt(ShipmentRecipient.FIELD, shipmentAmount, data);
  97 |     |     }
  98 |     | 
  99 |     |     function internalBalanceReceive(uint256 shipmentAmount, bytes memory data) private {
 100 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 101 |     | 
 102 |     |         address destination = abi.decode(data, (address));
 103 |     |         LibTransfer.sendToken(
 104 |     |             IERC20(s.sys.bean),
 105 |     |             shipmentAmount,
 106 |     |             destination,
 107 |     |             LibTransfer.To.INTERNAL
 108 |     |         );
 109 |     | 
 110 |     |         // Confirm successful receipt.
 111 |     |         emit Receipt(ShipmentRecipient.INTERNAL_BALANCE, shipmentAmount, data);
 112 |     |     }
 113 |     | 
 114 |     |     function externalBalanceReceive(uint256 shipmentAmount, bytes memory data) private {
 115 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 116 |     | 
 117 |     |         address destination = abi.decode(data, (address));
 118 |     |         LibTransfer.sendToken(
 119 |     |             IERC20(s.sys.bean),
 120 |     |             shipmentAmount,
 121 |     |             destination,
 122 |     |             LibTransfer.To.EXTERNAL
 123 |     |         );
 124 |     | 
 125 |     |         // Confirm successful receipt.
 126 |     |         emit Receipt(ShipmentRecipient.EXTERNAL_BALANCE, shipmentAmount, data);
 127 |     |     }
 128 |     | }
 129 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibShipping.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {AppStorage, LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
   6 |     | import {LibReceiving} from "contracts/libraries/LibReceiving.sol";
   7 |     | import {ShipmentRecipient, ShipmentRoute} from "contracts/beanstalk/storage/System.sol";
   8 |     | import {ShipmentPlan} from "contracts/ecosystem/ShipmentPlanner.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title LibShipping
  12 |     |  * @notice Library for shipments logic.
  13 |     |  * @dev Functions are marked public to reduce the size of SeasonFacet contract.
  14 |     |  */
  15 | *   | library LibShipping {
  16 |     |     /**
  17 |     |      * @notice Emitted during Sunrise when Beans mints are shipped through active routes.
  18 |     |      * @param season The Season in which Beans were distributed.
  19 |     |      * @param shipmentAmount The amount of Beans across all routes.
  20 |     |      */
  21 |     |     event Shipped(uint32 indexed season, uint256 shipmentAmount);
  22 |     | 
  23 |     |     /**
  24 |     |      * @notice Distributes Beans across all active shipping routes.
  25 |     |      * @param beansToShip The total number of Beans to distribute.
  26 |     |      */
  27 |     |     function ship(uint256 beansToShip) public {
  28 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  29 |     | 
  30 |     |         uint256 remainingBeansToShip = beansToShip;
  31 |     |         ShipmentRoute[] memory shipmentRoutes = s.sys.shipmentRoutes;
  32 |     |         ShipmentPlan[] memory shipmentPlans = new ShipmentPlan[](shipmentRoutes.length);
  33 |     |         uint256[] memory shipmentAmounts = new uint256[](shipmentRoutes.length);
  34 |     |         uint256 totalPoints;
  35 |     |         (shipmentPlans, totalPoints) = getShipmentPlans(shipmentRoutes);
  36 |     | 
  37 |     |         // May need to calculate individual stream rewards multiple times, since
  38 |     |         // they are dependent on each others caps. Once a cap is reached, excess Beans are
  39 |     |         // spread to other streams, proportional to their points.
  40 |     |         for (uint256 i; i < shipmentRoutes.length; i++) {
  41 |     |             bool capExceeded;
  42 |     | 
  43 |     |             // Calculate the amount of rewards to each stream. Ignores cap and plans with 0 points.
  44 |     |             getBeansFromPoints(shipmentAmounts, shipmentPlans, totalPoints, remainingBeansToShip);
  45 |     | 
  46 |     |             // Iterate though each stream, checking if cap is exceeded.
  47 |     |             for (uint256 j; j < shipmentAmounts.length; j++) {
  48 |     |                 // If shipment amount exceeds plan cap, adjust plan and totals before recomputing.
  49 |     |                 if (shipmentAmounts[j] > shipmentPlans[j].cap) {
  50 |     |                     shipmentAmounts[j] = shipmentPlans[j].cap;
  51 |     |                     remainingBeansToShip -= shipmentPlans[j].cap;
  52 |     |                     totalPoints -= shipmentPlans[j].points;
  53 |     |                     shipmentPlans[j].points = 0;
  54 |     |                     capExceeded = true;
  55 |     |                 }
  56 |     |             }
  57 |     | 
  58 |     |             // If no cap exceeded, amounts are final.
  59 |     |             if (!capExceeded) break;
  60 |     |         }
  61 |     | 
  62 |     |         // Ship it.
  63 |     |         for (uint256 i; i < shipmentAmounts.length; i++) {
  64 |     |             if (shipmentAmounts[i] == 0) continue;
  65 |     |             LibReceiving.receiveShipment(
  66 |     |                 shipmentRoutes[i].recipient,
  67 |     |                 shipmentAmounts[i],
  68 |     |                 shipmentRoutes[i].data
  69 |     |             );
  70 |     |         }
  71 |     | 
  72 |     |         emit Shipped(s.sys.season.current, beansToShip);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @notice Determines the amount of Beans to distribute to each shipping route based on points.
  77 |     |      * @dev Does not factor in route cap.
  78 |     |      * @dev If points are 0, does not alter the associated shippingAmount.
  79 |     |      * @dev Assumes shipmentAmounts and shipmentRoutes have matching shape and ordering.
  80 |     |      */
  81 |     |     function getBeansFromPoints(
  82 |     |         uint256[] memory shipmentAmounts,
  83 |     |         ShipmentPlan[] memory shipmentPlans,
  84 |     |         uint256 totalPoints,
  85 |     |         uint256 beansToShip
  86 |     |     ) public pure {
  87 |     |         for (uint256 i; i < shipmentPlans.length; i++) {
  88 |     |             // Do not modify amount for streams with 0 points. They either are zero or have already been set.
  89 |     |             if (shipmentPlans[i].points == 0) continue;
  90 |     |             shipmentAmounts[i] = (beansToShip * shipmentPlans[i].points) / totalPoints; // round down
  91 |     |         }
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @notice Gets the shipping plan for all shipping routes.
  96 |     |      * @dev Determines which routes are active and how many Beans they will receive.
  97 |     |      * @dev GetPlan functions should never fail/revert. Else they will have no Beans allocated.
  98 |     |      */
  99 |     |     function getShipmentPlans(
 100 |     |         ShipmentRoute[] memory shipmentRoutes
 101 |     |     ) public view returns (ShipmentPlan[] memory shipmentPlans, uint256 totalPoints) {
 102 |     |         shipmentPlans = new ShipmentPlan[](shipmentRoutes.length);
 103 |     |         for (uint256 i; i < shipmentRoutes.length; i++) {
 104 |     |             (bool success, bytes memory returnData) = shipmentRoutes[i].planContract.staticcall(
 105 |     |                 abi.encodeWithSelector(shipmentRoutes[i].planSelector, shipmentRoutes[i].data)
 106 |     |             );
 107 |     |             if (success) {
 108 |     |                 shipmentPlans[i] = abi.decode(returnData, (ShipmentPlan));
 109 |     |             } else {
 110 |     |                 shipmentPlans[i] = ShipmentPlan({points: 0, cap: 0});
 111 |     |             }
 112 |     |             totalPoints += shipmentPlans[i].points;
 113 |     |         }
 114 |     |     }
 115 |     | }
 116 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/LibTractor.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @title Lib Tractor
   9 |     |  **/
  10 | *   | library LibTractor {
  11 |     |     enum CounterUpdateType {
  12 |     |         INCREASE,
  13 |     |         DECREASE
  14 |     |     }
  15 |     | 
  16 |     |     bytes32 private constant TRACTOR_HASHED_NAME = keccak256(bytes("Tractor"));
  17 |     |     bytes32 private constant EIP712_TYPE_HASH =
  18 |     |         keccak256(
  19 |     |             bytes(
  20 |     |                 "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
  21 |     |             )
  22 |     |         );
  23 |     |     bytes32 public constant BLUEPRINT_TYPE_HASH =
  24 |     |         keccak256(
  25 |     |             bytes(
  26 |     |                 "Blueprint(address publisher,bytes data,bytes32[] operatorPasteInstrs,uint256 maxNonce,uint256 startTime,uint256 endTime)"
  27 |     |             )
  28 |     |         );
  29 |     | 
  30 |     |     event TractorVersionSet(string version);
  31 |     | 
  32 |     |     struct TractorStorage {
  33 |     |         // Number of times the blueprint has been run.
  34 |     |         mapping(bytes32 => uint256) blueprintNonce;
  35 |     |         // Publisher Address => counter id => counter value.
  36 |     |         mapping(address => mapping(bytes32 => uint256)) blueprintCounters;
  37 |     |         // Publisher of current operations. Set to address(1) when no active publisher.
  38 |     |         address payable activePublisher;
  39 |     |         // Version of Tractor. Only Blueprints using current Version can run.
  40 |     |         string version;
  41 |     |         // Hash of currently executing blueprint
  42 |     |         bytes32 currentBlueprintHash;
  43 |     |         // Address of the currently executing operator
  44 |     |         address operator;
  45 |     |     }
  46 |     | 
  47 |     |     // Blueprint stores blueprint related values
  48 |     |     struct Blueprint {
  49 |     |         address publisher;
  50 |     |         bytes data;
  51 |     |         bytes32[] operatorPasteInstrs;
  52 |     |         uint256 maxNonce;
  53 |     |         uint256 startTime;
  54 |     |         uint256 endTime;
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice Stores blueprint, hash, and signature, which enables verification.
  59 |     |      */
  60 |     |     struct Requisition {
  61 |     |         Blueprint blueprint;
  62 |     |         bytes32 blueprintHash; // including this is not strictly necessary, but helps avoid hashing more than once on chain
  63 |     |         bytes signature;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Get tractor storage from storage.
  68 |     |      * @return ts Storage object containing tractor data
  69 |     |      */
  70 | *   |     function _tractorStorage() internal pure returns (TractorStorage storage ts) {
  71 |     |         // keccak256("diamond.storage.tractor") == 0x7efbaaac9214ca1879e26b4df38e29a72561affb741bba775ce66d5bb6a82a07
  72 |     |         assembly {
  73 | *   |             ts.slot := 0x7efbaaac9214ca1879e26b4df38e29a72561affb741bba775ce66d5bb6a82a07
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @notice Set the tractor hashed version.
  79 |     |      */
  80 | *   |     function _setVersion(string memory version) internal {
  81 | *   |         _tractorStorage().version = version;
  82 | *   |         emit TractorVersionSet(version);
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @notice Increment the blueprint nonce by 1.
  87 |     |      * @param blueprintHash blueprint hash
  88 |     |      */
  89 |     |     function _incrementBlueprintNonce(bytes32 blueprintHash) internal {
  90 |     |         _tractorStorage().blueprintNonce[blueprintHash]++;
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice Cancel blueprint.
  95 |     |      * @dev set blueprintNonce to type(uint256).max
  96 |     |      * @param blueprintHash blueprint hash
  97 |     |      */
  98 |     |     function _cancelBlueprint(bytes32 blueprintHash) internal {
  99 |     |         _tractorStorage().blueprintNonce[blueprintHash] = type(uint256).max;
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @notice Set blueprint publisher address.
 104 |     |      * @param publisher blueprint publisher address
 105 |     |      */
 106 |     |     function _setPublisher(address payable publisher) internal {
 107 |     |         TractorStorage storage ts = _tractorStorage();
 108 |     |         require(
 109 |     |             uint160(bytes20(address(ts.activePublisher))) <= 1,
 110 |     |             "LibTractor: publisher already set"
 111 |     |         );
 112 |     |         ts.activePublisher = publisher;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @notice Reset blueprint publisher address.
 117 |     |      */
 118 | *   |     function _resetPublisher() internal {
 119 | *   |         _tractorStorage().activePublisher = payable(address(1));
 120 |     |     }
 121 |     | 
 122 |     |     /** @notice Return current activePublisher address.
 123 |     |      * @return publisher current activePublisher address
 124 |     |      */
 125 | *   |     function _getActivePublisher() internal view returns (address payable) {
 126 | *   |         return _tractorStorage().activePublisher;
 127 |     |     }
 128 |     | 
 129 |     |     /** @notice Return current activePublisher address or msg.sender if no active blueprint.
 130 |     |      * @return user to take actions on behalf of
 131 |     |      */
 132 | *   |     function _user() internal view returns (address payable user) {
 133 | *   |         user = _getActivePublisher();
 134 | *   |         if (uint160(bytes20(address(user))) <= 1) {
 135 | *   |             user = payable(msg.sender);
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Get blueprint nonce.
 141 |     |      * @param blueprintHash blueprint hash
 142 |     |      * @return nonce current blueprint nonce
 143 |     |      */
 144 |     |     function _getBlueprintNonce(bytes32 blueprintHash) internal view returns (uint256) {
 145 |     |         return _tractorStorage().blueprintNonce[blueprintHash];
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Calculates blueprint hash.
 150 |     |      * @dev https://eips.ethereum.org/EIPS/eip-712
 151 |     |      * @dev  https://github.com/BeanstalkFarms/Beanstalk/pull/727#discussion_r1577293450
 152 |     |      * @param blueprint blueprint object
 153 |     |      * @return hash calculated Blueprint hash
 154 |     |      */
 155 |     |     function _getBlueprintHash(Blueprint calldata blueprint) internal view returns (bytes32) {
 156 |     |         return
 157 |     |             _hashTypedDataV4(
 158 |     |                 keccak256(
 159 |     |                     abi.encode(
 160 |     |                         BLUEPRINT_TYPE_HASH,
 161 |     |                         blueprint.publisher,
 162 |     |                         keccak256(blueprint.data),
 163 |     |                         keccak256(abi.encodePacked(blueprint.operatorPasteInstrs)),
 164 |     |                         blueprint.maxNonce,
 165 |     |                         blueprint.startTime,
 166 |     |                         blueprint.endTime
 167 |     |                     )
 168 |     |                 )
 169 |     |             );
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice Hashes in an EIP712 compliant way.
 174 |     |      * @dev Returns an Ethereum Signed Typed Data, created from a
 175 |     |      * `domainSeparator` and a `structHash`. This produces hash corresponding
 176 |     |      * to the one signed with the
 177 |     |      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
 178 |     |      * JSON-RPC method as part of EIP-712.
 179 |     |      *
 180 |     |      * Sourced from OpenZeppelin 0.8 ECDSA lib.
 181 |     |      */
 182 |     |     function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {
 183 |     |         return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @notice Returns the domain separator for the current chain.
 188 |     |      */
 189 |     |     function _domainSeparatorV4() internal view returns (bytes32) {
 190 |     |         return
 191 |     |             keccak256(
 192 |     |                 abi.encode(
 193 |     |                     EIP712_TYPE_HASH,
 194 |     |                     TRACTOR_HASHED_NAME,
 195 |     |                     keccak256(bytes(_tractorStorage().version)),
 196 |     |                     block.chainid,
 197 |     |                     address(this)
 198 |     |                 )
 199 |     |             );
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @notice Set the current blueprint hash
 204 |     |      * @param blueprintHash The hash of the currently executing blueprint
 205 |     |      */
 206 |     |     function _setCurrentBlueprintHash(bytes32 blueprintHash) internal {
 207 |     |         _tractorStorage().currentBlueprintHash = blueprintHash;
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @notice Reset the current blueprint hash
 212 |     |      */
 213 |     |     function _resetCurrentBlueprintHash() internal {
 214 |     |         _tractorStorage().currentBlueprintHash = bytes32(uint256(1));
 215 |     |     }
 216 |     | 
 217 |     |     /**
 218 |     |      * @notice Get the current blueprint hash
 219 |     |      * @return The hash of the currently executing blueprint
 220 |     |      */
 221 |     |     function _getCurrentBlueprintHash() internal view returns (bytes32) {
 222 |     |         return _tractorStorage().currentBlueprintHash;
 223 |     |     }
 224 |     | 
 225 |     |     /**
 226 |     |      * @notice Set the operator
 227 |     |      * @param operator The operator address
 228 |     |      */
 229 |     |     function _setOperator(address operator) internal {
 230 |     |         _tractorStorage().operator = operator;
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @notice Reset the operator
 235 |     |      */
 236 |     |     function _resetOperator() internal {
 237 |     |         _tractorStorage().operator = address(1);
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @notice Get the operator
 242 |     |      * @return The operator address
 243 |     |      */
 244 |     |     function _getOperator() internal view returns (address) {
 245 |     |         return _tractorStorage().operator;
 246 |     |     }
 247 |     | }
 248 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibPRBMathRoundable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {PRBMath} from "@prb/math/contracts/PRBMath.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title LibPRBMathRoundable wraps PRB Math allow upwards rounding of 60.18 unsigned floating point mulDiv operations.
  9 |     |  * https://github.com/PaulRBerg/prb-math/releases/tag/v2.5.0
 10 |     |  **/
 11 | *   | library LibPRBMathRoundable {
 12 |     |     enum Rounding {
 13 |     |         Down, // Toward negative infinity
 14 |     |         Up, // Toward infinity
 15 |     |         Zero // Toward zero
 16 |     |     }
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 20 |     |      */
 21 |     |     function mulDiv(
 22 |     |         uint256 x,
 23 |     |         uint256 y,
 24 |     |         uint256 denominator,
 25 |     |         Rounding rounding
 26 |     |     ) internal pure returns (uint256) {
 27 |     |         uint256 result = PRBMath.mulDiv(x, y, denominator);
 28 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 29 |     |             result += 1;
 30 |     |         }
 31 |     |         return result;
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibRedundantMath128.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibRedundantMath variation of Open Zeppelin's Safe Math library for uint128.
  7 |     |  * @dev Newly developed code should not use this library. Instead opt for native arithmetic operators.
  8 |     |  *
  9 |     |  * This library replicates the behavior of 0.7 SafeMath libraries for 0.8. Safe math is unnecessary
 10 |     |  * in solidity ^0.8, so the functionality here is mostly redundant with default arithmetic
 11 |     |  * operators. However, manually updating over 1000 math operations throughout the repo was
 12 |     |  * deemed too likely to introduce logic errors. Instead, the original syntax was kept
 13 |     |  * and the underlying logic updated to be 0.8 appropriate.
 14 |     |  **/
 15 | *   | library LibRedundantMath128 {
 16 |     |     /**
 17 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 18 |     |      * overflow.
 19 |     |      *
 20 |     |      * Counterpart to Solidity's `+` operator.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - Addition cannot overflow.
 25 |     |      */
 26 | *   |     function add(uint128 a, uint128 b) internal pure returns (uint128) {
 27 | *   |         return a + b;
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 32 |     |      * overflow (when the result is negative).
 33 |     |      *
 34 |     |      * Counterpart to Solidity's `-` operator.
 35 |     |      *
 36 |     |      * Requirements:
 37 |     |      *
 38 |     |      * - Subtraction cannot overflow.
 39 |     |      */
 40 | *   |     function sub(uint128 a, uint128 b) internal pure returns (uint128) {
 41 | *   |         return a - b;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 46 |     |      * overflow.
 47 |     |      *
 48 |     |      * Counterpart to Solidity's `*` operator.
 49 |     |      *
 50 |     |      * Requirements:
 51 |     |      *
 52 |     |      * - Multiplication cannot overflow.
 53 |     |      */
 54 |     |     function mul(uint128 a, uint128 b) internal pure returns (uint128) {
 55 |     |         return a * b;
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 60 |     |      * division by zero. The result is rounded towards zero.
 61 |     |      *
 62 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 63 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 64 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 65 |     |      *
 66 |     |      * Requirements:
 67 |     |      *
 68 |     |      * - The divisor cannot be zero.
 69 |     |      */
 70 |     |     function div(uint128 a, uint128 b) internal pure returns (uint128) {
 71 |     |         return a / b;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 76 |     |      * reverting when dividing by zero.
 77 |     |      *
 78 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 79 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 80 |     |      * invalid opcode to revert (consuming all remaining gas).
 81 |     |      *
 82 |     |      * Requirements:
 83 |     |      *
 84 |     |      * - The divisor cannot be zero.
 85 |     |      */
 86 |     |     function mod(uint128 a, uint128 b) internal pure returns (uint128) {
 87 |     |         return a % b;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibRedundantMath256.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibRedundantMath variation of Open Zeppelin's Safe Math library for uint256.
  7 |     |  * @dev Newly developed code should not use this library. Instead opt for native arithmetic operators.
  8 |     |  *
  9 |     |  * This library replicates the behavior of 0.7 SafeMath libraries for 0.8. Safe math is unnecessary
 10 |     |  * in solidity ^0.8, so the functionality here is mostly redundant with default arithmetic
 11 |     |  * operators. However, manually updating over 1000 math operations throughout the repo was
 12 |     |  * deemed too likely to introduce logic errors. Instead, the original syntax was kept
 13 |     |  * and the underlying logic updated to be 0.8 appropriate.
 14 |     |  **/
 15 | *   | library LibRedundantMath256 {
 16 |     |     /**
 17 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 18 |     |      * overflow.
 19 |     |      *
 20 |     |      * Counterpart to Solidity's `+` operator.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - Addition cannot overflow.
 25 |     |      */
 26 | *   |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
 27 | *   |         return a + b;
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 32 |     |      * overflow (when the result is negative).
 33 |     |      *
 34 |     |      * Counterpart to Solidity's `-` operator.
 35 |     |      *
 36 |     |      * Requirements:
 37 |     |      *
 38 |     |      * - Subtraction cannot overflow.
 39 |     |      */
 40 | *   |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
 41 | *   |         return a - b;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 46 |     |      * overflow.
 47 |     |      *
 48 |     |      * Counterpart to Solidity's `*` operator.
 49 |     |      *
 50 |     |      * Requirements:
 51 |     |      *
 52 |     |      * - Multiplication cannot overflow.
 53 |     |      */
 54 | *   |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
 55 | *   |         return a * b;
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 60 |     |      * division by zero. The result is rounded towards zero.
 61 |     |      *
 62 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 63 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 64 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 65 |     |      *
 66 |     |      * Requirements:
 67 |     |      *
 68 |     |      * - The divisor cannot be zero.
 69 |     |      */
 70 | *   |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
 71 | *   |         return a / b;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 76 |     |      * reverting when dividing by zero.
 77 |     |      *
 78 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 79 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 80 |     |      * invalid opcode to revert (consuming all remaining gas).
 81 |     |      *
 82 |     |      * Requirements:
 83 |     |      *
 84 |     |      * - The divisor cannot be zero.
 85 |     |      */
 86 |     |     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
 87 |     |         return a % b;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibRedundantMath32.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibRedundantMath variation of Open Zeppelin's Safe Math library for uint32.
  7 |     |  * @dev Newly developed code should not use this library. Instead opt for native arithmetic operators.
  8 |     |  *
  9 |     |  * This library replicates the behavior of 0.7 SafeMath libraries for 0.8. Safe math is unnecessary
 10 |     |  * in solidity ^0.8, so the functionality here is mostly redundant with default arithmetic
 11 |     |  * operators. However, manually updating over 1000 math operations throughout the repo was
 12 |     |  * deemed too likely to introduce logic errors. Instead, the original syntax was kept
 13 |     |  * and the underlying logic updated to be 0.8 appropriate.
 14 |     |  **/
 15 | *   | library LibRedundantMath32 {
 16 |     |     /**
 17 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 18 |     |      * overflow.
 19 |     |      *
 20 |     |      * Counterpart to Solidity's `+` operator.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - Addition cannot overflow.
 25 |     |      */
 26 |     |     function add(uint32 a, uint32 b) internal pure returns (uint32) {
 27 |     |         return a + b;
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 32 |     |      * overflow (when the result is negative).
 33 |     |      *
 34 |     |      * Counterpart to Solidity's `-` operator.
 35 |     |      *
 36 |     |      * Requirements:
 37 |     |      *
 38 |     |      * - Subtraction cannot overflow.
 39 |     |      */
 40 |     |     function sub(uint32 a, uint32 b) internal pure returns (uint32) {
 41 |     |         return a - b;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 46 |     |      * overflow.
 47 |     |      *
 48 |     |      * Counterpart to Solidity's `*` operator.
 49 |     |      *
 50 |     |      * Requirements:
 51 |     |      *
 52 |     |      * - Multiplication cannot overflow.
 53 |     |      */
 54 |     |     function mul(uint32 a, uint32 b) internal pure returns (uint32) {
 55 |     |         return a * b;
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 60 |     |      * division by zero. The result is rounded towards zero.
 61 |     |      *
 62 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 63 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 64 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 65 |     |      *
 66 |     |      * Requirements:
 67 |     |      *
 68 |     |      * - The divisor cannot be zero.
 69 |     |      */
 70 |     |     function div(uint32 a, uint32 b) internal pure returns (uint32) {
 71 |     |         return a / b;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 76 |     |      * reverting when dividing by zero.
 77 |     |      *
 78 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 79 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 80 |     |      * invalid opcode to revert (consuming all remaining gas).
 81 |     |      *
 82 |     |      * Requirements:
 83 |     |      *
 84 |     |      * - The divisor cannot be zero.
 85 |     |      */
 86 | *   |     function mod(uint32 a, uint32 b) internal pure returns (uint32) {
 87 | *   |         return a % b;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibRedundantMathSigned128.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibRedundantMath variation of Open Zeppelin's Safe Math library for int128.
  7 |     |  * @dev Newly developed code should not use this library. Instead opt for native arithmetic operators.
  8 |     |  *
  9 |     |  * This library replicates the behavior of 0.7 SafeMath libraries for 0.8. Safe math is unnecessary
 10 |     |  * in solidity ^0.8, so the functionality here is mostly redundant with default arithmetic
 11 |     |  * operators. However, manually updating over 1000 math operations throughout the repo was
 12 |     |  * deemed too likely to introduce logic errors. Instead, the original syntax was kept
 13 |     |  * and the underlying logic updated to be 0.8 appropriate.
 14 |     |  **/
 15 | *   | library LibRedundantMathSigned128 {
 16 |     |     /**
 17 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 18 |     |      * overflow.
 19 |     |      *
 20 |     |      * Counterpart to Solidity's `+` operator.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - Addition cannot overflow.
 25 |     |      */
 26 |     |     function add(int128 a, int128 b) internal pure returns (int128) {
 27 |     |         return a + b;
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 32 |     |      * overflow (when the result is negative).
 33 |     |      *
 34 |     |      * Counterpart to Solidity's `-` operator.
 35 |     |      *
 36 |     |      * Requirements:
 37 |     |      *
 38 |     |      * - Subtraction cannot overflow.
 39 |     |      */
 40 |     |     function sub(int128 a, int128 b) internal pure returns (int128) {
 41 |     |         return a - b;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 46 |     |      * overflow.
 47 |     |      *
 48 |     |      * Counterpart to Solidity's `*` operator.
 49 |     |      *
 50 |     |      * Requirements:
 51 |     |      *
 52 |     |      * - Multiplication cannot overflow.
 53 |     |      */
 54 |     |     function mul(int128 a, int128 b) internal pure returns (int128) {
 55 |     |         return a * b;
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 60 |     |      * division by zero. The result is rounded towards zero.
 61 |     |      *
 62 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 63 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 64 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 65 |     |      *
 66 |     |      * Requirements:
 67 |     |      *
 68 |     |      * - The divisor cannot be zero.
 69 |     |      */
 70 |     |     function div(int128 a, int128 b) internal pure returns (int128) {
 71 |     |         return a / b;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 76 |     |      * reverting when dividing by zero.
 77 |     |      *
 78 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 79 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 80 |     |      * invalid opcode to revert (consuming all remaining gas).
 81 |     |      *
 82 |     |      * Requirements:
 83 |     |      *
 84 |     |      * - The divisor cannot be zero.
 85 |     |      */
 86 |     |     function mod(int128 a, int128 b) internal pure returns (int128) {
 87 |     |         return a % b;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibRedundantMathSigned256.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibRedundantMath variation of Open Zeppelin's Safe Math library for int256.
  7 |     |  * @dev Newly developed code should not use this library. Instead opt for native arithmetic operators.
  8 |     |  *
  9 |     |  * This library replicates the behavior of 0.7 SafeMath libraries for 0.8. Safe math is unnecessary
 10 |     |  * in solidity ^0.8, so the functionality here is mostly redundant with default arithmetic
 11 |     |  * operators. However, manually updating over 1000 math operations throughout the repo was
 12 |     |  * deemed too likely to introduce logic errors. Instead, the original syntax was kept
 13 |     |  * and the underlying logic updated to be 0.8 appropriate.
 14 |     |  **/
 15 | *   | library LibRedundantMathSigned256 {
 16 |     |     /**
 17 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 18 |     |      * overflow.
 19 |     |      *
 20 |     |      * Counterpart to Solidity's `+` operator.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - Addition cannot overflow.
 25 |     |      */
 26 |     |     function add(int256 a, int256 b) internal pure returns (int256) {
 27 |     |         return a + b;
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 32 |     |      * overflow (when the result is negative).
 33 |     |      *
 34 |     |      * Counterpart to Solidity's `-` operator.
 35 |     |      *
 36 |     |      * Requirements:
 37 |     |      *
 38 |     |      * - Subtraction cannot overflow.
 39 |     |      */
 40 |     |     function sub(int256 a, int256 b) internal pure returns (int256) {
 41 |     |         return a - b;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 46 |     |      * overflow.
 47 |     |      *
 48 |     |      * Counterpart to Solidity's `*` operator.
 49 |     |      *
 50 |     |      * Requirements:
 51 |     |      *
 52 |     |      * - Multiplication cannot overflow.
 53 |     |      */
 54 |     |     function mul(int256 a, int256 b) internal pure returns (int256) {
 55 |     |         return a * b;
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 60 |     |      * division by zero. The result is rounded towards zero.
 61 |     |      *
 62 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 63 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 64 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 65 |     |      *
 66 |     |      * Requirements:
 67 |     |      *
 68 |     |      * - The divisor cannot be zero.
 69 |     |      */
 70 |     |     function div(int256 a, int256 b) internal pure returns (int256) {
 71 |     |         return a / b;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 76 |     |      * reverting when dividing by zero.
 77 |     |      *
 78 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 79 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 80 |     |      * invalid opcode to revert (consuming all remaining gas).
 81 |     |      *
 82 |     |      * Requirements:
 83 |     |      *
 84 |     |      * - The divisor cannot be zero.
 85 |     |      */
 86 |     |     function mod(int256 a, int256 b) internal pure returns (int256) {
 87 |     |         return a % b;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Math/LibRedundantMathSigned96.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | /**
  6 |     |  * @title LibRedundantMath variation of Open Zeppelin's Safe Math library for int96.
  7 |     |  * @dev Newly developed code should not use this library. Instead opt for native arithmetic operators.
  8 |     |  *
  9 |     |  * This library replicates the behavior of 0.7 SafeMath libraries for 0.8. Safe math is unnecessary
 10 |     |  * in solidity ^0.8, so the functionality here is mostly redundant with default arithmetic
 11 |     |  * operators. However, manually updating over 1000 math operations throughout the repo was
 12 |     |  * deemed too likely to introduce logic errors. Instead, the original syntax was kept
 13 |     |  * and the underlying logic updated to be 0.8 appropriate.
 14 |     |  **/
 15 | *   | library LibRedundantMathSigned96 {
 16 |     |     /**
 17 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 18 |     |      * overflow.
 19 |     |      *
 20 |     |      * Counterpart to Solidity's `+` operator.
 21 |     |      *
 22 |     |      * Requirements:
 23 |     |      *
 24 |     |      * - Addition cannot overflow.
 25 |     |      */
 26 |     |     function add(int96 a, int96 b) internal pure returns (int96) {
 27 |     |         return a + b;
 28 |     |     }
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 32 |     |      * overflow (when the result is negative).
 33 |     |      *
 34 |     |      * Counterpart to Solidity's `-` operator.
 35 |     |      *
 36 |     |      * Requirements:
 37 |     |      *
 38 |     |      * - Subtraction cannot overflow.
 39 |     |      */
 40 | *   |     function sub(int96 a, int96 b) internal pure returns (int96) {
 41 | *   |         return a - b;
 42 |     |     }
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 46 |     |      * overflow.
 47 |     |      *
 48 |     |      * Counterpart to Solidity's `*` operator.
 49 |     |      *
 50 |     |      * Requirements:
 51 |     |      *
 52 |     |      * - Multiplication cannot overflow.
 53 |     |      */
 54 | *   |     function mul(int96 a, int96 b) internal pure returns (int96) {
 55 | *   |         return a * b;
 56 |     |     }
 57 |     | 
 58 |     |     /**
 59 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 60 |     |      * division by zero. The result is rounded towards zero.
 61 |     |      *
 62 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 63 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 64 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 65 |     |      *
 66 |     |      * Requirements:
 67 |     |      *
 68 |     |      * - The divisor cannot be zero.
 69 |     |      */
 70 |     |     function div(int96 a, int96 b) internal pure returns (int96) {
 71 |     |         return a / b;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 76 |     |      * reverting when dividing by zero.
 77 |     |      *
 78 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 79 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 80 |     |      * invalid opcode to revert (consuming all remaining gas).
 81 |     |      *
 82 |     |      * Requirements:
 83 |     |      *
 84 |     |      * - The divisor cannot be zero.
 85 |     |      */
 86 |     |     function mod(int96 a, int96 b) internal pure returns (int96) {
 87 |     |         return a % b;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Minting/LibMinting.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  8 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  9 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
 10 |     | import {C} from "contracts/C.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title Minting Library
 14 |     |  * @notice Contains Helper Fucntions for Minting related functionality.
 15 |     |  **/
 16 | *   | library LibMinting {
 17 |     |     using LibRedundantMath256 for uint256;
 18 |     | 
 19 |     |     function checkForMaxDeltaB(
 20 |     |         uint256 absoluteMax,
 21 |     |         uint256 relativeMax,
 22 |     |         int256 deltaB
 23 |     |     ) internal view returns (int256) {
 24 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 25 |     |         // get the maximum deltaB based on the relative max
 26 |     |         int256 maxDeltaB = int256(
 27 |     |             BeanstalkERC20(s.sys.bean).totalSupply().mul(relativeMax).div(C.PRECISION)
 28 |     |         );
 29 |     | 
 30 |     |         // if the absolute max is greater than the relative max, use the absolute max
 31 |     |         if (int256(absoluteMax) > maxDeltaB) maxDeltaB = int256(absoluteMax);
 32 |     |         // if the deltaB is negative, return the negative maxDeltaB
 33 |     |         if (deltaB < 0) return deltaB > -maxDeltaB ? deltaB : -maxDeltaB;
 34 |     |         return deltaB < maxDeltaB ? deltaB : maxDeltaB;
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Minting/LibWellMinting.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  *
   4 |     |  */
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {LibAppStorage} from "../LibAppStorage.sol";
   8 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   9 |     | import {LibMinting} from "./LibMinting.sol";
  10 |     | import {C} from "contracts/C.sol";
  11 |     | import {ICumulativePump} from "contracts/interfaces/basin/pumps/ICumulativePump.sol";
  12 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  13 |     | import {Call, IWell} from "contracts/interfaces/basin/IWell.sol";
  14 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  15 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  16 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  17 |     | import {IBeanstalkWellFunction} from "contracts/interfaces/basin/IBeanstalkWellFunction.sol";
  18 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  19 |     | import {IInstantaneousPump} from "contracts/interfaces/basin/pumps/IInstantaneousPump.sol";
  20 |     | 
  21 |     | /**
  22 |     |  * @title Well Minting Oracle Library
  23 |     |  * @notice Well Minting Oracle can be Checked or Captured to compute
  24 |     |  * the time weighted average Delta B since the last time the Oracle was Captured
  25 |     |  * for a given Well.
  26 |     |  *
  27 |     |  * @dev
  28 |     |  * The Oracle uses the Season timestamp stored in `s.sys.season.timestamp` to determine how many seconds
  29 |     |  * it has been since the last Season instead of storing its own for efficiency purposes.
  30 |     |  * Each Capture stores the encoded cumulative reserves returned by the Pump in `s.wellOracleSnapshots[well]`.
  31 |     |  *
  32 |     |  */
  33 | *   | library LibWellMinting {
  34 |     |     using LibRedundantMathSigned256 for int256;
  35 |     |     using LibRedundantMath256 for uint256;
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Emitted when a Well Minting Oracle is captured.
  39 |     |      * @param season The season that the Well was captured.
  40 |     |      * @param well The Well that was captured.
  41 |     |      * @param deltaB The time weighted average delta B computed during the Oracle capture.
  42 |     |      * @param cumulativeReserves The encoded cumulative reserves that were snapshotted most by the Oracle capture.
  43 |     |      */
  44 |     |     event WellOracle(uint32 indexed season, address well, int256 deltaB, bytes cumulativeReserves);
  45 |     | 
  46 |     |     //////////////////// CHECK ////////////////////
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Caps the deltaB at the absolute and relative max.
  50 |     |      * @return deltaB The time weighted average delta B balance since the last `capture` call.
  51 |     |      */
  52 |     |     function check(address well) external view returns (int256 deltaB) {
  53 |     |         deltaB = checkDeltaB(well);
  54 |     |         deltaB = LibMinting.checkForMaxDeltaB(C.WELL_ABSOLUTE_MAX, C.WELL_RATIO_MAX, deltaB);
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Returns the time weighted average delta B in a given Well
  59 |     |      * since the last Sunrise.
  60 |     |      * @return deltaB The time weighted average delta B balance since the last `capture` call.
  61 |     |      */
  62 |     |     function checkDeltaB(address well) internal view returns (int256 deltaB) {
  63 |     |         bytes memory lastSnapshot = LibAppStorage.diamondStorage().sys.wellOracleSnapshots[well];
  64 |     |         // If the length of the stored Snapshot for a given Well is 0,
  65 |     |         // then the Oracle is not initialized.
  66 |     |         if (lastSnapshot.length > 0) {
  67 |     |             (deltaB, , , ) = twaDeltaB(well, lastSnapshot);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     //////////////////// CHECK ////////////////////
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Returns the time weighted average delta B in a given Well
  75 |     |      * since the last Sunrise and snapshots the current cumulative reserves.
  76 |     |      * @return deltaB The time weighted average delta B balance since the last `capture` call.
  77 |     |      */
  78 |     |     function capture(address well) external returns (int256 deltaB) {
  79 |     |         bytes memory lastSnapshot = LibAppStorage.diamondStorage().sys.wellOracleSnapshots[well];
  80 |     |         // If the length of the stored Snapshot for a given Well is 0,
  81 |     |         // then the Oracle is not initialized.
  82 |     |         if (lastSnapshot.length > 0) {
  83 |     |             deltaB = updateOracle(well, lastSnapshot);
  84 |     |         } else {
  85 |     |             initializeOracle(well);
  86 |     |         }
  87 |     | 
  88 |     |         deltaB = LibMinting.checkForMaxDeltaB(C.WELL_ABSOLUTE_MAX, C.WELL_RATIO_MAX, deltaB);
  89 |     |     }
  90 |     | 
  91 |     |     //////////////////// Oracle ////////////////////
  92 |     | 
  93 |     |     /**
  94 |     |      * Initializes the Well Minting Oracle for a given Well by snapshotting the current
  95 |     |      * encoded cumulative reserves from a Beanstalk supported pump.
  96 |     |      */
  97 |     |     function initializeOracle(address well) internal {
  98 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  99 |     | 
 100 |     |         // If pump has not been initialized for `well`, `readCumulativeReserves` will revert.
 101 |     |         // Need to handle failure gracefully, so Sunrise does not revert.
 102 |     |         Call[] memory pumps = IWell(well).pumps();
 103 |     |         try ICumulativePump(pumps[0].target).readCumulativeReserves(well, pumps[0].data) returns (
 104 |     |             bytes memory lastSnapshot
 105 |     |         ) {
 106 |     |             s.sys.wellOracleSnapshots[well] = lastSnapshot;
 107 |     |             emit WellOracle(s.sys.season.current, well, 0, lastSnapshot);
 108 |     |         } catch {
 109 |     |             emit WellOracle(s.sys.season.current, well, 0, new bytes(0));
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /**
 114 |     |      * @dev Updates the Oracle snapshot for a given Well and returns the deltaB
 115 |     |      * given the previous snapshot in the Well
 116 |     |      */
 117 |     |     function updateOracle(
 118 |     |         address well,
 119 |     |         bytes memory lastSnapshot
 120 |     |     ) internal returns (int256 deltaB) {
 121 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 122 |     |         uint256[] memory twaReserves;
 123 |     |         uint256[] memory ratios;
 124 |     |         (deltaB, s.sys.wellOracleSnapshots[well], twaReserves, ratios) = twaDeltaB(
 125 |     |             well,
 126 |     |             lastSnapshot
 127 |     |         );
 128 |     | 
 129 |     |         // Set the Well reserves in storage, so that it can be read when calculating the
 130 |     |         // twa liquidity of the well when calculating the L2SR.
 131 |     |         // set the USD price of the non bean token so that it can be read when
 132 |     |         // calculating the price of Bean. See {LibEvaluate.evalPrice}.
 133 |     |         LibWell.setTwaReservesForWell(well, twaReserves);
 134 |     |         LibWell.setUsdTokenPriceForWell(well, ratios);
 135 |     |         emit WellOracle(s.sys.season.current, well, deltaB, s.sys.wellOracleSnapshots[well]);
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Calculates the delta B of a given well for a given set of well state parameters.
 140 |     |      * Designed to work for instantaneous and twa delta B calculations.
 141 |     |      */
 142 |     |     function getDeltaBInfoFromWell(
 143 |     |         address well,
 144 |     |         uint256[] memory reserves,
 145 |     |         bytes memory snapshot,
 146 |     |         uint256 lookback
 147 |     |     ) internal view returns (int256, bytes memory, uint256[] memory, uint256[] memory) {
 148 |     |         // get well tokens
 149 |     |         IERC20[] memory tokens = IWell(well).tokens();
 150 |     |         (uint256[] memory ratios, uint256 beanIndex, bool success) = LibWell.getRatiosAndBeanIndex(
 151 |     |             tokens,
 152 |     |             lookback
 153 |     |         );
 154 |     | 
 155 |     |         // If the Bean reserve is less than the minimum, the minting oracle should be considered off.
 156 |     |         if (reserves[beanIndex] < C.WELL_MINIMUM_BEAN_BALANCE) {
 157 |     |             return (0, snapshot, new uint256[](0), ratios);
 158 |     |         }
 159 |     | 
 160 |     |         // If the USD Oracle oracle call fails, the minting oracle should be considered off.
 161 |     |         if (!success) {
 162 |     |             return (0, snapshot, reserves, new uint256[](0));
 163 |     |         }
 164 |     | 
 165 |     |         int256 deltaB = calculateDeltaBAtBeanIndex(well, reserves, ratios, beanIndex);
 166 |     | 
 167 |     |         return (deltaB, snapshot, reserves, ratios);
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @dev Calculates the delta B at a given Bean index for a given Well address
 172 |     |      * based on the current well reserves, well ratios and well function.
 173 |     |      */
 174 |     |     function calculateDeltaBAtBeanIndex(
 175 |     |         address well,
 176 |     |         uint256[] memory reserves,
 177 |     |         uint256[] memory ratios,
 178 |     |         uint256 beanIndex
 179 |     |     ) internal view returns (int256) {
 180 |     |         Call memory wellFunction = IWell(well).wellFunction();
 181 |     |         try
 182 |     |             IBeanstalkWellFunction(wellFunction.target).calcReserveAtRatioSwap(
 183 |     |                 reserves,
 184 |     |                 beanIndex,
 185 |     |                 ratios,
 186 |     |                 wellFunction.data
 187 |     |             )
 188 |     |         returns (uint256 reserveAtRatioSwap) {
 189 |     |             return int256(reserveAtRatioSwap).sub(int256(reserves[beanIndex]));
 190 |     |         } catch {
 191 |     |             return 0;
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Calculates the time weighted average delta B since the input snapshot for
 197 |     |      * a given Well address.
 198 |     |      */
 199 |     |     function twaDeltaB(
 200 |     |         address well,
 201 |     |         bytes memory lastSnapshot
 202 |     |     ) internal view returns (int256, bytes memory, uint256[] memory, uint256[] memory) {
 203 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 204 |     |         // Try to call `readTwaReserves` and handle failure gracefully, so Sunrise does not revert.
 205 |     |         // On failure, reset the Oracle by returning an empty snapshot and a delta B of 0.
 206 |     |         Call[] memory pumps = IWell(well).pumps();
 207 |     |         try
 208 |     |             ICumulativePump(pumps[0].target).readTwaReserves(
 209 |     |                 well,
 210 |     |                 lastSnapshot,
 211 |     |                 uint40(s.sys.season.timestamp),
 212 |     |                 pumps[0].data
 213 |     |             )
 214 |     |         returns (uint256[] memory twaReserves, bytes memory snapshot) {
 215 |     |             // well, reserves, snapshot  lookback
 216 |     |             return (
 217 |     |                 getDeltaBInfoFromWell(
 218 |     |                     well,
 219 |     |                     twaReserves,
 220 |     |                     snapshot,
 221 |     |                     block.timestamp.sub(s.sys.season.timestamp)
 222 |     |                 )
 223 |     |             );
 224 |     |         } catch {
 225 |     |             // if the pump fails, return all 0s to avoid the sunrise reverting.
 226 |     |             return (0, new bytes(0), new uint256[](0), new uint256[](0));
 227 |     |         }
 228 |     |     }
 229 |     | 
 230 |     |     /**
 231 |     |      * @dev Calculates the instantaneous delta B for a given Well address.
 232 |     |      * @param well The address of the Well.
 233 |     |      * @return deltaB The instantaneous delta B balance since the last `capture` call.
 234 |     |      */
 235 |     |     function instantaneousDeltaB(address well) internal view returns (int256) {
 236 |     |         Call[] memory pumps = IWell(well).pumps();
 237 |     |         try
 238 |     |             IInstantaneousPump(pumps[0].target).readInstantaneousReserves(well, pumps[0].data)
 239 |     |         returns (uint256[] memory instReserves) {
 240 |     |             // if well is not initialized, return 0.
 241 |     |             if (instReserves.length == 0) {
 242 |     |                 return 0;
 243 |     |             }
 244 |     |             //                                          well, reserves,   snapshot,  lookback
 245 |     |             (int256 deltaB, , , ) = getDeltaBInfoFromWell(well, instReserves, new bytes(0), 0);
 246 |     |             return (deltaB);
 247 |     |         } catch {
 248 |     |             return 0;
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Calculates the total instantaneous delta B for all whitelisted Wells.
 254 |     |      */
 255 |     |     function getTotalInstantaneousDeltaB() internal view returns (int256 instDeltaB) {
 256 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 257 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 258 |     |             int256 wellInstDeltaB = instantaneousDeltaB(tokens[i]);
 259 |     |             instDeltaB += wellInstDeltaB;
 260 |     |         }
 261 |     |     }
 262 |     | }
 263 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Oracle/LibChainlinkOracle.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {IChainlinkAggregator} from "contracts/interfaces/IChainlinkAggregator.sol";
   9 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @title Chainlink Oracle Library
  13 |     |  * @notice Contains functionalty to fetch prices from Chainlink price feeds.
  14 |     |  * @dev currently supports:
  15 |     |  * - ETH/USD price feed
  16 |     |  **/
  17 | *   | library LibChainlinkOracle {
  18 |     |     using LibRedundantMath256 for uint256;
  19 |     | 
  20 |     |     uint256 constant PRECISION = 1e6; // use 6 decimal precision.
  21 |     | 
  22 |     |     // timeout for Oracles with a 1 hour heartbeat.
  23 |     |     uint256 constant FOUR_HOUR_TIMEOUT = 14400;
  24 |     |     // timeout for Oracles with a 1 day heartbeat.
  25 |     |     uint256 constant FOUR_DAY_TIMEOUT = 345600;
  26 |     | 
  27 |     |     struct TwapVariables {
  28 |     |         uint256 cumulativePrice;
  29 |     |         uint256 endTimestamp;
  30 |     |         uint256 lastTimestamp;
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Returns the TOKEN1/TOKEN2, or TOKEN2/TOKEN1 price with the option of using a TWA lookback.
  35 |     |      * Use `lookback = 0` for the instantaneous price. `lookback > 0` for a TWAP.
  36 |     |      * Use `tokenDecimals = 0` for TOKEN1/TOKEN2 price. `tokenDecimals > 0` for TOKEN2/TOKEN1 price.
  37 |     |      * Return value has 6 decimal precision if using TOKEN1/TOKEN2, and `tokenDecimals` if using TOKEN2/TOKEN1.
  38 |     |      * Returns 0 if `priceAggregatorAddress` is broken or frozen.
  39 |     |      **/
  40 | *   |     function getTokenPrice(
  41 |     |         address priceAggregatorAddress,
  42 |     |         uint256 maxTimeout,
  43 |     |         uint256 tokenDecimals,
  44 |     |         uint256 lookback,
  45 |     |         bool isMillion
  46 | *   |     ) internal view returns (uint256 price) {
  47 | *   |         return
  48 | *   |             lookback > 0
  49 |     |                 ? getTwap(priceAggregatorAddress, maxTimeout, tokenDecimals, lookback, isMillion)
  50 | *   |                 : getPrice(priceAggregatorAddress, maxTimeout, tokenDecimals, isMillion);
  51 |     |     }
  52 |     | 
  53 | *   |     function getTokenPrice(
  54 |     |         address priceAggregatorAddress,
  55 |     |         uint256 maxTimeout,
  56 |     |         uint256 tokenDecimals,
  57 |     |         uint256 lookback
  58 | *   |     ) internal view returns (uint256 price) {
  59 | *   |         return getTokenPrice(priceAggregatorAddress, maxTimeout, tokenDecimals, lookback, false);
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Returns the price of a given `priceAggregator`
  64 |     |      * Use `tokenDecimals = 0` for TOKEN1/TOKEN2 price. `tokenDecimals > 0` for TOKEN2/TOKEN1 price
  65 |     |      * where TOKEN1 is the numerator asset and TOKEN2 is the asset the oracle is denominated in.
  66 |     |      * Return value has 6 decimal precision if using TOKEN1/TOKEN2, and `tokenDecimals` if using TOKEN2/TOKEN1.
  67 |     |      * Returns 0 if Chainlink's price feed is broken or frozen.
  68 |     |      **/
  69 | *   |     function getPrice(
  70 |     |         address priceAggregatorAddress,
  71 |     |         uint256 maxTimeout,
  72 |     |         uint256 tokenDecimals,
  73 |     |         bool isMillion
  74 | *   |     ) internal view returns (uint256 price) {
  75 | *   |         IChainlinkAggregator priceAggregator = IChainlinkAggregator(priceAggregatorAddress);
  76 |     |         // First, try to get current decimal precision:
  77 | *   |         uint8 decimals;
  78 | *   |         try priceAggregator.decimals() returns (uint8 _decimals) {
  79 |     |             // If call to Chainlink succeeds, record the current decimal precision
  80 | *   |             decimals = _decimals;
  81 |     |         } catch {
  82 |     |             // If call to Chainlink aggregator reverts, return a price of 0 indicating failure
  83 |     |             return 0;
  84 |     |         }
  85 |     | 
  86 |     |         // Secondly, try to get latest price data:
  87 | *   |         try priceAggregator.latestRoundData() returns (
  88 |     |             uint80 roundId,
  89 |     |             int256 answer,
  90 |     |             uint256 /* startedAt */,
  91 |     |             uint256 timestamp,
  92 |     |             uint80 /* answeredInRound */
  93 |     |         ) {
  94 |     |             // Check for an invalid roundId that is 0
  95 | *   |             if (roundId == 0) return 0;
  96 | *   |             if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp, maxTimeout)) {
  97 |     |                 return 0;
  98 |     |             }
  99 |     | 
 100 |     |             // if token decimals is greater than 0, return the TOKEN2/TOKEN1 price instead (i.e invert the price).
 101 | *   |             if (tokenDecimals > 0) {
 102 |     |                 // if `isMillion` is set, return `MillionTOKEN2/TOKEN1` Price instead
 103 |     |                 // (i.e, the amount of TOKEN1 equal to a million of TOKEN2)
 104 | *   |                 if (isMillion) tokenDecimals = tokenDecimals + 6;
 105 | *   |                 price = uint256(10 ** (tokenDecimals + decimals)).div(uint256(answer));
 106 |     |             } else {
 107 |     |                 // Adjust to 6 decimal precision.
 108 |     |                 price = uint256(answer).mul(PRECISION).div(10 ** decimals);
 109 |     |             }
 110 |     |         } catch {
 111 |     |             // If call to Chainlink aggregator reverts, return a price of 0 indicating failure
 112 |     |             return 0;
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Returns the TWAP price from the Chainlink Oracle over the past `lookback` seconds.
 118 |     |      * Use `tokenDecimals = 0` for TOKEN1/TOKEN2 price. `tokenDecimals > 0` for TOKEN2/TOKEN1 price.
 119 |     |      * Return value has 6 decimal precision if using TOKEN1/TOKEN2, and `tokenDecimals` if using TOKEN2/TOKEN1.
 120 |     |      * Returns 0 if Chainlink's price feed is broken or frozen.
 121 |     |      **/
 122 |     |     function getTwap(
 123 |     |         address priceAggregatorAddress,
 124 |     |         uint256 maxTimeout,
 125 |     |         uint256 tokenDecimals,
 126 |     |         uint256 lookback,
 127 |     |         bool isMillion
 128 |     |     ) internal view returns (uint256 price) {
 129 |     |         // First, try to get current decimal precision:
 130 |     |         uint8 decimals;
 131 |     |         try IChainlinkAggregator(priceAggregatorAddress).decimals() returns (uint8 _decimals) {
 132 |     |             // If call to Chainlink succeeds, record the current decimal precision
 133 |     |             decimals = _decimals;
 134 |     |         } catch {
 135 |     |             // If call to Chainlink aggregator reverts, return a price of 0 indicating failure
 136 |     |             return 0;
 137 |     |         }
 138 |     | 
 139 |     |         // Secondly, try to get latest price data:
 140 |     |         try IChainlinkAggregator(priceAggregatorAddress).latestRoundData() returns (
 141 |     |             uint80 roundId,
 142 |     |             int256 answer,
 143 |     |             uint256 /* startedAt */,
 144 |     |             uint256 timestamp,
 145 |     |             uint80 /* answeredInRound */
 146 |     |         ) {
 147 |     |             // Check for an invalid roundId that is 0
 148 |     |             if (roundId == 0) return 0;
 149 |     |             if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp, maxTimeout)) {
 150 |     |                 return 0;
 151 |     |             }
 152 |     | 
 153 |     |             TwapVariables memory t;
 154 |     | 
 155 |     |             t.endTimestamp = block.timestamp.sub(lookback);
 156 |     | 
 157 |     |             if (isMillion) {
 158 |     |                 // if `isMillion` flag is enabled,
 159 |     |                 tokenDecimals = tokenDecimals + 6;
 160 |     |             }
 161 |     |             // Check if last round was more than `lookback` ago.
 162 |     |             if (timestamp <= t.endTimestamp) {
 163 |     |                 if (tokenDecimals > 0) {
 164 |     |                     return uint256(10 ** (tokenDecimals + decimals)).div(uint256(answer));
 165 |     |                 } else {
 166 |     |                     // Adjust to 6 decimal precision.
 167 |     |                     return uint256(answer).mul(PRECISION).div(10 ** decimals);
 168 |     |                 }
 169 |     |             } else {
 170 |     |                 t.lastTimestamp = block.timestamp;
 171 |     |                 // Loop through previous rounds and compute cumulative sum until
 172 |     |                 // a round at least `lookback` seconds ago is reached.
 173 |     |                 while (timestamp > t.endTimestamp) {
 174 |     |                     // if token decimals is greater than 0, return the TOKEN2/TOKEN1 price instead (i.e invert the price).
 175 |     |                     if (tokenDecimals > 0) {
 176 |     |                         answer = int256((10 ** (tokenDecimals + decimals)) / (uint256(answer)));
 177 |     |                     }
 178 |     |                     t.cumulativePrice = t.cumulativePrice.add(
 179 |     |                         uint256(answer).mul(t.lastTimestamp.sub(timestamp))
 180 |     |                     );
 181 |     |                     roundId -= 1;
 182 |     |                     t.lastTimestamp = timestamp;
 183 |     |                     (answer, timestamp) = getRoundData(
 184 |     |                         IChainlinkAggregator(priceAggregatorAddress),
 185 |     |                         roundId
 186 |     |                     );
 187 |     |                     if (
 188 |     |                         checkForInvalidTimestampOrAnswer(
 189 |     |                             timestamp,
 190 |     |                             answer,
 191 |     |                             t.lastTimestamp,
 192 |     |                             maxTimeout
 193 |     |                         )
 194 |     |                     ) {
 195 |     |                         return 0;
 196 |     |                     }
 197 |     |                 }
 198 |     |                 if (tokenDecimals > 0) {
 199 |     |                     answer = int256((10 ** (tokenDecimals + decimals)) / (uint256(answer)));
 200 |     |                 }
 201 |     |                 t.cumulativePrice = t.cumulativePrice.add(
 202 |     |                     uint256(answer).mul(t.lastTimestamp.sub(t.endTimestamp))
 203 |     |                 );
 204 |     |                 if (tokenDecimals > 0) {
 205 |     |                     price = t.cumulativePrice.div(lookback);
 206 |     |                 } else {
 207 |     |                     price = t.cumulativePrice.mul(PRECISION).div(10 ** decimals).div(lookback);
 208 |     |                 }
 209 |     |             }
 210 |     |         } catch {
 211 |     |             // If call to Chainlink aggregator reverts, return a price of 0 indicating failure
 212 |     |             return 0;
 213 |     |         }
 214 |     |     }
 215 |     | 
 216 |     |     function getRoundData(
 217 |     |         IChainlinkAggregator priceAggregator,
 218 |     |         uint80 roundId
 219 |     |     ) private view returns (int256, uint256) {
 220 |     |         try priceAggregator.getRoundData(roundId) returns (
 221 |     |             uint80 /* roundId */,
 222 |     |             int256 _answer,
 223 |     |             uint256 /* startedAt */,
 224 |     |             uint256 _timestamp,
 225 |     |             uint80 /* answeredInRound */
 226 |     |         ) {
 227 |     |             return (_answer, _timestamp);
 228 |     |         } catch {
 229 |     |             return (-1, 0);
 230 |     |         }
 231 |     |     }
 232 |     | 
 233 | *   |     function checkForInvalidTimestampOrAnswer(
 234 |     |         uint256 timestamp,
 235 |     |         int256 answer,
 236 |     |         uint256 currentTimestamp,
 237 |     |         uint256 maxTimeout
 238 | *   |     ) private pure returns (bool) {
 239 |     |         // Check for an invalid timeStamp that is 0, or in the future
 240 | *   |         if (timestamp == 0 || timestamp > currentTimestamp) return true;
 241 |     |         // Check if Chainlink's price feed has timed out
 242 | *   |         if (currentTimestamp.sub(timestamp) > maxTimeout) return true;
 243 |     |         // Check for non-positive price
 244 | *   |         if (answer <= 0) return true;
 245 |     | 
 246 | *   |         return false;
 247 |     |     }
 248 |     | }
 249 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Oracle/LibDeltaB.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {C} from "contracts/C.sol";
   6 |     | import {LibWell} from "../Well/LibWell.sol";
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
   9 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  10 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  11 |     | import {Call, IWell} from "contracts/interfaces/basin/IWell.sol";
  12 |     | import {ICappedReservesPump} from "contracts/interfaces/basin/pumps/ICappedReservesPump.sol";
  13 |     | import {IInstantaneousPump} from "contracts/interfaces/basin/pumps/IInstantaneousPump.sol";
  14 |     | import {IBeanstalkWellFunction} from "contracts/interfaces/basin/IBeanstalkWellFunction.sol";
  15 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title LibPipelineConvert
  19 |     |  */
  20 |     | 
  21 | *   | library LibDeltaB {
  22 |     |     using LibRedundantMath256 for uint256;
  23 |     |     using LibRedundantMathSigned256 for int256;
  24 |     | 
  25 |     |     uint256 internal constant ZERO_LOOKBACK = 0;
  26 |     | 
  27 |     |     /**
  28 |     |      * @param token The token to get the deltaB of.
  29 |     |      * @return The deltaB of the token, for Bean it returns 0.
  30 |     |      */
  31 |     |     function getCurrentDeltaB(address token) internal view returns (int256) {
  32 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  33 |     |         if (token == s.sys.bean) {
  34 |     |             return 0;
  35 |     |         }
  36 |     | 
  37 |     |         int256 deltaB = LibDeltaB.currentDeltaB(token);
  38 |     |         return deltaB;
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Calculates the current deltaB for a given Well address.
  43 |     |      * @param well The address of the Well.
  44 |     |      * @return The current deltaB uses the current reserves in the well.
  45 |     |      */
  46 |     |     function currentDeltaB(address well) internal view returns (int256) {
  47 |     |         try IWell(well).getReserves() returns (uint256[] memory reserves) {
  48 |     |             uint256 beanIndex = LibWell.getBeanIndex(IWell(well).tokens());
  49 |     |             // if less than minimum bean balance, return 0, otherwise
  50 |     |             // calculateDeltaBFromReserves will revert
  51 |     |             if (reserves[beanIndex] < C.WELL_MINIMUM_BEAN_BALANCE) {
  52 |     |                 return 0;
  53 |     |             }
  54 |     |             return calculateDeltaBFromReserves(well, reserves, ZERO_LOOKBACK);
  55 |     |         } catch {
  56 |     |             return 0;
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice returns the overall current deltaB for all whitelisted well tokens.
  62 |     |      */
  63 |     |     function overallCurrentDeltaB() internal view returns (int256 deltaB) {
  64 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
  65 |     |         for (uint256 i = 0; i < tokens.length; i++) {
  66 |     |             int256 wellDeltaB = currentDeltaB(tokens[i]);
  67 |     |             deltaB = deltaB.add(wellDeltaB);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @notice returns the instant reserves for a given well.
  73 |     |      * @dev empty array is returned if the well call reverts.
  74 |     |      * @return instReserves The reserves for the given well.
  75 |     |      */
  76 |     |     function instantReserves(address well) internal view returns (uint256[] memory) {
  77 |     |         // get first pump from well
  78 |     |         Call[] memory pumps = IWell(well).pumps();
  79 |     |         address pump = pumps[0].target;
  80 |     | 
  81 |     |         try IInstantaneousPump(pump).readInstantaneousReserves(well, pumps[0].data) returns (
  82 |     |             uint256[] memory instReserves
  83 |     |         ) {
  84 |     |             return instReserves;
  85 |     |         } catch {
  86 |     |             return new uint256[](0);
  87 |     |         }
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice returns the capped reserves for a given well.
  92 |     |      * @dev empty array is returned if the well call reverts.
  93 |     |      * @return cappedReserves The capped reserves for the given well.
  94 |     |      */
  95 |     |     function cappedReserves(address well) internal view returns (uint256[] memory) {
  96 |     |         // get first pump from well
  97 |     |         Call[] memory pumps = IWell(well).pumps();
  98 |     |         address pump = pumps[0].target;
  99 |     | 
 100 |     |         try ICappedReservesPump(pump).readCappedReserves(well, pumps[0].data) returns (
 101 |     |             uint256[] memory reserves
 102 |     |         ) {
 103 |     |             return reserves;
 104 |     |         } catch {
 105 |     |             return new uint256[](0);
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @notice returns the overall cappedReserves deltaB for all whitelisted well tokens.
 111 |     |      */
 112 |     |     function cappedReservesDeltaB(address well) internal view returns (int256) {
 113 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 114 |     |         if (well == s.sys.bean) {
 115 |     |             return 0;
 116 |     |         }
 117 |     | 
 118 |     |         uint256[] memory instReserves = cappedReserves(well);
 119 |     |         if (instReserves.length == 0) {
 120 |     |             return 0;
 121 |     |         }
 122 |     |         // if less than minimum bean balance, return 0, otherwise
 123 |     |         // calculateDeltaBFromReserves will revert
 124 |     |         if (instReserves[LibWell.getBeanIndexFromWell(well)] < C.WELL_MINIMUM_BEAN_BALANCE) {
 125 |     |             return 0;
 126 |     |         }
 127 |     |         // calculate deltaB.
 128 |     |         return calculateDeltaBFromReserves(well, instReserves, ZERO_LOOKBACK);
 129 |     |     }
 130 |     | 
 131 |     |     // Calculates overall deltaB, used by convert for stalk penalty purposes
 132 |     |     function overallCappedDeltaB() internal view returns (int256 deltaB) {
 133 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 134 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 135 |     |             int256 cappedDeltaB = cappedReservesDeltaB(tokens[i]);
 136 |     |             deltaB = deltaB.add(cappedDeltaB);
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @notice returns the LP supply for each whitelisted well
 142 |     |      */
 143 |     |     function getLpSupply() internal view returns (uint256[] memory lpSupply) {
 144 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 145 |     |         lpSupply = new uint256[](tokens.length);
 146 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 147 |     |             lpSupply[i] = IERC20(tokens[i]).totalSupply();
 148 |     |         }
 149 |     |     }
 150 |     | 
 151 |     |     /**
 152 |     |      * @notice returns the overall instantaneous deltaB for all whitelisted well tokens,
 153 |     |      * scaled by the change in LP supply.
 154 |     |      * @dev used in pipelineConvert.
 155 |     |      */
 156 |     |     function scaledOverallCurrentDeltaB(
 157 |     |         uint256[] memory lpSupply
 158 |     |     ) internal view returns (int256 deltaB) {
 159 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 160 |     |         address[] memory tokens = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 161 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 162 |     |             if (tokens[i] == s.sys.bean) continue;
 163 |     |             int256 wellDeltaB = scaledCurrentDeltaB(tokens[i], lpSupply[i]);
 164 |     |             deltaB = deltaB.add(wellDeltaB);
 165 |     |         }
 166 |     |     }
 167 |     | 
 168 |     |     function scaledCurrentDeltaB(
 169 |     |         address well,
 170 |     |         uint256 lpSupply
 171 |     |     ) internal view returns (int256 wellDeltaB) {
 172 |     |         wellDeltaB = currentDeltaB(well);
 173 |     |         if (wellDeltaB == 0) return 0; // prevent divide by zero
 174 |     |         wellDeltaB = scaledDeltaB(lpSupply, IERC20(well).totalSupply(), wellDeltaB);
 175 |     |     }
 176 |     | 
 177 |     |     /*
 178 |     |      * @notice returns the scaled deltaB, based on LP supply before and after convert
 179 |     |      */
 180 |     |     function scaledDeltaB(
 181 |     |         uint256 beforeLpTokenSupply,
 182 |     |         uint256 afterLpTokenSupply,
 183 |     |         int256 deltaB
 184 |     |     ) internal pure returns (int256) {
 185 |     |         return deltaB.mul(int256(beforeLpTokenSupply)).div(int(afterLpTokenSupply));
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @notice calculates the deltaB for a given well using the reserves.
 190 |     |      * @dev reverts if the bean reserve is less than the minimum,
 191 |     |      * or if the usd oracle fails.
 192 |     |      * This differs from the twaDeltaB, as this function should not be used within the sunrise function.
 193 |     |      */
 194 |     |     function calculateDeltaBFromReserves(
 195 |     |         address well,
 196 |     |         uint256[] memory reserves,
 197 |     |         uint256 lookback
 198 |     |     ) internal view returns (int256) {
 199 |     |         IERC20[] memory tokens = IWell(well).tokens();
 200 |     |         Call memory wellFunction = IWell(well).wellFunction();
 201 |     | 
 202 |     |         (uint256[] memory ratios, uint256 beanIndex, bool success) = LibWell.getRatiosAndBeanIndex(
 203 |     |             tokens,
 204 |     |             lookback
 205 |     |         );
 206 |     | 
 207 |     |         // Converts cannot be performed, if the Bean reserve is less than the minimum
 208 |     |         if (reserves[beanIndex] < C.WELL_MINIMUM_BEAN_BALANCE) {
 209 |     |             revert("Well: Bean reserve is less than the minimum");
 210 |     |         }
 211 |     | 
 212 |     |         // If the USD Oracle call fails, a deltaB cannot be determined.
 213 |     |         if (!success) {
 214 |     |             revert("Well: USD Oracle call failed");
 215 |     |         }
 216 |     | 
 217 |     |         try
 218 |     |             IBeanstalkWellFunction(wellFunction.target).calcReserveAtRatioSwap(
 219 |     |                 reserves,
 220 |     |                 beanIndex,
 221 |     |                 ratios,
 222 |     |                 wellFunction.data
 223 |     |             )
 224 |     |         returns (uint256 reserve) {
 225 |     |             return int256(reserve).sub(int256(reserves[beanIndex]));
 226 |     |         } catch {
 227 |     |             return 0;
 228 |     |         }
 229 |     |     }
 230 |     | }
 231 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Oracle/LibUniswapOracle.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  8 |     | import {LibUniswapOracleLibrary} from "./LibUniswapOracleLibrary.sol";
  9 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
 10 |     | 
 11 |     | interface IERC20Decimals {
 12 |     |     function decimals() external view returns (uint8);
 13 |     | }
 14 |     | 
 15 |     | /**
 16 |     |  * @title Uniswap Oracle Library
 17 |     |  * @notice Contains functionalty to read prices from Uniswap V3 pools.
 18 |     |  **/
 19 | *   | library LibUniswapOracle {
 20 |     |     // All instantaneous queries of Uniswap Oracles should use a 15 minute lookback.
 21 |     |     uint32 internal constant FIFTEEN_MINUTES = 900;
 22 |     |     uint256 constant PRECISION = 1e6;
 23 |     | 
 24 |     |     /**
 25 |     |      * @notice Given a tick and a token amount, calculates the amount of token received in exchange
 26 |     |      * @param baseTokenAmount Amount of baseToken to be converted.
 27 |     |      * @param baseToken Address of the ERC20 token contract used as the baseAmount denomination.
 28 |     |      * @param quoteToken Address of the ERC20 token contract used as the quoteAmount denomination.
 29 |     |      * @return price Amount of quoteToken. Value has 6 decimal precision.
 30 |     |      */
 31 |     |     function getTwap(
 32 |     |         uint32 lookback,
 33 |     |         address pool,
 34 |     |         address baseToken,
 35 |     |         address quoteToken,
 36 |     |         uint128 baseTokenAmount
 37 |     |     ) internal view returns (uint256 price) {
 38 |     |         (bool success, int24 tick) = consult(pool, lookback);
 39 |     |         if (!success) return 0;
 40 |     | 
 41 |     |         price = LibUniswapOracleLibrary.getQuoteAtTick(
 42 |     |             tick,
 43 |     |             baseTokenAmount,
 44 |     |             baseToken,
 45 |     |             quoteToken
 46 |     |         );
 47 |     | 
 48 |     |         uint256 baseTokenDecimals = IERC20Decimals(baseToken).decimals();
 49 |     |         uint256 quoteTokenDecimals = IERC20Decimals(quoteToken).decimals();
 50 |     |         int256 factor = int256(baseTokenDecimals) - int256(quoteTokenDecimals);
 51 |     | 
 52 |     |         // decimals are the same. i.e. DAI/WETH
 53 |     |         if (factor == 0) return (price * PRECISION) / (10 ** baseTokenDecimals);
 54 |     | 
 55 |     |         // scale decimals
 56 |     |         if (factor > 0) {
 57 |     |             price = price * (10 ** uint256(factor));
 58 |     |         } else {
 59 |     |             price = price / (10 ** uint256(-factor));
 60 |     |         }
 61 |     | 
 62 |     |         // set 1e6 precision
 63 |     |         price = (price * PRECISION) / (10 ** baseTokenDecimals);
 64 |     |     }
 65 |     | 
 66 |     |     /**
 67 |     |      * @dev A variation of {OracleLibrary.consult} that returns just the arithmetic mean tick and returns 0 on failure
 68 |     |      * instead of reverting if {IUniswapV3Pool.observe} reverts.
 69 |     |      * https://github.com/Uniswap/v3-periphery/blob/51f8871aaef2263c8e8bbf4f3410880b6162cdea/contracts/libraries/OracleLibrary.sol
 70 |     |      */
 71 |     |     function consult(
 72 |     |         address pool,
 73 |     |         uint32 secondsAgo
 74 |     |     ) internal view returns (bool success, int24 arithmeticMeanTick) {
 75 |     |         require(secondsAgo != 0, "BP");
 76 |     | 
 77 |     |         uint32[] memory secondsAgos = new uint32[](2);
 78 |     |         secondsAgos[0] = secondsAgo;
 79 |     |         secondsAgos[1] = 0;
 80 |     | 
 81 |     |         try IUniswapV3Pool(pool).observe(secondsAgos) returns (
 82 |     |             int56[] memory tickCumulatives,
 83 |     |             uint160[] memory
 84 |     |         ) {
 85 |     |             int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
 86 |     |             arithmeticMeanTick = SafeCast.toInt24(
 87 |     |                 int256(tickCumulativesDelta / int56(uint56(secondsAgo)))
 88 |     |             );
 89 |     |             // Always round to negative infinity
 90 |     |             if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0))
 91 |     |                 arithmeticMeanTick--;
 92 |     |             success = true;
 93 |     |         } catch {}
 94 |     |     }
 95 |     | }
 96 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Oracle/LibUniswapOracleLibrary.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0 <0.9.0;
   3 |     | 
   4 |     | import "@uniswap/v3-core/contracts/libraries/FullMath.sol";
   5 |     | import "@uniswap/v3-core/contracts/libraries/TickMath.sol";
   6 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
   7 |     | 
   8 |     | /// @title LibUniswapOracleLibrary
   9 |     | /// @notice Provides functions to integrate with V3 pool oracle
  10 |     | /// @dev forked from: https://github.com/Uniswap/v3-periphery/blob/0.8/contracts/libraries/OracleLibrary.sol,
  11 |     | /// due to node version incompatabilities.
  12 | *   | library LibUniswapOracleLibrary {
  13 |     |     /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool
  14 |     |     /// @param pool Address of the pool that we want to observe
  15 |     |     /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means
  16 |     |     /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp
  17 |     |     /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp
  18 |     |     function consult(
  19 |     |         address pool,
  20 |     |         uint32 secondsAgo
  21 |     |     ) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity) {
  22 |     |         require(secondsAgo != 0, "BP");
  23 |     | 
  24 |     |         uint32[] memory secondsAgos = new uint32[](2);
  25 |     |         secondsAgos[0] = secondsAgo;
  26 |     |         secondsAgos[1] = 0;
  27 |     | 
  28 |     |         (
  29 |     |             int56[] memory tickCumulatives,
  30 |     |             uint160[] memory secondsPerLiquidityCumulativeX128s
  31 |     |         ) = IUniswapV3Pool(pool).observe(secondsAgos);
  32 |     | 
  33 |     |         int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
  34 |     |         uint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -
  35 |     |             secondsPerLiquidityCumulativeX128s[0];
  36 |     | 
  37 |     |         arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));
  38 |     |         // Always round to negative infinity
  39 |     |         if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0))
  40 |     |             arithmeticMeanTick--;
  41 |     | 
  42 |     |         // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128
  43 |     |         uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;
  44 |     |         harmonicMeanLiquidity = uint128(
  45 |     |             secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32)
  46 |     |         );
  47 |     |     }
  48 |     | 
  49 |     |     /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
  50 |     |     /// @param tick Tick value used to calculate the quote
  51 |     |     /// @param baseAmount Amount of token to be converted
  52 |     |     /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
  53 |     |     /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
  54 |     |     /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
  55 |     |     function getQuoteAtTick(
  56 |     |         int24 tick,
  57 |     |         uint128 baseAmount,
  58 |     |         address baseToken,
  59 |     |         address quoteToken
  60 |     |     ) internal pure returns (uint256 quoteAmount) {
  61 |     |         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
  62 |     | 
  63 |     |         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
  64 |     |         if (sqrtRatioX96 <= type(uint128).max) {
  65 |     |             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
  66 |     |             quoteAmount = baseToken < quoteToken
  67 |     |                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
  68 |     |                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
  69 |     |         } else {
  70 |     |             uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
  71 |     |             quoteAmount = baseToken < quoteToken
  72 |     |                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
  73 |     |                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation
  78 |     |     /// @param pool Address of Uniswap V3 pool that we want to observe
  79 |     |     /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool
  80 |     |     function getOldestObservationSecondsAgo(
  81 |     |         address pool
  82 |     |     ) internal view returns (uint32 secondsAgo) {
  83 |     |         (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool)
  84 |     |             .slot0();
  85 |     |         require(observationCardinality > 0, "NI");
  86 |     | 
  87 |     |         (uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(
  88 |     |             (observationIndex + 1) % observationCardinality
  89 |     |         );
  90 |     | 
  91 |     |         // The next index might not be initialized if the cardinality is in the process of increasing
  92 |     |         // In this case the oldest observation is always in index 0
  93 |     |         if (!initialized) {
  94 |     |             (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);
  95 |     |         }
  96 |     | 
  97 |     |         unchecked {
  98 |     |             secondsAgo = uint32(block.timestamp) - observationTimestamp;
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice Given a pool, it returns the tick value as of the start of the current block
 103 |     |     /// @param pool Address of Uniswap V3 pool
 104 |     |     /// @return The tick that the pool was in at the start of the current block
 105 |     |     function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {
 106 |     |         (
 107 |     |             ,
 108 |     |             int24 tick,
 109 |     |             uint16 observationIndex,
 110 |     |             uint16 observationCardinality,
 111 |     |             ,
 112 |     |             ,
 113 |     | 
 114 |     |         ) = IUniswapV3Pool(pool).slot0();
 115 |     | 
 116 |     |         // 2 observations are needed to reliably calculate the block starting tick
 117 |     |         require(observationCardinality > 1, "NEO");
 118 |     | 
 119 |     |         // If the latest observation occurred in the past, then no tick-changing trades have happened in this block
 120 |     |         // therefore the tick in `slot0` is the same as at the beginning of the current block.
 121 |     |         // We don't need to check if this observation is initialized - it is guaranteed to be.
 122 |     |         (
 123 |     |             uint32 observationTimestamp,
 124 |     |             int56 tickCumulative,
 125 |     |             uint160 secondsPerLiquidityCumulativeX128,
 126 |     | 
 127 |     |         ) = IUniswapV3Pool(pool).observations(observationIndex);
 128 |     |         if (observationTimestamp != uint32(block.timestamp)) {
 129 |     |             return (tick, IUniswapV3Pool(pool).liquidity());
 130 |     |         }
 131 |     | 
 132 |     |         uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) %
 133 |     |             observationCardinality;
 134 |     |         (
 135 |     |             uint32 prevObservationTimestamp,
 136 |     |             int56 prevTickCumulative,
 137 |     |             uint160 prevSecondsPerLiquidityCumulativeX128,
 138 |     |             bool prevInitialized
 139 |     |         ) = IUniswapV3Pool(pool).observations(prevIndex);
 140 |     | 
 141 |     |         require(prevInitialized, "ONI");
 142 |     | 
 143 |     |         uint32 delta = observationTimestamp - prevObservationTimestamp;
 144 |     |         tick = int24((tickCumulative - int56(uint56(prevTickCumulative))) / int56(uint56(delta)));
 145 |     |         uint128 liquidity = uint128(
 146 |     |             (uint192(delta) * type(uint160).max) /
 147 |     |                 (uint192(
 148 |     |                     secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128
 149 |     |                 ) << 32)
 150 |     |         );
 151 |     |         return (tick, liquidity);
 152 |     |     }
 153 |     | 
 154 |     |     /// @notice Information for calculating a weighted arithmetic mean tick
 155 |     |     struct WeightedTickData {
 156 |     |         int24 tick;
 157 |     |         uint128 weight;
 158 |     |     }
 159 |     | 
 160 |     |     /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick
 161 |     |     /// @param weightedTickData An array of ticks and weights
 162 |     |     /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick
 163 |     |     /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,
 164 |     |     /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).
 165 |     |     /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.
 166 |     |     function getWeightedArithmeticMeanTick(
 167 |     |         WeightedTickData[] memory weightedTickData
 168 |     |     ) internal pure returns (int24 weightedArithmeticMeanTick) {
 169 |     |         // Accumulates the sum of products between each tick and its weight
 170 |     |         int256 numerator;
 171 |     | 
 172 |     |         // Accumulates the sum of the weights
 173 |     |         uint256 denominator;
 174 |     | 
 175 |     |         // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic
 176 |     |         for (uint256 i; i < weightedTickData.length; i++) {
 177 |     |             numerator += weightedTickData[i].tick * int256(uint256(weightedTickData[i].weight));
 178 |     |             denominator += weightedTickData[i].weight;
 179 |     |         }
 180 |     | 
 181 |     |         weightedArithmeticMeanTick = int24(numerator / int256(denominator));
 182 |     |         // Always round to negative infinity
 183 |     |         if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice Returns the "synthetic" tick which represents the price of the first entry in `tokens` in terms of the last
 187 |     |     /// @dev Useful for calculating relative prices along routes.
 188 |     |     /// @dev There must be one tick for each pairwise set of tokens.
 189 |     |     /// @param tokens The token contract addresses
 190 |     |     /// @param ticks The ticks, representing the price of each token pair in `tokens`
 191 |     |     /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`
 192 |     |     function getChainedPrice(
 193 |     |         address[] memory tokens,
 194 |     |         int24[] memory ticks
 195 |     |     ) internal pure returns (int256 syntheticTick) {
 196 |     |         require(tokens.length - 1 == ticks.length, "DL");
 197 |     |         for (uint256 i = 1; i <= ticks.length; i++) {
 198 |     |             // check the tokens for address sort order, then accumulate the
 199 |     |             // ticks into the running synthetic tick, ensuring that intermediate tokens "cancel out"
 200 |     |             tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[
 201 |     |                 i - 1
 202 |     |             ];
 203 |     |         }
 204 |     |     }
 205 |     | }
 206 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Oracle/LibUsdOracle.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {LibUniswapOracle} from "./LibUniswapOracle.sol";
   9 |     | import {LibChainlinkOracle} from "./LibChainlinkOracle.sol";
  10 |     | import {IUniswapV3PoolImmutables} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
  11 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
  12 |     | import {Implementation} from "contracts/beanstalk/storage/System.sol";
  13 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  14 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  15 |     | 
  16 |     | interface IERC20Decimals {
  17 |     |     function decimals() external view returns (uint8);
  18 |     | }
  19 |     | 
  20 |     | /**
  21 |     |  * @title Usd Oracle Library
  22 |     |  * @notice Contains functionalty to fetch the manipulation resistant USD price of different tokens.
  23 |     |  * @dev currently supports:
  24 |     |  **/
  25 | *   | library LibUsdOracle {
  26 |     |     using LibRedundantMath256 for uint256;
  27 |     | 
  28 |     |     uint256 constant UNISWAP_DENOMINATOR = 1e6;
  29 |     | 
  30 |     |     function getUsdPrice(address token) internal view returns (uint256) {
  31 |     |         return getUsdPrice(token, 0);
  32 |     |     }
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev Returns the price of 1 USD in terms of `token` with the option of using a lookback. (Usd:token Price)
  36 |     |      * `lookback` should be 0 if the instantaneous price is desired. Otherwise, it should be the
  37 |     |      * TWAP lookback in seconds.
  38 |     |      * If using a non-zero lookback, it is recommended to use a substantially large `lookback`
  39 |     |      * (> 900 seconds) to protect against manipulation.
  40 |     |      */
  41 |     |     function getUsdPrice(address token, uint256 lookback) internal view returns (uint256) {
  42 |     |         // call external implementation for token
  43 |     |         // note passing decimals controls pricing order (token:usd vs usd:token)
  44 |     |         return getTokenPriceFromExternal(token, IERC20Decimals(token).decimals(), lookback);
  45 |     |     }
  46 |     | 
  47 |     |     function getTokenPrice(address token) internal view returns (uint256) {
  48 |     |         return getTokenPrice(token, 0);
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @notice returns the price of a given token in USD (token:Usd Price)
  53 |     |      * @dev if ETH returns 1000 USD, this function returns 1000
  54 |     |      * (ignoring decimal precision)
  55 |     |      */
  56 |     |     function getTokenPrice(address token, uint256 lookback) internal view returns (uint256) {
  57 |     |         // call external implementation for token
  58 |     |         return getTokenPriceFromExternal(token, 0, lookback);
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice gets the token price from an external oracle.
  63 |     |      * @dev if address is 0, use the current contract.
  64 |     |      * If encodeType is 0x01, use the default chainlink implementation.
  65 |     |      * Returns 0 rather than reverting if the call fails.
  66 |     |      * Note: token here refers to the non bean token when quoting for a well price.
  67 |     |      */
  68 |     |     function getTokenPriceFromExternal(
  69 |     |         address token,
  70 |     |         uint256 tokenDecimals,
  71 |     |         uint256 lookback
  72 |     |     ) internal view returns (uint256 tokenPrice) {
  73 |     |         return getTokenPriceFromExternal(token, tokenDecimals, lookback, false);
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice returns the price of 1 Million USD in terms of `token` with the option of using a lookback.
  78 |     |      * @dev `LibWell.getRatiosAndBeanIndex` attempts to calculate the target ratios by fetching the usdPrice of each token.
  79 |     |      * For tokens with low decimal precision and high prices (ex. WBTC), using the usd:token price would result in a
  80 |     |      * large amount of precision loss. For this reason, tokens with less than 8 decimals use the 1 Million USD price instead..
  81 |     |      */
  82 |     |     function getMillionUsdPrice(address token, uint256 lookback) internal view returns (uint256) {
  83 |     |         return getTokenPriceFromExternal(token, IERC20Decimals(token).decimals(), lookback, true);
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice internal helper function for `getTokenPriceFromExternal`.
  88 |     |      * @dev the `isMillion` flag is used in `LibChainlinkOracle.getTokenPrice` to
  89 |     |      * return the MILLION_TOKEN2/TOKEN1 price, in cases where the price of TOKEN1 is extremely high (relative to token 2),
  90 |     |      * and when the decimals is very low.
  91 |     |      */
  92 |     |     function getTokenPriceFromExternal(
  93 |     |         address token,
  94 |     |         uint256 tokenDecimals,
  95 |     |         uint256 lookback,
  96 |     |         bool isMillion
  97 |     |     ) private view returns (uint256 tokenPrice) {
  98 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  99 |     |         Implementation memory oracleImpl = s.sys.oracleImplementation[token];
 100 |     | 
 101 |     |         // If the encode type is type 1, use the default chainlink implementation instead.
 102 |     |         // `target` refers to the address of the price aggergator implmentation
 103 |     |         if (oracleImpl.encodeType == bytes1(0x01)) {
 104 |     |             return
 105 |     |                 LibChainlinkOracle.getTokenPrice(
 106 |     |                     oracleImpl.target, // chainlink Aggergator Address
 107 |     |                     abi.decode(oracleImpl.data, (uint256)), // timeout
 108 |     |                     tokenDecimals, // token decimals
 109 |     |                     lookback,
 110 |     |                     isMillion
 111 |     |                 );
 112 |     |         } else if (oracleImpl.encodeType == bytes1(0x02)) {
 113 |     |             // if the encodeType is type 2, use a uniswap oracle implementation.
 114 |     | 
 115 |     |             // the uniswap oracle implementation combines the use of the chainlink and uniswap oracles.
 116 |     |             // the chainlink oracle is used to get the price of the non-oracle token (for example USDC) in order to
 117 |     |             // use that as a dollar representation
 118 |     |             address chainlinkToken = IUniswapV3PoolImmutables(oracleImpl.target).token0();
 119 |     | 
 120 |     |             if (chainlinkToken == token) {
 121 |     |                 chainlinkToken = IUniswapV3PoolImmutables(oracleImpl.target).token1();
 122 |     |             }
 123 |     | 
 124 |     |             // get twap from the `chainlinkToken` to `token`
 125 |     |             // exchange 1 `token` for `chainlinkToken`.
 126 |     |             tokenPrice = LibUniswapOracle.getTwap(
 127 |     |                 lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES : uint32(lookback),
 128 |     |                 oracleImpl.target,
 129 |     |                 token,
 130 |     |                 chainlinkToken,
 131 |     |                 tokenDecimals == 0
 132 |     |                     ? uint128(10 ** IERC20Decimals(token).decimals())
 133 |     |                     : uint128(10 ** tokenDecimals)
 134 |     |             );
 135 |     | 
 136 |     |             // call chainlink oracle from the OracleImplmentation contract
 137 |     |             Implementation memory chainlinkOracle = s.sys.oracleImplementation[chainlinkToken];
 138 |     | 
 139 |     |             // return the CL_TOKEN/USD or USD/CL_TOKEN, depending on `tokenDecimals`.
 140 |     |             uint256 chainlinkTokenDecimals = IERC20Decimals(chainlinkToken).decimals();
 141 |     |             uint256 chainlinkTokenPrice = LibChainlinkOracle.getTokenPrice(
 142 |     |                 chainlinkOracle.target,
 143 |     |                 abi.decode(chainlinkOracle.data, (uint256)), // timeout
 144 |     |                 tokenDecimals == 0 ? tokenDecimals : chainlinkTokenDecimals,
 145 |     |                 lookback,
 146 |     |                 false
 147 |     |             );
 148 |     | 
 149 |     |             // if token decimals != 0, Beanstalk is attempting to query the USD/TOKEN price, and
 150 |     |             // thus the price needs to be inverted.
 151 |     |             if (tokenDecimals != 0) {
 152 |     |                 // invert tokenPrice (to get CL_TOKEN/TOKEN).
 153 |     |                 // `tokenPrice` has 6 decimal precision (see {LibUniswapOracle.getTwap}).
 154 |     |                 // `tokenPrice` is scaled up to 1 million units, if the `isMillion` flag is enabled.
 155 |     |                 if (isMillion) {
 156 |     |                     tokenPrice = (1e12 * (10 ** tokenDecimals)) / tokenPrice;
 157 |     |                 } else {
 158 |     |                     tokenPrice = (1e6 * (10 ** tokenDecimals)) / tokenPrice;
 159 |     |                 }
 160 |     |                 // return the USD/TOKEN price.
 161 |     |                 // 1e6 * 1e`n` / 1e`n` = 1e6
 162 |     |                 return (tokenPrice * chainlinkTokenPrice) / (10 ** chainlinkTokenDecimals);
 163 |     |             }
 164 |     | 
 165 |     |             return (tokenPrice * chainlinkTokenPrice) / UNISWAP_DENOMINATOR;
 166 |     |         }
 167 |     | 
 168 |     |         // Non-zero addresses are enforced in verifyOracleImplementation, this is just an extra check.
 169 |     |         if (oracleImpl.target == address(0)) return 0;
 170 |     | 
 171 |     |         // if `isMillion` is enabled, append the boolean into the oracleImpl,
 172 |     |         // such that the oracle implementation can use the data.
 173 |     |         bytes memory oracleImplData = oracleImpl.data;
 174 |     |         if (isMillion) {
 175 |     |             oracleImplData = abi.encodePacked(oracleImpl.data, isMillion);
 176 |     |         }
 177 |     | 
 178 |     |         (bool success, bytes memory data) = oracleImpl.target.staticcall(
 179 |     |             abi.encodeWithSelector(oracleImpl.selector, tokenDecimals, lookback, oracleImplData)
 180 |     |         );
 181 |     | 
 182 |     |         if (!success) return 0;
 183 |     |         assembly {
 184 |     |             tokenPrice := mload(add(data, add(0x20, 0)))
 185 |     |         }
 186 |     |     }
 187 |     | }
 188 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibFlood.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "contracts/C.sol";
   8 |     | import {IWell} from "contracts/interfaces/basin/IWell.sol";
   9 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  10 |     | import {Account} from "contracts/beanstalk/storage/Account.sol";
  11 |     | import {LibDeltaB} from "contracts/libraries/Oracle/LibDeltaB.sol";
  12 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  13 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  14 |     | import {LibAppStorage, AppStorage} from "contracts/libraries/LibAppStorage.sol";
  15 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  16 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @title LibFlood handles logic relating to flooding.
  20 |     |  **/
  21 |     | 
  22 | *   | library LibFlood {
  23 |     |     using LibRedundantMath256 for uint256;
  24 |     |     // @notice This controls the percentage of Bean supply that is flooded to the field.
  25 |     |     // 1000 represents 1/1000, or 0.1% of total Bean supply.
  26 |     |     uint256 internal constant FLOOD_PODLINE_PERCENT_DENOMINATOR = 1000;
  27 |     | 
  28 |     |     /**
  29 |     |      * @notice Emitted when Beans are minted to a Well during the Season of Plenty.
  30 |     |      * @param season The Season in which Beans were minted for distribution.
  31 |     |      * @param well The Well that the SOP occurred in.
  32 |     |      * @param token The token that was swapped for Beans.
  33 |     |      * @param amount The amount of tokens which was received for swapping Beans.
  34 |     |      * @param beans The amount of Beans which were minted to the Well.
  35 |     |      */
  36 |     |     event SeasonOfPlentyWell(
  37 |     |         uint256 indexed season,
  38 |     |         address well,
  39 |     |         address token,
  40 |     |         uint256 amount,
  41 |     |         uint256 beans
  42 |     |     );
  43 |     | 
  44 |     |     /**
  45 |     |      * @notice Emitted when Beans are minted to the Field during the Season of Plenty.
  46 |     |      * @param toField The amount of Beans which were distributed to remaining Pods in the Field.
  47 |     |      */
  48 |     |     event SeasonOfPlentyField(uint256 toField);
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Emitted when the grownStalkToLP changes.
  52 |     |      * @param season The current Season
  53 |     |      * @param caseId The Weather case, which determines how the BeanToMaxLPGpPerBDVRatio is adjusted.
  54 |     |      * @param absChange The absolute change in the BeanToMaxLPGpPerBDVRatio.
  55 |     |      * @dev formula: L_n = L_n-1 +/- bL
  56 |     |      */
  57 |     |     event BeanToMaxLpGpPerBdvRatioChange(uint256 indexed season, uint256 caseId, int80 absChange);
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Emitted when the rain status changes.
  61 |     |      * @param season The current Season
  62 |     |      * @param raining True if it started raining this season, false if it stopped raining.
  63 |     |      */
  64 |     |     event RainStatus(uint256 indexed season, bool raining);
  65 |     | 
  66 |     |     // @dev In-memory struct used to store current deltaB, and then reduction amount per-well.
  67 |     |     struct WellDeltaB {
  68 |     |         address well;
  69 |     |         int256 deltaB;
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Oversaturated was previously referred to as Raining and thus code
  74 |     |      * references mentioning Rain really refer to Oversaturation. If P > 1 and the
  75 |     |      * Pod Rate is less than 5%, the Farm is Oversaturated. If it is Oversaturated
  76 |     |      * for a Season, each Season in which it continues to be Oversaturated, it Floods.
  77 |     |      */
  78 |     |     function handleRain(uint256 caseId) external {
  79 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  80 |     | 
  81 |     |         // reset floodHarvestablePods from prior season
  82 |     |         s.sys.rain.floodHarvestablePods = 0;
  83 |     | 
  84 |     |         // cases % 36  3-8 represent the case where the pod rate is less than 5% and P > 1.
  85 |     |         if (caseId.mod(36) < 3 || caseId.mod(36) > 8) {
  86 |     |             if (s.sys.season.raining) {
  87 |     |                 s.sys.season.raining = false;
  88 |     |                 emit RainStatus(s.sys.season.current, false);
  89 |     |             }
  90 |     |             return;
  91 |     |         } else if (!s.sys.season.raining) {
  92 |     |             initRainVariables();
  93 |     |             startRain(caseId);
  94 |     |         } else {
  95 |     |             // flood podline first, because it checks current Bean supply
  96 |     |             floodPodline();
  97 |     | 
  98 |     |             if (s.sys.rain.roots > 0) {
  99 |     |                 (
 100 |     |                     WellDeltaB[] memory wellDeltaBs,
 101 |     |                     uint256 totalPositiveDeltaB,
 102 |     |                     uint256 totalNegativeDeltaB,
 103 |     |                     uint256 positiveDeltaBCount
 104 |     |                 ) = getWellsByDeltaB();
 105 |     |                 wellDeltaBs = calculateSopPerWell(
 106 |     |                     wellDeltaBs,
 107 |     |                     totalPositiveDeltaB,
 108 |     |                     totalNegativeDeltaB,
 109 |     |                     positiveDeltaBCount
 110 |     |                 );
 111 |     | 
 112 |     |                 for (uint i; i < wellDeltaBs.length; i++) {
 113 |     |                     sopWell(wellDeltaBs[i]);
 114 |     |                 }
 115 |     | 
 116 |     |                 s.sys.season.lastSop = s.sys.season.rainStart;
 117 |     |                 s.sys.season.lastSopSeason = s.sys.season.current;
 118 |     |             }
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @notice Snapshot variables required to start raining.
 124 |     |      */
 125 |     |     function initRainVariables() internal {
 126 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 127 |     | 
 128 |     |         s.sys.season.raining = true;
 129 |     |         emit RainStatus(s.sys.season.current, true);
 130 |     |         address[] memory wells = LibWhitelistedTokens.getCurrentlySoppableWellLpTokens();
 131 |     |         // Set the plenty per root equal to previous rain start.
 132 |     |         uint32 season = s.sys.season.current;
 133 |     |         uint32 rainstartSeason = s.sys.season.rainStart;
 134 |     |         for (uint i; i < wells.length; i++) {
 135 |     |             s.sys.sop.sops[season][wells[i]] = s.sys.sop.sops[rainstartSeason][wells[i]];
 136 |     |         }
 137 |     |         s.sys.season.rainStart = s.sys.season.current;
 138 |     |         s.sys.rain.pods = s.sys.fields[s.sys.activeField].pods;
 139 |     |         s.sys.rain.roots = s.sys.silo.roots;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @notice Handles any system-level logic that occurs when it starts raining.
 144 |     |      */
 145 |     |     function startRain(uint256 caseId) internal {
 146 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 147 |     | 
 148 |     |         // upon rain, set beanToMaxLpGpPerBdvRatio to zero, to encourage converts down before starting to flood
 149 |     |         emit BeanToMaxLpGpPerBdvRatioChange(
 150 |     |             s.sys.season.current,
 151 |     |             caseId,
 152 |     |             -int80(int128(s.sys.seedGauge.beanToMaxLpGpPerBdvRatio))
 153 |     |         );
 154 |     |         s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = 0;
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev internal account-level logic to handle when beanstalk is raining. Called from mow.
 159 |     |      */
 160 | *   |     function handleRainAndSops(
 161 |     |         address account,
 162 |     |         uint32 lastUpdate,
 163 |     |         uint256 firstGerminatingRoots
 164 |     |     ) internal {
 165 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 166 |     | 
 167 |     |         // If a Sop has occured since last update, calculate rewards and set last Sop.
 168 | *   |         if (s.sys.season.lastSopSeason > lastUpdate) {
 169 |     |             address[] memory tokens = LibWhitelistedTokens.getSoppableWellLpTokens(); // includes de-whitelisted tokens
 170 |     |             for (uint i; i < tokens.length; i++) {
 171 |     |                 s.accts[account].sop.perWellPlenty[tokens[i]].plenty = balanceOfPlenty(
 172 |     |                     account,
 173 |     |                     tokens[i]
 174 |     |                 );
 175 |     |             }
 176 |     |             s.accts[account].lastSop = s.sys.season.lastSop;
 177 |     |         }
 178 |     |         // If no roots, reset Sop counters variables
 179 | *   |         if (s.accts[account].roots == 0) {
 180 | *   |             s.accts[account].lastSop = s.sys.season.rainStart;
 181 | *   |             s.accts[account].lastRain = 0;
 182 | *   |             return;
 183 |     |         }
 184 |     | 
 185 |     |         if (s.sys.season.raining) {
 186 |     |             // If rain started after update, set account variables to track rain.
 187 |     |             if (s.sys.season.rainStart > lastUpdate) {
 188 |     |                 s.accts[account].lastRain = s.sys.season.rainStart;
 189 |     |                 s.accts[account].sop.rainRoots = s.accts[account].roots;
 190 |     |                 if (s.sys.season.rainStart - 1 == lastUpdate) {
 191 |     |                     if (firstGerminatingRoots > 0) {
 192 |     |                         // if the account had just finished germinating roots this season (i.e,
 193 |     |                         // deposited in the previous season before raining, and mowed during a sop),
 194 |     |                         // Beanstalk will not allocate plenty to this deposit, and thus the roots
 195 |     |                         // needs to be deducted from the sop roots.
 196 |     |                         s.accts[account].sop.rainRoots = s.accts[account].sop.rainRoots.sub(
 197 |     |                             firstGerminatingRoots
 198 |     |                         );
 199 |     |                     }
 200 |     |                 }
 201 |     | 
 202 |     |                 //  s.accts[account].roots includes newly finished germinating roots from a fresh deposit
 203 |     |                 //  @ season before rainStart
 204 |     |             }
 205 |     |             // If there has been a Sop since rain started,
 206 |     |             // save plentyPerRoot in case another SOP happens during rain.
 207 |     |             if (s.sys.season.lastSop == s.sys.season.rainStart) {
 208 |     |                 address[] memory tokens = LibWhitelistedTokens.getSoppableWellLpTokens(); // includes de-whitelisted tokens (need to update account-level PPR for all tokens)
 209 |     |                 for (uint i; i < tokens.length; i++) {
 210 |     |                     s.accts[account].sop.perWellPlenty[tokens[i]].plentyPerRoot = s.sys.sop.sops[
 211 |     |                         s.sys.season.lastSop
 212 |     |                     ][tokens[i]];
 213 |     |                 }
 214 |     |             }
 215 |     |         } else if (s.accts[account].lastRain > 0) {
 216 |     |             // Reset Last Rain if not raining.
 217 |     |             s.accts[account].lastRain = 0;
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @dev returns the amount of `plenty` an account has.
 223 |     |      */
 224 |     |     function balanceOfPlenty(address account, address well) internal view returns (uint256 plenty) {
 225 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 226 |     |         Account storage a = s.accts[account];
 227 |     |         plenty = a.sop.perWellPlenty[well].plenty;
 228 |     |         uint256 previousPPR;
 229 |     | 
 230 |     |         // If lastRain > 0, then check if SOP occured during the rain period.
 231 |     |         if (s.accts[account].lastRain > 0) {
 232 |     |             // if the last processed SOP = the lastRain processed season,
 233 |     |             // then we use the stored roots to get the delta.
 234 |     |             if (a.lastSop == a.lastRain) {
 235 |     |                 previousPPR = a.sop.perWellPlenty[well].plentyPerRoot;
 236 |     |             } else {
 237 |     |                 previousPPR = s.sys.sop.sops[a.lastSop][well];
 238 |     |             }
 239 |     |             uint256 lastRainPPR = s.sys.sop.sops[s.accts[account].lastRain][well];
 240 |     | 
 241 |     |             // If there has been a SOP duing the rain sesssion since last update, process SOP.
 242 |     |             if (lastRainPPR > previousPPR) {
 243 |     |                 uint256 plentyPerRoot = lastRainPPR - previousPPR;
 244 |     |                 previousPPR = lastRainPPR;
 245 |     |                 plenty = plenty.add(
 246 |     |                     plentyPerRoot.mul(s.accts[account].sop.rainRoots).div(C.SOP_PRECISION)
 247 |     |                 );
 248 |     |             }
 249 |     |         } else {
 250 |     |             // If it was not raining, just use the PPR at previous SOP.
 251 |     |             previousPPR = s.sys.sop.sops[s.accts[account].lastSop][well];
 252 |     |         }
 253 |     | 
 254 |     |         // Handle and SOPs that started + ended before after last Silo update.
 255 |     |         if (s.sys.season.lastSop > s.accts[account].lastUpdate) {
 256 |     |             uint256 plentyPerRoot = s.sys.sop.sops[s.sys.season.lastSop][well].sub(previousPPR);
 257 |     |             plenty = plenty.add(plentyPerRoot.mul(s.accts[account].roots).div(C.SOP_PRECISION));
 258 |     |         }
 259 |     |     }
 260 |     | 
 261 |     |     /**
 262 |     |      * @notice Floods the field, up to 0.1% of the total Bean supply worth of pods.
 263 |     |      */
 264 |     |     function floodPodline() private {
 265 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 266 |     |         // Make 0.1% of the total bean supply worth of pods harvestable.
 267 |     | 
 268 |     |         uint256 totalBeanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 269 |     |         uint256 sopFieldBeans = totalBeanSupply.div(FLOOD_PODLINE_PERCENT_DENOMINATOR); // 1/1000 = 0.1% of total supply
 270 |     | 
 271 |     |         // Note there may be cases where zero harvestable pods are available. For clarity, the code will still emit an event
 272 |     |         // but with zero sop field beans.
 273 |     |         uint256 maxHarvestable = s.sys.fields[s.sys.activeField].pods.sub(
 274 |     |             s.sys.fields[s.sys.activeField].harvestable
 275 |     |         );
 276 |     | 
 277 |     |         sopFieldBeans = sopFieldBeans > maxHarvestable ? maxHarvestable : sopFieldBeans;
 278 |     | 
 279 |     |         // save floodHarvestablePods, so that it can be used in soil available calculation
 280 |     |         s.sys.rain.floodHarvestablePods = uint128(sopFieldBeans);
 281 |     | 
 282 |     |         s.sys.fields[s.sys.activeField].harvestable = s
 283 |     |             .sys
 284 |     |             .fields[s.sys.activeField]
 285 |     |             .harvestable
 286 |     |             .add(sopFieldBeans);
 287 |     |         BeanstalkERC20(s.sys.bean).mint(address(this), sopFieldBeans);
 288 |     | 
 289 |     |         emit SeasonOfPlentyField(sopFieldBeans);
 290 |     |     }
 291 |     | 
 292 |     |     function getWellsByDeltaB()
 293 |     |         internal
 294 |     |         view
 295 |     |         returns (
 296 |     |             WellDeltaB[] memory wellDeltaBs,
 297 |     |             uint256 totalPositiveDeltaB,
 298 |     |             uint256 totalNegativeDeltaB,
 299 |     |             uint256 positiveDeltaBCount
 300 |     |         )
 301 |     |     {
 302 |     |         address[] memory wells = LibWhitelistedTokens.getCurrentlySoppableWellLpTokens();
 303 |     |         wellDeltaBs = new WellDeltaB[](wells.length);
 304 |     | 
 305 |     |         for (uint i = 0; i < wells.length; i++) {
 306 |     |             wellDeltaBs[i] = WellDeltaB(wells[i], LibDeltaB.currentDeltaB(wells[i]));
 307 |     |             if (wellDeltaBs[i].deltaB > 0) {
 308 |     |                 totalPositiveDeltaB += uint256(wellDeltaBs[i].deltaB);
 309 |     |                 positiveDeltaBCount++;
 310 |     |             } else {
 311 |     |                 totalNegativeDeltaB += uint256(-wellDeltaBs[i].deltaB);
 312 |     |             }
 313 |     |         }
 314 |     | 
 315 |     |         // Sort the wellDeltaBs array
 316 |     |         quickSort(wellDeltaBs, 0, int(wellDeltaBs.length - 1));
 317 |     |     }
 318 |     | 
 319 |     |     function quickSort(
 320 |     |         WellDeltaB[] memory arr,
 321 |     |         int left,
 322 |     |         int right
 323 |     |     ) internal pure returns (WellDeltaB[] memory) {
 324 |     |         if (left >= right) return arr;
 325 |     | 
 326 |     |         // Choose the median of left, right, and middle as pivot (improves performance on random data)
 327 |     |         uint mid = uint(left) + (uint(right) - uint(left)) / 2;
 328 |     |         WellDeltaB memory pivot;
 329 |     | 
 330 |     |         if (arr[uint(left)].deltaB > arr[uint(mid)].deltaB) {
 331 |     |             if (arr[uint(left)].deltaB < arr[uint(right)].deltaB) {
 332 |     |                 pivot = arr[uint(left)];
 333 |     |             } else {
 334 |     |                 if (arr[uint(right)].deltaB > arr[uint(mid)].deltaB) {
 335 |     |                     pivot = arr[uint(right)];
 336 |     |                 } else {
 337 |     |                     pivot = arr[uint(mid)];
 338 |     |                 }
 339 |     |             }
 340 |     |         } else {
 341 |     |             if (arr[uint(mid)].deltaB < arr[uint(right)].deltaB) {
 342 |     |                 pivot = arr[uint(mid)];
 343 |     |             } else {
 344 |     |                 if (arr[uint(right)].deltaB > arr[uint(left)].deltaB) {
 345 |     |                     pivot = arr[uint(right)];
 346 |     |                 } else {
 347 |     |                     pivot = arr[uint(left)];
 348 |     |                 }
 349 |     |             }
 350 |     |         }
 351 |     | 
 352 |     |         int i = left;
 353 |     |         int j = right;
 354 |     |         while (i <= j) {
 355 |     |             while (arr[uint(i)].deltaB > pivot.deltaB) i++;
 356 |     |             while (pivot.deltaB > arr[uint(j)].deltaB) j--;
 357 |     |             if (i <= j) {
 358 |     |                 (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);
 359 |     |                 i++;
 360 |     |                 j--;
 361 |     |             }
 362 |     |         }
 363 |     | 
 364 |     |         if (left < j) {
 365 |     |             arr = quickSort(arr, left, j);
 366 |     |         }
 367 |     |         if (i < right) {
 368 |     |             return quickSort(arr, i, right);
 369 |     |         }
 370 |     |         return arr;
 371 |     |     }
 372 |     | 
 373 |     |     /**
 374 |     |      * @dev Flood was previously called a "Season of Plenty" (SOP for short).
 375 |     |      * When Beanstalk has been Oversaturated for a Season, Beanstalk returns the
 376 |     |      * Bean price to its peg by minting additional Beans and selling them directly
 377 |     |      * on the sop well. Proceeds from the sale in the form of WETH are distributed to
 378 |     |      * Stalkholders at the beginning of a Season in proportion to their Stalk
 379 |     |      * ownership when the Farm became Oversaturated. Also, at the beginning of the
 380 |     |      * Flood, all Pods that were minted before the Farm became Oversaturated Ripen
 381 |     |      * and become Harvestable.
 382 |     |      * For more information On Oversaturation see {handleRain}.
 383 |     |      */
 384 |     |     function sopWell(WellDeltaB memory wellDeltaB) private {
 385 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 386 |     |         if (wellDeltaB.deltaB > 0) {
 387 |     |             IERC20 sopToken = LibWell.getNonBeanTokenFromWell(wellDeltaB.well);
 388 |     | 
 389 |     |             uint256 sopBeans = uint256(wellDeltaB.deltaB);
 390 |     |             BeanstalkERC20(s.sys.bean).mint(address(this), sopBeans);
 391 |     | 
 392 |     |             // Approve and Swap Beans for the non-bean token of the SOP well.
 393 |     |             BeanstalkERC20(s.sys.bean).approve(wellDeltaB.well, sopBeans);
 394 |     |             uint256 amountOut = IWell(wellDeltaB.well).swapFrom(
 395 |     |                 BeanstalkERC20(s.sys.bean),
 396 |     |                 sopToken,
 397 |     |                 sopBeans,
 398 |     |                 0,
 399 |     |                 address(this),
 400 |     |                 type(uint256).max
 401 |     |             );
 402 |     |             rewardSop(wellDeltaB.well, amountOut, address(sopToken));
 403 |     |             emit SeasonOfPlentyWell(
 404 |     |                 s.sys.season.current,
 405 |     |                 wellDeltaB.well,
 406 |     |                 address(sopToken),
 407 |     |                 amountOut,
 408 |     |                 sopBeans
 409 |     |             );
 410 |     |         }
 411 |     |     }
 412 |     | 
 413 |     |     /**
 414 |     |      * @dev Allocate `sop token` during a Season of Plenty.
 415 |     |      */
 416 |     |     function rewardSop(address well, uint256 amount, address sopToken) private {
 417 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 418 |     |         s.sys.sop.sops[s.sys.season.rainStart][well] = s
 419 |     |         .sys
 420 |     |         .sop
 421 |     |         .sops[s.sys.season.lastSop][well].add(amount.mul(C.SOP_PRECISION).div(s.sys.rain.roots));
 422 |     | 
 423 |     |         // update Beanstalk's stored overall plenty for this well
 424 |     |         s.sys.sop.plentyPerSopToken[sopToken] += amount;
 425 |     |     }
 426 |     | 
 427 |     |     /*
 428 |     |      * @notice Calculates the amount of beans per well that should be minted in a sop.
 429 |     |      * @param wellDeltaBs The deltaBs of all whitelisted wells in which to flood. Must be sorted in descending order.
 430 |     |      */
 431 |     |     function calculateSopPerWell(
 432 |     |         WellDeltaB[] memory wellDeltaBs,
 433 |     |         uint256 totalPositiveDeltaB,
 434 |     |         uint256 totalNegativeDeltaB,
 435 |     |         uint256 positiveDeltaBCount
 436 |     |     ) internal pure returns (WellDeltaB[] memory) {
 437 |     |         // most likely case is that all deltaBs are positive
 438 |     |         if (positiveDeltaBCount == wellDeltaBs.length) {
 439 |     |             // if all deltaBs are positive, need to sop all to zero, so return existing deltaBs
 440 |     |             return wellDeltaBs;
 441 |     |         }
 442 |     | 
 443 |     |         if (totalPositiveDeltaB < totalNegativeDeltaB || positiveDeltaBCount == 0) {
 444 |     |             // The less than conditional can occur if the twaDeltaB is positive, but the instanteous deltaB is negative or 0
 445 |     |             // In that case, no reductions are needed.
 446 |     |             // If there are no positive values, no well flooding is needed, return zeros
 447 |     |             for (uint256 i = 0; i < positiveDeltaBCount; i++) {
 448 |     |                 wellDeltaBs[i].deltaB = 0;
 449 |     |             }
 450 |     |             return wellDeltaBs;
 451 |     |         }
 452 |     | 
 453 |     |         if (totalPositiveDeltaB < totalNegativeDeltaB) {
 454 |     |             for (uint256 i = 0; i < positiveDeltaBCount; i++) {
 455 |     |                 wellDeltaBs[i].deltaB = 0;
 456 |     |             }
 457 |     |             return wellDeltaBs;
 458 |     |         }
 459 |     | 
 460 |     |         uint256 shaveToLevel = totalNegativeDeltaB / positiveDeltaBCount;
 461 |     | 
 462 |     |         // Loop through positive deltaB wells starting at the highest, re-use the deltaB value slot
 463 |     |         // as reduction amount (amount of beans to flood per well).
 464 |     |         for (uint256 i = positiveDeltaBCount; i > 0; i--) {
 465 |     |             if (shaveToLevel > uint256(wellDeltaBs[i - 1].deltaB)) {
 466 |     |                 shaveToLevel += (shaveToLevel - uint256(wellDeltaBs[i - 1].deltaB)) / (i - 1);
 467 |     |                 // amount to sop for this well must be zero
 468 |     |                 wellDeltaBs[i - 1].deltaB = 0;
 469 |     |             } else {
 470 |     |                 wellDeltaBs[i - 1].deltaB = wellDeltaBs[i - 1].deltaB - int256(shaveToLevel);
 471 |     |             }
 472 |     |         }
 473 |     |         return wellDeltaBs;
 474 |     |     }
 475 |     | }
 476 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibGerminate.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {LibAppStorage} from "../LibAppStorage.sol";
   5 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
   6 |     | import {Deposited, GerminatingSilo, GerminationSide} from "contracts/beanstalk/storage/System.sol";
   7 |     | import {LibRedundantMath128} from "../Math/LibRedundantMath128.sol";
   8 |     | import {LibRedundantMath32} from "../Math/LibRedundantMath32.sol";
   9 |     | import {LibRedundantMathSigned96} from "../Math/LibRedundantMathSigned96.sol";
  10 |     | import {LibTokenSilo} from "./LibTokenSilo.sol";
  11 |     | import {LibSilo} from "./LibSilo.sol";
  12 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  13 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  14 |     | import {C} from "../../C.sol";
  15 |     | 
  16 |     | /**
  17 |     |  * @title LibGerminate
  18 |     |  * @notice LibGerminate handles logic associated with germination.
  19 |     |  * @dev "germinating" values are values that are currently inactive.
  20 |     |  * germinating values stay germinating until the 1 + the remainder of the current season as passed,
  21 |     |  * in which case they become active.
  22 |     |  *
  23 |     |  * The following are germinating:
  24 |     |  * - newly issued stalk (from new deposits or mowing)
  25 |     |  * - roots from newly issued stalk
  26 |     |  * - new bdv introduced in the silo.
  27 |     |  */
  28 | *   | library LibGerminate {
  29 |     |     using LibRedundantMath256 for uint256;
  30 |     |     using SafeCast for uint256;
  31 |     |     using LibRedundantMath32 for uint32;
  32 |     |     using LibRedundantMath128 for uint128;
  33 |     |     using LibRedundantMathSigned96 for int96;
  34 |     | 
  35 |     |     //////////////////////// EVENTS ////////////////////////
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice emitted when the farmers germinating stalk changes.
  39 |     |      */
  40 |     |     event FarmerGerminatingStalkBalanceChanged(
  41 |     |         address indexed account,
  42 |     |         int256 delta,
  43 |     |         GerminationSide germ
  44 |     |     );
  45 |     | 
  46 |     |     /**
  47 |     |      * @notice emitted when the total germinating amount/bdv changes.
  48 |     |      * @param germinationSeason the season the germination occured.
  49 |     |      * Does not always equal the current season.
  50 |     |      * @param token the token being updated.
  51 |     |      * @param deltaAmount the change in the total germinating amount.
  52 |     |      * @param deltaBdv the change in the total germinating bdv.
  53 |     |      */
  54 |     |     event TotalGerminatingBalanceChanged(
  55 |     |         uint256 germinationSeason,
  56 |     |         address indexed token,
  57 |     |         int256 deltaAmount,
  58 |     |         int256 deltaBdv
  59 |     |     );
  60 |     | 
  61 |     |     /**
  62 |     |      * @notice emitted when the total germinating stalk changes.
  63 |     |      * @param germinationSeason issuance season of germinating stalk
  64 |     |      * @param deltaGerminatingStalk the change in the total germinating stalk.
  65 |     |      * @dev the issuance season may differ from the season that this event was emitted in..
  66 |     |      */
  67 |     |     event TotalGerminatingStalkChanged(uint256 germinationSeason, int256 deltaGerminatingStalk);
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice emitted at the sunrise function when the total stalk and roots are incremented.
  71 |     |      * @dev currently, stalk and roots can only increase at the end of `endTotalGermination`,
  72 |     |      * but is casted in the event to allow for future decreases.
  73 |     |      */
  74 |     |     event TotalStalkChangedFromGermination(int256 deltaStalk, int256 deltaRoots);
  75 |     | 
  76 |     |     struct GermStem {
  77 |     |         int96 germinatingStem;
  78 |     |         int96 stemTip;
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Ends the germination process of system-wide values.
  83 |     |      * @dev we calculate the unclaimed germinating roots of 2 seasons ago
  84 |     |      * as the roots of the stalk should be calculated based on the total stalk
  85 |     |      * when germination finishes, rather than when germination starts.
  86 |     |      */
  87 |     |     function endTotalGermination(uint32 season, address[] memory tokens) external {
  88 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  89 |     | 
  90 |     |         // germination can only occur after season 3.
  91 |     |         if (season < 2) return;
  92 |     |         uint32 germinationSeason = season.sub(2);
  93 |     | 
  94 |     |         // base roots are used if there are no roots in the silo.
  95 |     |         // root calculation is skipped if no deposits have been made
  96 |     |         // in the season.
  97 |     |         uint256 finishedGerminatingStalk = s.sys.silo.unclaimedGerminating[germinationSeason].stalk;
  98 |     |         uint256 rootsFromGerminatingStalk;
  99 |     |         if (s.sys.silo.roots == 0) {
 100 |     |             rootsFromGerminatingStalk = finishedGerminatingStalk.mul(C.getRootsBase());
 101 |     |         } else if (s.sys.silo.unclaimedGerminating[germinationSeason].stalk > 0) {
 102 |     |             rootsFromGerminatingStalk = s.sys.silo.roots.mul(finishedGerminatingStalk).div(
 103 |     |                 s.sys.silo.stalk
 104 |     |             );
 105 |     |         }
 106 |     |         s.sys.silo.unclaimedGerminating[germinationSeason].roots = rootsFromGerminatingStalk;
 107 |     |         // increment total stalk and roots based on unclaimed values.
 108 |     |         s.sys.silo.stalk = s.sys.silo.stalk.add(finishedGerminatingStalk);
 109 |     |         s.sys.silo.roots = s.sys.silo.roots.add(rootsFromGerminatingStalk);
 110 |     | 
 111 |     |         // increment total deposited and amounts for each token.
 112 |     |         GerminationSide side = getSeasonGerminationSide();
 113 |     |         for (uint i; i < tokens.length; ++i) {
 114 |     |             // if the token has no deposits, skip.
 115 |     |             if (s.sys.silo.germinating[side][tokens[i]].amount == 0) {
 116 |     |                 continue;
 117 |     |             }
 118 |     | 
 119 |     |             LibTokenSilo.incrementTotalDeposited(
 120 |     |                 tokens[i],
 121 |     |                 s.sys.silo.germinating[side][tokens[i]].amount,
 122 |     |                 s.sys.silo.germinating[side][tokens[i]].bdv
 123 |     |             );
 124 |     | 
 125 |     |             // emit events.
 126 |     |             emit TotalGerminatingBalanceChanged(
 127 |     |                 germinationSeason,
 128 |     |                 tokens[i],
 129 |     |                 -int256(uint256(s.sys.silo.germinating[side][tokens[i]].amount)),
 130 |     |                 -int256(uint256(s.sys.silo.germinating[side][tokens[i]].bdv))
 131 |     |             );
 132 |     |             // clear deposited values.
 133 |     |             delete s.sys.silo.germinating[side][tokens[i]];
 134 |     |         }
 135 |     | 
 136 |     |         // emit change in total germinating stalk.
 137 |     |         emit TotalGerminatingStalkChanged(
 138 |     |             germinationSeason,
 139 |     |             -int256(uint256(finishedGerminatingStalk))
 140 |     |         );
 141 |     |         emit TotalStalkChangedFromGermination(
 142 |     |             int256(uint256(finishedGerminatingStalk)),
 143 |     |             int256(uint256(rootsFromGerminatingStalk))
 144 |     |         );
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice contains logic for ending germination for stalk and roots.
 149 |     |      * @param account address of the account to end germination for.
 150 |     |      * @param lastMowedSeason the last season the account mowed.
 151 |     |      *
 152 |     |      * @dev `first` refers to the set of germinating stalk
 153 |     |      * and roots created in the season closest to the current season.
 154 |     |      * i.e if a user deposited in season 10 and 11, the `first` stalk
 155 |     |      * would be season 11.
 156 |     |      *
 157 |     |      * the germination process:
 158 |     |      * - increments the assoicated values (bdv, stalk, roots)
 159 |     |      * - clears the germination struct for the account.
 160 |     |      *
 161 |     |      * @return firstGerminatingRoots the roots from the first germinating stalk.
 162 |     |      * used in {handleRain} to properly set the rain roots of a user,
 163 |     |      * if the user had deposited in the season prior to a rain.
 164 |     |      */
 165 | *   |     function endAccountGermination(
 166 |     |         address account,
 167 |     |         uint32 lastMowedSeason,
 168 |     |         uint32 currentSeason
 169 | *   |     ) internal returns (uint256 firstGerminatingRoots) {
 170 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 171 | *   |         bool lastUpdateOdd = isSeasonOdd(lastMowedSeason);
 172 | *   |         (uint256 firstStalk, uint256 secondStalk) = getGerminatingStalk(account, lastUpdateOdd);
 173 | *   |         uint256 totalRootsFromGermination;
 174 | *   |         uint256 germinatingStalk;
 175 |     | 
 176 |     |         // check to end germination for first stalk.
 177 |     |         // if last mowed season is greater or equal than (currentSeason - 1),
 178 |     |         // then the first stalk is still germinating.
 179 | *   |         if (firstStalk > 0 && lastMowedSeason < currentSeason.sub(1)) {
 180 |     |             (uint256 roots, GerminationSide germState) = claimGerminatingRoots(
 181 |     |                 account,
 182 |     |                 lastMowedSeason,
 183 |     |                 firstStalk,
 184 |     |                 lastUpdateOdd
 185 |     |             );
 186 |     |             germinatingStalk = firstStalk;
 187 |     |             totalRootsFromGermination = roots;
 188 |     |             firstGerminatingRoots = roots;
 189 |     |             emit FarmerGerminatingStalkBalanceChanged(
 190 |     |                 account,
 191 |     |                 -int256(uint256(germinatingStalk)),
 192 |     |                 germState
 193 |     |             );
 194 |     |         }
 195 |     | 
 196 |     |         // check to end germination for second stalk.
 197 | *   |         if (secondStalk > 0) {
 198 |     |             (uint256 roots, GerminationSide germState) = claimGerminatingRoots(
 199 |     |                 account,
 200 |     |                 lastMowedSeason.sub(1),
 201 |     |                 secondStalk,
 202 |     |                 !lastUpdateOdd
 203 |     |             );
 204 |     |             germinatingStalk = germinatingStalk.add(secondStalk);
 205 |     |             totalRootsFromGermination = totalRootsFromGermination.add(roots);
 206 |     |             emit FarmerGerminatingStalkBalanceChanged(
 207 |     |                 account,
 208 |     |                 -int256(uint256(secondStalk)),
 209 |     |                 germState
 210 |     |             );
 211 |     |         }
 212 |     | 
 213 |     |         // increment users stalk and roots.
 214 | *   |         if (germinatingStalk > 0) {
 215 |     |             s.accts[account].stalk = s.accts[account].stalk.add(germinatingStalk);
 216 |     |             s.accts[account].roots = s.accts[account].roots.add(totalRootsFromGermination);
 217 |     | 
 218 |     |             // emit event. Active stalk is incremented, germinating stalk is decremented.
 219 |     |             emit LibSilo.StalkBalanceChanged(
 220 |     |                 account,
 221 |     |                 int256(uint256(germinatingStalk)),
 222 |     |                 int256(uint256(totalRootsFromGermination))
 223 |     |             );
 224 |     |         }
 225 |     |     }
 226 |     | 
 227 |     |     /**
 228 |     |      * @notice Claims the germinating roots of an account,
 229 |     |      * as well as clears the germinating stalk and roots.
 230 |     |      *
 231 |     |      * @param account address of the account to end germination for.
 232 |     |      * @param season the season to calculate the germinating roots for.
 233 |     |      * @param stalk the stalk to calculate the germinating roots for.
 234 |     |      * @param clearOdd whether to clear the odd or even germinating stalk.
 235 |     |      */
 236 |     |     function claimGerminatingRoots(
 237 |     |         address account,
 238 |     |         uint32 season,
 239 |     |         uint256 stalk,
 240 |     |         bool clearOdd
 241 |     |     ) private returns (uint256 roots, GerminationSide germState) {
 242 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 243 |     | 
 244 |     |         roots = calculateGerminatingRoots(season, stalk);
 245 |     | 
 246 |     |         if (clearOdd) {
 247 |     |             delete s.accts[account].germinatingStalk[GerminationSide.ODD];
 248 |     |             germState = GerminationSide.ODD;
 249 |     |         } else {
 250 |     |             delete s.accts[account].germinatingStalk[GerminationSide.EVEN];
 251 |     |             germState = GerminationSide.EVEN;
 252 |     |         }
 253 |     | 
 254 |     |         // deduct from unclaimed values.
 255 |     |         s.sys.silo.unclaimedGerminating[season].stalk = s
 256 |     |             .sys
 257 |     |             .silo
 258 |     |             .unclaimedGerminating[season]
 259 |     |             .stalk
 260 |     |             .sub(stalk);
 261 |     |         s.sys.silo.unclaimedGerminating[season].roots = s
 262 |     |             .sys
 263 |     |             .silo
 264 |     |             .unclaimedGerminating[season]
 265 |     |             .roots
 266 |     |             .sub(roots);
 267 |     |     }
 268 |     | 
 269 |     |     /**
 270 |     |      * @notice calculates the germinating roots for a given stalk and season.
 271 |     |      * @param season the season to use when calculating the germinating roots.
 272 |     |      * @param stalk the stalk to calculate the germinating roots for.
 273 |     |      */
 274 |     |     function calculateGerminatingRoots(
 275 |     |         uint32 season,
 276 |     |         uint256 stalk
 277 |     |     ) private view returns (uint256 roots) {
 278 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 279 |     | 
 280 |     |         // if the stalk is equal to the remaining unclaimed germinating stalk,
 281 |     |         // then return the remaining unclaimed germinating roots.
 282 |     |         if (stalk == s.sys.silo.unclaimedGerminating[season].stalk) {
 283 |     |             roots = s.sys.silo.unclaimedGerminating[season].roots;
 284 |     |         } else {
 285 |     |             // calculate the roots:
 286 |     |             roots = uint256(stalk).mul(s.sys.silo.unclaimedGerminating[season].roots).div(
 287 |     |                 s.sys.silo.unclaimedGerminating[season].stalk
 288 |     |             );
 289 |     |         }
 290 |     |     }
 291 |     | 
 292 |     |     /**
 293 |     |      * @notice returns the germinatingStalk of the account,
 294 |     |      * ordered based on the parity of lastUpdate.
 295 |     |      * @dev if lastUpdate is odd, then `firstStalk` is the odd stalk.
 296 |     |      */
 297 | *   |     function getGerminatingStalk(
 298 |     |         address account,
 299 |     |         bool lastUpdateOdd
 300 | *   |     ) internal view returns (uint128 firstStalk, uint128 secondStalk) {
 301 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 302 | *   |         if (lastUpdateOdd) {
 303 |     |             firstStalk = s.accts[account].germinatingStalk[GerminationSide.ODD];
 304 |     |             secondStalk = s.accts[account].germinatingStalk[GerminationSide.EVEN];
 305 |     |         } else {
 306 | *   |             firstStalk = s.accts[account].germinatingStalk[GerminationSide.EVEN];
 307 | *   |             secondStalk = s.accts[account].germinatingStalk[GerminationSide.ODD];
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @notice returns the germinating stalk and roots that will finish germinating
 313 |     |      * upon an interaction with the silo.
 314 |     |      */
 315 |     |     function getFinishedGerminatingStalkAndRoots(
 316 |     |         address account,
 317 |     |         uint32 lastMowedSeason,
 318 |     |         uint32 currentSeason
 319 |     |     ) internal view returns (uint256 germinatingStalk, uint256 germinatingRoots) {
 320 |     |         // if user has mowed already,
 321 |     |         // then there are no germinating stalk and roots to finish.
 322 |     |         if (lastMowedSeason == currentSeason) {
 323 |     |             return (0, 0);
 324 |     |         }
 325 |     | 
 326 |     |         (uint128 firstStalk, uint128 secondStalk) = getGerminatingStalk(
 327 |     |             account,
 328 |     |             isSeasonOdd(lastMowedSeason)
 329 |     |         );
 330 |     | 
 331 |     |         // check to end germination for first stalk.
 332 |     |         // if last mowed season is the greater or equal than (currentSeason - 1),
 333 |     |         // then the first stalk is still germinating.
 334 |     |         if (firstStalk > 0 && lastMowedSeason < currentSeason.sub(1)) {
 335 |     |             germinatingStalk = firstStalk;
 336 |     |             germinatingRoots = calculateGerminatingRoots(lastMowedSeason, firstStalk);
 337 |     |         }
 338 |     | 
 339 |     |         // check to end germination for second stalk.
 340 |     |         if (secondStalk > 0) {
 341 |     |             germinatingStalk = germinatingStalk.add(secondStalk);
 342 |     |             germinatingRoots = germinatingRoots.add(
 343 |     |                 calculateGerminatingRoots(lastMowedSeason.sub(1), secondStalk)
 344 |     |             );
 345 |     |         }
 346 |     |     }
 347 |     | 
 348 |     |     /**
 349 |     |      * @notice returns the stalk currently germinating for an account.
 350 |     |      * Does not include germinating stalk that will finish germinating
 351 |     |      * upon an interaction with the silo.
 352 |     |      */
 353 |     |     function getCurrentGerminatingStalk(
 354 |     |         address account,
 355 |     |         uint32 lastMowedSeason
 356 |     |     ) internal view returns (uint256 germinatingStalk) {
 357 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 358 |     | 
 359 |     |         // if the last mowed season is less than the current season - 1,
 360 |     |         // then there are no germinating stalk and roots (as all germinating assets have finished).
 361 |     |         if (lastMowedSeason < s.sys.season.current.sub(1)) {
 362 |     |             return 0;
 363 |     |         } else {
 364 |     |             (uint128 firstStalk, uint128 secondStalk) = getGerminatingStalk(
 365 |     |                 account,
 366 |     |                 isSeasonOdd(lastMowedSeason)
 367 |     |             );
 368 |     |             germinatingStalk = firstStalk.add(secondStalk);
 369 |     |         }
 370 |     |     }
 371 |     | 
 372 |     |     /**
 373 |     |      * @notice returns the unclaimed germinating stalk and roots.
 374 |     |      */
 375 |     |     function getUnclaimedGerminatingStalkAndRoots(
 376 |     |         uint32 season
 377 |     |     ) internal view returns (GerminatingSilo memory unclaimed) {
 378 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 379 |     |         unclaimed = s.sys.silo.unclaimedGerminating[season];
 380 |     |     }
 381 |     | 
 382 |     |     /**
 383 |     |      * @notice returns the total germinating bdv and amount for a token.
 384 |     |      */
 385 |     |     function getTotalGerminatingForToken(
 386 |     |         address token
 387 |     |     ) internal view returns (uint256 bdv, uint256 amount) {
 388 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 389 |     |         return (
 390 |     |             s.sys.silo.germinating[GerminationSide.ODD][token].bdv +
 391 |     |                 s.sys.silo.germinating[GerminationSide.EVEN][token].bdv,
 392 |     |             s.sys.silo.germinating[GerminationSide.ODD][token].amount +
 393 |     |                 s.sys.silo.germinating[GerminationSide.EVEN][token].amount
 394 |     |         );
 395 |     |     }
 396 |     | 
 397 |     |     /**
 398 |     |      * @notice determines whether a deposit (token + stem) should be germinating or not.
 399 |     |      * If germinating, determines whether the deposit should be set to even or odd.
 400 |     |      *
 401 |     |      * @dev `getGerminationState` should be used if the stemTip and germinatingStem
 402 |     |      * have not been calculated yet. Otherwise, use `_getGerminationState` for gas effiecnecy.
 403 |     |      */
 404 | *   |     function getGerminationState(
 405 |     |         address token,
 406 |     |         int96 stem
 407 | *   |     ) internal view returns (GerminationSide, int96) {
 408 | *   |         GermStem memory germStem = getGerminatingStem(token);
 409 | *   |         return (_getGerminationState(stem, germStem), germStem.stemTip);
 410 |     |     }
 411 |     | 
 412 |     |     /**
 413 |     |      * @notice returns the `germinating` stem of a token.
 414 |     |      * @dev the 'germinating' stem is the stem where deposits that have a stem
 415 |     |      * equal or higher than this value are germinating.
 416 |     |      */
 417 | *   |     function getGerminatingStem(address token) internal view returns (GermStem memory germStem) {
 418 | *   |         germStem.stemTip = LibTokenSilo.stemTipForToken(token);
 419 | *   |         germStem.germinatingStem = _getGerminatingStem(token, germStem.stemTip);
 420 |     |     }
 421 |     | 
 422 |     |     /**
 423 |     |      * @notice returns the highest stem that is not germinating for a token.
 424 |     |      * @notice requires a minimum stem of 1.
 425 |     |      */
 426 |     |     function getHighestNonGerminatingStem(address token) internal view returns (int96 stem) {
 427 |     |         return getGerminatingStem(token).germinatingStem - 1;
 428 |     |     }
 429 |     | 
 430 |     |     /**
 431 |     |      * @notice returns the `germinating` stem of a token.
 432 |     |      * @dev the 'germinating' stem is the stem where deposits that have a stem
 433 |     |      * equal or higher than this value are germinating.
 434 |     |      */
 435 | *   |     function _getGerminatingStem(address token, int96 stemTip) internal view returns (int96 stem) {
 436 | *   |         return __getGerminatingStem(stemTip, int96(uint96(getPrevStalkEarnedPerSeason(token))));
 437 |     |     }
 438 |     | 
 439 |     |     /**
 440 |     |      * @notice Gas efficent version of `_getGerminatingStem`.
 441 |     |      *
 442 |     |      * @dev use when the stemTip and germinatingStem have already been calculated.
 443 |     |      * Assumes the same token is used.
 444 |     |      * prevStalkEarnedPerSeason is the stalkEarnedPerSeason of the previous season.
 445 |     |      * since `lastStemTip` + `prevStalkEarnedPerSeason` is the current stemTip,
 446 |     |      * safeMath is not needed.
 447 |     |      */
 448 | *   |     function __getGerminatingStem(
 449 |     |         int96 stemTip,
 450 |     |         int96 prevStalkEarnedPerSeason
 451 | *   |     ) internal pure returns (int96 stem) {
 452 | *   |         return stemTip - prevStalkEarnedPerSeason;
 453 |     |     }
 454 |     | 
 455 |     |     /**
 456 |     |      * @notice returns the stalkEarnedPerSeason of a token of the previous season.
 457 |     |      * @dev if the milestone season is not the current season, then the stalkEarnedPerSeason
 458 |     |      * hasn't changed from the previous season. Otherwise, we calculate the prevStalkEarnedPerSeason.
 459 |     |      */
 460 |     | 
 461 | *   |     function getPrevStalkEarnedPerSeason(
 462 |     |         address token
 463 | *   |     ) private view returns (uint40 prevStalkEarnedPerSeason) {
 464 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 465 |     | 
 466 | *   |         if (s.sys.silo.assetSettings[token].milestoneSeason < s.sys.season.current) {
 467 | *   |             prevStalkEarnedPerSeason = s.sys.silo.assetSettings[token].stalkEarnedPerSeason;
 468 | *   |         } else {
 469 | *   |             int40 deltaStalkEarnedPerSeason = s
 470 |     |                 .sys
 471 |     |                 .silo
 472 | *   |                 .assetSettings[token]
 473 |     |                 .deltaStalkEarnedPerSeason;
 474 | *   |             if (deltaStalkEarnedPerSeason >= 0) {
 475 | *   |                 prevStalkEarnedPerSeason =
 476 | *   |                     s.sys.silo.assetSettings[token].stalkEarnedPerSeason -
 477 | *   |                     uint40(deltaStalkEarnedPerSeason);
 478 |     |             } else {
 479 |     |                 prevStalkEarnedPerSeason =
 480 |     |                     s.sys.silo.assetSettings[token].stalkEarnedPerSeason +
 481 |     |                     uint40(-deltaStalkEarnedPerSeason);
 482 |     |             }
 483 |     |         }
 484 |     |     }
 485 |     | 
 486 |     |     /**
 487 |     |      * @notice internal function for germination stem.
 488 |     |      * @dev a deposit is germinating if the stem is the stemTip or the germinationStem.
 489 |     |      * the 'germinationStem` is the stem of the token of the previous season.
 490 |     |      *
 491 |     |      * The function must check whether the stem is equal to the germinationStem,
 492 |     |      * to determine which germination state it is in.
 493 |     |      */
 494 | *   |     function _getGerminationState(
 495 |     |         int96 stem,
 496 |     |         GermStem memory germData
 497 | *   |     ) internal view returns (GerminationSide) {
 498 | *   |         if (stem < germData.germinatingStem) {
 499 |     |             // if the stem of the deposit is lower than the germination stem,
 500 |     |             // then the deposit is not germinating.
 501 |     |             return GerminationSide.NOT_GERMINATING;
 502 |     |         } else {
 503 |     |             // return the gemination state based on whether the stem
 504 |     |             // is equal to the stemTip.
 505 |     |             // if the stem is equal to the stem tip, it is in the initial stages of germination.
 506 |     |             // if the stem is not equal to the stemTip, its in the germination process.
 507 | *   |             if (stem == germData.stemTip) {
 508 | *   |                 return isCurrentSeasonOdd() ? GerminationSide.ODD : GerminationSide.EVEN;
 509 |     |             } else {
 510 | *   |                 return isCurrentSeasonOdd() ? GerminationSide.EVEN : GerminationSide.ODD;
 511 |     |             }
 512 |     |         }
 513 |     |     }
 514 |     | 
 515 |     |     /**
 516 |     |      * @notice returns the germination side for the current season.
 517 |     |      * @dev used in new deposits, as all new deposits are germinating.
 518 |     |      */
 519 | *   |     function getSeasonGerminationSide() internal view returns (GerminationSide) {
 520 | *   |         return isCurrentSeasonOdd() ? GerminationSide.ODD : GerminationSide.EVEN;
 521 |     |     }
 522 |     | 
 523 |     |     /**
 524 |     |      * @notice returns the germination state for a given season.
 525 |     |      */
 526 |     |     function getGerminationStateForSeason(uint32 season) internal pure returns (GerminationSide) {
 527 |     |         return isSeasonOdd(season) ? GerminationSide.ODD : GerminationSide.EVEN;
 528 |     |     }
 529 |     | 
 530 |     |     /**
 531 |     |      * @notice returns whether the current season is odd. Used for Germination.
 532 |     |      * @dev even % 2 = 0 (false), odd % 2 = 1 (true)
 533 |     |      */
 534 | *   |     function isCurrentSeasonOdd() internal view returns (bool) {
 535 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 536 | *   |         return isSeasonOdd(s.sys.season.current);
 537 |     |     }
 538 |     | 
 539 |     |     /**
 540 |     |      * @notice returns whether `season` is odd.
 541 |     |      */
 542 | *   |     function isSeasonOdd(uint32 season) internal pure returns (bool) {
 543 | *   |         return season.mod(2) == 0 ? false : true;
 544 |     |     }
 545 |     | }
 546 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibSilo.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | pragma abicoder v2;
   7 |     | 
   8 |     | import {LibAppStorage} from "../LibAppStorage.sol";
   9 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  10 |     | import {GerminationSide} from "contracts/beanstalk/storage/System.sol";
  11 |     | import {C} from "../../C.sol";
  12 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  13 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  14 |     | import {LibBytes} from "../LibBytes.sol";
  15 |     | import {LibTokenSilo} from "./LibTokenSilo.sol";
  16 |     | import {LibRedundantMath128} from "../Math/LibRedundantMath128.sol";
  17 |     | import {LibRedundantMath32} from "../Math/LibRedundantMath32.sol";
  18 |     | import {LibRedundantMathSigned96} from "../Math/LibRedundantMathSigned96.sol";
  19 |     | import {LibGerminate} from "./LibGerminate.sol";
  20 |     | import {LibWhitelistedTokens} from "./LibWhitelistedTokens.sol";
  21 |     | import {LibTractor} from "../LibTractor.sol";
  22 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  23 |     | import {IWell} from "contracts/interfaces/basin/IWell.sol";
  24 |     | import {LibFlood} from "contracts/libraries/Silo/LibFlood.sol";
  25 |     | 
  26 |     | /**
  27 |     |  * @title LibSilo
  28 |     |  * @notice Contains functions for minting, burning, and transferring of
  29 |     |  * Stalk and Roots within the Silo.
  30 |     |  *
  31 |     |  * @dev Here, we refer to "minting" as the combination of
  32 |     |  * increasing the total balance of Stalk/Roots, as well as allocating
  33 |     |  * them to a particular account. However, in other places throughout Beanstalk
  34 |     |  * (like during the Sunrise), Beanstalk's total balance of Stalk increases
  35 |     |  * without allocating to a particular account. One example is {Sun-rewardToSilo}
  36 |     |  * which increases `s.silo.stalk` but does not allocate it to any account. The
  37 |     |  * allocation occurs during `{SiloFacet-plant}`. Does this change how we should
  38 |     |  * call "minting"?
  39 |     |  *
  40 |     |  * In the ERC20 context, "minting" increases the supply of a token and allocates
  41 |     |  * the new tokens to an account in one action. I've adjusted the comments below
  42 |     |  * to use "mint" in the same sense.
  43 |     |  */
  44 | *   | library LibSilo {
  45 |     |     using LibRedundantMath256 for uint256;
  46 |     |     using LibRedundantMath128 for uint128;
  47 |     |     using LibRedundantMathSigned96 for int96;
  48 |     |     using LibRedundantMath32 for uint32;
  49 |     |     using SafeCast for uint256;
  50 |     | 
  51 |     |     uint128 internal constant PRECISION = 1e6;
  52 |     |     //////////////////////// EVENTS ////////////////////////
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Emitted when `account` gains or loses Stalk.
  56 |     |      * @param account The account that gained or lost Stalk.
  57 |     |      * @param delta The change in Stalk.
  58 |     |      * @param deltaRoots The change in Roots.
  59 |     |      *
  60 |     |      * @dev Should be emitted anytime a Deposit is added, removed or transferred
  61 |     |      * AND anytime an account Mows Grown Stalk.
  62 |     |      */
  63 |     |     event StalkBalanceChanged(address indexed account, int256 delta, int256 deltaRoots);
  64 |     | 
  65 |     |     /**
  66 |     |      * @notice Emitted when a deposit is removed from the silo.
  67 |     |      *
  68 |     |      * @param account The account assoicated with the removed deposit.
  69 |     |      * @param token The token address of the removed deposit.
  70 |     |      * @param stem The stem of the removed deposit.
  71 |     |      * @param amount The amount of "token" removed from an deposit.
  72 |     |      * @param bdv The instanteous bdv removed from the deposit.
  73 |     |      */
  74 |     |     event RemoveDeposit(
  75 |     |         address indexed account,
  76 |     |         address indexed token,
  77 |     |         int96 stem,
  78 |     |         uint256 amount,
  79 |     |         uint256 bdv
  80 |     |     );
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Emitted when multiple deposits are removed from the silo.
  84 |     |      *
  85 |     |      * @param account The account assoicated with the removed deposit.
  86 |     |      * @param token The token address of the removed deposit.
  87 |     |      * @param stems A list of stems of the removed deposits.
  88 |     |      * @param amounts A list of amounts removed from the deposits.
  89 |     |      * @param amount the total summation of the amount removed.
  90 |     |      * @param bdvs A list of bdvs removed from the deposits.
  91 |     |      */
  92 |     |     event RemoveDeposits(
  93 |     |         address indexed account,
  94 |     |         address indexed token,
  95 |     |         int96[] stems,
  96 |     |         uint256[] amounts,
  97 |     |         uint256 amount,
  98 |     |         uint256[] bdvs
  99 |     |     );
 100 |     | 
 101 |     |     /**
 102 |     |      * @notice Emitted when deposit is approved for spender.
 103 |     |      */
 104 |     |     event DepositApproval(
 105 |     |         address indexed owner,
 106 |     |         address indexed spender,
 107 |     |         address token,
 108 |     |         uint256 amount
 109 |     |     );
 110 |     | 
 111 |     |     /**
 112 |     |      * AssetsRemoved contains the assets removed
 113 |     |      * during a withdraw or convert.
 114 |     |      *
 115 |     |      * @dev seperated into 3 catagories:
 116 |     |      * active: non-germinating assets.
 117 |     |      * odd: odd germinating assets.
 118 |     |      * even: even germinating assets.
 119 |     |      * grownStalk from germinating depoists are seperated
 120 |     |      * as that stalk is not germinating.
 121 |     |      */
 122 |     |     struct AssetsRemoved {
 123 |     |         Removed active;
 124 |     |         Removed odd;
 125 |     |         Removed even;
 126 |     |         uint256 grownStalkFromGermDeposits;
 127 |     |     }
 128 |     | 
 129 |     |     struct Removed {
 130 |     |         uint256 tokens;
 131 |     |         uint256 stalk;
 132 |     |         uint256 bdv;
 133 |     |     }
 134 |     | 
 135 |     |     //////////////////////// MINT ////////////////////////
 136 |     | 
 137 |     |     /**
 138 |     |      * @dev Mints Stalk and Roots to `account`.
 139 |     |      *
 140 |     |      * `roots` are an underlying accounting variable that is used to track
 141 |     |      * how many earned beans a user has.
 142 |     |      *
 143 |     |      * When a farmer's state is updated, the ratio should hold:
 144 |     |      *
 145 |     |      *  Total Roots     User Roots
 146 |     |      * ------------- = ------------
 147 |     |      *  Total Stalk     User Stalk
 148 |     |      *
 149 |     |      * @param account the address to mint Stalk and Roots to
 150 |     |      * @param stalk the amount of stalk to mint
 151 |     |      *
 152 |     |      * @dev Stalk that is not germinating are `active`, meaning that they
 153 |     |      * are eligible for bean mints. To mint germinating stalk, use
 154 |     |      * `mintGerminatingStalk`.
 155 |     |      */
 156 |     |     function mintActiveStalk(address account, uint256 stalk) internal {
 157 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 158 |     |         uint256 roots;
 159 |     |         if (s.sys.silo.roots == 0) {
 160 |     |             roots = uint256(stalk.mul(C.getRootsBase()));
 161 |     |         } else {
 162 |     |             // germinating assets should be considered
 163 |     |             // when calculating roots
 164 |     |             roots = s.sys.silo.roots.mul(stalk).div(s.sys.silo.stalk);
 165 |     |         }
 166 |     | 
 167 |     |         // increment user and total stalk;
 168 |     |         s.sys.silo.stalk = s.sys.silo.stalk.add(stalk);
 169 |     |         s.accts[account].stalk = s.accts[account].stalk.add(stalk);
 170 |     | 
 171 |     |         // increment user and total roots
 172 |     |         s.sys.silo.roots = s.sys.silo.roots.add(roots);
 173 |     |         s.accts[account].roots = s.accts[account].roots.add(roots);
 174 |     | 
 175 |     |         emit StalkBalanceChanged(account, int256(stalk), int256(roots));
 176 |     |     }
 177 |     | 
 178 |     |     /**
 179 |     |      * @notice Mints Roots to `account` and updates the system total.
 180 |     |      *
 181 |     |      * @param account the address to min rain roots to
 182 |     |      * @param rainRoots the amount of rain roots to mint
 183 |     |      *
 184 |     |      * @dev Rain roots are minted at the start of a rain season and
 185 |     |      * after redepositing during a convert operation.
 186 |     |      */
 187 |     |     function mintRainRoots(address account, uint256 rainRoots) internal {
 188 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 189 |     |         // increase user rain roots
 190 |     |         s.accts[account].sop.rainRoots = s.accts[account].sop.rainRoots + rainRoots;
 191 |     |         // increase system rain roots
 192 |     |         s.sys.rain.roots = s.sys.rain.roots + rainRoots;
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @notice mintGerminatingStalk contains logic for minting stalk that is germinating.
 197 |     |      * @dev `germinating stalk` are newly issued stalk that are not eligible for bean mints,
 198 |     |      * until 2 `gm` calls have passed, at which point they are considered `grown stalk`.
 199 |     |      *
 200 |     |      * Since germinating stalk are not elgible for bean mints, when calculating the roots of these
 201 |     |      * stalk, it should use the stalk and roots of the system once the stalk is fully germinated,
 202 |     |      * rather than at the time of minting.
 203 |     |      */
 204 | *   |     function mintGerminatingStalk(address account, uint128 stalk, GerminationSide side) internal {
 205 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 206 |     | 
 207 | *   |         s.accts[account].germinatingStalk[side] += stalk;
 208 |     | 
 209 |     |         // germinating stalk are either newly germinating, or partially germinated.
 210 |     |         // Thus they can only be incremented in the latest or previous season.
 211 | *   |         uint32 season = s.sys.season.current;
 212 | *   |         if (LibGerminate.getSeasonGerminationSide() == side) {
 213 | *   |             s.sys.silo.unclaimedGerminating[season].stalk += stalk;
 214 |     |         } else {
 215 |     |             s.sys.silo.unclaimedGerminating[season - 1].stalk += stalk;
 216 |     |         }
 217 |     | 
 218 |     |         // emit events.
 219 | *   |         emit LibGerminate.FarmerGerminatingStalkBalanceChanged(
 220 | *   |             account,
 221 | *   |             int256(uint256(stalk)),
 222 | *   |             side
 223 |     |         );
 224 | *   |         emit LibGerminate.TotalGerminatingStalkChanged(season, int256(uint256(stalk)));
 225 |     |     }
 226 |     | 
 227 |     |     //////////////////////// BURN ////////////////////////
 228 |     | 
 229 |     |     /**
 230 |     |      * @notice Burns stalk and roots from an account.
 231 |     |      */
 232 |     |     function burnActiveStalk(
 233 |     |         address account,
 234 |     |         uint256 stalk
 235 |     |     ) internal returns (uint256 roots, uint256 deltaRainRoots) {
 236 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 237 |     |         if (stalk == 0) return (0, 0);
 238 |     | 
 239 |     |         // Calculate the amount of Roots for the given amount of Stalk.
 240 |     |         roots = s.sys.silo.roots.mul(stalk).div(s.sys.silo.stalk);
 241 |     |         if (roots > s.accts[account].roots) roots = s.accts[account].roots;
 242 |     | 
 243 |     |         // Decrease supply of Stalk; Remove Stalk from the balance of `account`
 244 |     |         s.sys.silo.stalk = s.sys.silo.stalk.sub(stalk);
 245 |     |         s.accts[account].stalk = s.accts[account].stalk.sub(stalk);
 246 |     | 
 247 |     |         // Decrease supply of Roots; Remove Roots from the balance of `account`
 248 |     |         s.sys.silo.roots = s.sys.silo.roots.sub(roots);
 249 |     |         s.accts[account].roots = s.accts[account].roots.sub(roots);
 250 |     | 
 251 |     |         // If it is Raining and the account now has less roots than the
 252 |     |         // account's current rain roots, set the account's rain roots
 253 |     |         // to the account's current roots and subtract the difference
 254 |     |         // from Beanstalk's total rain roots.
 255 |     |         if (s.accts[account].sop.rainRoots > s.accts[account].roots) {
 256 |     |             uint256 deltaRoots = s.accts[account].sop.rainRoots.sub(s.accts[account].roots);
 257 |     |             s.accts[account].sop.rainRoots = s.accts[account].roots;
 258 |     |             // decrease system rain roots
 259 |     |             s.sys.rain.roots = s.sys.rain.roots.sub(deltaRoots);
 260 |     |             // set the return value to the rain roots that were burned.
 261 |     |             deltaRainRoots = deltaRoots;
 262 |     |         }
 263 |     | 
 264 |     |         // emit event.
 265 |     |         emit StalkBalanceChanged(account, -int256(stalk), -int256(roots));
 266 |     |     }
 267 |     | 
 268 |     |     /**
 269 |     |      * @notice Burns germinating stalk.
 270 |     |      * @dev Germinating stalk does not have any roots assoicated with it.
 271 |     |      */
 272 | *   |     function burnGerminatingStalk(address account, uint128 stalk, GerminationSide side) external {
 273 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 274 |     | 
 275 | *   |         s.accts[account].germinatingStalk[side] -= stalk;
 276 |     | 
 277 |     |         // germinating stalk are either newly germinating, or partially germinated.
 278 |     |         // Thus they can only be decremented in the latest or previous season.
 279 | *   |         uint32 season = s.sys.season.current;
 280 | *   |         if (LibGerminate.getSeasonGerminationSide() == side) {
 281 | *   |             s.sys.silo.unclaimedGerminating[season].stalk -= stalk;
 282 |     |         } else {
 283 |     |             s.sys.silo.unclaimedGerminating[season - 1].stalk -= stalk;
 284 |     |         }
 285 |     | 
 286 |     |         // emit events.
 287 | *   |         emit LibGerminate.FarmerGerminatingStalkBalanceChanged(
 288 | *   |             account,
 289 | *   |             -int256(uint256(stalk)),
 290 | *   |             side
 291 |     |         );
 292 | *   |         emit LibGerminate.TotalGerminatingStalkChanged(season, -int256(uint256(stalk)));
 293 |     |     }
 294 |     | 
 295 |     |     //////////////////////// TRANSFER ////////////////////////
 296 |     | 
 297 |     |     /**
 298 |     |      * @notice Decrements the Stalk and Roots of `sender` and increments the Stalk
 299 |     |      * and Roots of `recipient` by the same amount.
 300 |     |      *
 301 |     |      */
 302 |     |     function transferStalk(address sender, address recipient, uint256 stalk) internal {
 303 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 304 |     |         uint256 roots;
 305 |     |         // calc roots to send based on sender roots
 306 |     |         roots = stalk == s.accts[sender].stalk
 307 |     |             ? s.accts[sender].roots
 308 |     |             : s.sys.silo.roots.mul(stalk).sub(1).div(s.sys.silo.stalk).add(1);
 309 |     | 
 310 |     |         // Subtract Stalk and Roots from the 'sender' balance.
 311 |     |         s.accts[sender].stalk = s.accts[sender].stalk.sub(stalk);
 312 |     |         s.accts[sender].roots = s.accts[sender].roots.sub(roots);
 313 |     |         emit StalkBalanceChanged(sender, -int256(stalk), -int256(roots));
 314 |     | 
 315 |     |         // If the senders resulting roots are less than the senders rain roots,
 316 |     |         // transfer the difference to the recipient.
 317 |     |         if (s.accts[sender].sop.rainRoots > s.accts[sender].roots) {
 318 |     |             uint256 deltaRoots = s.accts[sender].sop.rainRoots.sub(s.accts[sender].roots);
 319 |     |             s.accts[sender].sop.rainRoots = s.accts[sender].roots;
 320 |     |             s.accts[recipient].sop.rainRoots = s.accts[recipient].sop.rainRoots.add(deltaRoots);
 321 |     |         }
 322 |     | 
 323 |     |         // Add Stalk and Roots to the 'recipient' balance.
 324 |     |         s.accts[recipient].stalk = s.accts[recipient].stalk.add(stalk);
 325 |     |         s.accts[recipient].roots = s.accts[recipient].roots.add(roots);
 326 |     |         emit StalkBalanceChanged(recipient, int256(stalk), int256(roots));
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @notice germinating counterpart of `transferStalk`.
 331 |     |      * @dev assumes stalk is germinating.
 332 |     |      */
 333 | *   |     function transferGerminatingStalk(
 334 |     |         address sender,
 335 |     |         address recipient,
 336 |     |         uint256 stalk,
 337 |     |         GerminationSide side
 338 | *   |     ) internal {
 339 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 340 |     |         // Subtract Germinating Stalk from the 'sender' balance,
 341 |     |         // and Add to the 'recipient' balance.
 342 | *   |         s.accts[sender].germinatingStalk[side] -= stalk.toUint128();
 343 | *   |         s.accts[recipient].germinatingStalk[side] += stalk.toUint128();
 344 |     | 
 345 |     |         // emit events.
 346 | *   |         emit LibGerminate.FarmerGerminatingStalkBalanceChanged(
 347 | *   |             sender,
 348 | *   |             -int256(uint256(stalk)),
 349 | *   |             side
 350 |     |         );
 351 | *   |         emit LibGerminate.FarmerGerminatingStalkBalanceChanged(
 352 | *   |             recipient,
 353 | *   |             int256(uint256(stalk)),
 354 | *   |             side
 355 |     |         );
 356 |     |     }
 357 |     | 
 358 |     |     /**
 359 |     |      * @notice transfers both stalk and Germinating Stalk.
 360 |     |      * @dev used in {TokenSilo._transferDeposits}
 361 |     |      */
 362 | *   |     function transferStalkAndGerminatingStalk(
 363 |     |         address sender,
 364 |     |         address recipient,
 365 |     |         address token,
 366 |     |         AssetsRemoved memory ar
 367 | *   |     ) external {
 368 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 369 | *   |         uint256 stalkPerBDV = s.sys.silo.assetSettings[token].stalkIssuedPerBdv;
 370 |     | 
 371 | *   |         if (ar.odd.bdv > 0) {
 372 | *   |             uint256 initialStalk = ar.odd.bdv.mul(stalkPerBDV);
 373 | *   |             transferGerminatingStalk(sender, recipient, initialStalk, GerminationSide.ODD);
 374 |     |         }
 375 | *   |         if (ar.even.bdv > 0) {
 376 |     |             uint256 initialStalk = ar.even.bdv.mul(stalkPerBDV);
 377 |     |             transferGerminatingStalk(sender, recipient, initialStalk, GerminationSide.EVEN);
 378 |     |         }
 379 |     | 
 380 |     |         // a Germinating Deposit may have Grown Stalk (which is not Germinating),
 381 |     |         // but the base Stalk is still Germinating.
 382 |     |         // Grown Stalk from non-Germinating Deposits, and base stalk from Earned Bean Deposits.
 383 |     |         // base stalk from non-germinating deposits.
 384 |     |         // grown stalk from Even Germinating Deposits.
 385 |     |         // grown stalk from Odd Germinating Deposits.
 386 | *   |         ar.active.stalk = ar
 387 |     |             .active
 388 |     |             .stalk
 389 | *   |             .add(ar.active.bdv.mul(stalkPerBDV))
 390 | *   |             .add(ar.even.stalk)
 391 | *   |             .add(ar.odd.stalk);
 392 | *   |         if (ar.active.stalk > 0) {
 393 |     |             transferStalk(sender, recipient, ar.active.stalk);
 394 |     |         }
 395 |     |     }
 396 |     | 
 397 |     |     /**
 398 |     |      * @dev Claims the Grown Stalk for `account` and applies it to their Stalk
 399 |     |      * balance. Also handles Season of Plenty related rain.
 400 |     |      *
 401 |     |      * This is why `_mow()` must be called before any actions that change Seeds,
 402 |     |      * including:
 403 |     |      *  - {SiloFacet-deposit}
 404 |     |      *  - {SiloFacet-withdrawDeposit}
 405 |     |      *  - {SiloFacet-withdrawDeposits}
 406 |     |      *  - {_plant}
 407 |     |      *  - {SiloFacet-transferDeposit(s)}
 408 |     |      */
 409 | *   |     function _mow(address account, address token) external {
 410 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 411 |     | 
 412 | *   |         uint32 lastUpdate = _lastUpdate(account);
 413 |     | 
 414 | *   |         uint32 currentSeason = s.sys.season.current;
 415 |     | 
 416 |     |         // End account germination.
 417 | *   |         uint256 firstGerminatingRoots;
 418 | *   |         if (lastUpdate < currentSeason) {
 419 | *   |             firstGerminatingRoots = LibGerminate.endAccountGermination(
 420 | *   |                 account,
 421 | *   |                 lastUpdate,
 422 | *   |                 currentSeason
 423 |     |             );
 424 |     |         }
 425 |     | 
 426 |     |         // sop data only needs to be updated once per season,
 427 |     |         // if it started raining and it's still raining, or there was a sop
 428 |     | 
 429 | *   |         if (
 430 | *   |             (lastUpdate <= s.sys.season.rainStart || s.accts[account].lastRain > 0) &&
 431 | *   |             lastUpdate <= currentSeason
 432 |     |         ) {
 433 |     |             // Increments `plenty` for `account` if a Flood has occured.
 434 |     |             // Saves Rain Roots for `account` if it is Raining.
 435 | *   |             LibFlood.handleRainAndSops(account, lastUpdate, firstGerminatingRoots);
 436 |     |         }
 437 |     | 
 438 |     |         // Calculate the amount of Grown Stalk claimable by `account`.
 439 |     |         // Increase the account's balance of Stalk and Roots.
 440 | *   |         __mow(account, token);
 441 |     | 
 442 |     |         // update lastUpdate for sop and germination calculations.
 443 | *   |         s.accts[account].lastUpdate = currentSeason;
 444 |     |     }
 445 |     | 
 446 |     |     /**
 447 |     |      * @dev Updates the mowStatus for the given account and token,
 448 |     |      * and mints Grown Stalk for the given account and token.
 449 |     |      */
 450 | *   |     function __mow(address account, address token) private {
 451 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 452 |     | 
 453 | *   |         int96 _stemTip = LibTokenSilo.stemTipForToken(token);
 454 | *   |         int96 _lastStem = s.accts[account].mowStatuses[token].lastStem;
 455 | *   |         uint128 _bdv = s.accts[account].mowStatuses[token].bdv;
 456 |     | 
 457 |     |         // if:
 458 |     |         // 1: account has no bdv (new token deposit)
 459 |     |         // 2: the lastStem is the same as the stemTip (implying that a user has mowed),
 460 |     |         // then skip calculations to save gas.
 461 | *   |         if (_bdv > 0) {
 462 | *   |             if (_lastStem == _stemTip) {
 463 | *   |                 return;
 464 |     |             }
 465 |     | 
 466 |     |             // grown stalk does not germinate and is immediately included for bean mints.
 467 |     |             mintActiveStalk(account, _balanceOfGrownStalk(_lastStem, _stemTip, _bdv));
 468 |     |         }
 469 |     | 
 470 |     |         // If this `account` has no BDV, skip to save gas. Update lastStem.
 471 |     |         // (happen on initial deposit, since mow is called before any deposit)
 472 | *   |         s.accts[account].mowStatuses[token].lastStem = _stemTip;
 473 | *   |         return;
 474 |     |     }
 475 |     | 
 476 |     |     /**
 477 |     |      * @notice returns the last season an account interacted with the silo.
 478 |     |      */
 479 | *   |     function _lastUpdate(address account) internal view returns (uint32) {
 480 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 481 | *   |         return s.accts[account].lastUpdate;
 482 |     |     }
 483 |     | 
 484 |     |     /**
 485 |     |      * @dev returns the balance of amount of grown stalk based on stems.
 486 |     |      * @param lastStem the stem assoicated with the last mow
 487 |     |      * @param latestStem the current stem for a given token
 488 |     |      * @param bdv the bdv used to calculate grown stalk
 489 |     |      */
 490 |     |     function _balanceOfGrownStalk(
 491 |     |         int96 lastStem,
 492 |     |         int96 latestStem,
 493 |     |         uint128 bdv
 494 |     |     ) internal pure returns (uint256) {
 495 |     |         return stalkReward(lastStem, latestStem, bdv);
 496 |     |     }
 497 |     | 
 498 |     |     //////////////////////// REMOVE ////////////////////////
 499 |     | 
 500 |     |     /**
 501 |     |      * @dev Removes from a single Deposit, emits the RemoveDeposit event,
 502 |     |      * and returns the Stalk/BDV that were removed.
 503 |     |      *
 504 |     |      * Used in:
 505 |     |      * - {TokenSilo:_withdrawDeposit}
 506 |     |      * - {TokenSilo:_transferDeposit}
 507 |     |      */
 508 | *   |     function _removeDepositFromAccount(
 509 |     |         address account,
 510 |     |         address token,
 511 |     |         int96 stem,
 512 |     |         uint256 amount,
 513 |     |         LibTokenSilo.Transfer transferType
 514 |     |     )
 515 |     |         internal
 516 |     |         returns (
 517 | *   |             uint256 initialStalkRemoved,
 518 | *   |             uint256 grownStalkRemoved,
 519 | *   |             uint256 bdvRemoved,
 520 | *   |             GerminationSide side
 521 |     |         )
 522 | *   |     {
 523 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 524 | *   |         int96 stemTip;
 525 | *   |         (side, stemTip) = LibGerminate.getGerminationState(token, stem);
 526 | *   |         bdvRemoved = LibTokenSilo.removeDepositFromAccount(account, token, stem, amount);
 527 |     | 
 528 |     |         // the initial and grown stalk are seperated as there are instances
 529 |     |         // where the initial stalk issued for a deposit is germinating. Grown stalk never germinates,
 530 |     |         // and thus is not included in the germinating stalk.
 531 | *   |         initialStalkRemoved = bdvRemoved.mul(s.sys.silo.assetSettings[token].stalkIssuedPerBdv);
 532 |     | 
 533 | *   |         grownStalkRemoved = stalkReward(stem, stemTip, bdvRemoved.toUint128());
 534 |     |         /**
 535 |     |          *  {_removeDepositFromAccount} is used for both withdrawing and transferring deposits.
 536 |     |          *  In the case of a withdraw, only the {TransferSingle} Event needs to be emitted.
 537 |     |          *  In the case of a transfer, a different {TransferSingle}/{TransferBatch}
 538 |     |          *  Event is emitted in {TokenSilo._transferDeposit(s)},
 539 |     |          *  and thus, this event is ommited.
 540 |     |          */
 541 | *   |         if (transferType == LibTokenSilo.Transfer.emitTransferSingle) {
 542 |     |             // "removing" a deposit is equivalent to "burning" an ERC1155 token.
 543 | *   |             emit LibTokenSilo.TransferSingle(
 544 | *   |                 LibTractor._user(), // operator
 545 | *   |                 account, // from
 546 | *   |                 address(0), // to
 547 | *   |                 LibBytes.packAddressAndStem(token, stem), // depositid
 548 | *   |                 amount // token amount
 549 |     |             );
 550 |     |         }
 551 | *   |         emit RemoveDeposit(account, token, stem, amount, bdvRemoved);
 552 |     |     }
 553 |     | 
 554 |     |     /**
 555 |     |      * @dev Removes from multiple Deposits, emits the RemoveDeposits
 556 |     |      * event, and returns the Stalk/BDV that were removed.
 557 |     |      *
 558 |     |      * Used in:
 559 |     |      * - {TokenSilo:_withdrawDeposits}
 560 |     |      *
 561 |     |      * @notice with the addition of germination, AssetsRemoved
 562 |     |      * keeps track of the germinating data.
 563 |     |      */
 564 | *   |     function _removeDepositsFromAccount(
 565 |     |         address account,
 566 |     |         address token,
 567 |     |         int96[] calldata stems,
 568 |     |         uint256[] calldata amounts
 569 | *   |     ) internal returns (AssetsRemoved memory ar) {
 570 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 571 |     | 
 572 | *   |         uint256[] memory bdvsRemoved = new uint256[](stems.length);
 573 | *   |         uint256[] memory removedDepositIDs = new uint256[](stems.length);
 574 | *   |         LibGerminate.GermStem memory germStem = LibGerminate.getGerminatingStem(token);
 575 | *   |         for (uint256 i; i < stems.length; ++i) {
 576 | *   |             GerminationSide side = LibGerminate._getGerminationState(stems[i], germStem);
 577 | *   |             uint256 crateBdv = LibTokenSilo.removeDepositFromAccount(
 578 | *   |                 account,
 579 | *   |                 token,
 580 | *   |                 stems[i],
 581 | *   |                 amounts[i]
 582 |     |             );
 583 | *   |             bdvsRemoved[i] = crateBdv;
 584 | *   |             removedDepositIDs[i] = LibBytes.packAddressAndStem(token, stems[i]);
 585 | *   |             uint256 crateStalk = stalkReward(stems[i], germStem.stemTip, crateBdv.toUint128());
 586 |     | 
 587 |     |             // if the deposit is germinating, decrement germinating values,
 588 |     |             // otherwise increment deposited values.
 589 | *   |             if (side == GerminationSide.NOT_GERMINATING) {
 590 |     |                 ar.active.bdv = ar.active.bdv.add(crateBdv);
 591 |     |                 ar.active.stalk = ar.active.stalk.add(crateStalk);
 592 |     |                 ar.active.tokens = ar.active.tokens.add(amounts[i]);
 593 |     |             } else {
 594 | *   |                 if (side == GerminationSide.ODD) {
 595 | *   |                     ar.odd.bdv = ar.odd.bdv.add(crateBdv);
 596 | *   |                     ar.odd.tokens = ar.odd.tokens.add(amounts[i]);
 597 |     |                 } else {
 598 |     |                     ar.even.bdv = ar.even.bdv.add(crateBdv);
 599 |     |                     ar.even.tokens = ar.even.tokens.add(amounts[i]);
 600 |     |                 }
 601 |     |                 // grown stalk from germinating deposits do not germinate,
 602 |     |                 // and thus must be added to the grown stalk.
 603 | *   |                 ar.grownStalkFromGermDeposits = ar.grownStalkFromGermDeposits.add(crateStalk);
 604 |     |             }
 605 |     |         }
 606 |     | 
 607 |     |         // add initial stalk deposit to all stalk removed.
 608 | *   |         {
 609 | *   |             uint256 stalkIssuedPerBdv = s.sys.silo.assetSettings[token].stalkIssuedPerBdv;
 610 | *   |             if (ar.active.tokens > 0) {
 611 |     |                 ar.active.stalk = ar.active.stalk.add(ar.active.bdv.mul(stalkIssuedPerBdv));
 612 |     |             }
 613 |     | 
 614 | *   |             if (ar.odd.tokens > 0) {
 615 | *   |                 ar.odd.stalk = ar.odd.bdv.mul(stalkIssuedPerBdv);
 616 |     |             }
 617 |     | 
 618 | *   |             if (ar.even.tokens > 0) {
 619 |     |                 ar.even.stalk = ar.even.bdv.mul(stalkIssuedPerBdv);
 620 |     |             }
 621 |     |         }
 622 |     | 
 623 |     |         // "removing" deposits is equivalent to "burning" a batch of ERC1155 tokens.
 624 | *   |         emit LibTokenSilo.TransferBatch(
 625 | *   |             LibTractor._user(),
 626 | *   |             account,
 627 | *   |             address(0),
 628 | *   |             removedDepositIDs,
 629 | *   |             amounts
 630 |     |         );
 631 |     | 
 632 | *   |         emit RemoveDeposits(
 633 | *   |             account,
 634 | *   |             token,
 635 | *   |             stems,
 636 | *   |             amounts,
 637 | *   |             ar.active.tokens.add(ar.odd.tokens).add(ar.even.tokens),
 638 | *   |             bdvsRemoved
 639 |     |         );
 640 |     |     }
 641 |     | 
 642 |     |     //////////////////////// UTILITIES ////////////////////////
 643 |     | 
 644 |     |     /**
 645 |     |      * @notice Calculates the Stalk reward based on the start and end
 646 |     |      * stems, and the amount of BDV deposited. Stems represent the
 647 |     |      * amount of grown stalk per BDV, so the difference between the
 648 |     |      * start index and end index (stem) multiplied by the amount of
 649 |     |      * bdv deposited will give the amount of stalk earned.
 650 |     |      * formula: stalk = bdv * (ΔstalkPerBdv)
 651 |     |      *
 652 |     |      * @dev endStem must be larger than startStem.
 653 |     |      *
 654 |     |      */
 655 | *   |     function stalkReward(
 656 |     |         int96 startStem,
 657 |     |         int96 endStem,
 658 |     |         uint128 bdv
 659 | *   |     ) internal pure returns (uint256) {
 660 | *   |         return uint256(uint96(endStem.sub(startStem))).mul(bdv);
 661 |     |     }
 662 |     | 
 663 |     |     /**
 664 |     |      * @dev Internal function to compute `account` balance of Earned Beans.
 665 |     |      *
 666 |     |      * The number of Earned Beans is equal to the difference between:
 667 |     |      *  - the "expected" Stalk balance, determined from the account balance of
 668 |     |      *    Roots.
 669 |     |      *  - the "account" Stalk balance, stored in account storage.
 670 |     |      * divided by the number of Stalk per Bean.
 671 |     |      * The earned beans from the latest season
 672 |     |      */
 673 |     |     function _balanceOfEarnedBeans(
 674 |     |         uint256 accountStalk,
 675 |     |         uint256 accountRoots
 676 |     |     ) internal view returns (uint256 beans) {
 677 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 678 |     |         // There will be no Roots before the first Deposit is made.
 679 |     |         if (s.sys.silo.roots == 0) return 0;
 680 |     | 
 681 |     |         uint256 stalk = s.sys.silo.stalk.mul(accountRoots).div(s.sys.silo.roots);
 682 |     |         // Beanstalk rounds down when minting Roots. Thus, it is possible that
 683 |     |         // balanceOfRoots / totalRoots * totalStalk < s.accts[account].stalk.
 684 |     |         // As `account` Earned Balance balance should never be negative,
 685 |     |         // Beanstalk returns 0 instead.
 686 |     |         if (stalk <= accountStalk) return 0;
 687 |     | 
 688 |     |         // Calculate Earned Stalk and convert to Earned Beans.
 689 |     |         beans = (stalk - accountStalk).div(C.STALK_PER_BEAN);
 690 |     |         if (beans > s.sys.silo.earnedBeans) return s.sys.silo.earnedBeans;
 691 |     | 
 692 |     |         return beans;
 693 |     |     }
 694 |     | 
 695 |     |     /**
 696 |     |      * @notice Returns the amount of Germinating Stalk
 697 |     |      * for a given GerminationSide enum.
 698 |     |      * @dev When a Farmer attempts to withdraw Beans from a Deposit that has a Germinating Stem,
 699 |     |      * `checkForEarnedBeans` is called to determine how many of the Beans were Planted vs Deposited.
 700 |     |      * If a Farmer withdraws a Germinating Deposit with Earned Beans, only subtract the Germinating Beans
 701 |     |      * from the Germinating Balances
 702 |     |      * @return germinatingStalk stalk that is germinating for a given GerminationSide enum.
 703 |     |      * @return earnedBeanStalk the earned bean portion of stalk for a given GerminationSide enum.
 704 |     |      */
 705 |     |     function checkForEarnedBeans(
 706 |     |         address account,
 707 |     |         uint256 stalk,
 708 |     |         GerminationSide side
 709 |     |     ) internal view returns (uint256 germinatingStalk, uint256 earnedBeanStalk) {
 710 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 711 |     |         uint256 farmerGerminatingStalk = s.accts[account].germinatingStalk[side];
 712 |     |         if (stalk > farmerGerminatingStalk) {
 713 |     |             return (farmerGerminatingStalk, stalk.sub(farmerGerminatingStalk));
 714 |     |         } else {
 715 |     |             return (stalk, 0);
 716 |     |         }
 717 |     |     }
 718 |     | 
 719 |     |     //////////////////////// APPROVE ////////////////////////
 720 |     | 
 721 | *   |     function _spendDepositAllowance(
 722 |     |         address owner,
 723 |     |         address spender,
 724 |     |         address token,
 725 |     |         uint256 amount
 726 | *   |     ) external {
 727 | *   |         uint256 currentAllowance = depositAllowance(owner, spender, token);
 728 | *   |         if (currentAllowance != type(uint256).max) {
 729 | *   |             require(currentAllowance >= amount, "Silo: insufficient allowance");
 730 | *   |             _approveDeposit(owner, spender, token, currentAllowance - amount);
 731 |     |         }
 732 |     |     }
 733 |     | 
 734 | *   |     function _approveDeposit(
 735 |     |         address account,
 736 |     |         address spender,
 737 |     |         address token,
 738 |     |         uint256 amount
 739 | *   |     ) internal {
 740 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 741 | *   |         s.accts[account].depositAllowances[spender][token] = amount;
 742 | *   |         emit DepositApproval(account, spender, token, amount);
 743 |     |     }
 744 |     | 
 745 | *   |     function depositAllowance(
 746 |     |         address owner,
 747 |     |         address spender,
 748 |     |         address token
 749 | *   |     ) public view returns (uint256) {
 750 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 751 | *   |         return s.accts[owner].depositAllowances[spender][token];
 752 |     |     }
 753 |     | 
 754 |     |     /**
 755 |     |      * @notice Updates the sorted list of deposit IDs for a given account and token
 756 |     |      * @param account The address of the account to update
 757 |     |      * @param token The token address to update deposit IDs for
 758 |     |      * @param sortedDepositIds The sorted list of deposit IDs to store
 759 |     |      */
 760 |     |     function _setSortedDepositIds(
 761 |     |         address account,
 762 |     |         address token,
 763 |     |         uint256[] calldata sortedDepositIds
 764 |     |     ) internal {
 765 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 766 |     |         s.accts[account].depositIdList[token].depositIds = sortedDepositIds;
 767 |     |     }
 768 |     | }
 769 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibTokenSilo.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   7 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   8 |     | import {LibAppStorage} from "../LibAppStorage.sol";
   9 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  10 |     | import {Deposited, GerminationSide} from "contracts/beanstalk/storage/System.sol";
  11 |     | import {DepositListData} from "contracts/beanstalk/storage/Account.sol";
  12 |     | import {C} from "../../C.sol";
  13 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  14 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
  15 |     | import {LibRedundantMathSigned128} from "contracts/libraries/Math/LibRedundantMathSigned128.sol";
  16 |     | import {LibRedundantMathSigned96} from "contracts/libraries/Math/LibRedundantMathSigned96.sol";
  17 |     | import {LibBytes} from "contracts/libraries/LibBytes.sol";
  18 |     | import {LibGerminate} from "contracts/libraries/Silo/LibGerminate.sol";
  19 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  20 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  21 |     | 
  22 |     | /**
  23 |     |  * @title LibTokenSilo
  24 |     |  * @notice Contains functions for depositing, withdrawing and claiming
  25 |     |  * whitelisted Silo tokens.
  26 |     |  *
  27 |     |  * For functionality related to Stalk, and Roots, see {LibSilo}.
  28 |     |  */
  29 | *   | library LibTokenSilo {
  30 |     |     using LibRedundantMath256 for uint256;
  31 |     |     using LibRedundantMath128 for uint128;
  32 |     |     using LibRedundantMath32 for uint32;
  33 |     |     using LibRedundantMathSigned128 for int128;
  34 |     |     using SafeCast for int128;
  35 |     |     using SafeCast for uint256;
  36 |     |     using LibRedundantMathSigned96 for int96;
  37 |     | 
  38 |     |     //////////////////////// ENUM ////////////////////////
  39 |     |     /**
  40 |     |      * @dev when a user deposits or withdraws a deposit, the
  41 |     |      * {TrasferSingle} event is emitted. However, in the case
  42 |     |      * of a transfer, this emission is ommited. This enum is
  43 |     |      * used to determine if the event should be emitted.
  44 |     |      */
  45 |     |     enum Transfer {
  46 |     |         emitTransferSingle,
  47 |     |         noEmitTransferSingle
  48 |     |     }
  49 |     | 
  50 |     |     //////////////////////// EVENTS ////////////////////////
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Emitted when `account` adds a single Deposit to the Silo.
  54 |     |      *
  55 |     |      * There is no "AddDeposits" event because there is currently no operation in which Beanstalk
  56 |     |      * creates multiple Deposits in different stems:
  57 |     |      *
  58 |     |      *  - `deposit()` always places the user's deposit in the current season.
  59 |     |      *  - `convert()` collapses multiple deposits into a single Season to prevent loss of Stalk.
  60 |     |      *
  61 |     |      * @param account The account that added a Deposit.
  62 |     |      * @param token Address of the whitelisted ERC20 token that was deposited.
  63 |     |      * @param stem The stem index that this `amount` was added to.
  64 |     |      * @param amount Amount of `token` added to `stem`.
  65 |     |      * @param bdv The BDV associated with `amount` of `token` at the time of Deposit.
  66 |     |      */
  67 |     |     event AddDeposit(
  68 |     |         address indexed account,
  69 |     |         address indexed token,
  70 |     |         int96 stem,
  71 |     |         uint256 amount,
  72 |     |         uint256 bdv
  73 |     |     );
  74 |     | 
  75 |     |     // added as the ERC1155 deposit upgrade
  76 |     |     event TransferSingle(
  77 |     |         address indexed operator,
  78 |     |         address indexed sender,
  79 |     |         address indexed recipient,
  80 |     |         uint256 depositId,
  81 |     |         uint256 amount
  82 |     |     );
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Emitted when multiple deposits are withdrawn or transferred.
  86 |     |      *
  87 |     |      * @dev This event is emitted in `convert()`
  88 |     |      *
  89 |     |      * @param operator the address that performed the operation.
  90 |     |      * @param from the address the Deposit is being transferred from.
  91 |     |      * @param to the address the Deposit is being transferred to.
  92 |     |      * @param ids the depositIDs of the Deposit.
  93 |     |      * @param values the amounts of the Deposit.
  94 |     |      */
  95 |     |     event TransferBatch(
  96 |     |         address indexed operator,
  97 |     |         address indexed from,
  98 |     |         address indexed to,
  99 |     |         uint256[] ids,
 100 |     |         uint256[] values
 101 |     |     );
 102 |     | 
 103 |     |     //////////////////////// ACCOUNTING: TOTALS GERMINATING ////////////////////////
 104 |     | 
 105 |     |     /**
 106 |     |      * @notice Increment the total amount and bdv of `token` germinating in the Silo.
 107 |     |      * @dev when an asset is `deposited` in the silo, it is not immediately eliable for
 108 |     |      * bean mints. It must `germinate` (stay deposited the silo) for a certain
 109 |     |      * amount of seasons (the remainer of the current season + 1). This function
 110 |     |      * increments the total amount and bdv germinating in the silo. The {sunrise}
 111 |     |      * function ends the germination process for even or odd germinating deposits.
 112 |     |      *
 113 |     |      * This protects beanstalk from flashloan attacks, and makes `totalDeposited` and
 114 |     |      * `totalDepositedBdv` significantly more MEV resistant.
 115 |     |      */
 116 | *   |     function incrementTotalGerminating(
 117 |     |         address token,
 118 |     |         uint256 amount,
 119 |     |         uint256 bdv,
 120 |     |         GerminationSide side
 121 | *   |     ) internal {
 122 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 123 |     | 
 124 |     |         // verify side is valid
 125 | *   |         if (side != GerminationSide.ODD && side != GerminationSide.EVEN) {
 126 |     |             revert("invalid germinationSide"); // should not ever get here
 127 |     |         }
 128 |     | 
 129 |     |         // increment germinating amount and bdv.
 130 | *   |         s.sys.silo.germinating[side][token].amount += amount.toUint128();
 131 | *   |         s.sys.silo.germinating[side][token].bdv += bdv.toUint128();
 132 |     | 
 133 |     |         // emit event.
 134 | *   |         emit LibGerminate.TotalGerminatingBalanceChanged(
 135 | *   |             LibGerminate.getSeasonGerminationSide() == side
 136 | *   |                 ? s.sys.season.current
 137 |     |                 : s.sys.season.current - 1,
 138 | *   |             token,
 139 | *   |             int256(amount),
 140 | *   |             int256(bdv)
 141 |     |         );
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Decrement the total amount and bdv of `token` germinating in the Silo.
 146 |     |      * @dev `decrementTotalGerminating` should be used when removing deposits
 147 |     |      * that are < 2 seasons old.
 148 |     |      */
 149 | *   |     function decrementTotalGerminating(
 150 |     |         address token,
 151 |     |         uint256 amount,
 152 |     |         uint256 bdv,
 153 |     |         GerminationSide side
 154 | *   |     ) internal {
 155 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 156 |     | 
 157 |     |         // verify side is valid
 158 | *   |         if (side != GerminationSide.ODD && side != GerminationSide.EVEN) {
 159 |     |             revert("invalid germinationSide"); // should not ever get here
 160 |     |         }
 161 |     | 
 162 |     |         // decrement germinating amount and bdv.
 163 | *   |         s.sys.silo.germinating[side][token].amount -= amount.toUint128();
 164 | *   |         s.sys.silo.germinating[side][token].bdv -= bdv.toUint128();
 165 |     | 
 166 | *   |         emit LibGerminate.TotalGerminatingBalanceChanged(
 167 | *   |             LibGerminate.getSeasonGerminationSide() == side
 168 | *   |                 ? s.sys.season.current
 169 |     |                 : s.sys.season.current - 1,
 170 | *   |             token,
 171 | *   |             -int256(amount),
 172 | *   |             -int256(bdv)
 173 |     |         );
 174 |     |     }
 175 |     | 
 176 |     |     //////////////////////// ACCOUNTING: TOTALS ////////////////////////
 177 |     | 
 178 |     |     /**
 179 |     |      * @dev Increment the total amount and bdv of `token` deposited in the Silo.
 180 |     |      * @dev `IncrementTotalDeposited` should be used when removing deposits that are
 181 |     |      * >= 2 seasons old (ex. when a user converts).
 182 |     |      */
 183 |     |     function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {
 184 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 185 |     |         s.sys.silo.balances[token].deposited = s.sys.silo.balances[token].deposited.add(
 186 |     |             amount.toUint128()
 187 |     |         );
 188 |     |         s.sys.silo.balances[token].depositedBdv = s.sys.silo.balances[token].depositedBdv.add(
 189 |     |             bdv.toUint128()
 190 |     |         );
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice Decrement the total amount and bdv of `token` deposited in the Silo.
 195 |     |      * @dev `decrementTotalDeposited` should be used when removing deposits that are
 196 |     |      * >= 2 seasons old.
 197 |     |      */
 198 |     |     function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {
 199 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 200 |     |         s.sys.silo.balances[token].deposited = s.sys.silo.balances[token].deposited.sub(
 201 |     |             amount.toUint128()
 202 |     |         );
 203 |     |         s.sys.silo.balances[token].depositedBdv = s.sys.silo.balances[token].depositedBdv.sub(
 204 |     |             bdv.toUint128()
 205 |     |         );
 206 |     |     }
 207 |     | 
 208 |     |     //////////////////////// ADD DEPOSIT ////////////////////////
 209 |     | 
 210 |     |     /**
 211 |     |      * @return stalk The amount of Stalk received for this Deposit.
 212 |     |      *
 213 |     |      * @dev Calculate the current BDV for `amount` of `token`, then perform
 214 |     |      * Deposit accounting.
 215 |     |      */
 216 | *   |     function deposit(
 217 |     |         address account,
 218 |     |         address token,
 219 |     |         int96 stem,
 220 |     |         uint256 amount
 221 | *   |     ) external returns (uint256 stalk, GerminationSide) {
 222 | *   |         uint256 bdv = beanDenominatedValue(token, amount);
 223 | *   |         return depositWithBDV(account, token, stem, amount, bdv);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @dev Once the BDV received for Depositing `amount` of `token` is known,
 228 |     |      * add a Deposit for `account` and update the total amount Deposited.
 229 |     |      *
 230 |     |      * `s.sys.assetSettings[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.
 231 |     |      */
 232 | *   |     function depositWithBDV(
 233 |     |         address account,
 234 |     |         address token,
 235 |     |         int96 stem,
 236 |     |         uint256 amount,
 237 |     |         uint256 bdv
 238 | *   |     ) internal returns (uint256 stalk, GerminationSide side) {
 239 | *   |         require(bdv > 0, "Silo: No Beans under Token.");
 240 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 241 |     | 
 242 |     |         // determine whether the deposit is odd or even germinating
 243 | *   |         side = LibGerminate.getSeasonGerminationSide();
 244 |     | 
 245 |     |         // all new deposits will increment total germination.
 246 | *   |         incrementTotalGerminating(token, amount, bdv, side);
 247 |     | 
 248 | *   |         addDepositToAccount(account, token, stem, amount, bdv, Transfer.emitTransferSingle);
 249 |     | 
 250 | *   |         stalk = bdv.mul(s.sys.silo.assetSettings[token].stalkIssuedPerBdv);
 251 |     |     }
 252 |     | 
 253 |     |     /**
 254 |     |      * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a
 255 |     |      * precalculated `bdv`.
 256 |     |      *
 257 |     |      * If a Deposit doesn't yet exist, one is created. Otherwise, the existing
 258 |     |      * Deposit is updated.
 259 |     |      *
 260 |     |      * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,
 261 |     |      * since both values can be packed into one slot.
 262 |     |      *
 263 |     |      * Unlike {removeDepositFromAccount}, this function DOES EMIT an
 264 |     |      * {AddDeposit} event. See {removeDepositFromAccount} for more details.
 265 |     |      */
 266 | *   |     function addDepositToAccount(
 267 |     |         address account,
 268 |     |         address token,
 269 |     |         int96 stem,
 270 |     |         uint256 amount,
 271 |     |         uint256 bdv,
 272 |     |         Transfer transferType
 273 | *   |     ) public {
 274 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 275 | *   |         uint256 depositId = LibBytes.packAddressAndStem(token, stem);
 276 |     | 
 277 |     |         // add a depositId to an account's depositList, if there is not an existing deposit.
 278 | *   |         if (s.accts[account].deposits[depositId].amount == 0 && amount > 0) {
 279 | *   |             s.accts[account].depositIdList[token].depositIds.push(depositId);
 280 | *   |             s.accts[account].depositIdList[token].idIndex[depositId] =
 281 | *   |                 s.accts[account].depositIdList[token].depositIds.length -
 282 | *   |                 1;
 283 |     |         }
 284 |     |         // add amount and bdv to the deposits.
 285 | *   |         s.accts[account].deposits[depositId].amount = s
 286 | *   |             .accts[account]
 287 | *   |             .deposits[depositId]
 288 |     |             .amount
 289 | *   |             .add(amount.toUint128());
 290 | *   |         s.accts[account].deposits[depositId].bdv = s.accts[account].deposits[depositId].bdv.add(
 291 | *   |             bdv.toUint128()
 292 |     |         );
 293 |     | 
 294 |     |         // Will not overflow b/c crateBDV <= type(uint128).max
 295 | *   |         s.accts[account].mowStatuses[token].bdv = s.accts[account].mowStatuses[token].bdv.add(
 296 | *   |             bdv.toUint128()
 297 |     |         );
 298 |     | 
 299 |     |         /**
 300 |     |          *  {addDepositToAccount} is used for both depositing and transferring deposits.
 301 |     |          *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.
 302 |     |          *  In the case of a transfer, a different {TransferSingle}/{TransferBatch}
 303 |     |          *  Event is emitted in {TokenSilo._transferDeposit(s)},
 304 |     |          *  and thus, this event is ommited.
 305 |     |          */
 306 | *   |         if (transferType == Transfer.emitTransferSingle) {
 307 | *   |             emit TransferSingle(
 308 | *   |                 LibTractor._user(), // operator
 309 | *   |                 address(0), // from
 310 | *   |                 account, // to
 311 | *   |                 depositId, // depositID
 312 | *   |                 amount // token amount
 313 |     |             );
 314 |     |         }
 315 | *   |         emit AddDeposit(account, token, stem, amount, bdv);
 316 |     |     }
 317 |     | 
 318 |     |     //////////////////////// REMOVE DEPOSIT ////////////////////////
 319 |     | 
 320 |     |     /**
 321 |     |      * @dev Remove `amount` of `token` from a user's Deposit in `stem`.
 322 |     |      *
 323 |     |      * A "Crate" refers to the existing Deposit in storage at:
 324 |     |      *  `s.accts[account].deposits[token][stem]`
 325 |     |      *
 326 |     |      * Partially removing a Deposit should scale its BDV proportionally. For ex.
 327 |     |      * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.
 328 |     |      *
 329 |     |      * During an update, `amount` & `bdv` are cast uint256 -> uint128 to
 330 |     |      * optimize storage cost, since both values can be packed into one slot.
 331 |     |      *
 332 |     |      * This function DOES **NOT** EMIT a {RemoveDeposit} event. This
 333 |     |      * asymmetry occurs because {removeDepositFromAccount} is called in a loop
 334 |     |      * in places where multiple deposits are removed simultaneously, including
 335 |     |      * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.
 336 |     |      */
 337 | *   |     function removeDepositFromAccount(
 338 |     |         address account,
 339 |     |         address token,
 340 |     |         int96 stem,
 341 |     |         uint256 amount
 342 | *   |     ) internal returns (uint256 crateBDV) {
 343 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 344 | *   |         uint256 depositId = LibBytes.packAddressAndStem(token, stem);
 345 |     | 
 346 | *   |         uint256 crateAmount = s.accts[account].deposits[depositId].amount;
 347 | *   |         crateBDV = s.accts[account].deposits[depositId].bdv;
 348 | *   |         require(amount <= crateAmount, "Silo: Crate balance too low.");
 349 |     | 
 350 |     |         // Partial remove
 351 | *   |         if (amount < crateAmount) {
 352 |     |             // round up removal of BDV. (x - 1)/y + 1
 353 |     |             // https://stackoverflow.com/questions/17944
 354 | *   |             uint256 removedBDV = amount.mul(crateBDV).sub(1).div(crateAmount).add(1);
 355 | *   |             uint256 updatedBDV = crateBDV.sub(removedBDV);
 356 | *   |             uint256 updatedAmount = crateAmount.sub(amount);
 357 |     | 
 358 |     |             // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV,
 359 |     |             // which are both <= type(uint128).max
 360 | *   |             s.accts[account].deposits[depositId].amount = uint128(updatedAmount);
 361 | *   |             s.accts[account].deposits[depositId].bdv = uint128(updatedBDV);
 362 |     | 
 363 | *   |             s.accts[account].mowStatuses[token].bdv = s.accts[account].mowStatuses[token].bdv.sub(
 364 | *   |                 uint128(removedBDV)
 365 |     |             );
 366 |     | 
 367 | *   |             return removedBDV;
 368 |     |         }
 369 |     |         // Full remove
 370 | *   |         if (crateAmount > 0) {
 371 | *   |             delete s.accts[account].deposits[depositId];
 372 | *   |             removeDepositIDfromAccountList(account, token, depositId);
 373 |     |         }
 374 |     | 
 375 |     |         // Will not overflow b/c crateBDV <= type(uint128).max
 376 | *   |         s.accts[account].mowStatuses[token].bdv = s.accts[account].mowStatuses[token].bdv.sub(
 377 | *   |             uint128(crateBDV)
 378 |     |         );
 379 |     |     }
 380 |     | 
 381 |     |     //////////////////////// GETTERS ////////////////////////
 382 |     | 
 383 |     |     /**
 384 |     |      * @dev Calculate the BDV ("Bean Denominated Value") for `amount` of `token`.
 385 |     |      *
 386 |     |      * Makes a call to a BDV function defined in the AssetSettings for this
 387 |     |      * `token`. See {AppStorage.sol:Storage-AssetSettings} for more information.
 388 |     |      */
 389 | *   |     function beanDenominatedValue(
 390 |     |         address token,
 391 |     |         uint256 amount
 392 | *   |     ) internal view returns (uint256 bdv) {
 393 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 394 | *   |         require(
 395 | *   |             s.sys.silo.assetSettings[token].selector != bytes4(0),
 396 |     |             "Silo: Token not whitelisted"
 397 |     |         );
 398 |     | 
 399 | *   |         (bool success, bytes memory data) = address(this).staticcall(
 400 | *   |             encodeBdvFunction(
 401 | *   |                 token,
 402 | *   |                 s.sys.silo.assetSettings[token].encodeType,
 403 | *   |                 s.sys.silo.assetSettings[token].selector,
 404 | *   |                 amount
 405 |     |             )
 406 |     |         );
 407 |     | 
 408 | *   |         if (!success) {
 409 |     |             if (data.length == 0) revert();
 410 |     |             assembly {
 411 |     |                 revert(add(32, data), mload(data))
 412 |     |             }
 413 |     |         }
 414 |     | 
 415 | *   |         assembly {
 416 | *   |             bdv := mload(add(data, add(0x20, 0)))
 417 |     |         }
 418 |     |     }
 419 |     | 
 420 | *   |     function encodeBdvFunction(
 421 |     |         address token,
 422 |     |         bytes1 encodeType,
 423 |     |         bytes4 selector,
 424 |     |         uint256 amount
 425 | *   |     ) internal pure returns (bytes memory callData) {
 426 | *   |         if (encodeType == 0x00) {
 427 | *   |             callData = abi.encodeWithSelector(selector, amount);
 428 |     |         } else if (encodeType == 0x01) {
 429 |     |             callData = abi.encodeWithSelector(selector, token, amount);
 430 |     |         } else {
 431 |     |             revert("Silo: Invalid encodeType");
 432 |     |         }
 433 |     |     }
 434 |     | 
 435 |     |     /**
 436 |     |      * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.
 437 |     |      *
 438 |     |      * Silo Deposits are stored within each {Account} as a mapping of:
 439 |     |      *  `uint256 DepositID => { uint128 amount, uint128 bdv }`
 440 |     |      *  The DepositID is the concatination of the token address and the stem.
 441 |     |      */
 442 |     |     function getDeposit(
 443 |     |         address account,
 444 |     |         address token,
 445 |     |         int96 stem
 446 |     |     ) internal view returns (uint256 amount, uint256 bdv) {
 447 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 448 |     |         uint256 depositId = LibBytes.packAddressAndStem(token, stem);
 449 |     |         amount = s.accts[account].deposits[depositId].amount;
 450 |     |         bdv = s.accts[account].deposits[depositId].bdv;
 451 |     |     }
 452 |     | 
 453 |     |     /**
 454 |     |      * @dev Get the number of Stalk per BDV per Season for a whitelisted token.
 455 |     |      * 6 decimal precision: 1e10 units = 1 stalk per season
 456 |     |      */
 457 |     |     function stalkEarnedPerSeason(address token) internal view returns (uint256) {
 458 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 459 |     |         return uint256(s.sys.silo.assetSettings[token].stalkEarnedPerSeason);
 460 |     |     }
 461 |     | 
 462 |     |     /**
 463 |     |      * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.
 464 |     |      */
 465 |     |     function stalkIssuedPerBdv(address token) internal view returns (uint256) {
 466 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 467 |     |         return uint256(s.sys.silo.assetSettings[token].stalkIssuedPerBdv);
 468 |     |     }
 469 |     | 
 470 |     |     /**
 471 |     |      * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.
 472 |     |      */
 473 | *   |     function stemTipForToken(address token) internal view returns (int96 _stemTip) {
 474 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 475 |     |         // Will not over/underflow because all casted variables are types smaller that int96.
 476 | *   |         _stemTip =
 477 | *   |             s.sys.silo.assetSettings[token].milestoneStem +
 478 | *   |             toInt96(s.sys.silo.assetSettings[token].stalkEarnedPerSeason).mul(
 479 | *   |                 toInt96(s.sys.season.current).sub(
 480 | *   |                     toInt96(s.sys.silo.assetSettings[token].milestoneSeason)
 481 |     |                 )
 482 |     |             );
 483 |     |     }
 484 |     | 
 485 |     |     /**
 486 |     |      * @dev returns the amount of grown stalk a deposit has earned.
 487 |     |      */
 488 |     |     function grownStalkForDeposit(
 489 |     |         address account,
 490 |     |         address token,
 491 |     |         int96 stem
 492 |     |     ) internal view returns (uint256 grownStalk) {
 493 |     |         // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits
 494 |     |         int96 _stemTip = stemTipForToken(token);
 495 |     |         require(stem <= _stemTip, "Silo: Invalid Deposit");
 496 |     |         // The check in the above line guarantees that subtraction result is positive
 497 |     |         // and thus the cast to `uint256` is safe.
 498 |     |         uint256 deltaStemTip = uint256(int256(_stemTip.sub(stem)));
 499 |     |         // no stalk has grown if the stem is equal to the stemTip.
 500 |     |         if (deltaStemTip == 0) return 0;
 501 |     |         (, uint256 bdv) = getDeposit(account, token, stem);
 502 |     | 
 503 |     |         grownStalk = deltaStemTip.mul(bdv);
 504 |     |     }
 505 |     | 
 506 |     |     /**
 507 |     |      * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.
 508 |     |      */
 509 |     |     function calculateStalkFromStemAndBdv(
 510 |     |         address token,
 511 |     |         int96 grownStalkIndexOfDeposit,
 512 |     |         uint256 bdv
 513 |     |     ) internal view returns (uint256 grownStalk) {
 514 |     |         // current latest grown stalk index
 515 |     |         int96 _stemTipForToken = stemTipForToken(address(token));
 516 |     |         // note: _stemTipForToken should always be >= grownStalkIndexOfDeposit
 517 |     |         return uint256(int256(_stemTipForToken.sub(grownStalkIndexOfDeposit))).mul(bdv);
 518 |     |     }
 519 |     | 
 520 |     |     /**
 521 |     |      * @notice returns the grown stalk and germination state of a deposit,
 522 |     |      * based on the amount of grown stalk it has earned.
 523 |     |      */
 524 |     |     function calculateStemForTokenFromGrownStalk(
 525 |     |         address token,
 526 |     |         uint256 grownStalk,
 527 |     |         uint256 bdv
 528 |     |     ) internal view returns (int96 stem, GerminationSide side) {
 529 |     |         LibGerminate.GermStem memory germStem = LibGerminate.getGerminatingStem(token);
 530 |     |         stem = germStem.stemTip.sub(SafeCast.toInt96(SafeCast.toInt256(grownStalk.div(bdv))));
 531 |     |         side = LibGerminate._getGerminationState(stem, germStem);
 532 |     |     }
 533 |     | 
 534 |     |     /**
 535 |     |      * @notice returns the grown stalk needed to make a deposit non-germinating, given the bdv and token.
 536 |     |      */
 537 |     |     function calculateGrownStalkAtNonGerminatingStem(
 538 |     |         address token,
 539 |     |         uint256 bdv
 540 |     |     ) internal view returns (uint256 newGrownStalk) {
 541 |     |         int96 nonGerminatingStem = LibGerminate.getHighestNonGerminatingStem(token);
 542 |     |         return calculateStalkFromStemAndBdv(token, nonGerminatingStem, bdv);
 543 |     |     }
 544 |     | 
 545 | *   |     function toInt96(uint256 value) internal pure returns (int96) {
 546 | *   |         return SafeCast.toInt96(SafeCast.toInt256(value));
 547 |     |     }
 548 |     | 
 549 |     |     /**
 550 |     |      * @notice removes an depositID from an account's depositID list.
 551 |     |      */
 552 | *   |     function removeDepositIDfromAccountList(
 553 |     |         address account,
 554 |     |         address token,
 555 |     |         uint256 depositId
 556 | *   |     ) internal {
 557 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 558 | *   |         DepositListData storage list = s.accts[account].depositIdList[token];
 559 | *   |         uint256 i = findDepositIdForAccount(account, token, depositId);
 560 | *   |         list.depositIds[i] = list.depositIds[list.depositIds.length - 1];
 561 | *   |         list.idIndex[list.depositIds[i]] = i;
 562 | *   |         list.idIndex[depositId] = type(uint256).max;
 563 | *   |         list.depositIds.pop();
 564 |     |     }
 565 |     | 
 566 |     |     /**
 567 |     |      * @notice given an depositId, find the index of the depositId in the account's deposit list.
 568 |     |      */
 569 | *   |     function findDepositIdForAccount(
 570 |     |         address account,
 571 |     |         address token,
 572 |     |         uint256 depositId
 573 | *   |     ) internal view returns (uint256 i) {
 574 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 575 | *   |         i = s.accts[account].depositIdList[token].idIndex[depositId];
 576 |     |     }
 577 |     | }
 578 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibTractorHelpers.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {IBeanstalk} from "contracts/interfaces/IBeanstalk.sol";
   5 |     | import {IOperatorWhitelist} from "contracts/ecosystem/OperatorWhitelist.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title LibTractorHelpers
   9 |     |  * @author FordPinto
  10 |     |  * @notice Library with helper functions for Silo operations
  11 |     |  */
  12 | *   | library LibTractorHelpers {
  13 |     |     struct WithdrawalPlan {
  14 |     |         address[] sourceTokens;
  15 |     |         int96[][] stems;
  16 |     |         uint256[][] amounts;
  17 |     |         uint256[] availableBeans;
  18 |     |         uint256 totalAvailableBeans;
  19 |     |     }
  20 |     | 
  21 |     |     // Struct to hold variables for the combineWithdrawalPlans function
  22 |     |     struct CombineWithdrawalPlansStruct {
  23 |     |         address[] tempSourceTokens;
  24 |     |         int96[][] tempStems;
  25 |     |         uint256[][] tempAmounts;
  26 |     |         uint256[] tempAvailableBeans;
  27 |     |         uint256 totalSourceTokens;
  28 |     |         address token;
  29 |     |         int96[] stems;
  30 |     |         uint256[] amounts;
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @notice Combines multiple withdrawal plans into a single plan
  35 |     |      * @dev This function aggregates the amounts used from each deposit across all plans
  36 |     |      * @param plans Array of withdrawal plans to combine
  37 |     |      * @return combinedPlan A single withdrawal plan that represents the total usage across all input plans
  38 |     |      */
  39 |     |     function combineWithdrawalPlans(
  40 |     |         WithdrawalPlan[] memory plans,
  41 |     |         IBeanstalk beanstalk
  42 |     |     ) external view returns (WithdrawalPlan memory combinedPlan) {
  43 |     |         if (plans.length == 0) {
  44 |     |             return combinedPlan;
  45 |     |         }
  46 |     | 
  47 |     |         IBeanstalk.WhitelistStatus[] memory whitelistStatuses = beanstalk.getWhitelistStatuses();
  48 |     | 
  49 |     |         // Initialize the struct with shared variables
  50 |     |         CombineWithdrawalPlansStruct memory vars;
  51 |     | 
  52 |     |         // Initialize arrays for the combined plan with maximum possible size
  53 |     |         vars.tempSourceTokens = new address[](whitelistStatuses.length);
  54 |     |         vars.tempStems = new int96[][](whitelistStatuses.length);
  55 |     |         vars.tempAmounts = new uint256[][](whitelistStatuses.length);
  56 |     |         vars.tempAvailableBeans = new uint256[](whitelistStatuses.length);
  57 |     |         vars.totalSourceTokens = 0;
  58 |     | 
  59 |     |         // Initialize total available beans
  60 |     |         combinedPlan.totalAvailableBeans = 0;
  61 |     | 
  62 |     |         // Process each whitelisted token
  63 |     |         for (uint256 i = 0; i < whitelistStatuses.length; i++) {
  64 |     |             vars.token = whitelistStatuses[i].token;
  65 |     | 
  66 |     |             // Calculate maximum possible stems for this token
  67 |     |             uint256 maxPossibleStems = 0;
  68 |     |             for (uint256 j = 0; j < plans.length; j++) {
  69 |     |                 for (uint256 k = 0; k < plans[j].sourceTokens.length; k++) {
  70 |     |                     if (plans[j].sourceTokens[k] == vars.token) {
  71 |     |                         maxPossibleStems += plans[j].stems[k].length;
  72 |     |                     }
  73 |     |                 }
  74 |     |             }
  75 |     | 
  76 |     |             // Skip tokens with no stems
  77 |     |             if (maxPossibleStems == 0) {
  78 |     |                 continue;
  79 |     |             }
  80 |     | 
  81 |     |             // Create arrays with maximum possible size
  82 |     |             vars.stems = new int96[](maxPossibleStems);
  83 |     |             vars.amounts = new uint256[](maxPossibleStems);
  84 |     |             uint256 seenStemsCount = 0;
  85 |     | 
  86 |     |             // Initialize availableBeans for this token
  87 |     |             vars.tempAvailableBeans[vars.totalSourceTokens] = 0;
  88 |     | 
  89 |     |             // Sum up amounts for each stem across all plans and calculate availableBeans
  90 |     |             for (uint256 j = 0; j < plans.length; j++) {
  91 |     |                 for (uint256 k = 0; k < plans[j].sourceTokens.length; k++) {
  92 |     |                     if (plans[j].sourceTokens[k] == vars.token) {
  93 |     |                         // Add to availableBeans for this token
  94 |     |                         vars.tempAvailableBeans[vars.totalSourceTokens] += plans[j].availableBeans[
  95 |     |                             k
  96 |     |                         ];
  97 |     | 
  98 |     |                         // Process stems
  99 |     |                         for (uint256 l = 0; l < plans[j].stems[k].length; l++) {
 100 |     |                             int96 stem = plans[j].stems[k][l];
 101 |     |                             uint256 amount = plans[j].amounts[k][l];
 102 |     | 
 103 |     |                             // Find if we've seen this stem before
 104 |     |                             bool found = false;
 105 |     |                             for (uint256 m = 0; m < seenStemsCount; m++) {
 106 |     |                                 if (vars.stems[m] == stem) {
 107 |     |                                     vars.amounts[m] += amount;
 108 |     |                                     found = true;
 109 |     |                                     break;
 110 |     |                                 }
 111 |     |                             }
 112 |     | 
 113 |     |                             if (!found) {
 114 |     |                                 vars.stems[seenStemsCount] = stem;
 115 |     |                                 vars.amounts[seenStemsCount] = amount;
 116 |     |                                 seenStemsCount++;
 117 |     |                             }
 118 |     |                         }
 119 |     |                     }
 120 |     |                 }
 121 |     |             }
 122 |     | 
 123 |     |             // Skip tokens with no stems after processing
 124 |     |             if (seenStemsCount == 0) {
 125 |     |                 continue;
 126 |     |             }
 127 |     | 
 128 |     |             // Sort stems in descending order
 129 |     |             for (uint256 j = 0; j < seenStemsCount - 1; j++) {
 130 |     |                 for (uint256 k = 0; k < seenStemsCount - j - 1; k++) {
 131 |     |                     if (vars.stems[k] < vars.stems[k + 1]) {
 132 |     |                         (vars.stems[k], vars.stems[k + 1]) = (vars.stems[k + 1], vars.stems[k]);
 133 |     |                         (vars.amounts[k], vars.amounts[k + 1]) = (
 134 |     |                             vars.amounts[k + 1],
 135 |     |                             vars.amounts[k]
 136 |     |                         );
 137 |     |                     }
 138 |     |                 }
 139 |     |             }
 140 |     | 
 141 |     |             // Update array lengths
 142 |     |             // Create local variables for assembly block
 143 |     |             int96[] memory stemsArray = vars.stems;
 144 |     |             uint256[] memory amountsArray = vars.amounts;
 145 |     | 
 146 |     |             assembly {
 147 |     |                 mstore(stemsArray, seenStemsCount)
 148 |     |                 mstore(amountsArray, seenStemsCount)
 149 |     |             }
 150 |     | 
 151 |     |             // Update the struct with the modified arrays
 152 |     |             vars.stems = stemsArray;
 153 |     |             vars.amounts = amountsArray;
 154 |     | 
 155 |     |             // Store token and its data
 156 |     |             vars.tempSourceTokens[vars.totalSourceTokens] = vars.token;
 157 |     |             vars.tempStems[vars.totalSourceTokens] = vars.stems;
 158 |     |             vars.tempAmounts[vars.totalSourceTokens] = vars.amounts;
 159 |     | 
 160 |     |             // Add to total available beans
 161 |     |             combinedPlan.totalAvailableBeans += vars.tempAvailableBeans[vars.totalSourceTokens];
 162 |     | 
 163 |     |             vars.totalSourceTokens++;
 164 |     |         }
 165 |     | 
 166 |     |         // Create the final arrays with the exact size needed
 167 |     |         combinedPlan.sourceTokens = new address[](vars.totalSourceTokens);
 168 |     |         combinedPlan.stems = new int96[][](vars.totalSourceTokens);
 169 |     |         combinedPlan.amounts = new uint256[][](vars.totalSourceTokens);
 170 |     |         combinedPlan.availableBeans = new uint256[](vars.totalSourceTokens);
 171 |     | 
 172 |     |         // Copy data to the final arrays
 173 |     |         for (uint256 i = 0; i < vars.totalSourceTokens; i++) {
 174 |     |             combinedPlan.sourceTokens[i] = vars.tempSourceTokens[i];
 175 |     |             combinedPlan.stems[i] = vars.tempStems[i];
 176 |     |             combinedPlan.amounts[i] = vars.tempAmounts[i];
 177 |     |             combinedPlan.availableBeans[i] = vars.tempAvailableBeans[i];
 178 |     |         }
 179 |     | 
 180 |     |         return combinedPlan;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @notice Checks if the current operator is whitelisted
 185 |     |      * @param whitelistedOperators Array of whitelisted operator addresses
 186 |     |      * @param beanstalk The Beanstalk contract instance
 187 |     |      * @return isWhitelisted Whether the current operator is whitelisted
 188 |     |      */
 189 |     |     function isOperatorWhitelisted(
 190 |     |         address[] calldata whitelistedOperators,
 191 |     |         IBeanstalk beanstalk
 192 |     |     ) external view returns (bool) {
 193 |     |         // If there are no whitelisted operators, pass in, accept any operator
 194 |     |         if (whitelistedOperators.length == 0) {
 195 |     |             return true;
 196 |     |         }
 197 |     | 
 198 |     |         address currentOperator = beanstalk.operator();
 199 |     |         for (uint256 i = 0; i < whitelistedOperators.length; i++) {
 200 |     |             address checkAddress = whitelistedOperators[i];
 201 |     |             if (checkAddress == currentOperator) {
 202 |     |                 return true;
 203 |     |             } else {
 204 |     |                 // Skip if address is a precompiled contract (address < 0x20)
 205 |     |                 if (uint160(checkAddress) <= 0x20) continue;
 206 |     | 
 207 |     |                 // Check if the address is a contract before attempting staticcall
 208 |     |                 uint256 size;
 209 |     |                 assembly {
 210 |     |                     size := extcodesize(checkAddress)
 211 |     |                 }
 212 |     | 
 213 |     |                 if (size > 0) {
 214 |     |                     try
 215 |     |                         IOperatorWhitelist(checkAddress).checkOperatorWhitelist(currentOperator)
 216 |     |                     returns (bool success) {
 217 |     |                         if (success) {
 218 |     |                             return true;
 219 |     |                         }
 220 |     |                     } catch {
 221 |     |                         // If the call fails, continue to the next address
 222 |     |                         continue;
 223 |     |                     }
 224 |     |                 }
 225 |     |             }
 226 |     |         }
 227 |     |         return false;
 228 |     |     }
 229 |     | 
 230 |     |     function sortTokens(
 231 |     |         address[] memory tokens,
 232 |     |         uint256[] memory index
 233 |     |     ) external pure returns (address[] memory, uint256[] memory) {
 234 |     |         for (uint256 i = 0; i < tokens.length - 1; i++) {
 235 |     |             for (uint256 j = 0; j < tokens.length - i - 1; j++) {
 236 |     |                 uint256 j1 = j + 1;
 237 |     |                 if (index[j] < index[j1]) {
 238 |     |                     // Swap index
 239 |     |                     (index[j], index[j1]) = (index[j1], index[j]);
 240 |     | 
 241 |     |                     // Swap corresponding tokens
 242 |     |                     (tokens[j], tokens[j1]) = (tokens[j1], tokens[j]);
 243 |     |                 }
 244 |     |             }
 245 |     |         }
 246 |     |         return (tokens, index);
 247 |     |     }
 248 |     | 
 249 |     |     function sortTokenIndices(
 250 |     |         uint8[] memory tokenIndices,
 251 |     |         uint256[] memory index
 252 |     |     ) external pure returns (uint8[] memory, uint256[] memory) {
 253 |     |         for (uint256 i = 0; i < tokenIndices.length - 1; i++) {
 254 |     |             for (uint256 j = 0; j < tokenIndices.length - i - 1; j++) {
 255 |     |                 uint256 j1 = j + 1;
 256 |     |                 if (index[j] > index[j1]) {
 257 |     |                     // Swap index
 258 |     |                     (index[j], index[j1]) = (index[j1], index[j]);
 259 |     | 
 260 |     |                     // Swap token indices
 261 |     |                     (tokenIndices[j], tokenIndices[j1]) = (tokenIndices[j1], tokenIndices[j]);
 262 |     |                 }
 263 |     |             }
 264 |     |         }
 265 |     |         return (tokenIndices, index);
 266 |     |     }
 267 |     | }
 268 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibWhitelist.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "../../C.sol";
   8 |     | import {LibAppStorage} from "../LibAppStorage.sol";
   9 |     | import {Implementation} from "contracts/beanstalk/storage/System.sol";
  10 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  11 |     | import {AssetSettings} from "contracts/beanstalk/storage/System.sol";
  12 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  13 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  14 |     | import {LibWell, IWell} from "contracts/libraries/Well/LibWell.sol";
  15 |     | import {IChainlinkAggregator} from "contracts/interfaces/IChainlinkAggregator.sol";
  16 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  17 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  18 |     | import {IERC20Decimals} from "contracts/libraries/Oracle/LibUsdOracle.sol";
  19 |     | 
  20 |     | /**
  21 |     |  * @title LibWhitelist
  22 |     |  * @notice Handles adding and removing ERC-20 tokens from the Silo Whitelist.
  23 |     |  */
  24 | *   | library LibWhitelist {
  25 |     |     using LibRedundantMath32 for uint32;
  26 |     |     using SafeCast for int32;
  27 |     | 
  28 |     |     /**
  29 |     |      * @notice Emitted when a token is added to the Silo Whitelist.
  30 |     |      * @param token ERC-20 token being added to the Silo Whitelist.
  31 |     |      * @param selector The function selector that returns the BDV of a given token.
  32 |     |      * @param stalkEarnedPerSeason The Stalk per BDV per Season received from depositing `token`.
  33 |     |      * @param stalkIssuedPerBdv The Stalk per BDV given from depositing `token`.
  34 |     |      * @param gaugePoints The gauge points of the token.
  35 |     |      * @param optimalPercentDepositedBdv The target percentage
  36 |     |      * of the total LP deposited BDV for this token.
  37 |     |      */
  38 |     |     event WhitelistToken(
  39 |     |         address indexed token,
  40 |     |         bytes4 selector,
  41 |     |         uint40 stalkEarnedPerSeason,
  42 |     |         uint256 stalkIssuedPerBdv,
  43 |     |         uint128 gaugePoints,
  44 |     |         uint64 optimalPercentDepositedBdv
  45 |     |     );
  46 |     | 
  47 |     |     /**
  48 |     |      * @notice Emitted when the oracle implementation for a token is updated.
  49 |     |      */
  50 |     |     event UpdatedOracleImplementationForToken(
  51 |     |         address indexed token,
  52 |     |         Implementation oracleImplementation
  53 |     |     );
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Emitted when the gauge point implementation for a token is updated.
  57 |     |      */
  58 |     |     event UpdatedGaugePointImplementationForToken(
  59 |     |         address indexed token,
  60 |     |         Implementation gaugePointImplementation
  61 |     |     );
  62 |     | 
  63 |     |     /**
  64 |     |      * @notice Emitted when the liquidity weight implementation for a token is updated.
  65 |     |      */
  66 |     |     event UpdatedLiquidityWeightImplementationForToken(
  67 |     |         address indexed token,
  68 |     |         Implementation liquidityWeightImplementation
  69 |     |     );
  70 |     | 
  71 |     |     /**
  72 |     |      * @notice Emitted when the gauge settings are updated.
  73 |     |      * @param token Token that is being updated.
  74 |     |      * @param optimalPercentDepositedBdv The new optimal Percent deposited BDV
  75 |     |      */
  76 |     |     event UpdatedOptimalPercentDepositedBdvForToken(
  77 |     |         address indexed token,
  78 |     |         uint64 optimalPercentDepositedBdv
  79 |     |     );
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Emitted when the stalk per bdv per season for a Silo token is updated.
  83 |     |      * @param token ERC-20 token being updated in the Silo Whitelist.
  84 |     |      * @param stalkEarnedPerSeason New stalk per bdv per season value for this token.
  85 |     |      * @param season The season that the new stalk per bdv per season value becomes active (The current season).
  86 |     |      */
  87 |     |     event UpdatedStalkPerBdvPerSeason(
  88 |     |         address indexed token,
  89 |     |         uint40 stalkEarnedPerSeason,
  90 |     |         uint32 season
  91 |     |     );
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice Emitted when a token is removed from the Silo Whitelist.
  95 |     |      * @param token ERC-20 token being removed from the Silo Whitelist.
  96 |     |      */
  97 |     |     event DewhitelistToken(address indexed token);
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Adds an ERC-20 token to the Silo Whitelist.
 101 |     |      * Assumes future tokens will be well pool tokens.
 102 |     |      * Assumes if the gpImplementation and lwImplementation targets are not set,
 103 |     |      * that they are implemented in this diamond.
 104 |     |      * Oracle Implementations may or may not be implemented, depending on the token.
 105 |     |      */
 106 |     |     function whitelistToken(
 107 |     |         address token,
 108 |     |         bytes4 selector,
 109 |     |         uint48 stalkIssuedPerBdv,
 110 |     |         uint40 stalkEarnedPerSeason,
 111 |     |         bytes1 encodeType,
 112 |     |         uint128 gaugePoints,
 113 |     |         uint64 optimalPercentDepositedBdv,
 114 |     |         Implementation memory oracleImplementation,
 115 |     |         Implementation memory gpImplementation,
 116 |     |         Implementation memory lwImplementation
 117 |     |     ) internal {
 118 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 119 |     | 
 120 |     |         // verify the gaugePoint and liquidityWeight selector.
 121 |     |         verifyGaugePointImplementation(gpImplementation);
 122 |     |         verifyLiquidityWeightImplementation(lwImplementation);
 123 |     | 
 124 |     |         // add whitelist status
 125 |     |         verifyWhitelistStatus(token, selector, stalkIssuedPerBdv);
 126 |     | 
 127 |     |         // If an LP token, initialize oracle storage variables and set Oracle Implementation:
 128 |     |         if (token != address(s.sys.bean)) {
 129 |     |             s.sys.usdTokenPrice[token] = 1;
 130 |     |             s.sys.twaReserves[token].reserve0 = 1;
 131 |     |             s.sys.twaReserves[token].reserve1 = 1;
 132 |     | 
 133 |     |             // the Oracle should return the price for the non-bean asset in USD
 134 |     |             address nonBeanToken = address(LibWell.getNonBeanTokenFromWell(token));
 135 |     |             verifyOracleImplementation(nonBeanToken, oracleImplementation);
 136 |     |             s.sys.oracleImplementation[nonBeanToken] = oracleImplementation;
 137 |     |             emit UpdatedOracleImplementationForToken(nonBeanToken, oracleImplementation);
 138 |     |         }
 139 |     | 
 140 |     |         require(
 141 |     |             s.sys.silo.assetSettings[token].milestoneSeason == 0,
 142 |     |             "Whitelist: Token already whitelisted"
 143 |     |         );
 144 |     |         // beanstalk requires all whitelisted assets to have a minimum stalkEarnedPerSeeason
 145 |     |         // of 1 (due to the germination update). set stalkEarnedPerSeason to 1 to prevent revert.
 146 |     |         if (stalkEarnedPerSeason == 0) stalkEarnedPerSeason = 1;
 147 |     |         s.sys.silo.assetSettings[token].selector = selector;
 148 |     |         s.sys.silo.assetSettings[token].stalkEarnedPerSeason = stalkEarnedPerSeason;
 149 |     |         s.sys.silo.assetSettings[token].stalkIssuedPerBdv = stalkIssuedPerBdv;
 150 |     |         s.sys.silo.assetSettings[token].milestoneSeason = uint32(s.sys.season.current);
 151 |     |         s.sys.silo.assetSettings[token].encodeType = encodeType;
 152 |     |         s.sys.silo.assetSettings[token].gaugePoints = gaugePoints;
 153 |     |         s.sys.silo.assetSettings[token].optimalPercentDepositedBdv = optimalPercentDepositedBdv;
 154 |     |         s.sys.silo.assetSettings[token].gaugePointImplementation = gpImplementation;
 155 |     |         s.sys.silo.assetSettings[token].liquidityWeightImplementation = lwImplementation;
 156 |     | 
 157 |     |         emit WhitelistToken(
 158 |     |             token,
 159 |     |             selector,
 160 |     |             stalkEarnedPerSeason,
 161 |     |             stalkIssuedPerBdv,
 162 |     |             gaugePoints,
 163 |     |             optimalPercentDepositedBdv
 164 |     |         );
 165 |     | 
 166 |     |         emit UpdatedGaugePointImplementationForToken(token, gpImplementation);
 167 |     |         emit UpdatedLiquidityWeightImplementationForToken(token, lwImplementation);
 168 |     |     }
 169 |     | 
 170 |     |     /**
 171 |     |      * @notice Updates gauge settings for token.
 172 |     |      * @dev {LibWhitelistedTokens} must be updated to include the new token.
 173 |     |      */
 174 |     |     function updateGaugeForToken(
 175 |     |         address token,
 176 |     |         uint64 optimalPercentDepositedBdv,
 177 |     |         Implementation memory gpImplementation,
 178 |     |         Implementation memory lwImplementation
 179 |     |     ) internal {
 180 |     |         updateGaugePointImplementationForToken(token, gpImplementation);
 181 |     |         updateLiquidityWeightImplementationForToken(token, lwImplementation);
 182 |     |         updateOptimalPercentDepositedBdvForToken(token, optimalPercentDepositedBdv);
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @dev Updates the Stalk per BDV per Season for a token.
 187 |     |      */
 188 |     |     function updateStalkPerBdvPerSeasonForToken(
 189 |     |         address token,
 190 |     |         uint40 stalkEarnedPerSeason
 191 |     |     ) internal {
 192 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 193 |     | 
 194 |     |         require(s.sys.silo.assetSettings[token].milestoneSeason != 0, "Token not whitelisted");
 195 |     | 
 196 |     |         // beanstalk requires a min. stalkEarnedPerSeason of 1.
 197 |     |         if (stalkEarnedPerSeason == 0) stalkEarnedPerSeason = 1;
 198 |     | 
 199 |     |         // update milestone stem and season.
 200 |     |         s.sys.silo.assetSettings[token].milestoneStem = LibTokenSilo.stemTipForToken(token);
 201 |     |         s.sys.silo.assetSettings[token].milestoneSeason = s.sys.season.current;
 202 |     | 
 203 |     |         // stalkEarnedPerSeason is set to int32 before casting down.
 204 |     |         s.sys.silo.assetSettings[token].deltaStalkEarnedPerSeason =
 205 |     |             int40(stalkEarnedPerSeason) -
 206 |     |             int40(s.sys.silo.assetSettings[token].stalkEarnedPerSeason);
 207 |     |         s.sys.silo.assetSettings[token].stalkEarnedPerSeason = stalkEarnedPerSeason;
 208 |     | 
 209 |     |         emit UpdatedStalkPerBdvPerSeason(token, stalkEarnedPerSeason, s.sys.season.current);
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Updates optimalPercentDepositedBdv token.
 214 |     |      * @dev {LibWhitelistedTokens} must be updated to include the new token.
 215 |     |      */
 216 | *   |     function updateOptimalPercentDepositedBdvForToken(
 217 |     |         address token,
 218 |     |         uint64 optimalPercentDepositedBdv
 219 | *   |     ) internal {
 220 | *   |         AssetSettings storage ss = LibAppStorage.diamondStorage().sys.silo.assetSettings[token];
 221 | *   |         ss.optimalPercentDepositedBdv = optimalPercentDepositedBdv;
 222 | *   |         emit UpdatedOptimalPercentDepositedBdvForToken(token, optimalPercentDepositedBdv);
 223 |     |     }
 224 |     | 
 225 |     |     /**
 226 |     |      * @notice updates the oracle implementation for a token.
 227 |     |      */
 228 | *   |     function updateOracleImplementationForToken(
 229 |     |         address token,
 230 |     |         Implementation memory oracleImplementation
 231 | *   |     ) internal {
 232 |     |         // check that new implementation is valid.
 233 | *   |         verifyOracleImplementation(token, oracleImplementation);
 234 |     | 
 235 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 236 | *   |         s.sys.oracleImplementation[token] = oracleImplementation;
 237 |     | 
 238 | *   |         emit UpdatedOracleImplementationForToken(token, oracleImplementation);
 239 |     |     }
 240 |     | 
 241 |     |     /**
 242 |     |      * @notice updates the gauge point implementation for a token.
 243 |     |      */
 244 |     |     function updateGaugePointImplementationForToken(
 245 |     |         address token,
 246 |     |         Implementation memory gpImplementation
 247 |     |     ) internal {
 248 |     |         AssetSettings storage ss = LibAppStorage.diamondStorage().sys.silo.assetSettings[token];
 249 |     |         require(ss.selector != 0, "Whitelist: Token not whitelisted in Silo");
 250 |     | 
 251 |     |         // check that new implementation is valid.
 252 |     |         verifyGaugePointImplementation(gpImplementation);
 253 |     | 
 254 |     |         ss.gaugePointImplementation = gpImplementation;
 255 |     | 
 256 |     |         emit UpdatedGaugePointImplementationForToken(token, gpImplementation);
 257 |     |     }
 258 |     | 
 259 |     |     /**
 260 |     |      * @notice updates the gauge point implementation for a token.
 261 |     |      */
 262 |     |     function updateLiquidityWeightImplementationForToken(
 263 |     |         address token,
 264 |     |         Implementation memory lwImplementation
 265 |     |     ) internal {
 266 |     |         AssetSettings storage ss = LibAppStorage.diamondStorage().sys.silo.assetSettings[token];
 267 |     |         require(ss.selector != 0, "Whitelist: Token not whitelisted in Silo");
 268 |     | 
 269 |     |         // check that new implementation is valid.
 270 |     |         verifyLiquidityWeightImplementation(lwImplementation);
 271 |     | 
 272 |     |         ss.liquidityWeightImplementation = lwImplementation;
 273 |     | 
 274 |     |         emit UpdatedLiquidityWeightImplementationForToken(token, lwImplementation);
 275 |     |     }
 276 |     | 
 277 |     |     /**
 278 |     |      * @notice Removes an ERC-20 token from the Silo Whitelist.
 279 |     |      *
 280 |     |      */
 281 |     |     function dewhitelistToken(address token) internal {
 282 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 283 |     | 
 284 |     |         uint256 tokenStatusIndex = LibWhitelistedTokens.findWhitelistStatusIndex(token);
 285 |     | 
 286 |     |         // before dewhitelisting, verify that `libWhitelistedTokens` are updated.
 287 |     |         LibWhitelistedTokens.updateWhitelistStatus(
 288 |     |             token,
 289 |     |             false,
 290 |     |             false,
 291 |     |             false,
 292 |     |             s.sys.silo.whitelistStatuses[tokenStatusIndex].isSoppable // if token was soppable, it should remain so, so that previous sops can be claimed.
 293 |     |         );
 294 |     | 
 295 |     |         // set the stalkEarnedPerSeason to 1 and update milestone stem.
 296 |     |         // stalkEarnedPerSeason requires a min value of 1.
 297 |     |         updateStalkPerBdvPerSeasonForToken(token, 1);
 298 |     | 
 299 |     |         // delete the selector and encodeType.
 300 |     |         delete s.sys.silo.assetSettings[token].selector;
 301 |     |         delete s.sys.silo.assetSettings[token].encodeType;
 302 |     | 
 303 |     |         // delete gaugePoints, gaugePointSelector, liquidityWeightSelector, and optimalPercentDepositedBdv.
 304 |     |         delete s.sys.silo.assetSettings[token].gaugePoints;
 305 |     |         delete s.sys.silo.assetSettings[token].gaugePointImplementation;
 306 |     |         delete s.sys.silo.assetSettings[token].liquidityWeightImplementation;
 307 |     |         delete s.sys.silo.assetSettings[token].optimalPercentDepositedBdv;
 308 |     | 
 309 |     |         // delete implementations:
 310 |     |         delete s.sys.silo.assetSettings[token].gaugePointImplementation;
 311 |     |         delete s.sys.silo.assetSettings[token].liquidityWeightImplementation;
 312 |     | 
 313 |     |         emit DewhitelistToken(token);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @notice Verifies whether the bdv selector is valid.
 318 |     |      */
 319 |     |     function verifyBDVselector(address token, bytes1 encodeType, bytes4 selector) internal view {
 320 |     |         (bool success, ) = address(this).staticcall(
 321 |     |             LibTokenSilo.encodeBdvFunction(token, encodeType, selector, 0)
 322 |     |         );
 323 |     |         require(success, "Whitelist: Invalid BDV selector");
 324 |     |     }
 325 |     | 
 326 |     |     /**
 327 |     |      * @notice Verifies whether a gaugePointSelector at an external contract
 328 |     |      * is valid for the gauge system.
 329 |     |      */
 330 | *   |     function verifyOracleImplementation(
 331 |     |         address token,
 332 |     |         Implementation memory oracleImplementation
 333 | *   |     ) internal {
 334 | *   |         bool success;
 335 | *   |         bytes memory returnData;
 336 |     |         // if the encode type is 0x01, verify using the chainlink implementation.
 337 | *   |         if (oracleImplementation.encodeType == bytes1(0x01)) {
 338 | *   |             (success, returnData) = oracleImplementation.target.staticcall(
 339 | *   |                 abi.encodeWithSelector(IChainlinkAggregator.decimals.selector)
 340 |     |             );
 341 | *   |         } else if (oracleImplementation.encodeType == bytes1(0x02)) {
 342 |     |             // 0x0dfe1681 == token0() for uniswap pools.
 343 |     |             (success, returnData) = oracleImplementation.target.staticcall(
 344 |     |                 abi.encodeWithSelector(0x0dfe1681)
 345 |     |             );
 346 |     |         } else {
 347 |     |             // external oracles must have a target address
 348 | *   |             require(oracleImplementation.target != address(0), "Whitelist: Invalid Target Address");
 349 |     | 
 350 |     |             // verify you passed in a callable oracle selector
 351 | *   |             (success, returnData) = oracleImplementation.target.call(
 352 | *   |                 abi.encodeWithSelector(
 353 | *   |                     oracleImplementation.selector,
 354 | *   |                     IERC20Decimals(token).decimals(),
 355 | *   |                     0,
 356 | *   |                     oracleImplementation.data
 357 |     |                 )
 358 |     |             );
 359 |     |         }
 360 | *   |         require(success && returnData.length > 0, "Whitelist: Invalid Oracle Implementation");
 361 |     |     }
 362 |     | 
 363 |     |     /**
 364 |     |      * @notice Verifies whether a gaugePointSelector at an external contract
 365 |     |      * is valid for the gauge system.
 366 |     |      */
 367 |     |     function verifyGaugePointImplementation(Implementation memory gpImplementation) internal view {
 368 |     |         // if the target is not set, assume the gaugePoint implementation is in this diamond.
 369 |     |         address target = gpImplementation.target == address(0)
 370 |     |             ? address(this)
 371 |     |             : gpImplementation.target;
 372 |     |         // verify you passed in a callable gaugePoint selector
 373 |     |         (bool success, bytes memory returnData) = target.staticcall(
 374 |     |             abi.encodeWithSelector(gpImplementation.selector, 0, 0, 0, gpImplementation.data)
 375 |     |         );
 376 |     |         require(success && returnData.length > 0, "Whitelist: Invalid GaugePoint Implementation");
 377 |     |     }
 378 |     | 
 379 |     |     /**
 380 |     |      * @notice Verifies whether liquidityWeight selector at an external contract
 381 |     |      * is valid for the gauge system.
 382 |     |      */
 383 |     |     function verifyLiquidityWeightImplementation(Implementation memory lw) internal view {
 384 |     |         // if the target is not set, assume the liquidity weight implementation is in this diamond.
 385 |     |         address target = lw.target == address(0) ? address(this) : lw.target;
 386 |     |         // verify you passed in a callable liquidityWeight selector
 387 |     |         (bool success, bytes memory returnData) = target.staticcall(
 388 |     |             abi.encodeWithSelector(lw.selector, lw.data)
 389 |     |         );
 390 |     |         require(
 391 |     |             success && returnData.length > 0,
 392 |     |             "Whitelist: Invalid LiquidityWeight Implementation"
 393 |     |         );
 394 |     |     }
 395 |     | 
 396 |     |     /**
 397 |     |      * @notice verifies whether a token is not whitelisted.
 398 |     |      * @dev if the token has been previously whitelisted,
 399 |     |      * return the current stalk issued per bdv.
 400 |     |      */
 401 |     |     function verifyWhitelistStatus(
 402 |     |         address token,
 403 |     |         bytes4 selector,
 404 |     |         uint48 stalkIssuedPerBdv
 405 |     |     ) internal {
 406 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 407 |     | 
 408 |     |         (bool isWhitelisted, bool previouslyWhitelisted) = LibWhitelistedTokens.checkWhitelisted(
 409 |     |             token
 410 |     |         );
 411 |     |         require(isWhitelisted == false, "Whitelist: Token already whitelisted");
 412 |     | 
 413 |     |         // add whitelist status. If previously whitelisted, update the status rather than appending.
 414 |     |         if (previouslyWhitelisted) {
 415 |     |             LibWhitelistedTokens.updateWhitelistStatus(
 416 |     |                 token,
 417 |     |                 true, // Whitelisted by default.
 418 |     |                 token != address(s.sys.bean), // Assumes tokens that are not Bean are LP tokens.
 419 |     |                 selector == LibWell.WELL_BDV_SELECTOR,
 420 |     |                 selector == LibWell.WELL_BDV_SELECTOR // Assumes wells are soppable if selector is WELL_BDV_SELECTOR
 421 |     |             );
 422 |     |         } else {
 423 |     |             // assumes new tokens are well pool tokens.
 424 |     |             LibWhitelistedTokens.addWhitelistStatus(
 425 |     |                 token,
 426 |     |                 true, // Whitelisted by default.
 427 |     |                 token != address(s.sys.bean), // Assumes tokens that are not Bean are LP tokens.
 428 |     |                 selector == LibWell.WELL_BDV_SELECTOR,
 429 |     |                 selector == LibWell.WELL_BDV_SELECTOR // Assumes wells are soppable if selector is WELL_BDV_SELECTOR
 430 |     |             );
 431 |     |         }
 432 |     | 
 433 |     |         // if the token has previously been whitelisted, the stalkIssuedPerBdv
 434 |     |         // cannot be updated, as previous deposits would have been made with the
 435 |     |         // previous value.
 436 |     |         if (previouslyWhitelisted) {
 437 |     |             require(
 438 |     |                 s.sys.silo.assetSettings[token].stalkIssuedPerBdv == stalkIssuedPerBdv,
 439 |     |                 "Whitelist: Cannot update stalkIssuedPerBdv"
 440 |     |             );
 441 |     |         }
 442 |     |     }
 443 |     | }
 444 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Silo/LibWhitelistedTokens.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {C} from "../../C.sol";
   8 |     | import {LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
   9 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  10 |     | import {WhitelistStatus} from "contracts/beanstalk/storage/System.sol";
  11 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title LibWhitelistedTokens
  15 |     |  * @notice LibWhitelistedTokens holds different lists of types of Whitelisted Tokens.
  16 |     |  *
  17 |     |  * @dev manages the WhitelistStatuses for all tokens in the Silo in order to track lists.
  18 |     |  * Note: dewhitelisting a token doesn't remove it's WhitelistStatus entirely–It just modifies it.
  19 |     |  */
  20 | *   | library LibWhitelistedTokens {
  21 |     |     /**
  22 |     |      * @notice Emitted when a Whitelis Status is added.
  23 |     |      */
  24 |     |     event AddWhitelistStatus(
  25 |     |         address token,
  26 |     |         uint256 index,
  27 |     |         bool isWhitelisted,
  28 |     |         bool isWhitelistedLp,
  29 |     |         bool isWhitelistedWell,
  30 |     |         bool isSoppable
  31 |     |     );
  32 |     | 
  33 |     |     /**
  34 |     |      * @notice Emitted when a Whitelist Status is updated.
  35 |     |      */
  36 |     |     event UpdateWhitelistStatus(
  37 |     |         address token,
  38 |     |         uint256 index,
  39 |     |         bool isWhitelisted,
  40 |     |         bool isWhitelistedLp,
  41 |     |         bool isWhitelistedWell,
  42 |     |         bool isSoppable
  43 |     |     );
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Returns all tokens that are currently or previously in the silo.
  47 |     |      * @dev includes Dewhitelisted tokens with existing Deposits.
  48 |     |      */
  49 |     |     function getSiloTokens() internal view returns (address[] memory tokens) {
  50 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  51 |     |         uint256 numberOfSiloTokens = s.sys.silo.whitelistStatuses.length;
  52 |     | 
  53 |     |         tokens = new address[](numberOfSiloTokens);
  54 |     | 
  55 |     |         for (uint256 i = 0; i < numberOfSiloTokens; i++) {
  56 |     |             tokens[i] = s.sys.silo.whitelistStatuses[i].token;
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @notice Returns the current Whitelisted tokens.
  62 |     |      */
  63 | *   |     function getWhitelistedTokens() internal view returns (address[] memory tokens) {
  64 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
  65 | *   |         uint256 numberOfSiloTokens = s.sys.silo.whitelistStatuses.length;
  66 | *   |         uint256 tokensLength;
  67 |     | 
  68 | *   |         tokens = new address[](numberOfSiloTokens);
  69 |     | 
  70 | *   |         for (uint256 i = 0; i < numberOfSiloTokens; i++) {
  71 | *   |             if (s.sys.silo.whitelistStatuses[i].isWhitelisted) {
  72 | *   |                 tokens[tokensLength++] = s.sys.silo.whitelistStatuses[i].token;
  73 |     |             }
  74 |     |         }
  75 | *   |         assembly {
  76 | *   |             mstore(tokens, tokensLength)
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @notice Returns the current Whitelisted LP tokens.
  82 |     |      */
  83 |     |     function getWhitelistedLpTokens() internal view returns (address[] memory tokens) {
  84 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  85 |     |         uint256 numberOfSiloTokens = s.sys.silo.whitelistStatuses.length;
  86 |     |         uint256 tokensLength;
  87 |     | 
  88 |     |         tokens = new address[](numberOfSiloTokens);
  89 |     | 
  90 |     |         for (uint256 i = 0; i < numberOfSiloTokens; i++) {
  91 |     |             if (s.sys.silo.whitelistStatuses[i].isWhitelistedLp) {
  92 |     |                 // assembly {
  93 |     |                 //     mstore(tokens, add(mload(tokens), 1))
  94 |     |                 // }
  95 |     |                 tokens[tokensLength++] = s.sys.silo.whitelistStatuses[i].token;
  96 |     |             }
  97 |     |         }
  98 |     |         assembly {
  99 |     |             mstore(tokens, tokensLength)
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Returns the current Whitelisted Well LP tokens.
 105 |     |      */
 106 |     |     function getWhitelistedWellLpTokens() internal view returns (address[] memory tokens) {
 107 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 108 |     |         uint256 numberOfSiloTokens = s.sys.silo.whitelistStatuses.length;
 109 |     |         uint256 tokensLength;
 110 |     | 
 111 |     |         tokens = new address[](numberOfSiloTokens);
 112 |     | 
 113 |     |         for (uint256 i = 0; i < numberOfSiloTokens; i++) {
 114 |     |             if (s.sys.silo.whitelistStatuses[i].isWhitelistedWell) {
 115 |     |                 tokens[tokensLength++] = s.sys.silo.whitelistStatuses[i].token;
 116 |     |             }
 117 |     |         }
 118 |     |         assembly {
 119 |     |             mstore(tokens, tokensLength)
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Returns all tokens that are currently or previously soppable.
 125 |     |      * Reviewer note: maybe need a better name for this function? Necessary if a sop happens for a well and it becomes de-whitelisted.
 126 |     |      */
 127 | *   |     function getSoppableWellLpTokens() internal view returns (address[] memory tokens) {
 128 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 129 | *   |         uint256 numberOfSiloTokens = s.sys.silo.whitelistStatuses.length;
 130 | *   |         uint256 tokensLength;
 131 |     | 
 132 | *   |         tokens = new address[](numberOfSiloTokens);
 133 |     | 
 134 | *   |         for (uint256 i = 0; i < numberOfSiloTokens; i++) {
 135 | *   |             if (s.sys.silo.whitelistStatuses[i].isSoppable) {
 136 | *   |                 tokens[tokensLength++] = s.sys.silo.whitelistStatuses[i].token;
 137 |     |             }
 138 |     |         }
 139 | *   |         assembly {
 140 | *   |             mstore(tokens, tokensLength)
 141 |     |         }
 142 |     |     }
 143 |     | 
 144 |     |     function wellIsOrWasSoppable(address well) internal view returns (bool) {
 145 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 146 |     |         uint256 tokenStatusIndex = findWhitelistStatusIndex(well);
 147 |     |         return s.sys.silo.whitelistStatuses[tokenStatusIndex].isSoppable;
 148 |     |     }
 149 |     | 
 150 | *   |     function getSopTokens() internal view returns (address[] memory) {
 151 | *   |         address[] memory tokens = getSoppableWellLpTokens();
 152 | *   |         for (uint256 i = 0; i < tokens.length; i++) {
 153 | *   |             tokens[i] = address(LibWell.getNonBeanTokenFromWell(tokens[i]));
 154 |     |         }
 155 | *   |         return tokens;
 156 |     |     }
 157 |     | 
 158 |     |     /**
 159 |     |      * @notice Returns all tokens that are currently soppable.
 160 |     |      */
 161 |     |     function getCurrentlySoppableWellLpTokens() internal view returns (address[] memory tokens) {
 162 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 163 |     |         uint256 numberOfSiloTokens = s.sys.silo.whitelistStatuses.length;
 164 |     |         uint256 tokensLength;
 165 |     | 
 166 |     |         tokens = new address[](numberOfSiloTokens);
 167 |     | 
 168 |     |         for (uint256 i = 0; i < numberOfSiloTokens; i++) {
 169 |     |             if (
 170 |     |                 s.sys.silo.whitelistStatuses[i].isWhitelistedWell &&
 171 |     |                 s.sys.silo.whitelistStatuses[i].isSoppable
 172 |     |             ) {
 173 |     |                 tokens[tokensLength++] = s.sys.silo.whitelistStatuses[i].token;
 174 |     |             }
 175 |     |         }
 176 |     |         assembly {
 177 |     |             mstore(tokens, tokensLength)
 178 |     |         }
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @notice Returns the Whitelist statues for all tokens that have been whitelisted and not manually removed.
 183 |     |      */
 184 |     |     function getWhitelistedStatuses()
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (WhitelistStatus[] memory _whitelistStatuses)
 188 |     |     {
 189 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 190 |     |         _whitelistStatuses = s.sys.silo.whitelistStatuses;
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @notice Returns the Whitelist status for a given token.
 195 |     |      */
 196 |     |     function getWhitelistedStatus(
 197 |     |         address token
 198 |     |     ) internal view returns (WhitelistStatus memory _whitelistStatus) {
 199 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 200 |     |         uint256 tokenStatusIndex = findWhitelistStatusIndex(token);
 201 |     |         _whitelistStatus = s.sys.silo.whitelistStatuses[tokenStatusIndex];
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice Adds a Whitelist Status for a given `token`.
 206 |     |      */
 207 | *   |     function addWhitelistStatus(
 208 |     |         address token,
 209 |     |         bool isWhitelisted,
 210 |     |         bool isWhitelistedLp,
 211 |     |         bool isWhitelistedWell,
 212 |     |         bool isSoppable
 213 | *   |     ) internal {
 214 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 215 | *   |         s.sys.silo.whitelistStatuses.push(
 216 | *   |             WhitelistStatus(token, isWhitelisted, isWhitelistedLp, isWhitelistedWell, isSoppable)
 217 |     |         );
 218 |     | 
 219 | *   |         emit AddWhitelistStatus(
 220 | *   |             token,
 221 | *   |             s.sys.silo.whitelistStatuses.length - 1,
 222 | *   |             isWhitelisted,
 223 | *   |             isWhitelistedLp,
 224 | *   |             isWhitelistedWell,
 225 | *   |             isSoppable
 226 |     |         );
 227 |     |     }
 228 |     | 
 229 |     |     /**
 230 |     |      * @notice Modifies the exisiting Whitelist Status of `token`.
 231 |     |      */
 232 |     |     function updateWhitelistStatus(
 233 |     |         address token,
 234 |     |         bool isWhitelisted,
 235 |     |         bool isWhitelistedLp,
 236 |     |         bool isWhitelistedWell,
 237 |     |         bool isSoppable
 238 |     |     ) internal {
 239 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 240 |     |         uint256 tokenStatusIndex = findWhitelistStatusIndex(token);
 241 |     | 
 242 |     |         s.sys.silo.whitelistStatuses[tokenStatusIndex].isWhitelisted = isWhitelisted;
 243 |     |         s.sys.silo.whitelistStatuses[tokenStatusIndex].isWhitelistedLp = isWhitelistedLp;
 244 |     |         s.sys.silo.whitelistStatuses[tokenStatusIndex].isWhitelistedWell = isWhitelistedWell;
 245 |     |         s.sys.silo.whitelistStatuses[tokenStatusIndex].isSoppable = isSoppable;
 246 |     | 
 247 |     |         emit UpdateWhitelistStatus(
 248 |     |             token,
 249 |     |             tokenStatusIndex,
 250 |     |             isWhitelisted,
 251 |     |             isWhitelistedLp,
 252 |     |             isWhitelistedWell,
 253 |     |             isSoppable
 254 |     |         );
 255 |     |     }
 256 |     | 
 257 |     |     /**
 258 |     |      * @notice Finds the index of a given `token`'s Whitelist Status.
 259 |     |      */
 260 |     |     function findWhitelistStatusIndex(address token) internal view returns (uint256) {
 261 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 262 |     |         uint256 whitelistedStatusLength = s.sys.silo.whitelistStatuses.length;
 263 |     |         uint256 i;
 264 |     |         while (s.sys.silo.whitelistStatuses[i].token != token) {
 265 |     |             i++;
 266 |     |             if (i >= whitelistedStatusLength) {
 267 |     |                 revert("LibWhitelistedTokens: Token not found");
 268 |     |             }
 269 |     |         }
 270 |     |         return i;
 271 |     |     }
 272 |     | 
 273 |     |     /**
 274 |     |      * @notice checks if a token is whitelisted.
 275 |     |      * @dev checks whether a token is in the whitelistStatuses array. If it is,
 276 |     |      * verify whether `isWhitelisted` is set to false.
 277 |     |      * @param token the token to check.
 278 |     |      */
 279 |     |     function checkWhitelisted(
 280 |     |         address token
 281 |     |     ) internal view returns (bool isWhitelisted, bool previouslyWhitelisted) {
 282 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 283 |     |         uint256 whitelistedStatusLength = s.sys.silo.whitelistStatuses.length;
 284 |     | 
 285 |     |         if (whitelistedStatusLength == 0) {
 286 |     |             return (false, false);
 287 |     |         }
 288 |     | 
 289 |     |         uint256 i;
 290 |     |         while (s.sys.silo.whitelistStatuses[i].token != token) {
 291 |     |             i++;
 292 |     |             if (i >= whitelistedStatusLength) {
 293 |     |                 // if the token does not appear in the array
 294 |     |                 // it has not been whitelisted nor dewhitelisted.
 295 |     |                 return (false, false);
 296 |     |             }
 297 |     |         }
 298 |     | 
 299 |     |         if (s.sys.silo.whitelistStatuses[i].isWhitelisted) {
 300 |     |             // token is whitelisted.
 301 |     |             return (true, false);
 302 |     |         } else {
 303 |     |             // token has been whitelisted previously.
 304 |     |             return (false, true);
 305 |     |         }
 306 |     |     }
 307 |     | 
 308 |     |     function getIndexFromWhitelistedWellLpTokens(address token) internal view returns (uint256) {
 309 |     |         address[] memory whitelistedWellLpTokens = getWhitelistedWellLpTokens();
 310 |     |         for (uint256 i; i < whitelistedWellLpTokens.length; i++) {
 311 |     |             if (whitelistedWellLpTokens[i] == token) {
 312 |     |                 return i;
 313 |     |             }
 314 |     |         }
 315 |     | 
 316 |     |         revert("LibWhitelistedTokens: Token not found");
 317 |     |     }
 318 |     | }
 319 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Token/LibBalance.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   7 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   8 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
   9 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  10 |     | import {LibAppStorage} from "../LibAppStorage.sol";
  11 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  12 |     | 
  13 |     | /**
  14 |     |  * @title LibInternalBalance
  15 |     |  * @notice Handles internal read/write functions for Internal User Balances.
  16 |     |  * Largely inspired by Balancer's Vault.
  17 |     |  */
  18 | *   | library LibBalance {
  19 |     |     using SafeERC20 for IERC20;
  20 |     |     using LibRedundantMath256 for uint256;
  21 |     |     using SafeCast for uint256;
  22 |     | 
  23 |     |     /**
  24 |     |      * @notice Emitted when an account's Internal Balance changes.
  25 |     |      * @param account The account whose balance changed.
  26 |     |      * @param token Which token balance changed.
  27 |     |      * @param delta The amount the balance increased (if positive) or decreased (if negative).
  28 |     |      */
  29 |     |     event InternalBalanceChanged(address indexed account, IERC20 indexed token, int256 delta);
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Returns the sum of `account`'s Internal and External (ERC20) balance of `token`
  33 |     |      */
  34 |     |     function getBalance(address account, IERC20 token) internal view returns (uint256 balance) {
  35 |     |         balance = token.balanceOf(account).add(getInternalBalance(account, token));
  36 |     |         return balance;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Increases `account`'s Internal Balance of `token` by `amount`.
  41 |     |      */
  42 | *   |     function increaseInternalBalance(address account, IERC20 token, uint256 amount) internal {
  43 | *   |         uint256 currentBalance = getInternalBalance(account, token);
  44 | *   |         uint256 newBalance = currentBalance.add(amount);
  45 | *   |         setInternalBalance(account, token, newBalance, amount.toInt256());
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Decreases `account`'s Internal Balance of `token` by `amount`. If `allowPartial` is true, this function
  50 |     |      * doesn't revert if `account` doesn't have enough balance, and sets it to zero and returns the deducted amount
  51 |     |      * instead.
  52 |     |      */
  53 | *   |     function decreaseInternalBalance(
  54 |     |         address account,
  55 |     |         IERC20 token,
  56 |     |         uint256 amount,
  57 |     |         bool allowPartial
  58 | *   |     ) internal returns (uint256 deducted) {
  59 | *   |         uint256 currentBalance = getInternalBalance(account, token);
  60 | *   |         require(
  61 | *   |             allowPartial || (currentBalance >= amount),
  62 |     |             "Balance: Insufficient internal balance"
  63 |     |         );
  64 |     | 
  65 | *   |         deducted = Math.min(currentBalance, amount);
  66 |     |         // By construction, `deducted` is lower or equal to `currentBalance`,
  67 |     |         // so we don't need to use checked arithmetic.
  68 | *   |         uint256 newBalance = currentBalance - deducted;
  69 | *   |         setInternalBalance(account, token, newBalance, -(deducted.toInt256()));
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Sets `account`'s Internal Balance of `token` to `newBalance`.
  74 |     |      *
  75 |     |      * Emits an {InternalBalanceChanged} event. This event includes `delta`, which is the amount the balance increased
  76 |     |      * (if positive) or decreased (if negative). To avoid reading the current balance in order to compute the delta,
  77 |     |      * this function relies on the caller providing it directly.
  78 |     |      */
  79 | *   |     function setInternalBalance(
  80 |     |         address account,
  81 |     |         IERC20 token,
  82 |     |         uint256 newBalance,
  83 |     |         int256 delta
  84 | *   |     ) private {
  85 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
  86 | *   |         delta >= 0
  87 | *   |             ? s.sys.internalTokenBalanceTotal[token] = s.sys.internalTokenBalanceTotal[token].add(
  88 | *   |                 uint256(delta)
  89 |     |             )
  90 | *   |             : s.sys.internalTokenBalanceTotal[token] = s.sys.internalTokenBalanceTotal[token].sub(
  91 | *   |             uint256(-delta)
  92 |     |         );
  93 | *   |         s.accts[account].internalTokenBalance[token] = newBalance;
  94 | *   |         emit InternalBalanceChanged(account, token, delta);
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Returns `account`'s Internal Balance of `token`.
  99 |     |      */
 100 | *   |     function getInternalBalance(
 101 |     |         address account,
 102 |     |         IERC20 token
 103 | *   |     ) internal view returns (uint256 balance) {
 104 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 105 | *   |         balance = s.accts[account].internalTokenBalance[token];
 106 |     |     }
 107 |     | }
 108 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Token/LibEth.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "../LibAppStorage.sol";
  8 |     | import "../LibTractor.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title LibEth
 12 |     |  **/
 13 |     | 
 14 | *   | library LibEth {
 15 |     |     function refundEth() internal {
 16 |     |         if (address(this).balance > 0) {
 17 |     |             (bool success, ) = LibTractor._user().call{value: address(this).balance}(new bytes(0));
 18 |     |             require(success, "Eth transfer Failed.");
 19 |     |         }
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Token/LibTokenApprove.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import {LibAppStorage} from "../LibAppStorage.sol";
  7 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title LibTokenApprove
 11 |     |  */
 12 | *   | library LibTokenApprove {
 13 |     |     event TokenApproval(
 14 |     |         address indexed owner,
 15 |     |         address indexed spender,
 16 |     |         IERC20 token,
 17 |     |         uint256 amount
 18 |     |     );
 19 |     | 
 20 |     |     function approve(address account, address spender, IERC20 token, uint256 amount) internal {
 21 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 22 |     |         s.accts[account].tokenAllowances[spender][token] = amount;
 23 |     |         emit TokenApproval(account, spender, token, amount);
 24 |     |     }
 25 |     | 
 26 |     |     function allowance(
 27 |     |         address account,
 28 |     |         address spender,
 29 |     |         IERC20 token
 30 |     |     ) internal view returns (uint256) {
 31 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 32 |     |         return s.accts[account].tokenAllowances[spender][token];
 33 |     |     }
 34 |     | 
 35 |     |     function spendAllowance(address owner, address spender, IERC20 token, uint256 amount) internal {
 36 |     |         uint256 currentAllowance = allowance(owner, spender, token);
 37 |     |         if (currentAllowance != type(uint256).max) {
 38 |     |             require(currentAllowance >= amount, "Token: insufficient allowance");
 39 |     |             approve(owner, spender, token, currentAllowance - amount);
 40 |     |         }
 41 |     |     }
 42 |     | }
 43 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Token/LibTransfer.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import "../../interfaces/IBean.sol";
   7 |     | import "./LibBalance.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title LibTransfer
  11 |     |  * @notice Handles the recieving and sending of Tokens to/from internal Balances.
  12 |     |  */
  13 | *   | library LibTransfer {
  14 |     |     using SafeERC20 for IERC20;
  15 |     |     using LibRedundantMath256 for uint256;
  16 |     | 
  17 |     |     event TokenTransferred(
  18 |     |         address indexed token,
  19 |     |         address indexed sender,
  20 |     |         address indexed recipient,
  21 |     |         uint256 amount,
  22 |     |         From fromMode,
  23 |     |         To toMode
  24 |     |     );
  25 |     | 
  26 |     |     enum From {
  27 |     |         EXTERNAL,
  28 |     |         INTERNAL,
  29 |     |         EXTERNAL_INTERNAL,
  30 |     |         INTERNAL_TOLERANT
  31 |     |     }
  32 |     |     enum To {
  33 |     |         EXTERNAL,
  34 |     |         INTERNAL
  35 |     |     }
  36 |     | 
  37 |     |     function transferToken(
  38 |     |         IERC20 token,
  39 |     |         address sender,
  40 |     |         address recipient,
  41 |     |         uint256 amount,
  42 |     |         From fromMode,
  43 |     |         To toMode
  44 |     |     ) internal returns (uint256 transferredAmount) {
  45 |     |         if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {
  46 |     |             uint256 beforeBalance = token.balanceOf(recipient);
  47 |     |             token.safeTransferFrom(sender, recipient, amount);
  48 |     |             return token.balanceOf(recipient).sub(beforeBalance);
  49 |     |         }
  50 |     |         amount = receiveToken(token, amount, sender, fromMode);
  51 |     |         sendToken(token, amount, recipient, toMode);
  52 |     |         emit TokenTransferred(address(token), sender, recipient, amount, fromMode, toMode);
  53 |     |         return amount;
  54 |     |     }
  55 |     | 
  56 | *   |     function receiveToken(
  57 |     |         IERC20 token,
  58 |     |         uint256 amount,
  59 |     |         address sender,
  60 |     |         From mode
  61 | *   |     ) internal returns (uint256 receivedAmount) {
  62 | *   |         if (amount == 0) return 0;
  63 | *   |         if (mode != From.EXTERNAL) {
  64 | *   |             receivedAmount = LibBalance.decreaseInternalBalance(
  65 | *   |                 sender,
  66 | *   |                 token,
  67 | *   |                 amount,
  68 | *   |                 mode != From.INTERNAL
  69 |     |             );
  70 | *   |             if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT) return receivedAmount;
  71 |     |         }
  72 | *   |         uint256 beforeBalance = token.balanceOf(address(this));
  73 | *   |         token.safeTransferFrom(sender, address(this), amount - receivedAmount);
  74 | *   |         return receivedAmount.add(token.balanceOf(address(this)).sub(beforeBalance));
  75 |     |     }
  76 |     | 
  77 | *   |     function sendToken(IERC20 token, uint256 amount, address recipient, To mode) internal {
  78 | *   |         if (amount == 0) return;
  79 | *   |         if (mode == To.INTERNAL) LibBalance.increaseInternalBalance(recipient, token, amount);
  80 | *   |         else token.safeTransfer(recipient, amount);
  81 |     |     }
  82 |     | 
  83 |     |     function burnToken(
  84 |     |         IBean token,
  85 |     |         uint256 amount,
  86 |     |         address sender,
  87 |     |         From mode
  88 |     |     ) internal returns (uint256 burnt) {
  89 |     |         // burnToken only can be called with Bean token, which is a Beanstalk token.
  90 |     |         // Beanstalk's ERC-20 implementation uses OpenZeppelin's ERC20Burnable
  91 |     |         // which reverts if burnFrom function call cannot burn full amount.
  92 |     |         if (mode == From.EXTERNAL) {
  93 |     |             token.burnFrom(sender, amount);
  94 |     |             burnt = amount;
  95 |     |         } else {
  96 |     |             burnt = LibTransfer.receiveToken(token, amount, sender, mode);
  97 |     |             token.burn(burnt);
  98 |     |         }
  99 |     |     }
 100 |     | 
 101 |     |     function mintToken(IBean token, uint256 amount, address recipient, To mode) internal {
 102 |     |         if (mode == To.EXTERNAL) {
 103 |     |             token.mint(recipient, amount);
 104 |     |         } else {
 105 |     |             token.mint(address(this), amount);
 106 |     |             LibTransfer.sendToken(token, amount, recipient, mode);
 107 |     |         }
 108 |     |     }
 109 |     | }
 110 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Token/LibWeth.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | import "../../interfaces/IWETH.sol";
  7 |     | import "../LibTractor.sol";
  8 |     | import "./LibTransfer.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title LibWeth handles wrapping and unwrapping Weth
 12 |     |  * Largely inspired by Balancer's Vault
 13 |     |  **/
 14 |     | 
 15 | *   | library LibWeth {
 16 |     |     address constant WETH = 0x4200000000000000000000000000000000000006;
 17 |     | 
 18 |     |     function wrap(uint256 amount, LibTransfer.To mode) internal {
 19 |     |         deposit(amount);
 20 |     |         LibTransfer.sendToken(IERC20(WETH), amount, LibTractor._user(), mode);
 21 |     |     }
 22 |     | 
 23 |     |     function unwrap(uint256 amount, LibTransfer.From mode) internal {
 24 |     |         amount = LibTransfer.receiveToken(IERC20(WETH), amount, LibTractor._user(), mode);
 25 |     |         withdraw(amount);
 26 |     |         (bool success, ) = LibTractor._user().call{value: amount}(new bytes(0));
 27 |     |         require(success, "Weth: unwrap failed");
 28 |     |     }
 29 |     | 
 30 |     |     function deposit(uint256 amount) private {
 31 |     |         IWETH(WETH).deposit{value: amount}();
 32 |     |     }
 33 |     | 
 34 |     |     function withdraw(uint256 amount) private {
 35 |     |         IWETH(WETH).withdraw(amount);
 36 |     |     }
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Well/LibWell.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
   8 |     | import {ICumulativePump} from "contracts/interfaces/basin/pumps/ICumulativePump.sol";
   9 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  10 |     | import {IWell, Call} from "contracts/interfaces/basin/IWell.sol";
  11 |     | import {C} from "contracts/C.sol";
  12 |     | import {LibAppStorage} from "../LibAppStorage.sol";
  13 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  14 |     | import {LibUsdOracle} from "contracts/libraries/Oracle/LibUsdOracle.sol";
  15 |     | import {LibRedundantMath128} from "contracts/libraries/Math/LibRedundantMath128.sol";
  16 |     | import {IMultiFlowPumpWellFunction} from "contracts/interfaces/basin/pumps/IMultiFlowPumpWellFunction.sol";
  17 |     | import {IBeanstalkWellFunction} from "contracts/interfaces/basin/IBeanstalkWellFunction.sol";
  18 |     | 
  19 |     | interface IERC20Decimals {
  20 |     |     function decimals() external view returns (uint8);
  21 |     | }
  22 |     | 
  23 |     | /**
  24 |     |  * @title Well Library
  25 |     |  * Contains helper functions for common Well related functionality.
  26 |     |  **/
  27 | *   | library LibWell {
  28 |     |     using LibRedundantMath256 for uint256;
  29 |     |     using LibRedundantMath128 for uint128;
  30 |     | 
  31 |     |     // The BDV Selector that all Wells should be whitelisted with.
  32 |     |     bytes4 internal constant WELL_BDV_SELECTOR = 0xc84c7727;
  33 |     | 
  34 |     |     uint256 private constant BEAN_UNIT = 1e6;
  35 |     | 
  36 |     |     function getRatiosAndBeanIndex(
  37 |     |         IERC20[] memory tokens
  38 |     |     ) internal view returns (uint[] memory ratios, uint beanIndex, bool success) {
  39 |     |         return getRatiosAndBeanIndex(tokens, 0);
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Returns the price ratios between `tokens` and the index of Bean in `tokens`.
  44 |     |      * These actions are combined into a single function for gas efficiency.
  45 |     |      */
  46 |     |     function getRatiosAndBeanIndex(
  47 |     |         IERC20[] memory tokens,
  48 |     |         uint256 lookback
  49 |     |     ) internal view returns (uint[] memory ratios, uint beanIndex, bool success) {
  50 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  51 |     |         success = true;
  52 |     |         ratios = new uint[](tokens.length);
  53 |     |         beanIndex = type(uint256).max;
  54 |     |         bool isMillion;
  55 |     |         address bean = s.sys.bean;
  56 |     | 
  57 |     |         // fetch the bean index and check whether the ratios precision needs to be increased.
  58 |     |         for (uint i; i < tokens.length; ++i) {
  59 |     |             if (address(tokens[i]) == bean) {
  60 |     |                 beanIndex = i;
  61 |     |             } else if (IERC20Decimals(address(tokens[i])).decimals() <= 8) {
  62 |     |                 // if the nonBean token in the well has a low decimal precision,
  63 |     |                 // set `isMillion` such that the ratio is set to be on a million basis.
  64 |     |                 isMillion = true;
  65 |     |             }
  66 |     |         }
  67 |     | 
  68 |     |         // get the target ratios.
  69 |     |         for (uint i; i < tokens.length; ++i) {
  70 |     |             if (address(tokens[i]) == bean) {
  71 |     |                 if (isMillion) {
  72 |     |                     ratios[i] = 1e12;
  73 |     |                 } else {
  74 |     |                     ratios[i] = 1e6;
  75 |     |                 }
  76 |     |             } else {
  77 |     |                 if (isMillion) {
  78 |     |                     ratios[i] = LibUsdOracle.getMillionUsdPrice(address(tokens[i]), lookback);
  79 |     |                 } else {
  80 |     |                     ratios[i] = LibUsdOracle.getUsdPrice(address(tokens[i]), lookback);
  81 |     |                 }
  82 |     |                 if (ratios[i] == 0) {
  83 |     |                     success = false;
  84 |     |                 }
  85 |     |             }
  86 |     |         }
  87 |     | 
  88 |     |         require(beanIndex != type(uint256).max, "Bean not in Well.");
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Returns the index of Bean in a list of tokens.
  93 |     |      */
  94 |     |     function getBeanIndex(IERC20[] memory tokens) internal view returns (uint beanIndex) {
  95 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  96 |     |         for (beanIndex; beanIndex < tokens.length; ++beanIndex) {
  97 |     |             if (s.sys.bean == address(tokens[beanIndex])) {
  98 |     |                 return beanIndex;
  99 |     |             }
 100 |     |         }
 101 |     |         revert("Bean not in Well.");
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev Returns the first ERC20 well token that is not Bean.
 106 |     |      */
 107 | *   |     function getNonBeanIndex(IERC20[] memory tokens) internal view returns (uint nonBeanIndex) {
 108 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 109 | *   |         for (nonBeanIndex; nonBeanIndex < tokens.length; ++nonBeanIndex) {
 110 | *   |             if (s.sys.bean != address(tokens[nonBeanIndex])) {
 111 | *   |                 return nonBeanIndex;
 112 |     |             }
 113 |     |         }
 114 |     |         revert("Non-Bean not in Well.");
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns the index of Bean given a Well.
 119 |     |      */
 120 |     |     function getBeanIndexFromWell(address well) internal view returns (uint beanIndex) {
 121 |     |         IERC20[] memory tokens = IWell(well).tokens();
 122 |     |         beanIndex = getBeanIndex(tokens);
 123 |     |     }
 124 |     | 
 125 | *   |     function getNonBeanTokenFromWell(address well) internal view returns (IERC20 nonBeanToken) {
 126 | *   |         IERC20[] memory tokens = IWell(well).tokens();
 127 | *   |         return tokens[getNonBeanIndex(tokens)];
 128 |     |     }
 129 |     | 
 130 |     |     /**
 131 |     |      * @dev Returns the non-Bean token within a Well.
 132 |     |      * Assumes a well with 2 tokens only, with Bean being one of them.
 133 |     |      * Cannot fail (and thus revert), as wells cannot have 2 of the same tokens as the pairing.
 134 |     |      */
 135 | *   |     function getNonBeanTokenAndIndexFromWell(
 136 |     |         address well
 137 | *   |     ) internal view returns (address, uint256) {
 138 | *   |         AppStorage storage s = LibAppStorage.diamondStorage();
 139 | *   |         IERC20[] memory tokens = IWell(well).tokens();
 140 | *   |         for (uint256 i; i < tokens.length; i++) {
 141 | *   |             if (address(tokens[i]) != s.sys.bean) {
 142 | *   |                 return (address(tokens[i]), i);
 143 |     |             }
 144 |     |         }
 145 |     |         revert("LibWell: invalid well:");
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Returns whether an address is a whitelisted Well by checking
 150 |     |      * if the BDV function selector is the `wellBdv` function.
 151 |     |      */
 152 |     |     function isWell(address well) internal view returns (bool _isWell) {
 153 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 154 |     |         return s.sys.silo.assetSettings[well].selector == WELL_BDV_SELECTOR;
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @notice gets the non-bean usd liquidity of a well,
 159 |     |      * using the twa reserves and price in storage.
 160 |     |      *
 161 |     |      * @dev this is done for gas efficency purposes, rather than calling the pump multiple times.
 162 |     |      * This function should be called after the reserves for the well have been set.
 163 |     |      * Currently this is only done in {seasonFacet.sunrise}.
 164 |     |      *
 165 |     |      * if LibWell.getUsdTokenPriceForWell() returns 1, then this function is called without the reserves being set.
 166 |     |      * if s.sys.usdTokenPrice[well] or s.sys.twaReserves[well] returns 0, then the oracle failed to compute
 167 |     |      * a valid price this Season, and thus beanstalk cannot calculate the usd liquidity.
 168 |     |      */
 169 |     |     function getWellTwaUsdLiquidityFromReserves(
 170 |     |         address well,
 171 |     |         uint256[] memory twaReserves
 172 |     |     ) internal view returns (uint256 usdLiquidity) {
 173 |     |         uint256 tokenUsd = getUsdTokenPriceForWell(well);
 174 |     |         (address token, uint256 j) = getNonBeanTokenAndIndexFromWell(well);
 175 |     |         if (tokenUsd > 1) {
 176 |     |             return twaReserves[j].mul(1e18).div(tokenUsd);
 177 |     |         }
 178 |     | 
 179 |     |         // if tokenUsd == 0, then the beanstalk could not compute a valid eth price,
 180 |     |         // and should return 0. if s.sys.twaReserves[well].reserve1 is 0, the previous if block will return 0.
 181 |     |         if (tokenUsd == 0) {
 182 |     |             return 0;
 183 |     |         }
 184 |     | 
 185 |     |         // if the function reaches here, then this is called outside the sunrise function
 186 |     |         // (i.e, seasonGetterFacet.getLiquidityToSupplyRatio()).We use LibUsdOracle
 187 |     |         // to get the price. This should never be reached during sunrise and thus
 188 |     |         // should not impact gas.
 189 |     |         // LibUsdOracle returns the price with 1e6 precision.
 190 |     |         // twaReserves has the same decimal precision as the token.
 191 |     |         // The return value is then used in LibEvaluate.calcLPToSupplyRatio that assumes 18 decimal precision,
 192 |     |         // so we need to account for whitelisted tokens that have less than 18 decimals by dividing the
 193 |     |         // precision by the token decimals.
 194 |     |         // Here tokenUsd = 1 so 1e6 * 1eN * 1e12 / 1eN = 1e18.
 195 |     | 
 196 |     |         uint8 tokenDecimals = IERC20Decimals(token).decimals();
 197 |     |         return
 198 |     |             LibUsdOracle.getTokenPrice(token).mul(twaReserves[j]).mul(1e12).div(
 199 |     |                 10 ** tokenDecimals
 200 |     |             );
 201 |     |     }
 202 |     | 
 203 |     |     /**
 204 |     |      * @dev Sets the price in {AppStorage.usdTokenPrice} given a set of ratios.
 205 |     |      * Assumes
 206 |     |      * 1) Ratios correspond to the Constant Product Well indexes.
 207 |     |      * 2) the Well is a 2 token Well.
 208 |     |      */
 209 |     |     function setUsdTokenPriceForWell(address well, uint256[] memory ratios) internal {
 210 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 211 |     | 
 212 |     |         // If the reserves length is 0, then {LibWellMinting} failed to compute
 213 |     |         // valid manipulation resistant reserves and thus the price is set to 0
 214 |     |         // indicating that the oracle failed to compute a valid price this Season.
 215 |     |         if (ratios.length == 0) {
 216 |     |             s.sys.usdTokenPrice[well] = 0;
 217 |     |         } else {
 218 |     |             (, uint256 j) = getNonBeanTokenAndIndexFromWell(well);
 219 |     |             uint256 i = j == 0 ? 1 : 0;
 220 |     |             // usdTokenPrice is scaled down to USD/TOKEN, in the cases where
 221 |     |             // Beanstalk calculated the MILLION_USD/TOKEN price instead of USD/TOKEN price.
 222 |     |             // Beanstalk accepts the loss of precision here, as `usdTokenPrice[well]` is used for
 223 |     |             // calculating the liquidity and excessive price.
 224 |     |             s.sys.usdTokenPrice[well] = (ratios[j] * 1e6) / ratios[i];
 225 |     |         }
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice Returns the USD / TKN price stored in {AppStorage.usdTokenPrice}.
 230 |     |      * @dev assumes TKN has 18 decimals.
 231 |     |      */
 232 |     |     function getUsdTokenPriceForWell(address well) internal view returns (uint tokenUsd) {
 233 |     |         tokenUsd = LibAppStorage.diamondStorage().sys.usdTokenPrice[well];
 234 |     |     }
 235 |     | 
 236 |     |     /**
 237 |     |      * @notice resets token price for a well to 1.
 238 |     |      * @dev must be called at the end of sunrise() once the
 239 |     |      * price is not needed anymore to save gas.
 240 |     |      */
 241 |     |     function resetUsdTokenPriceForWell(address well) internal {
 242 |     |         LibAppStorage.diamondStorage().sys.usdTokenPrice[well] = 1;
 243 |     |     }
 244 |     | 
 245 |     |     /**
 246 |     |      * @notice Returns the USD price of Bean in a given well.
 247 |     |      * @dev This function calculates the USD price of Bean by first determining the price of the non-Bean token in the well,
 248 |     |      * and then using the reserves from the pump to calculate the Bean price.
 249 |     |      * This can only be called during sunrise.
 250 |     |      * @param well The address of the well to calculate the Bean USD price for.
 251 |     |      * @return beanUsdPrice The USD price of Bean in the well.
 252 |     |      */
 253 |     |     function getBeanUsdPriceForWell(address well) internal view returns (uint256) {
 254 |     |         uint256 tokenBeanPrice = getTokenBeanPriceFromTwaReserves(well);
 255 |     |         return getBeanUsdPriceFromTokenBeanPrice(well, tokenBeanPrice);
 256 |     |     }
 257 |     | 
 258 |     |     /**
 259 |     |      * @notice Returns the USD price of Bean in a given well.
 260 |     |      * @dev This function calculates the USD price of Bean by first determining the price of the non-Bean token in the well,
 261 |     |      * and then using the reserves from the pump to calculate the Bean price.
 262 |     |      * This can only be called during sunrise.
 263 |     |      * @param well The address of the well to calculate the Bean USD price for.
 264 |     |      * @return beanUsdPrice The USD price of Bean in the well.
 265 |     |      */
 266 |     |     function getBeanUsdPriceFromTokenBeanPrice(
 267 |     |         address well,
 268 |     |         uint256 tokenBeanPrice
 269 |     |     ) internal view returns (uint256) {
 270 |     |         if (tokenBeanPrice == 0) {
 271 |     |             return 0;
 272 |     |         }
 273 |     | 
 274 |     |         address nonBeanToken = address(getNonBeanTokenFromWell(well));
 275 |     |         uint256 nonBeanTokenDecimals = IERC20Decimals(nonBeanToken).decimals();
 276 |     | 
 277 |     |         uint256 beanUsdPrice = uint256(10 ** (12 + nonBeanTokenDecimals)).div(
 278 |     |             getUsdTokenPriceForWell(well).mul(tokenBeanPrice)
 279 |     |         );
 280 |     | 
 281 |     |         return beanUsdPrice;
 282 |     |     }
 283 |     | 
 284 |     |     /**
 285 |     |      * @dev Sets the twaReserves in {AppStorage.usdTokenPrice}.
 286 |     |      * assumes the twaReserve indexes correspond to the Constant Product Well indexes.
 287 |     |      * if the length of the twaReserves is 0, then the minting oracle is off.
 288 |     |      *
 289 |     |      */
 290 |     |     function setTwaReservesForWell(address well, uint256[] memory twaReserves) internal {
 291 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 292 |     |         // if the length of twaReserves is 0, then return 0.
 293 |     |         // the length of twaReserves should never be 1, but
 294 |     |         // is added to prevent revert.
 295 |     |         if (twaReserves.length <= 1) {
 296 |     |             delete s.sys.twaReserves[well].reserve0;
 297 |     |             delete s.sys.twaReserves[well].reserve1;
 298 |     |         } else {
 299 |     |             // safeCast not needed as the reserves are uint128 in the wells.
 300 |     |             s.sys.twaReserves[well].reserve0 = uint128(twaReserves[0]);
 301 |     |             s.sys.twaReserves[well].reserve1 = uint128(twaReserves[1]);
 302 |     |         }
 303 |     |     }
 304 |     | 
 305 |     |     /**
 306 |     |      * @notice Returns the TKN / USD price stored in {AppStorage.usdTokenPrice}.
 307 |     |      * @dev assumes TKN has 18 decimals.
 308 |     |      */
 309 |     |     function getTwaReservesForWell(
 310 |     |         address well
 311 |     |     ) internal view returns (uint256[] memory twaReserves) {
 312 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 313 |     |         twaReserves = new uint256[](2);
 314 |     |         twaReserves[0] = s.sys.twaReserves[well].reserve0;
 315 |     |         twaReserves[1] = s.sys.twaReserves[well].reserve1;
 316 |     |     }
 317 |     | 
 318 |     |     /**
 319 |     |      * @notice resets token price for a well to 1.
 320 |     |      * @dev must be called at the end of sunrise() once the
 321 |     |      * price is not needed anymore to save gas.
 322 |     |      */
 323 |     |     function resetTwaReservesForWell(address well) internal {
 324 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 325 |     |         s.sys.twaReserves[well].reserve0 = 1;
 326 |     |         s.sys.twaReserves[well].reserve1 = 1;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @notice returns the price in terms of TKN/BEAN.
 331 |     |      * (if eth is 1000 beans, this function will return 1000e6);
 332 |     |      */
 333 |     |     function getTokenBeanPriceFromTwaReserves(address well) internal view returns (uint256 price) {
 334 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 335 |     |         // s.sys.twaReserve[well] should be set prior to this function being called.
 336 |     |         // 'price' is in terms of reserve0:reserve1.
 337 |     |         if (s.sys.twaReserves[well].reserve0 <= 1 || s.sys.twaReserves[well].reserve1 <= 1) {
 338 |     |             price = 0;
 339 |     |         } else {
 340 |     |             // fetch the bean index from the well in order to properly return the bean price.
 341 |     |             uint256[] memory reserves = new uint256[](2);
 342 |     |             reserves[0] = s.sys.twaReserves[well].reserve0;
 343 |     |             reserves[1] = s.sys.twaReserves[well].reserve1;
 344 |     | 
 345 |     |             Call memory wellFunction = IWell(well).wellFunction();
 346 |     | 
 347 |     |             if (getBeanIndexFromWell(well) == 0) {
 348 |     |                 price = calculateTokenBeanPriceFromReserves(well, 0, 1, reserves, wellFunction);
 349 |     |             } else {
 350 |     |                 price = calculateTokenBeanPriceFromReserves(well, 1, 0, reserves, wellFunction);
 351 |     |             }
 352 |     |         }
 353 |     |     }
 354 |     | 
 355 |     |     /**
 356 |     |      * @notice Calculates the token price in terms of Bean by increasing
 357 |     |      * the bean reserves of the given well by 1 and recaclulating the new reserves,
 358 |     |      * while maintaining the same liquidity levels.
 359 |     |      * This essentially simulates a swap of 1 Bean for the non bean token and quotes the price.
 360 |     |      * @dev wrapped in a try/catch to return gracefully.
 361 |     |      */
 362 |     |     function calculateTokenBeanPriceFromReserves(
 363 |     |         address well,
 364 |     |         uint256 beanIndex,
 365 |     |         uint256 nonBeanIndex,
 366 |     |         uint256[] memory reserves,
 367 |     |         Call memory wellFunction
 368 |     |     ) internal view returns (uint256 price) {
 369 |     |         // attempt to calculate the LP token Supply.
 370 |     |         try
 371 |     |             IBeanstalkWellFunction(wellFunction.target).calcLpTokenSupply(
 372 |     |                 reserves,
 373 |     |                 wellFunction.data
 374 |     |             )
 375 |     |         returns (uint256 lpTokenSupply) {
 376 |     |             address nonBeanToken = address(IWell(well).tokens()[nonBeanIndex]);
 377 |     |             uint256 oldReserve = reserves[nonBeanIndex];
 378 |     |             reserves[beanIndex] = reserves[beanIndex] + BEAN_UNIT;
 379 |     | 
 380 |     |             try
 381 |     |                 IBeanstalkWellFunction(wellFunction.target).calcReserve(
 382 |     |                     reserves,
 383 |     |                     nonBeanIndex,
 384 |     |                     lpTokenSupply,
 385 |     |                     wellFunction.data
 386 |     |                 )
 387 |     |             returns (uint256 newReserve) {
 388 |     |                 // Measure the delta of the non bean reserve.
 389 |     |                 // Due to the invariant of the well function, old reserve > new reserve.
 390 |     |                 uint256 delta = oldReserve - newReserve;
 391 |     |                 price = (10 ** (IERC20Decimals(nonBeanToken).decimals() + 6)) / delta;
 392 |     |             } catch {
 393 |     |                 return 0;
 394 |     |             }
 395 |     |         } catch {
 396 |     |             return 0;
 397 |     |         }
 398 |     |     }
 399 |     | 
 400 |     |     function getTwaReservesFromStorageOrBeanstalkPump(
 401 |     |         address well
 402 |     |     ) internal view returns (uint256[] memory twaReserves) {
 403 |     |         twaReserves = getTwaReservesForWell(well);
 404 |     |         if (twaReserves[0] == 1) {
 405 |     |             twaReserves = getTwaReservesFromPump(well);
 406 |     |         }
 407 |     |     }
 408 |     | 
 409 |     |     /**
 410 |     |      * @notice gets the TwaReserves of a given well.
 411 |     |      * @dev only supports wells that are whitelisted in beanstalk.
 412 |     |      * the initial timestamp and reserves is the timestamp of the start
 413 |     |      * of the last season. wrapped in try/catch to return gracefully.
 414 |     |      */
 415 |     |     function getTwaReservesFromPump(address well) internal view returns (uint256[] memory) {
 416 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 417 |     |         Call[] memory pumps = IWell(well).pumps();
 418 |     |         try
 419 |     |             ICumulativePump(pumps[0].target).readTwaReserves(
 420 |     |                 well,
 421 |     |                 s.sys.wellOracleSnapshots[well],
 422 |     |                 uint40(s.sys.season.timestamp),
 423 |     |                 pumps[0].data
 424 |     |             )
 425 |     |         returns (uint[] memory twaReserves, bytes memory) {
 426 |     |             return twaReserves;
 427 |     |         } catch {
 428 |     |             return (new uint256[](2));
 429 |     |         }
 430 |     |     }
 431 |     | 
 432 |     |     /**
 433 |     |      * @notice returns the twa reserves for well,
 434 |     |      * given the cumulative reserves and timestamp.
 435 |     |      * @dev wrapped in a try/catch to return gracefully.
 436 |     |      */
 437 |     |     function getTwaReservesFromPump(
 438 |     |         address well,
 439 |     |         bytes memory cumulativeReserves,
 440 |     |         uint40 timestamp
 441 |     |     ) internal view returns (uint256[] memory) {
 442 |     |         Call[] memory pump = IWell(well).pumps();
 443 |     |         try
 444 |     |             ICumulativePump(pump[0].target).readTwaReserves(
 445 |     |                 well,
 446 |     |                 cumulativeReserves,
 447 |     |                 timestamp,
 448 |     |                 pump[0].data
 449 |     |             )
 450 |     |         returns (uint[] memory twaReserves, bytes memory) {
 451 |     |             return twaReserves;
 452 |     |         } catch {
 453 |     |             return (new uint256[](2));
 454 |     |         }
 455 |     |     }
 456 |     | 
 457 |     |     /**
 458 |     |      * @notice gets the TwaLiquidity of a given well.
 459 |     |      * @dev only supports wells that are whitelisted in beanstalk.
 460 |     |      * the initial timestamp and reserves is the timestamp of the start
 461 |     |      * of the last season.
 462 |     |      */
 463 |     |     function getTwaLiquidityFromPump(
 464 |     |         address well,
 465 |     |         uint256 tokenUsdPrice
 466 |     |     ) internal view returns (uint256 usdLiquidity) {
 467 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 468 |     |         (, uint256 j) = getNonBeanTokenAndIndexFromWell(well);
 469 |     |         Call[] memory pumps = IWell(well).pumps();
 470 |     |         try
 471 |     |             ICumulativePump(pumps[0].target).readTwaReserves(
 472 |     |                 well,
 473 |     |                 s.sys.wellOracleSnapshots[well],
 474 |     |                 uint40(s.sys.season.timestamp),
 475 |     |                 pumps[0].data
 476 |     |             )
 477 |     |         returns (uint[] memory twaReserves, bytes memory) {
 478 |     |             usdLiquidity = tokenUsdPrice.mul(twaReserves[j]).div(1e6);
 479 |     |         } catch {
 480 |     |             // if pump fails to return a value, return 0.
 481 |     |             usdLiquidity = 0;
 482 |     |         }
 483 |     |     }
 484 |     | }
 485 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/libraries/Well/LibWellBdv.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {LibRedundantMath256} from "contracts/libraries/Math/LibRedundantMath256.sol";
  8 |     | import {IInstantaneousPump} from "contracts/interfaces/basin/pumps/IInstantaneousPump.sol";
  9 |     | import {Call, IWell} from "contracts/interfaces/basin/IWell.sol";
 10 |     | import {IWellFunction} from "contracts/interfaces/basin/IWellFunction.sol";
 11 |     | import {LibWell} from "contracts/libraries/Well/LibWell.sol";
 12 |     | import {C} from "contracts/C.sol";
 13 |     | 
 14 |     | /**
 15 |     |  * @title Well Bdv Library
 16 |     |  * @notice contains a function to calulate the BDV of a given Well LP Token
 17 |     |  **/
 18 | *   | library LibWellBdv {
 19 |     |     using LibRedundantMath256 for uint256;
 20 |     | 
 21 |     |     uint private constant BEAN_UNIT = 1e6;
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Calculates the `_bdv` of a given Well LP Token given a relevant
 25 |     |      * `well` and `amount` value by computing the delta LP token supply given a small change in the Bean reserve balance.
 26 |     |      */
 27 |     |     function bdv(address well, uint amount) internal view returns (uint _bdv) {
 28 |     |         uint beanIndex = LibWell.getBeanIndexFromWell(well);
 29 |     | 
 30 |     |         // For now, assume Beanstalk should always use the first pump and given that the Well has been whitelisted, it should be assumed
 31 |     |         // that the first Pump has been verified when the Well was whitelisted.
 32 |     |         Call[] memory pumps = IWell(well).pumps();
 33 |     |         uint[] memory reserves = IInstantaneousPump(pumps[0].target).readInstantaneousReserves(
 34 |     |             well,
 35 |     |             pumps[0].data
 36 |     |         );
 37 |     |         // If the Bean reserve is beneath the minimum balance, the oracle should be considered as off.
 38 |     |         require(
 39 |     |             reserves[beanIndex] >= C.WELL_MINIMUM_BEAN_BALANCE,
 40 |     |             "Silo: Well Bean balance below min"
 41 |     |         );
 42 |     |         Call memory wellFunction = IWell(well).wellFunction();
 43 |     |         uint lpTokenSupplyBefore = IWellFunction(wellFunction.target).calcLpTokenSupply(
 44 |     |             reserves,
 45 |     |             wellFunction.data
 46 |     |         );
 47 |     |         reserves[beanIndex] = reserves[beanIndex].sub(BEAN_UNIT); // remove one Bean
 48 |     |         uint deltaLPTokenSupply = lpTokenSupplyBefore.sub(
 49 |     |             IWellFunction(wellFunction.target).calcLpTokenSupply(reserves, wellFunction.data)
 50 |     |         );
 51 |     |         _bdv = amount.mul(BEAN_UNIT).div(deltaLPTokenSupply);
 52 |     |     }
 53 |     | }
 54 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/MockBudget.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IBudget} from "contracts/interfaces/IBudget.sol";
  6 |     | 
  7 | *   | contract MockBudget is IBudget {
  8 |     |     event Distribute();
  9 |     | 
 10 | *   |     constructor() {}
 11 |     | 
 12 |     |     function distribute() external {
 13 |     |         emit Distribute();
 14 |     |     }
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/MockChainlinkAggregator.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import "contracts/interfaces/IChainlinkAggregator.sol";
   7 |     | 
   8 | *   | contract MockChainlinkAggregator is IChainlinkAggregator {
   9 |     |     uint80 lastRound;
  10 |     |     mapping(uint80 => int256) answers;
  11 |     |     mapping(uint80 => uint256) startedAts;
  12 |     |     mapping(uint80 => uint256) updatedAts;
  13 |     |     mapping(uint80 => uint80) answeredInRounds;
  14 |     |     uint8 _decimals;
  15 |     | 
  16 | *   |     function decimals() external view override returns (uint8) {
  17 | *   |         return _decimals;
  18 |     |     }
  19 |     | 
  20 |     |     function description() external pure override returns (string memory) {
  21 |     |         return "Mock Chainlink Aggregator";
  22 |     |     }
  23 |     | 
  24 |     |     function version() external pure override returns (uint256) {
  25 |     |         return 1;
  26 |     |     }
  27 |     | 
  28 | *   |     function getLatestRoundId() external view returns (uint80) {
  29 | *   |         return lastRound;
  30 |     |     }
  31 |     | 
  32 |     |     function getRoundData(
  33 |     |         uint80 _roundId
  34 |     |     )
  35 |     |         external
  36 |     |         view
  37 |     |         override
  38 |     |         returns (
  39 |     |             uint80 roundId,
  40 |     |             int256 answer,
  41 |     |             uint256 startedAt,
  42 |     |             uint256 updatedAt,
  43 |     |             uint80 answeredInRound
  44 |     |         )
  45 |     |     {
  46 |     |         if (_roundId > lastRound) revert();
  47 |     |         if (_roundId == 0) revert();
  48 |     |         roundId = _roundId;
  49 |     |         answer = answers[_roundId];
  50 |     |         startedAt = startedAts[_roundId];
  51 |     |         updatedAt = updatedAts[_roundId];
  52 |     |         answeredInRound = answeredInRounds[_roundId];
  53 |     |     }
  54 |     | 
  55 | *   |     function latestRoundData()
  56 |     |         external
  57 |     |         view
  58 |     |         override
  59 |     |         returns (
  60 | *   |             uint80 roundId,
  61 | *   |             int256 answer,
  62 | *   |             uint256 startedAt,
  63 | *   |             uint256 updatedAt,
  64 | *   |             uint80 answeredInRound
  65 |     |         )
  66 |     |     {
  67 | *   |         if (lastRound == 0) revert();
  68 | *   |         roundId = lastRound;
  69 | *   |         answer = answers[lastRound];
  70 | *   |         startedAt = startedAts[lastRound];
  71 | *   |         updatedAt = updatedAts[lastRound];
  72 | *   |         answeredInRound = answeredInRounds[lastRound];
  73 |     |     }
  74 |     | 
  75 | *   |     function addRound(
  76 |     |         int256 answer,
  77 |     |         uint256 startedAt,
  78 |     |         uint256 updatedAt,
  79 |     |         uint80 answeredInRound
  80 |     |     ) external {
  81 | *   |         lastRound += 1;
  82 | *   |         answers[lastRound] = answer;
  83 | *   |         startedAts[lastRound] = startedAt;
  84 | *   |         updatedAts[lastRound] = updatedAt;
  85 | *   |         answeredInRounds[lastRound] = answeredInRound;
  86 |     |     }
  87 |     | 
  88 |     |     function setRound(
  89 |     |         uint80 roundId,
  90 |     |         int256 answer,
  91 |     |         uint256 startedAt,
  92 |     |         uint256 updatedAt,
  93 |     |         uint80 answeredInRound
  94 |     |     ) external {
  95 |     |         answers[roundId] = answer;
  96 |     |         startedAts[roundId] = startedAt;
  97 |     |         updatedAts[roundId] = updatedAt;
  98 |     |         answeredInRounds[roundId] = answeredInRound;
  99 |     |     }
 100 |     | 
 101 | *   |     function setDecimals(uint8 __decimals) external {
 102 | *   |         _decimals = __decimals;
 103 |     |     }
 104 |     | 
 105 |     |     function setOracleFailure() external {
 106 |     |         lastRound = 0;
 107 |     |     }
 108 |     | }
 109 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/MockPayback.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import {IPayback} from "contracts/interfaces/IPayback.sol";
  7 |     | 
  8 | *   | contract MockPayback is IPayback {
  9 | *   |     uint256 constant INITIAL_REMAINING = 1_000_000_000e6;
 10 |     | 
 11 |     |     address bean;
 12 |     |     uint256 remainingBean;
 13 |     |     uint256 amountPaid;
 14 |     | 
 15 | *   |     constructor(address beanAddress) {
 16 | *   |         bean = beanAddress;
 17 | *   |         remainingBean = INITIAL_REMAINING;
 18 |     |     }
 19 |     | 
 20 |     |     function siloRemaining() external view returns (uint256) {
 21 |     |         uint256 balance = IERC20(bean).balanceOf(address(this));
 22 |     |         // Silo gets paid off first.
 23 |     |         uint256 remaining = (remainingBean * 1) / 4;
 24 |     |         if (remaining > balance) {
 25 |     |             return remaining - balance;
 26 |     |         }
 27 |     |         return 0;
 28 |     |     }
 29 |     | 
 30 |     |     function barnRemaining() external view returns (uint256) {
 31 |     |         uint256 balance = IERC20(bean).balanceOf(address(this));
 32 |     |         if (remainingBean > balance) {
 33 |     |             return remainingBean - balance;
 34 |     |         }
 35 |     |         return 0;
 36 |     |     }
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/MockShipmentPlanner.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import {ShipmentPlan, IBeanstalk} from "contracts/ecosystem/ShipmentPlanner.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ShipmentPlanner
 10 |     |  * @notice Same as standard Shipment planner, but implements two Fields with different points.
 11 |     |  */
 12 |     | contract MockShipmentPlanner {
 13 |     |     uint256 constant SILO_POINTS = 5_000_000_000_000_000;
 14 |     |     uint256 constant FIELD_1_POINTS = 5_000_000_000_000_000;
 15 |     |     uint256 constant FIELD_0_POINTS = FIELD_1_POINTS / 5;
 16 |     | 
 17 |     |     IBeanstalk beanstalk;
 18 |     |     IERC20 bean;
 19 |     | 
 20 |     |     constructor(address beanstalkAddress, address beanAddress) {
 21 |     |         beanstalk = IBeanstalk(beanstalkAddress);
 22 |     |         bean = IERC20(beanAddress);
 23 |     |     }
 24 |     | 
 25 |     |     function getSiloPlan(bytes memory) external pure returns (ShipmentPlan memory shipmentPlan) {
 26 |     |         return ShipmentPlan({points: SILO_POINTS, cap: type(uint256).max});
 27 |     |     }
 28 |     | 
 29 |     |     function getFieldPlanMulti(
 30 |     |         bytes memory data
 31 |     |     ) external view returns (ShipmentPlan memory shipmentPlan) {
 32 |     |         uint256 fieldId = abi.decode(data, (uint256));
 33 |     |         require(fieldId < beanstalk.fieldCount(), "Field does not exist");
 34 |     |         if (!beanstalk.isHarvesting(fieldId)) return shipmentPlan;
 35 |     |         uint256 points;
 36 |     |         if (fieldId == 0) points = FIELD_0_POINTS;
 37 |     |         else if (fieldId == 1) points = FIELD_1_POINTS;
 38 |     |         else revert("Field plan does not exist");
 39 |     |         return ShipmentPlan({points: points, cap: beanstalk.totalUnharvestable(fieldId)});
 40 |     |     }
 41 |     | }
 42 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/MockToken.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  8 |     | import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title Mock Token
 12 |     |  **/
 13 | *   | contract MockToken is ERC20, ERC20Burnable {
 14 | *   |     uint8 private _decimals = 18;
 15 | *   |     string private _symbol = "MOCK";
 16 | *   |     string private _name = "MockToken";
 17 |     | 
 18 | *   |     constructor(string memory name, string memory __symbol) ERC20(name, __symbol) {}
 19 |     | 
 20 | *   |     function mint(address account, uint256 amount) external returns (bool) {
 21 | *   |         _mint(account, amount);
 22 | *   |         return true;
 23 |     |     }
 24 |     | 
 25 |     |     function burnFrom(address account, uint256 amount) public override(ERC20Burnable) {
 26 |     |         ERC20Burnable.burnFrom(account, amount);
 27 |     |     }
 28 |     | 
 29 |     |     function burn(uint256 amount) public override {
 30 |     |         ERC20Burnable.burn(amount);
 31 |     |     }
 32 |     | 
 33 | *   |     function setDecimals(uint256 dec) public {
 34 | *   |         _decimals = uint8(dec);
 35 |     |     }
 36 |     | 
 37 | *   |     function decimals() public view virtual override returns (uint8) {
 38 | *   |         return _decimals;
 39 |     |     }
 40 |     | 
 41 |     |     function setSymbol(string memory sym) public {
 42 |     |         _symbol = sym;
 43 |     |     }
 44 |     | 
 45 |     |     function symbol() public view virtual override returns (string memory) {
 46 |     |         return _symbol;
 47 |     |     }
 48 |     | 
 49 |     |     function setName(string memory name_) public {
 50 |     |         _name = name_;
 51 |     |     }
 52 |     | }
 53 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockAttackFacet.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  8 |     | 
  9 |     | import {C} from "contracts/C.sol";
 10 |     | import {Invariable} from "contracts/beanstalk/Invariable.sol";
 11 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
 12 |     | import {LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
 13 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
 14 |     | import {LibBalance} from "contracts/libraries/Token/LibBalance.sol";
 15 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
 16 |     | import {LibWeth} from "contracts/libraries/Token/LibWeth.sol";
 17 |     | 
 18 |     | /**
 19 |     |  * @title Mock Attack Facet
 20 |     |  * @notice Facet for simulating attacks by directly manipulating underlying Beanstalk state.
 21 |     |  **/
 22 |     | contract MockAttackFacet is Invariable {
 23 |     |     AppStorage internal s;
 24 |     | 
 25 |     |     address constant BEAN_ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd;
 26 |     |     address constant WETH = LibWeth.WETH;
 27 |     | 
 28 |     |     function revert_netFlow() external noNetFlow {
 29 |     |         BeanstalkERC20(s.sys.bean).transferFrom(msg.sender, address(this), 1);
 30 |     |     }
 31 |     | 
 32 |     |     function revert_outFlow() external noOutFlow {
 33 |     |         BeanstalkERC20(s.sys.bean).transfer(msg.sender, 1);
 34 |     |     }
 35 |     | 
 36 |     |     function revert_oneOutFlow() external oneOutFlow(s.sys.bean) {
 37 |     |         BeanstalkERC20(s.sys.bean).transfer(msg.sender, 1);
 38 |     |         IERC20(WETH).transfer(msg.sender, 1);
 39 |     |     }
 40 |     | 
 41 |     |     function revert_supplyChange() external noSupplyChange {
 42 |     |         BeanstalkERC20(s.sys.bean).burn(1);
 43 |     |     }
 44 |     | 
 45 |     |     function revert_supplyIncrease() external noSupplyIncrease {
 46 |     |         BeanstalkERC20(s.sys.bean).mint(msg.sender, 1);
 47 |     |     }
 48 |     | 
 49 |     |     ////// Variations of asset theft, internal and external ///////
 50 |     | 
 51 |     |     /**
 52 |     |      * @notice Simulates stealing of Bean from Beanstalk diamond.
 53 |     |      * @dev Does not directly trigger an invariant failure.
 54 |     |      */
 55 |     |     function stealBeans(uint256 amount) external {
 56 |     |         BeanstalkERC20(s.sys.bean).transfer(msg.sender, amount);
 57 |     |     }
 58 |     | 
 59 |     |     function exploitUserInternalTokenBalance() public {
 60 |     |         LibBalance.increaseInternalBalance(msg.sender, IERC20(s.sys.bean), 100_000_000);
 61 |     |     }
 62 |     | 
 63 |     |     function exploitUserSendTokenInternal() public {
 64 |     |         LibTransfer.sendToken(
 65 |     |             IERC20(BEAN_ETH_WELL),
 66 |     |             100_000_000_000,
 67 |     |             msg.sender,
 68 |     |             LibTransfer.To.INTERNAL
 69 |     |         );
 70 |     |     }
 71 |     | 
 72 |     |     function exploitSop() public {
 73 |     |         s.sys.sop.plentyPerSopToken[WETH] = 100_000_000;
 74 |     |     }
 75 |     | 
 76 |     |     function exploitPodOrderBeans() public {
 77 |     |         s.sys.orderLockedBeans = 100_000_000;
 78 |     |     }
 79 |     | }
 80 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockConvertFacet.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "../../beanstalk/facets/silo/ConvertFacet.sol";
  8 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  9 |     | import {LibConvert} from "contracts/libraries/Convert/LibConvert.sol";
 10 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title Mock Convert Facet
 14 |     |  **/
 15 |     | contract MockConvertFacet is ConvertFacet {
 16 |     |     using LibRedundantMath256 for uint256;
 17 |     |     using SafeERC20 for IERC20;
 18 |     | 
 19 |     |     event MockConvert(uint256 stalkRemoved, uint256 bdvRemoved);
 20 |     | 
 21 |     |     function withdrawForConvertE(
 22 |     |         address token,
 23 |     |         int96[] memory stems,
 24 |     |         uint256[] memory amounts,
 25 |     |         uint256 maxTokens // address account
 26 |     |     ) external {
 27 |     |         LibSilo._mow(msg.sender, token);
 28 |     |         // if (account == address(0)) account = msg.sender;
 29 |     |         (uint256 stalkRemoved, uint256 bdvRemoved, uint256 deltaRainRoots) = LibConvert
 30 |     |             ._withdrawTokens(token, stems, amounts, maxTokens, LibTractor._user());
 31 |     | 
 32 |     |         emit MockConvert(stalkRemoved, bdvRemoved);
 33 |     |     }
 34 |     | 
 35 |     |     function depositForConvertE(
 36 |     |         address token,
 37 |     |         uint256 amount,
 38 |     |         uint256 bdv,
 39 |     |         uint256 grownStalk,
 40 |     |         uint256 deltaRainRoots // address account
 41 |     |     ) external {
 42 |     |         LibSilo._mow(msg.sender, token);
 43 |     |         // if (account == address(0)) account = msg.sender;
 44 |     |         LibConvert._depositTokensForConvert(
 45 |     |             token,
 46 |     |             amount,
 47 |     |             bdv,
 48 |     |             grownStalk,
 49 |     |             deltaRainRoots,
 50 |     |             LibTractor._user()
 51 |     |         );
 52 |     |     }
 53 |     | 
 54 |     |     function convertInternalE(
 55 |     |         address tokenIn,
 56 |     |         uint amountIn,
 57 |     |         bytes calldata convertData
 58 |     |     )
 59 |     |         external
 60 |     |         returns (
 61 |     |             address toToken,
 62 |     |             address fromToken,
 63 |     |             uint256 toAmount,
 64 |     |             uint256 fromAmount,
 65 |     |             address account,
 66 |     |             bool decreaseBDV
 67 |     |         )
 68 |     |     {
 69 |     |         IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);
 70 |     |         LibConvert.ConvertParams memory cp = LibConvert.convert(convertData);
 71 |     |         toToken = cp.toToken;
 72 |     |         fromToken = cp.fromToken;
 73 |     |         toAmount = cp.toAmount;
 74 |     |         fromAmount = cp.fromAmount;
 75 |     |         account = cp.account;
 76 |     |         decreaseBDV = cp.decreaseBDV;
 77 |     |         IERC20(toToken).safeTransfer(msg.sender, toAmount);
 78 |     |     }
 79 |     | }
 80 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockFieldFacet.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
   8 |     | import {LibPRBMathRoundable} from "contracts/libraries/Math/LibPRBMathRoundable.sol";
   9 |     | import "contracts/libraries/Math/LibRedundantMath256.sol";
  10 |     | import "contracts/beanstalk/facets/field/FieldFacet.sol";
  11 |     | import {LibGaugeHelpers} from "contracts/libraries/LibGaugeHelpers.sol";
  12 |     | import {GaugeId} from "contracts/beanstalk/storage/System.sol";
  13 |     | /**
  14 |     |  * @title Mock Field Facet
  15 |     |  **/
  16 |     | contract MockFieldFacet is FieldFacet {
  17 |     |     using LibPRBMathRoundable for uint256;
  18 |     |     using LibRedundantMath256 for uint256;
  19 |     |     using LibRedundantMath128 for uint128;
  20 |     | 
  21 |     |     function incrementTotalSoilE(uint128 amount) external {
  22 |     |         s.sys.soil += amount;
  23 |     |     }
  24 |     | 
  25 |     |     function incrementTotalHarvestableE(uint256 fieldId, uint256 amount) external {
  26 |     |         BeanstalkERC20(s.sys.bean).mint(address(this), amount);
  27 |     |         s.sys.fields[fieldId].harvestable += amount;
  28 |     |     }
  29 |     | 
  30 |     |     function incrementTotalPodsE(uint256 fieldId, uint256 amount) external {
  31 |     |         s.sys.fields[fieldId].pods += amount;
  32 |     |     }
  33 |     | 
  34 |     |     function setUnharvestable(uint256 amount) external {
  35 |     |         // Get current harvestable index
  36 |     |         uint256 currentIndex = s.sys.fields[s.sys.activeField].harvestable;
  37 |     |         // Set pods for the current field
  38 |     |         s.sys.fields[s.sys.activeField].harvestable = currentIndex + amount;
  39 |     |     }
  40 |     | 
  41 |     |     function totalRealSoil() external view returns (uint256) {
  42 |     |         return s.sys.soil;
  43 |     |     }
  44 |     | 
  45 |     |     function beanSown() external view returns (uint256) {
  46 |     |         return s.sys.beanSown;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev used for testing purposes - refactor field facet upon next field deployment,
  51 |     |      * to avoid duplicate code.
  52 |     |      */
  53 |     |     function mockGetMorningTemp(
  54 |     |         uint256 initalTemp,
  55 |     |         uint256 delta
  56 |     |     ) external pure returns (uint256 scaledTemperature) {
  57 |     |         // check most likely case first
  58 |     |         if (delta > 24) {
  59 |     |             return uint256(initalTemp);
  60 |     |         }
  61 |     | 
  62 |     |         // Binary Search
  63 |     |         if (delta < 13) {
  64 |     |             if (delta < 7) {
  65 |     |                 if (delta < 4) {
  66 |     |                     if (delta < 2) {
  67 |     |                         // delta == 0, same block as sunrise
  68 |     |                         if (delta < 1) {
  69 |     |                             return _scaleTemperature(10000000000, initalTemp);
  70 |     |                         } else {
  71 |     |                             // delta == 1
  72 |     |                             return _scaleTemperature(279415312704, initalTemp);
  73 |     |                         }
  74 |     |                     }
  75 |     |                     if (delta == 2) {
  76 |     |                         return _scaleTemperature(409336034395, initalTemp);
  77 |     |                     } else {
  78 |     |                         // delta == 3
  79 |     |                         return _scaleTemperature(494912626048, initalTemp);
  80 |     |                     }
  81 |     |                 }
  82 |     |                 if (delta < 6) {
  83 |     |                     if (delta == 4) {
  84 |     |                         return _scaleTemperature(558830625409, initalTemp);
  85 |     |                     } else {
  86 |     |                         // delta == 5
  87 |     |                         return _scaleTemperature(609868162219, initalTemp);
  88 |     |                     }
  89 |     |                 } else {
  90 |     |                     // delta == 6
  91 |     |                     return _scaleTemperature(652355825780, initalTemp);
  92 |     |                 }
  93 |     |             }
  94 |     |             if (delta < 10) {
  95 |     |                 if (delta < 9) {
  96 |     |                     if (delta == 7) {
  97 |     |                         return _scaleTemperature(688751347100, initalTemp);
  98 |     |                     } else {
  99 |     |                         // delta == 8
 100 |     |                         return _scaleTemperature(720584687295, initalTemp);
 101 |     |                     }
 102 |     |                 } else {
 103 |     |                     // delta == 9
 104 |     |                     return _scaleTemperature(748873234524, initalTemp);
 105 |     |                 }
 106 |     |             }
 107 |     |             if (delta < 12) {
 108 |     |                 if (delta == 10) {
 109 |     |                     return _scaleTemperature(774327938752, initalTemp);
 110 |     |                 } else {
 111 |     |                     // delta == 11
 112 |     |                     return _scaleTemperature(797465225780, initalTemp);
 113 |     |                 }
 114 |     |             } else {
 115 |     |                 // delta == 12
 116 |     |                 return _scaleTemperature(818672068791, initalTemp);
 117 |     |             }
 118 |     |         }
 119 |     |         if (delta < 19) {
 120 |     |             if (delta < 16) {
 121 |     |                 if (delta < 15) {
 122 |     |                     if (delta == 13) {
 123 |     |                         return _scaleTemperature(838245938114, initalTemp);
 124 |     |                     } else {
 125 |     |                         // delta == 14
 126 |     |                         return _scaleTemperature(856420437864, initalTemp);
 127 |     |                     }
 128 |     |                 } else {
 129 |     |                     // delta == 15
 130 |     |                     return _scaleTemperature(873382373802, initalTemp);
 131 |     |                 }
 132 |     |             }
 133 |     |             if (delta < 18) {
 134 |     |                 if (delta == 16) {
 135 |     |                     return _scaleTemperature(889283474924, initalTemp);
 136 |     |                 } else {
 137 |     |                     // delta == 17
 138 |     |                     return _scaleTemperature(904248660443, initalTemp);
 139 |     |                 }
 140 |     |             } else {
 141 |     |                 // delta == 18
 142 |     |                 return _scaleTemperature(918382006208, initalTemp);
 143 |     |             }
 144 |     |         }
 145 |     |         if (delta < 22) {
 146 |     |             if (delta < 21) {
 147 |     |                 if (delta == 19) {
 148 |     |                     return _scaleTemperature(931771138485, initalTemp);
 149 |     |                 } else {
 150 |     |                     // delta == 20
 151 |     |                     return _scaleTemperature(944490527707, initalTemp);
 152 |     |                 }
 153 |     |             } else {
 154 |     |                 // delta = 21
 155 |     |                 return _scaleTemperature(956603996980, initalTemp);
 156 |     |             }
 157 |     |         }
 158 |     |         if (delta <= 23) {
 159 |     |             if (delta == 22) {
 160 |     |                 return _scaleTemperature(968166659804, initalTemp);
 161 |     |             } else {
 162 |     |                 // delta == 23
 163 |     |                 return _scaleTemperature(979226436102, initalTemp);
 164 |     |             }
 165 |     |         } else {
 166 |     |             // delta == 24
 167 |     |             return _scaleTemperature(989825252096, initalTemp);
 168 |     |         }
 169 |     |     }
 170 |     | 
 171 |     |     function _scaleTemperature(
 172 |     |         uint256 pct,
 173 |     |         uint256 initalTemp
 174 |     |     ) private pure returns (uint256 scaledTemperature) {
 175 |     |         // To save gas, `pct` is pre-calculated to 12 digits. Here we
 176 |     |         // perform the following transformation:
 177 |     |         // (1e6)    maxTemperature
 178 |     |         // (1e12)    * pct
 179 |     |         // (1e12)     / TEMPERATURE_DIVISOR
 180 |     |         // (1e6)     = scaledYield
 181 |     |         scaledTemperature = initalTemp.mulDiv(pct, 1e12, LibPRBMathRoundable.Rounding.Up);
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @notice allows for sowing specific amount of soil at temp
 186 |     |      */
 187 |     |     function mockSow(
 188 |     |         uint256 beans,
 189 |     |         uint256 _morningTemperature,
 190 |     |         uint32 maxTemperature,
 191 |     |         bool abovePeg
 192 |     |     ) external returns (uint256 pods) {
 193 |     |         s.sys.weather.temp = maxTemperature;
 194 |     |         pods = LibDibbler.sow(beans, _morningTemperature, msg.sender, abovePeg);
 195 |     |         return pods;
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @notice returns the total soil at a certain morning temperature.
 200 |     |      */
 201 |     |     function totalSoilAtMorningTemp(
 202 |     |         uint256 morningTemperature
 203 |     |     ) external view returns (uint256 totalSoil) {
 204 |     |         // Above peg: Soil is dynamic
 205 |     |         return
 206 |     |             LibDibbler.scaleSoilUp(
 207 |     |                 uint256(s.sys.soil), // min soil
 208 |     |                 uint256(s.sys.weather.temp), // max temperature
 209 |     |                 morningTemperature // temperature adjusted by number of blocks since Sunrise
 210 |     |             );
 211 |     |     }
 212 |     | 
 213 |     |     function setMaxTemp(uint32 t) external {
 214 |     |         s.sys.weather.temp = t;
 215 |     |     }
 216 |     | 
 217 |     |     function setCultivationFactor(uint256 cultivationFactor) external {
 218 |     |         s.sys.gaugeData.gauges[GaugeId.CULTIVATION_FACTOR].value = abi.encode(cultivationFactor);
 219 |     |     }
 220 |     | }
 221 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockPipelineConvertFacet.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "../../beanstalk/facets/silo/PipelineConvertFacet.sol";
  8 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  9 |     | import {LibConvert} from "contracts/libraries/Convert/LibConvert.sol";
 10 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @title Mock Pipeline Convert Facet
 14 |     |  **/
 15 |     | contract MockPipelineConvertFacet is PipelineConvertFacet {
 16 |     |     function calculateConvertCapacityPenaltyE(
 17 |     |         uint256 overallCappedDeltaB,
 18 |     |         uint256 overallAmountInDirectionOfPeg,
 19 |     |         address inputToken,
 20 |     |         uint256 inputTokenAmountInDirectionOfPeg,
 21 |     |         address outputToken,
 22 |     |         uint256 outputTokenAmountInDirectionOfPeg
 23 |     |     ) external view returns (uint256 cumulativePenalty, LibConvert.PenaltyData memory pdCapacity) {
 24 |     |         (cumulativePenalty, pdCapacity) = LibConvert.calculateConvertCapacityPenalty(
 25 |     |             overallCappedDeltaB,
 26 |     |             overallAmountInDirectionOfPeg,
 27 |     |             inputToken,
 28 |     |             inputTokenAmountInDirectionOfPeg,
 29 |     |             outputToken,
 30 |     |             outputTokenAmountInDirectionOfPeg
 31 |     |         );
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockSeasonFacet.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT*/
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import "contracts/libraries/Math/LibRedundantMath256.sol";
   7 |     | import "contracts/beanstalk/facets/sun/SeasonFacet.sol";
   8 |     | import {AssetSettings, Deposited, Field, GerminationSide} from "contracts/beanstalk/storage/System.sol";
   9 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  10 |     | import {IERC1155} from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
  11 |     | import "../MockToken.sol";
  12 |     | import "contracts/libraries/LibBytes.sol";
  13 |     | import {LibChainlinkOracle} from "contracts/libraries/Oracle/LibChainlinkOracle.sol";
  14 |     | import {LibUsdOracle} from "contracts/libraries/Oracle/LibUsdOracle.sol";
  15 |     | import {LibAppStorage} from "contracts/libraries/LibAppStorage.sol";
  16 |     | import {LibRedundantMathSigned256} from "contracts/libraries/Math/LibRedundantMathSigned256.sol";
  17 |     | import {Decimal} from "contracts/libraries/Decimal.sol";
  18 |     | import {LibGauge} from "contracts/libraries/LibGauge.sol";
  19 |     | import {LibRedundantMath32} from "contracts/libraries/Math/LibRedundantMath32.sol";
  20 |     | import {LibWellMinting} from "contracts/libraries/Minting/LibWellMinting.sol";
  21 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  22 |     | import {LibTokenSilo} from "contracts/libraries/Silo/LibTokenSilo.sol";
  23 |     | import {IWell, Call} from "contracts/interfaces/basin/IWell.sol";
  24 |     | import {ShipmentRecipient} from "contracts/beanstalk/storage/System.sol";
  25 |     | import {LibReceiving} from "contracts/libraries/LibReceiving.sol";
  26 |     | import {LibFlood} from "contracts/libraries/Silo/LibFlood.sol";
  27 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  28 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  29 |     | import {LibGaugeHelpers} from "contracts/libraries/LibGaugeHelpers.sol";
  30 |     | import {GaugeId, Gauge} from "contracts/beanstalk/storage/System.sol";
  31 |     | 
  32 |     | /**
  33 |     |  * @title Mock Season Facet
  34 |     |  *
  35 |     |  */
  36 |     | interface ResetPool {
  37 |     |     function reset_cumulative() external;
  38 |     | }
  39 |     | 
  40 |     | interface IMockPump {
  41 |     |     function update(uint256[] memory _reserves, bytes memory) external;
  42 |     | 
  43 |     |     function update(address well, uint256[] memory _reserves, bytes memory) external;
  44 |     | 
  45 |     |     function readInstantaneousReserves(
  46 |     |         address well,
  47 |     |         bytes memory data
  48 |     |     ) external view returns (uint256[] memory reserves);
  49 |     | }
  50 |     | 
  51 |     | contract MockSeasonFacet is SeasonFacet {
  52 |     |     using LibRedundantMath256 for uint256;
  53 |     |     using LibRedundantMath32 for uint32;
  54 |     |     using LibRedundantMathSigned256 for int256;
  55 |     | 
  56 |     |     event DeltaB(int256 deltaB);
  57 |     | 
  58 |     |     address constant BEAN_ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd;
  59 |     | 
  60 |     |     function reentrancyGuardTest() public nonReentrant {
  61 |     |         reentrancyGuardTest();
  62 |     |     }
  63 |     | 
  64 |     |     function setYieldE(uint256 t) public {
  65 |     |         s.sys.weather.temp = uint32(t);
  66 |     |     }
  67 |     | 
  68 |     |     function siloSunrise(uint256 amount) public {
  69 |     |         require(!s.sys.paused, "Season: Paused.");
  70 |     |         s.sys.season.current += 1;
  71 |     |         s.sys.season.timestamp = block.timestamp;
  72 |     |         s.sys.season.sunriseBlock = uint64(block.number);
  73 |     |         mockStepSilo(amount);
  74 |     |         LibGerminate.endTotalGermination(
  75 |     |             s.sys.season.current,
  76 |     |             LibWhitelistedTokens.getWhitelistedTokens()
  77 |     |         );
  78 |     |     }
  79 |     | 
  80 |     |     function mockStepSilo(uint256 amount) public {
  81 |     |         BeanstalkERC20(s.sys.bean).mint(address(this), amount);
  82 |     |         LibReceiving.receiveShipment(ShipmentRecipient.SILO, amount, bytes(""));
  83 |     |     }
  84 |     | 
  85 |     |     function rainSunrise() public {
  86 |     |         require(!s.sys.paused, "Season: Paused.");
  87 |     |         s.sys.season.current += 1;
  88 |     |         s.sys.season.sunriseBlock = uint64(block.number);
  89 |     |         // update last snapshot in beanstalk.
  90 |     |         stepOracle();
  91 |     |         LibGerminate.endTotalGermination(
  92 |     |             s.sys.season.current,
  93 |     |             LibWhitelistedTokens.getWhitelistedTokens()
  94 |     |         );
  95 |     |         mockStartSop();
  96 |     |     }
  97 |     | 
  98 |     |     function rainSunrises(uint256 amount) public {
  99 |     |         require(!s.sys.paused, "Season: Paused.");
 100 |     |         for (uint256 i; i < amount; ++i) {
 101 |     |             s.sys.season.current += 1;
 102 |     |             stepOracle();
 103 |     |             LibGerminate.endTotalGermination(
 104 |     |                 s.sys.season.current,
 105 |     |                 LibWhitelistedTokens.getWhitelistedTokens()
 106 |     |             );
 107 |     |             mockStartSop();
 108 |     |         }
 109 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 110 |     |     }
 111 |     | 
 112 |     |     function droughtSunrise() public {
 113 |     |         require(!s.sys.paused, "Season: Paused.");
 114 |     |         s.sys.season.current += 1;
 115 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 116 |     |         // update last snapshot in beanstalk.
 117 |     |         stepOracle();
 118 |     |         LibGerminate.endTotalGermination(
 119 |     |             s.sys.season.current,
 120 |     |             LibWhitelistedTokens.getWhitelistedTokens()
 121 |     |         );
 122 |     |         LibFlood.handleRain(2);
 123 |     |     }
 124 |     | 
 125 |     |     function rainSiloSunrise(uint256 amount) public {
 126 |     |         require(!s.sys.paused, "Season: Paused.");
 127 |     |         s.sys.season.current += 1;
 128 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 129 |     |         // update last snapshot in beanstalk.
 130 |     |         stepOracle();
 131 |     |         LibGerminate.endTotalGermination(
 132 |     |             s.sys.season.current,
 133 |     |             LibWhitelistedTokens.getWhitelistedTokens()
 134 |     |         );
 135 |     |         mockStartSop();
 136 |     |         mockStepSilo(amount);
 137 |     |     }
 138 |     | 
 139 |     |     function droughtSiloSunrise(uint256 amount) public {
 140 |     |         require(!s.sys.paused, "Season: Paused.");
 141 |     |         s.sys.season.current += 1;
 142 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 143 |     |         // update last snapshot in beanstalk.
 144 |     |         stepOracle();
 145 |     |         LibGerminate.endTotalGermination(
 146 |     |             s.sys.season.current,
 147 |     |             LibWhitelistedTokens.getWhitelistedTokens()
 148 |     |         );
 149 |     |         mockStartSop();
 150 |     |         mockStepSilo(amount);
 151 |     |     }
 152 |     | 
 153 |     |     function sunSunriseWithL2srScaling(int256 deltaB, uint256 caseId) public {
 154 |     |         require(!s.sys.paused, "Season: Paused.");
 155 |     |         s.sys.season.current += 1;
 156 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 157 |     |         (uint256 caseId, LibEvaluate.BeanstalkState memory bs) = calcCaseIdAndHandleRain(deltaB);
 158 |     |         stepSun(caseId, bs);
 159 |     |     }
 160 |     | 
 161 |     |     function sunSunrise(
 162 |     |         int256 deltaB,
 163 |     |         uint256 caseId,
 164 |     |         LibEvaluate.BeanstalkState memory bs
 165 |     |     ) public {
 166 |     |         require(!s.sys.paused, "Season: Paused.");
 167 |     |         s.sys.season.current += 1;
 168 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 169 |     |         bs.twaDeltaB = deltaB;
 170 |     |         stepGauges(bs);
 171 |     |         stepSun(caseId, bs);
 172 |     |     }
 173 |     | 
 174 |     |     function seedGaugeSunSunrise(int256 deltaB, uint256 caseId, bool oracleFailure) public {
 175 |     |         require(!s.sys.paused, "Season: Paused.");
 176 |     |         s.sys.season.current += 1;
 177 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 178 |     |         LibEvaluate.BeanstalkState memory bs = LibEvaluate.BeanstalkState({
 179 |     |             deltaPodDemand: Decimal.zero(),
 180 |     |             lpToSupplyRatio: Decimal.zero(),
 181 |     |             podRate: Decimal.zero(),
 182 |     |             largestLiqWell: address(0),
 183 |     |             oracleFailure: false,
 184 |     |             largestLiquidWellTwapBeanPrice: 0,
 185 |     |             twaDeltaB: deltaB
 186 |     |         });
 187 |     |         updateTemperatureAndBeanToMaxLpGpPerBdvRatio(caseId, bs, oracleFailure);
 188 |     |         stepSun(caseId, bs); // Do not scale soil down using L2SR
 189 |     |     }
 190 |     | 
 191 |     |     function seedGaugeSunSunrise(int256 deltaB, uint256 caseId) public {
 192 |     |         seedGaugeSunSunrise(deltaB, caseId, false);
 193 |     |     }
 194 |     | 
 195 |     |     function sunTemperatureSunrise(int256 deltaB, uint256 caseId, uint32 t) public {
 196 |     |         require(!s.sys.paused, "Season: Paused.");
 197 |     |         s.sys.season.current += 1;
 198 |     |         s.sys.weather.temp = t;
 199 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 200 |     |         stepSun(
 201 |     |             caseId,
 202 |     |             LibEvaluate.BeanstalkState({
 203 |     |                 deltaPodDemand: Decimal.zero(),
 204 |     |                 lpToSupplyRatio: Decimal.zero(),
 205 |     |                 podRate: Decimal.zero(),
 206 |     |                 largestLiqWell: address(0),
 207 |     |                 oracleFailure: false,
 208 |     |                 largestLiquidWellTwapBeanPrice: 0,
 209 |     |                 twaDeltaB: deltaB
 210 |     |             })
 211 |     |         ); // Do not scale soil down using L2SR
 212 |     |     }
 213 |     | 
 214 |     |     function lightSunrise() public {
 215 |     |         require(!s.sys.paused, "Season: Paused.");
 216 |     |         s.sys.season.current += 1;
 217 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 218 |     |     }
 219 |     | 
 220 |     |     /**
 221 |     |      * @dev Mocks the stepSeason function.
 222 |     |      */
 223 |     |     function mockStepSeason() public returns (uint32 season) {
 224 |     |         s.sys.season.current += 1;
 225 |     |         season = s.sys.season.current;
 226 |     |         s.sys.season.sunriseBlock = uint64(block.number); // Note: Will overflow in the year 3650.
 227 |     |         emit Sunrise(season);
 228 |     |     }
 229 |     | 
 230 |     |     function fastForward(uint32 _s) public {
 231 |     |         // teleport current sunrise 2 seasons ahead,
 232 |     |         // end germination,
 233 |     |         // then teleport remainder of seasons.
 234 |     |         if (_s >= 2) {
 235 |     |             s.sys.season.current += 2;
 236 |     |             LibGerminate.endTotalGermination(
 237 |     |                 s.sys.season.current,
 238 |     |                 LibWhitelistedTokens.getWhitelistedTokens()
 239 |     |             );
 240 |     |             s.sys.season.current += _s - 2;
 241 |     |         } else {
 242 |     |             s.sys.season.current += _s;
 243 |     |         }
 244 |     |     }
 245 |     | 
 246 |     |     function teleportSunrise(uint32 _s) public {
 247 |     |         s.sys.season.current = _s;
 248 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 249 |     |     }
 250 |     | 
 251 |     |     function farmSunrise() public {
 252 |     |         require(!s.sys.paused, "Season: Paused.");
 253 |     |         s.sys.season.current += 1;
 254 |     |         s.sys.season.timestamp = block.timestamp;
 255 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 256 |     |         LibGerminate.endTotalGermination(
 257 |     |             s.sys.season.current,
 258 |     |             LibWhitelistedTokens.getWhitelistedTokens()
 259 |     |         );
 260 |     |     }
 261 |     | 
 262 |     |     function farmSunrises(uint256 number) public {
 263 |     |         require(!s.sys.paused, "Season: Paused.");
 264 |     |         for (uint256 i; i < number; ++i) {
 265 |     |             s.sys.season.current += 1;
 266 |     |             s.sys.season.timestamp = block.timestamp;
 267 |     |             // ending germination only needs to occur for the first two loops.
 268 |     |             if (i < 2) {
 269 |     |                 LibGerminate.endTotalGermination(
 270 |     |                     s.sys.season.current,
 271 |     |                     LibWhitelistedTokens.getWhitelistedTokens()
 272 |     |                 );
 273 |     |             }
 274 |     |         }
 275 |     |         s.sys.season.sunriseBlock = uint64(block.number);
 276 |     |     }
 277 |     | 
 278 |     |     function setMaxTempE(uint32 number) public {
 279 |     |         s.sys.weather.temp = number;
 280 |     |     }
 281 |     | 
 282 |     |     function setAbovePegE(bool peg) public {
 283 |     |         s.sys.season.abovePeg = peg;
 284 |     |     }
 285 |     | 
 286 |     |     function setLastDSoilE(uint128 number) public {
 287 |     |         s.sys.weather.lastDeltaSoil = number;
 288 |     |     }
 289 |     | 
 290 |     |     function setNextSowTimeE(uint32 _time) public {
 291 |     |         s.sys.weather.thisSowTime = _time;
 292 |     |     }
 293 |     | 
 294 |     |     function setLastSowTimeE(uint32 number) public {
 295 |     |         s.sys.weather.lastSowTime = number;
 296 |     |     }
 297 |     | 
 298 |     |     function setSoilE(uint256 amount) public {
 299 |     |         setSoil(amount);
 300 |     |     }
 301 |     | 
 302 |     |     function resetState() public {
 303 |     |         for (uint256 i; i < s.sys.fieldCount; i++) {
 304 |     |             s.sys.fields[i].pods = 0;
 305 |     |             s.sys.fields[i].harvested = 0;
 306 |     |             s.sys.fields[i].harvestable = 0;
 307 |     |         }
 308 |     |         delete s.sys.silo;
 309 |     |         delete s.sys.weather;
 310 |     |         s.sys.weather.lastSowTime = type(uint32).max;
 311 |     |         s.sys.weather.thisSowTime = type(uint32).max;
 312 |     |         delete s.sys.rain;
 313 |     |         delete s.sys.season;
 314 |     |         s.sys.season.start = block.timestamp;
 315 |     |         s.sys.season.timestamp = block.timestamp;
 316 |     |         s.sys.silo.stalk = 0;
 317 |     |         s.sys.season.current = 1;
 318 |     |         s.sys.paused = false;
 319 |     |         BeanstalkERC20(s.sys.bean).burn(BeanstalkERC20(s.sys.bean).balanceOf(address(this)));
 320 |     |     }
 321 |     | 
 322 |     |     function calcCaseIdE(int256 deltaB, uint128 endSoil) external {
 323 |     |         s.sys.soil = endSoil;
 324 |     |         s.sys.beanSown = endSoil;
 325 |     |         calcCaseIdAndHandleRain(deltaB);
 326 |     |     }
 327 |     | 
 328 |     |     function setCurrentSeasonE(uint32 _season) public {
 329 |     |         s.sys.season.current = _season;
 330 |     |     }
 331 |     | 
 332 |     |     function calcCaseIdWithParams(
 333 |     |         uint256 pods,
 334 |     |         uint256 _lastDeltaSoil,
 335 |     |         uint128 beanSown,
 336 |     |         uint128 endSoil,
 337 |     |         int256 deltaB,
 338 |     |         bool raining,
 339 |     |         bool rainRoots,
 340 |     |         bool aboveQ,
 341 |     |         uint256 L2SRState
 342 |     |     ) public {
 343 |     |         // L2SR
 344 |     |         // 3 = exs high, 1 = rea high, 2 = rea low, 3 = exs low
 345 |     |         uint256[] memory reserves = new uint256[](2);
 346 |     |         if (L2SRState == 3) {
 347 |     |             // reserves[1] = 0.8e1
 348 |     |             reserves[1] = uint256(801e18);
 349 |     |         } else if (L2SRState == 2) {
 350 |     |             // reserves[1] = 0.8e18 - 1;
 351 |     |             reserves[1] = uint256(799e18);
 352 |     |         } else if (L2SRState == 1) {
 353 |     |             // reserves[1] = 0.4e18 - 1;
 354 |     |             reserves[1] = uint256(399e18);
 355 |     |         } else if (L2SRState == 0) {
 356 |     |             // reserves[1] = 0.12e18 - 1;
 357 |     |             reserves[1] = uint256(119e18);
 358 |     |         }
 359 |     |         uint256 beanEthPrice = 1000e6;
 360 |     |         uint256 l2srBean = beanEthPrice.mul(1000);
 361 |     |         reserves[0] = reserves[1].mul(beanEthPrice).div(1e18);
 362 |     |         if (l2srBean > BeanstalkERC20(s.sys.bean).totalSupply()) {
 363 |     |             BeanstalkERC20(s.sys.bean).mint(
 364 |     |                 address(this),
 365 |     |                 l2srBean - BeanstalkERC20(s.sys.bean).totalSupply()
 366 |     |             );
 367 |     |         }
 368 |     |         Call[] memory pump = IWell(BEAN_ETH_WELL).pumps();
 369 |     |         IMockPump(pump[0].target).update(pump[0].target, reserves, pump[0].data);
 370 |     |         s.sys.twaReserves[BEAN_ETH_WELL].reserve0 = uint128(reserves[0]);
 371 |     |         s.sys.twaReserves[BEAN_ETH_WELL].reserve1 = uint128(reserves[1]);
 372 |     |         s.sys.usdTokenPrice[BEAN_ETH_WELL] = 0.001e18;
 373 |     |         if (aboveQ) {
 374 |     |             // increase bean price
 375 |     |             s.sys.twaReserves[BEAN_ETH_WELL].reserve0 = uint128(reserves[0].mul(10).div(11));
 376 |     |         } else {
 377 |     |             // decrease bean price
 378 |     |             s.sys.twaReserves[BEAN_ETH_WELL].reserve0 = uint128(reserves[0]);
 379 |     |         }
 380 |     | 
 381 |     |         /// FIELD ///
 382 |     |         s.sys.season.raining = raining;
 383 |     |         s.sys.rain.roots = rainRoots ? 1 : 0;
 384 |     |         s.sys.fields[s.sys.activeField].pods = (pods.mul(BeanstalkERC20(s.sys.bean).totalSupply()) /
 385 |     |             1000); // previous tests used 1000 as the total supply.
 386 |     |         s.sys.weather.lastDeltaSoil = uint128(_lastDeltaSoil);
 387 |     |         s.sys.beanSown = beanSown;
 388 |     |         s.sys.soil = endSoil;
 389 |     |         mockcalcCaseIdAndHandleRain(deltaB);
 390 |     |     }
 391 |     | 
 392 |     |     function resetSeasonStart(uint256 amount) public {
 393 |     |         s.sys.season.start = block.timestamp.sub(amount + 3600 * 2);
 394 |     |     }
 395 |     | 
 396 |     |     function captureE() external returns (int256 deltaB) {
 397 |     |         deltaB = stepOracle();
 398 |     |         emit DeltaB(deltaB);
 399 |     |     }
 400 |     | 
 401 |     |     function captureWellE(address well) external returns (int256 deltaB) {
 402 |     |         deltaB = LibWellMinting.capture(well);
 403 |     |         s.sys.season.timestamp = block.timestamp;
 404 |     |         emit DeltaB(deltaB);
 405 |     |     }
 406 |     | 
 407 |     |     function resetPools(address[] calldata pools) external {
 408 |     |         for (uint256 i; i < pools.length; ++i) {
 409 |     |             ResetPool(pools[i]).reset_cumulative();
 410 |     |         }
 411 |     |     }
 412 |     | 
 413 |     |     function setSunriseBlock(uint256 _block) external {
 414 |     |         s.sys.season.sunriseBlock = uint64(_block);
 415 |     |     }
 416 |     | 
 417 |     |     function mockSetMilestoneStem(address token, int96 stem) external {
 418 |     |         s.sys.silo.assetSettings[token].milestoneStem = stem;
 419 |     |     }
 420 |     | 
 421 |     |     function mockSetMilestoneSeason(address token, uint32 season) external {
 422 |     |         s.sys.silo.assetSettings[token].milestoneSeason = season;
 423 |     |     }
 424 |     | 
 425 |     |     //constants for old seeds values
 426 |     | 
 427 |     |     function lastDeltaSoil() external view returns (uint256) {
 428 |     |         return uint256(s.sys.weather.lastDeltaSoil);
 429 |     |     }
 430 |     | 
 431 |     |     function lastSowTime() external view returns (uint256) {
 432 |     |         return uint256(s.sys.weather.lastSowTime);
 433 |     |     }
 434 |     | 
 435 |     |     function thisSowTime() external view returns (uint256) {
 436 |     |         return uint256(s.sys.weather.thisSowTime);
 437 |     |     }
 438 |     | 
 439 |     |     function getT() external view returns (uint256) {
 440 |     |         return uint256(s.sys.weather.temp);
 441 |     |     }
 442 |     | 
 443 |     |     function setBeanToMaxLpGpPerBdvRatio(uint128 percent) external {
 444 |     |         s.sys.seedGauge.beanToMaxLpGpPerBdvRatio = percent;
 445 |     |     }
 446 |     | 
 447 |     |     function setUsdEthPrice(uint256 price) external {
 448 |     |         s.sys.usdTokenPrice[BEAN_ETH_WELL] = price;
 449 |     |     }
 450 |     | 
 451 |     |     function mockStepGauges(LibEvaluate.BeanstalkState memory bs) external {
 452 |     |         LibGaugeHelpers.engage(abi.encode(bs));
 453 |     |     }
 454 |     | 
 455 |     |     function calculateCultivationFactorDeltaE(
 456 |     |         LibEvaluate.BeanstalkState memory bs
 457 |     |     ) external returns (uint256) {
 458 |     |         uint256 cultivationFactor = abi.decode(
 459 |     |             LibGaugeHelpers.getGaugeValue(GaugeId.CULTIVATION_FACTOR),
 460 |     |             (uint256)
 461 |     |         );
 462 |     |         Gauge memory g = s.sys.gaugeData.gauges[GaugeId.CULTIVATION_FACTOR];
 463 |     |         (bytes memory newCultivationFactorBytes, ) = LibGaugeHelpers.getGaugeResult(
 464 |     |             g,
 465 |     |             abi.encode(bs)
 466 |     |         );
 467 |     |         uint256 newCultivationFactor = abi.decode(newCultivationFactorBytes, (uint256));
 468 |     |         if (newCultivationFactor > cultivationFactor) {
 469 |     |             return newCultivationFactor - cultivationFactor;
 470 |     |         } else {
 471 |     |             return cultivationFactor - newCultivationFactor;
 472 |     |         }
 473 |     |     }
 474 |     | 
 475 |     |     function mockStepGauge() external {
 476 |     |         (
 477 |     |             uint256 maxLpGpPerBdv,
 478 |     |             LibGauge.LpGaugePointData[] memory lpGpData,
 479 |     |             uint256 totalGaugePoints,
 480 |     |             uint256 totalLpBdv
 481 |     |         ) = LibGauge.updateGaugePoints();
 482 |     |         if (totalLpBdv == type(uint256).max) return;
 483 |     |         LibGauge.updateGrownStalkEarnedPerSeason(
 484 |     |             maxLpGpPerBdv,
 485 |     |             lpGpData,
 486 |     |             totalGaugePoints,
 487 |     |             totalLpBdv
 488 |     |         );
 489 |     |     }
 490 |     | 
 491 |     |     function stepGauge() external {
 492 |     |         LibGauge.stepGauge();
 493 |     |     }
 494 |     | 
 495 |     |     function mockSetAverageGrownStalkPerBdvPerSeason(
 496 |     |         uint128 _averageGrownStalkPerBdvPerSeason
 497 |     |     ) external {
 498 |     |         s.sys.seedGauge.averageGrownStalkPerBdvPerSeason = _averageGrownStalkPerBdvPerSeason;
 499 |     |     }
 500 |     | 
 501 |     |     /**
 502 |     |      * @notice Mocks the updateGrownStalkEarnedPerSeason function.
 503 |     |      * @dev used to test the updateGrownStalkPerSeason updating.
 504 |     |      */
 505 |     |     function mockUpdateAverageGrownStalkPerBdvPerSeason() external {
 506 |     |         LibGauge.updateGrownStalkEarnedPerSeason(0, new LibGauge.LpGaugePointData[](0), 100e18, 0);
 507 |     |     }
 508 |     | 
 509 |     |     function gaugePointsNoChange(
 510 |     |         uint256 currentGaugePoints,
 511 |     |         uint256,
 512 |     |         uint256
 513 |     |     ) external pure returns (uint256) {
 514 |     |         return currentGaugePoints;
 515 |     |     }
 516 |     | 
 517 |     |     function mockinitializeGaugeForToken(
 518 |     |         address token,
 519 |     |         bytes4 gaugePointSelector,
 520 |     |         bytes4 liquidityWeightSelector,
 521 |     |         uint96,
 522 |     |         uint64 optimalPercentDepositedBdv
 523 |     |     ) external {
 524 |     |         AssetSettings storage ss = LibAppStorage.diamondStorage().sys.silo.assetSettings[token];
 525 |     |         ss.gaugePointImplementation.selector = gaugePointSelector;
 526 |     |         ss.liquidityWeightImplementation.selector = liquidityWeightSelector;
 527 |     |         ss.optimalPercentDepositedBdv = optimalPercentDepositedBdv;
 528 |     |     }
 529 |     | 
 530 |     |     function mockEndTotalGerminationForToken(address token) external {
 531 |     |         // increment total deposited and amounts for each token.
 532 |     |         GerminationSide side = LibGerminate.getSeasonGerminationSide();
 533 |     |         LibTokenSilo.incrementTotalDeposited(
 534 |     |             token,
 535 |     |             s.sys.silo.germinating[side][token].amount,
 536 |     |             s.sys.silo.germinating[side][token].bdv
 537 |     |         );
 538 |     |         delete s.sys.silo.germinating[side][token];
 539 |     |     }
 540 |     | 
 541 |     |     function mockUpdateAverageStalkPerBdvPerSeason() external {
 542 |     |         LibGauge.updateAverageStalkPerBdvPerSeason();
 543 |     |     }
 544 |     | 
 545 |     |     function mockStartSop() internal {
 546 |     |         LibFlood.handleRain(3);
 547 |     |     }
 548 |     | 
 549 |     |     function mockIncrementGermination(
 550 |     |         address,
 551 |     |         address token,
 552 |     |         uint128 amount,
 553 |     |         uint128 bdv,
 554 |     |         GerminationSide side
 555 |     |     ) external {
 556 |     |         LibTokenSilo.incrementTotalGerminating(token, amount, bdv, side);
 557 |     |     }
 558 |     | 
 559 |     |     /**
 560 |     |      * @notice simulates beanstalk state based on the parameters.
 561 |     |      * @param price below, above, significant above peg.
 562 |     |      * @param podRate extremely low, low, high, extremely high.
 563 |     |      * @param changeInSoilDemand decreasing, steady, increasing.
 564 |     |      * @param liquidityToSupplyRatio extremely low, low, high, extremely high.
 565 |     |      * @dev
 566 |     |      * assumes the initial L2SR is >80%.
 567 |     |      * assumes only one well with beans.
 568 |     |      */
 569 |     |     function setBeanstalkState(
 570 |     |         uint256 price,
 571 |     |         uint256 podRate,
 572 |     |         uint256 changeInSoilDemand,
 573 |     |         uint256 liquidityToSupplyRatio,
 574 |     |         address targetWell
 575 |     |     ) external returns (int256 deltaB) {
 576 |     |         ////////// PRICE //////////
 577 |     |         deltaB = setPrice(price, targetWell);
 578 |     | 
 579 |     |         ////////// L2SR //////////
 580 |     |         setL2SR(liquidityToSupplyRatio, targetWell);
 581 |     | 
 582 |     |         // POD RATE
 583 |     |         setPodRate(podRate);
 584 |     | 
 585 |     |         ////// DELTA POD DEMAND //////
 586 |     |         setChangeInSoilDemand(changeInSoilDemand);
 587 |     |     }
 588 |     | 
 589 |     |     /**
 590 |     |      * @notice sets the price state of beanstalk.
 591 |     |      * @dev 0 = below peg, 1 = above peg, 2 = significantly above peg.
 592 |     |      */
 593 |     |     function setPrice(uint256 price, address targetWell) public returns (int256 deltaB) {
 594 |     |         // initalize beanTknPrice, and reserves.
 595 |     |         uint256 ethPrice = 1000e6;
 596 |     |         s.sys.usdTokenPrice[targetWell] = 1e24 / ethPrice;
 597 |     |         uint256[] memory reserves = IWell(targetWell).getReserves();
 598 |     |         s.sys.twaReserves[targetWell].reserve0 = uint128(reserves[0]);
 599 |     |         s.sys.twaReserves[targetWell].reserve1 = uint128(reserves[1]);
 600 |     |         if (price == 0) {
 601 |     |             // below peg
 602 |     |             deltaB = -1;
 603 |     |             s.sys.season.abovePeg = false;
 604 |     |         } else {
 605 |     |             // above peg
 606 |     |             deltaB = 1;
 607 |     |             s.sys.season.abovePeg = true;
 608 |     |             if (price == 2) {
 609 |     |                 // excessively above peg
 610 |     | 
 611 |     |                 // to get Q, decrease s.sys.reserve0 of the well to be >1.05.
 612 |     |                 s.sys.twaReserves[targetWell].reserve0 = uint128(reserves[0].mul(90).div(100));
 613 |     |             }
 614 |     |         }
 615 |     |     }
 616 |     | 
 617 |     |     /**
 618 |     |      * @notice sets the pod rate state of beanstalk.
 619 |     |      * @dev 0 = Extremely low, 1 = Reasonably Low, 2 = Reasonably High, 3 = Extremely High.
 620 |     |      */
 621 |     |     function setPodRate(uint256 podRate) public {
 622 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 623 |     |         if (podRate == 0) {
 624 |     |             // < 5%
 625 |     |             s.sys.fields[s.sys.activeField].pods = beanSupply.mul(49).div(1000);
 626 |     |         } else if (podRate == 1) {
 627 |     |             // < 15%
 628 |     |             s.sys.fields[s.sys.activeField].pods = beanSupply.mul(149).div(1000);
 629 |     |         } else if (podRate == 2) {
 630 |     |             // < 25%
 631 |     |             s.sys.fields[s.sys.activeField].pods = beanSupply.mul(249).div(1000);
 632 |     |         } else if (podRate == 3) {
 633 |     |             // > 25%
 634 |     |             s.sys.fields[s.sys.activeField].pods = beanSupply.mul(251).div(1000);
 635 |     |         } else {
 636 |     |             // > 100%
 637 |     |             s.sys.fields[s.sys.activeField].pods = beanSupply.mul(1001).div(1000);
 638 |     |         }
 639 |     |     }
 640 |     | 
 641 |     |     /**
 642 |     |      * @notice sets the change in soil demand state of beanstalk.
 643 |     |      * @dev 0 = decreasing, 1 = steady, 2 = increasing.
 644 |     |      */
 645 |     |     function setChangeInSoilDemand(uint256 changeInSoilDemand) public {
 646 |     |         if (changeInSoilDemand == 0) {
 647 |     |             // decreasing demand
 648 |     |             // 200 beans sown last season, 100 beans sown this season
 649 |     |             setLastSeasonAndThisSeasonBeanSown(200e6, 100e6);
 650 |     |             s.sys.weather.lastSowTime = 600; // last season, everything was sown in 10 minutes.
 651 |     |             s.sys.weather.thisSowTime = 2400; // this season, everything was sown in 40 minutes.
 652 |     |         } else if (changeInSoilDemand == 1) {
 653 |     |             // steady demand
 654 |     |             // 100 beans sown last season, 100 beans sown this season
 655 |     |             setLastSeasonAndThisSeasonBeanSown(100e6, 100e6);
 656 |     |             s.sys.weather.lastSowTime = 60 * 21; // last season, everything was sown in 21 minutes, this is past the 20 minute increasing window
 657 |     |             s.sys.weather.thisSowTime = 60 * 21; // this season, everything was sown in 21 minutes.
 658 |     |         } else {
 659 |     |             // increasing demand
 660 |     |             // 100 beans sown last season, 200 beans sown this season
 661 |     |             setLastSeasonAndThisSeasonBeanSown(100e6, 200e6);
 662 |     |             s.sys.weather.lastSowTime = type(uint32).max; // last season, no one sow'd
 663 |     |             s.sys.weather.thisSowTime = type(uint32).max - 1; // this season, someone sow'd
 664 |     |         }
 665 |     |     }
 666 |     | 
 667 |     |     /**
 668 |     |      * @notice sets the L2SR state of beanstalk.
 669 |     |      * @dev 0 = extremely low, 1 = low, 2 = high, 3 = extremely high.
 670 |     |      */
 671 |     |     function setL2SR(uint256 liquidityToSupplyRatio, address targetWell) public {
 672 |     |         uint256 beansInWell = BeanstalkERC20(s.sys.bean).balanceOf(targetWell);
 673 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 674 |     |         uint256 currentL2SR = beansInWell.mul(1e18).div(beanSupply);
 675 |     | 
 676 |     |         // issue beans to sender based on ratio and supply of well.
 677 |     |         uint256 ratio = 1e18;
 678 |     |         if (liquidityToSupplyRatio == 0) {
 679 |     |             // < 12%
 680 |     |             ratio = 0.119e18;
 681 |     |         } else if (liquidityToSupplyRatio == 1) {
 682 |     |             // < 40%
 683 |     |             ratio = 0.399e18;
 684 |     |         } else if (liquidityToSupplyRatio == 2) {
 685 |     |             // < 80%
 686 |     |             ratio = 0.799e18;
 687 |     |         } else {
 688 |     |             ratio = 0.801e18;
 689 |     |         }
 690 |     | 
 691 |     |         // mint new beans outside of the well for the L2SR to change.
 692 |     |         uint256 newSupply = beansInWell.mul(currentL2SR).div(ratio).sub(beansInWell);
 693 |     |         beanSupply += newSupply;
 694 |     | 
 695 |     |         BeanstalkERC20(s.sys.bean).mint(msg.sender, newSupply);
 696 |     |     }
 697 |     | 
 698 |     |     /**
 699 |     |      * @notice mock updates case id and beanstalk state. disables oracle failure.
 700 |     |      */
 701 |     |     function mockcalcCaseIdAndHandleRain(
 702 |     |         int256 deltaB
 703 |     |     ) public returns (uint256 caseId, LibEvaluate.BeanstalkState memory bs) {
 704 |     |         uint256 beanSupply = BeanstalkERC20(s.sys.bean).totalSupply();
 705 |     |         // prevents infinite L2SR and podrate
 706 |     |         if (beanSupply == 0) {
 707 |     |             s.sys.weather.temp = 1e6;
 708 |     |             return (9, bs); // Reasonably low
 709 |     |         }
 710 |     |         // Calculate Case Id
 711 |     |         (caseId, bs) = LibEvaluate.evaluateBeanstalk(deltaB, beanSupply);
 712 |     |         updateTemperatureAndBeanToMaxLpGpPerBdvRatio(caseId, bs, false);
 713 |     |         LibFlood.handleRain(caseId);
 714 |     |     }
 715 |     | 
 716 |     |     function getSeasonStart() external view returns (uint256) {
 717 |     |         return s.sys.season.start;
 718 |     |     }
 719 |     | 
 720 |     |     /**
 721 |     |      * @notice returns the timestamp in which the next sunrise can be called.
 722 |     |      */
 723 |     |     function getNextSeasonStart() external view returns (uint256) {
 724 |     |         uint256 currentSeason = s.sys.season.current;
 725 |     |         return s.sys.season.start + ((currentSeason + 1) * 3600);
 726 |     |     }
 727 |     | 
 728 |     |     /**
 729 |     |      * @notice intializes the oracle for all whitelisted well lp tokens.
 730 |     |      * @dev should only be used if the oracle has not been initialized.
 731 |     |      */
 732 |     |     function initOracleForAllWhitelistedWells() external {
 733 |     |         address[] memory lp = LibWhitelistedTokens.getWhitelistedWellLpTokens();
 734 |     |         for (uint256 i = 0; i < lp.length; i++) {
 735 |     |             initOracleForWell(lp[i]);
 736 |     |         }
 737 |     |     }
 738 |     | 
 739 |     |     function initOracleForWell(address well) internal {
 740 |     |         require(s.sys.wellOracleSnapshots[well].length == 0, "Season: Oracle already initialized.");
 741 |     |         LibWellMinting.initializeOracle(well);
 742 |     |     }
 743 |     | 
 744 |     |     function getPoolDeltaBWithoutCap(address well) external view returns (int256 deltaB) {
 745 |     |         bytes memory lastSnapshot = LibAppStorage.diamondStorage().sys.wellOracleSnapshots[well];
 746 |     |         // If the length of the stored Snapshot for a given Well is 0,
 747 |     |         // then the Oracle is not initialized.
 748 |     |         if (lastSnapshot.length > 0) {
 749 |     |             (deltaB, , , ) = LibWellMinting.twaDeltaB(well, lastSnapshot);
 750 |     |         }
 751 |     |     }
 752 |     | 
 753 |     |     function captureWellEInstantaneous(address well) external returns (int256 instDeltaB) {
 754 |     |         instDeltaB = LibWellMinting.instantaneousDeltaB(well);
 755 |     |         s.sys.season.timestamp = block.timestamp;
 756 |     |         emit DeltaB(instDeltaB);
 757 |     |     }
 758 |     | 
 759 |     |     function setLastSeasonAndThisSeasonBeanSown(
 760 |     |         uint128 lastSeasonBeanSown,
 761 |     |         uint128 thisSeasonBeanSown
 762 |     |     ) public {
 763 |     |         s.sys.weather.lastDeltaSoil = lastSeasonBeanSown;
 764 |     |         s.sys.beanSown = thisSeasonBeanSown;
 765 |     |     }
 766 |     | 
 767 |     |     function setMinSoilSownDemand(uint256 minSoilSownDemand) public {
 768 |     |         s.sys.extEvaluationParameters.minSoilSownDemand = minSoilSownDemand;
 769 |     |     }
 770 |     | }
 771 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockSiloFacet.sol
   1 |     | /*
   2 |     |  SPDX-License-Identifier: MIT
   3 |     | */
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import "contracts/libraries/Math/LibRedundantMath256.sol";
   8 |     | import "contracts/libraries/Math/LibRedundantMath128.sol";
   9 |     | import "contracts/beanstalk/facets/silo/SiloFacet.sol";
  10 |     | import "contracts/libraries/Silo/LibWhitelist.sol";
  11 |     | import "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  12 |     | import "contracts/libraries/LibTractor.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title Mock Silo Facet
  16 |     |  *
  17 |     |  */
  18 |     | contract MockSiloFacet is SiloFacet {
  19 |     |     uint256 private constant AMOUNT_TO_BDV_BEAN_ETH = 119894802186829;
  20 |     |     uint256 private constant AMOUNT_TO_BDV_BEAN_3CRV = 992035;
  21 |     |     uint256 private constant AMOUNT_TO_BDV_BEAN_LUSD = 983108;
  22 |     | 
  23 |     |     using SafeCast for uint256;
  24 |     |     using LibRedundantMath128 for uint128;
  25 |     |     using LibRedundantMath256 for uint256;
  26 |     | 
  27 |     |     function mockBDV(uint256 amount) external pure returns (uint256) {
  28 |     |         return amount;
  29 |     |     }
  30 |     | 
  31 |     |     function mockBDVIncrease(uint256 amount) external pure returns (uint256) {
  32 |     |         return amount.mul(3).div(2);
  33 |     |     }
  34 |     | 
  35 |     |     /// @dev Mocks a BDV decrease of 10
  36 |     |     function mockBDVDecrease(uint256 amount) external pure returns (uint256) {
  37 |     |         return amount - 10;
  38 |     |     }
  39 |     | 
  40 |     |     /// @dev Mocks a constant BDV of 1e6
  41 |     |     function newMockBDV() external pure returns (uint256) {
  42 |     |         return 1e6;
  43 |     |     }
  44 |     | 
  45 |     |     /// @dev Mocks a decrease in constant BDV
  46 |     |     function newMockBDVDecrease() external pure returns (uint256) {
  47 |     |         return 0.9e6;
  48 |     |     }
  49 |     | 
  50 |     |     /// @dev Mocks an increase in constant BDV
  51 |     |     function newMockBDVIncrease() external pure returns (uint256) {
  52 |     |         return 1.1e6;
  53 |     |     }
  54 |     | 
  55 |     |     /// @dev changes bdv selector of token
  56 |     |     function mockChangeBDVSelector(address token, bytes4 selector) external {
  57 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
  58 |     |         s.sys.silo.assetSettings[token].selector = selector;
  59 |     |     }
  60 |     | 
  61 |     |     //////////////////////// ADD DEPOSIT ////////////////////////
  62 |     | 
  63 |     |     // function balanceOfSeeds(address account) public view returns (uint256) {
  64 |     |     //     return s.accts[account].silo.seeds;
  65 |     |     // }
  66 |     | 
  67 |     |     /**
  68 |     |      * @notice Whitelists a token for testing purposes.
  69 |     |      * @dev no gauge. no error checking.
  70 |     |      */
  71 |     |     function mockWhitelistToken(
  72 |     |         address token,
  73 |     |         bytes4 selector,
  74 |     |         uint48 stalkIssuedPerBdv,
  75 |     |         uint40 stalkEarnedPerSeason
  76 |     |     ) external {
  77 |     |         s.sys.silo.assetSettings[token].selector = selector;
  78 |     |         s.sys.silo.assetSettings[token].stalkIssuedPerBdv = stalkIssuedPerBdv; //previously just called "stalk"
  79 |     |         s.sys.silo.assetSettings[token].stalkEarnedPerSeason = stalkEarnedPerSeason; //previously called "seeds"
  80 |     | 
  81 |     |         s.sys.silo.assetSettings[token].milestoneSeason = uint24(s.sys.season.current);
  82 |     |         LibWhitelistedTokens.addWhitelistStatus(
  83 |     |             token,
  84 |     |             true,
  85 |     |             true,
  86 |     |             selector == LibWell.WELL_BDV_SELECTOR,
  87 |     |             false // is soppable
  88 |     |         );
  89 |     | 
  90 |     |         // emit WhitelistToken(token, selector, stalkEarnedPerSeason, stalkIssuedPerBdv);
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Whitelists a token for testing purposes.
  95 |     |      * @dev no error checking.
  96 |     |      */
  97 |     |     function mockWhitelistTokenWithGauge(
  98 |     |         address token,
  99 |     |         bytes4 selector,
 100 |     |         uint16 stalkIssuedPerBdv,
 101 |     |         uint24 stalkEarnedPerSeason,
 102 |     |         bytes1 encodeType,
 103 |     |         bytes4 gaugePointSelector,
 104 |     |         bytes4 liquidityWeightSelector,
 105 |     |         uint128 gaugePoints,
 106 |     |         uint64 optimalPercentDepositedBdv
 107 |     |     ) external {
 108 |     |         if (stalkEarnedPerSeason == 0) stalkEarnedPerSeason = 1;
 109 |     |         s.sys.silo.assetSettings[token].selector = selector;
 110 |     |         s.sys.silo.assetSettings[token].stalkEarnedPerSeason = stalkEarnedPerSeason;
 111 |     |         s.sys.silo.assetSettings[token].stalkIssuedPerBdv = stalkIssuedPerBdv;
 112 |     |         s.sys.silo.assetSettings[token].milestoneSeason = uint32(s.sys.season.current);
 113 |     |         s.sys.silo.assetSettings[token].encodeType = encodeType;
 114 |     |         s.sys.silo.assetSettings[token].gaugePointImplementation.selector = gaugePointSelector;
 115 |     |         s
 116 |     |             .sys
 117 |     |             .silo
 118 |     |             .assetSettings[token]
 119 |     |             .liquidityWeightImplementation
 120 |     |             .selector = liquidityWeightSelector;
 121 |     |         s.sys.silo.assetSettings[token].gaugePoints = gaugePoints;
 122 |     |         s.sys.silo.assetSettings[token].optimalPercentDepositedBdv = optimalPercentDepositedBdv;
 123 |     | 
 124 |     |         LibWhitelistedTokens.addWhitelistStatus(
 125 |     |             token,
 126 |     |             true,
 127 |     |             true,
 128 |     |             selector == LibWell.WELL_BDV_SELECTOR,
 129 |     |             true
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     function addWhitelistSelector(address token, bytes4 selector) external {
 134 |     |         s.sys.silo.assetSettings[token].selector = selector;
 135 |     |     }
 136 |     | 
 137 |     |     function removeWhitelistSelector(address token) external {
 138 |     |         s.sys.silo.assetSettings[token].selector = 0x00000000;
 139 |     |     }
 140 |     | 
 141 |     |     function mockLiquidityWeight() external pure returns (uint256) {
 142 |     |         return 0.5e18;
 143 |     |     }
 144 |     | 
 145 |     |     function mockUpdateLiquidityWeight(
 146 |     |         address token,
 147 |     |         address newLiquidityWeightImplementation,
 148 |     |         bytes1 encodeType,
 149 |     |         bytes4 selector,
 150 |     |         bytes memory data
 151 |     |     ) external {
 152 |     |         s.sys.silo.assetSettings[token].liquidityWeightImplementation = Implementation(
 153 |     |             newLiquidityWeightImplementation,
 154 |     |             selector,
 155 |     |             encodeType,
 156 |     |             data
 157 |     |         );
 158 |     |     }
 159 |     | 
 160 |     |     function incrementTotalDepositedAmount(address token, uint256 amount) internal {
 161 |     |         AppStorage storage s = LibAppStorage.diamondStorage();
 162 |     |         s.sys.silo.balances[token].deposited = s.sys.silo.balances[token].deposited.add(
 163 |     |             amount.toUint128()
 164 |     |         );
 165 |     |     }
 166 |     | 
 167 |     |     function setStalkAndRoots(address account, uint128 stalk, uint256 roots) external {
 168 |     |         s.sys.silo.stalk = stalk;
 169 |     |         s.sys.silo.roots = stalk;
 170 |     |         s.accts[account].stalk = stalk;
 171 |     |         s.accts[account].roots = roots;
 172 |     |     }
 173 |     | 
 174 |     |     function reduceAccountRainRoots(address account, uint256 rainRoots) external {
 175 |     |         // reduce user rain roots
 176 |     |         s.accts[account].sop.rainRoots = s.accts[account].sop.rainRoots.sub(rainRoots);
 177 |     |         // reduce global rain roots
 178 |     |         s.sys.rain.roots = s.sys.rain.roots.sub(rainRoots);
 179 |     |     }
 180 |     | }
 181 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/mockFacets/MockWhitelistFacet.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "contracts/beanstalk/facets/silo/WhitelistFacet.sol";
  8 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title Mock Whitelist Facet
 12 |     |  *
 13 |     |  */
 14 |     | contract MockWhitelistFacet is WhitelistFacet {
 15 |     |     function updateWhitelistStatus(
 16 |     |         address token,
 17 |     |         bool isWhitelisted,
 18 |     |         bool isWhitelistedLp,
 19 |     |         bool isWhitelistedWell,
 20 |     |         bool isSoppable
 21 |     |     ) external {
 22 |     |         LibWhitelistedTokens.updateWhitelistStatus(
 23 |     |             token,
 24 |     |             isWhitelisted,
 25 |     |             isWhitelistedLp,
 26 |     |             isWhitelistedWell,
 27 |     |             isSoppable
 28 |     |         );
 29 |     |     }
 30 |     | 
 31 |     |     function addWhitelistStatus(
 32 |     |         address token,
 33 |     |         bool isWhitelisted,
 34 |     |         bool isWhitelistedLp,
 35 |     |         bool isWhitelistedWell,
 36 |     |         bool isSoppable
 37 |     |     ) external {
 38 |     |         LibWhitelistedTokens.addWhitelistStatus(
 39 |     |             token,
 40 |     |             isWhitelisted,
 41 |     |             isWhitelistedLp,
 42 |     |             isWhitelistedWell,
 43 |     |             isSoppable
 44 |     |         );
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/newMockInitDiamond.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  8 |     | import {AssetSettings} from "contracts/beanstalk/storage/System.sol";
  9 |     | import "contracts/beanstalk/init/InitalizeDiamond.sol";
 10 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
 11 |     | import {LibWhitelist} from "contracts/libraries/Silo/LibWhitelist.sol";
 12 |     | import {BDVFacet} from "contracts/beanstalk/facets/silo/BDVFacet.sol";
 13 |     | 
 14 |     | /**
 15 |     |  * @title MockInitDiamond
 16 |     |  * @notice MockInitDiamond initializes the Beanstalk Diamond.
 17 |     |  * @dev MockInitDiamond additionally:
 18 |     |  * - Whitelists the bean:wsteth well.
 19 |     |  **/
 20 |     | contract MockInitDiamond is InitalizeDiamond {
 21 |     |     // min 1micro stalk earned per season due to germination.
 22 |     |     uint32 internal constant INIT_BEAN_WSTETH_WELL_STALK_EARNED_PER_SEASON = 4e6;
 23 |     |     uint128 internal constant INIT_TOKEN_POINTS = 100e18;
 24 |     |     uint32 internal constant INIT_BEAN_PERCENT_TARGET = 50e6;
 25 |     | 
 26 |     |     // Tokens
 27 |     |     address internal constant BEAN = address(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab);
 28 |     |     address internal constant BEAN_ETH_WELL = address(0xBEA0e11282e2bB5893bEcE110cF199501e872bAd);
 29 |     |     address internal constant BEAN_WSTETH_WELL =
 30 |     |         address(0xBeA0000113B0d182f4064C86B71c315389E4715D);
 31 |     | 
 32 |     |     function init() external {
 33 |     |         // initalize the default state of the diamond.
 34 |     |         // {see. InitalizeDiamond.initalizeDiamond()}
 35 |     |         initalizeDiamond(BEAN, BEAN_ETH_WELL);
 36 |     | 
 37 |     |         // Whitelist the LP well.
 38 |     |         whitelistLPWell(BEAN_WSTETH_WELL);
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @notice Whitelist a well LP token.
 43 |     |      */
 44 |     |     function whitelistLPWell(address well) internal {
 45 |     |         // note: no error checking:
 46 |     |         s.sys.silo.assetSettings[well] = AssetSettings({
 47 |     |             selector: BDVFacet.wellBdv.selector,
 48 |     |             stalkEarnedPerSeason: INIT_BEAN_WSTETH_WELL_STALK_EARNED_PER_SEASON,
 49 |     |             stalkIssuedPerBdv: INIT_STALK_ISSUED_PER_BDV,
 50 |     |             milestoneSeason: s.sys.season.current,
 51 |     |             milestoneStem: 0,
 52 |     |             encodeType: 0x01,
 53 |     |             deltaStalkEarnedPerSeason: 0,
 54 |     |             gaugePoints: INIT_TOKEN_POINTS,
 55 |     |             optimalPercentDepositedBdv: INIT_BEAN_PERCENT_TARGET,
 56 |     |             gaugePointImplementation: Implementation(
 57 |     |                 address(0),
 58 |     |                 IGaugeFacet.defaultGaugePoints.selector,
 59 |     |                 bytes1(0),
 60 |     |                 new bytes(0)
 61 |     |             ),
 62 |     |             liquidityWeightImplementation: Implementation(
 63 |     |                 address(0),
 64 |     |                 ILiquidityWeightFacet.maxWeight.selector,
 65 |     |                 bytes1(0),
 66 |     |                 new bytes(0)
 67 |     |             )
 68 |     |         });
 69 |     | 
 70 |     |         // updates the optimal percent deposited for bean:eth.
 71 |     |         LibWhitelist.updateOptimalPercentDepositedBdvForToken(
 72 |     |             BEAN_ETH_WELL,
 73 |     |             INIT_BEAN_TOKEN_WELL_PERCENT_TARGET - INIT_BEAN_PERCENT_TARGET
 74 |     |         );
 75 |     | 
 76 |     |         // update whitelist status.
 77 |     |         LibWhitelistedTokens.addWhitelistStatus(
 78 |     |             well,
 79 |     |             true, // is whitelisted,
 80 |     |             true, // is LP
 81 |     |             true, // is well
 82 |     |             true // is soppable
 83 |     |         );
 84 |     | 
 85 |     |         s.sys.usdTokenPrice[well] = 1;
 86 |     |         s.sys.twaReserves[well].reserve0 = 1;
 87 |     |         s.sys.twaReserves[well].reserve1 = 1;
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/uniswap/MockUniswapV3Deployer.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3PoolDeployer.sol";
  5 |     | 
  6 |     | import "./MockUniswapV3Pool.sol";
  7 |     | 
  8 |     | contract MockUniswapV3PoolDeployer is IUniswapV3PoolDeployer {
  9 |     |     struct Parameters {
 10 |     |         address factory;
 11 |     |         address token0;
 12 |     |         address token1;
 13 |     |         uint24 fee;
 14 |     |         int24 tickSpacing;
 15 |     |     }
 16 |     | 
 17 |     |     /// @inheritdoc IUniswapV3PoolDeployer
 18 | *   |     Parameters public override parameters;
 19 |     | 
 20 |     |     /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then
 21 |     |     /// clearing it after deploying the pool.
 22 |     |     /// @param factory The contract address of the Uniswap V3 factory
 23 |     |     /// @param token0 The first token of the pool by address sort order
 24 |     |     /// @param token1 The second token of the pool by address sort order
 25 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 26 |     |     /// @param tickSpacing The spacing between usable ticks
 27 | *   |     function deploy(
 28 |     |         address factory,
 29 |     |         address token0,
 30 |     |         address token1,
 31 |     |         uint24 fee,
 32 |     |         int24 tickSpacing
 33 | *   |     ) internal returns (address pool) {
 34 | *   |         parameters = Parameters({
 35 | *   |             factory: factory,
 36 | *   |             token0: token0,
 37 | *   |             token1: token1,
 38 | *   |             fee: fee,
 39 | *   |             tickSpacing: tickSpacing
 40 |     |         });
 41 | *   |         pool = address(new MockUniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());
 42 | *   |         delete parameters;
 43 |     |     }
 44 |     | }
 45 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/uniswap/MockUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.20;
  3 |     | 
  4 |     | import "./MockUniswapV3Deployer.sol";
  5 |     | import "./MockUniswapV3Pool.sol";
  6 |     | 
  7 |     | /// @title Canonical Uniswap V3 factory
  8 |     | /// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees
  9 |     | 
 10 | *   | contract MockUniswapV3Factory is MockUniswapV3PoolDeployer {
 11 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 12 |     | 
 13 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 14 |     | 
 15 |     |     event PoolCreated(
 16 |     |         address indexed token0,
 17 |     |         address indexed token1,
 18 |     |         uint24 indexed fee,
 19 |     |         int24 tickSpacing,
 20 |     |         address pool
 21 |     |     );
 22 |     | 
 23 |     |     address public owner;
 24 |     | 
 25 |     |     mapping(uint24 => int24) public feeAmountTickSpacing;
 26 |     |     mapping(address => mapping(address => mapping(uint24 => address))) public getPool;
 27 |     | 
 28 | *   |     constructor() {
 29 | *   |         owner = msg.sender;
 30 | *   |         emit OwnerChanged(address(0), msg.sender);
 31 |     | 
 32 | *   |         feeAmountTickSpacing[100] = 2;
 33 | *   |         feeAmountTickSpacing[500] = 10;
 34 | *   |         emit FeeAmountEnabled(500, 10);
 35 | *   |         feeAmountTickSpacing[3000] = 60;
 36 | *   |         emit FeeAmountEnabled(3000, 60);
 37 | *   |         feeAmountTickSpacing[10000] = 200;
 38 | *   |         emit FeeAmountEnabled(10000, 200);
 39 |     |     }
 40 |     | 
 41 | *   |     function createPool(
 42 |     |         address tokenA,
 43 |     |         address tokenB,
 44 |     |         uint24 fee
 45 | *   |     ) external returns (address pool) {
 46 | *   |         require(tokenA != tokenB);
 47 | *   |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 48 | *   |         require(token0 != address(0));
 49 | *   |         int24 tickSpacing = feeAmountTickSpacing[fee];
 50 | *   |         require(tickSpacing != 0);
 51 | *   |         require(getPool[token0][token1][fee] == address(0));
 52 | *   |         pool = deploy(address(this), token0, token1, fee, tickSpacing);
 53 | *   |         getPool[token0][token1][fee] = pool;
 54 |     |         // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses
 55 | *   |         getPool[token1][token0][fee] = pool;
 56 | *   |         emit PoolCreated(token0, token1, fee, tickSpacing, pool);
 57 |     |     }
 58 |     | }
 59 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/uniswap/MockUniswapV3Pool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "@uniswap/v3-core/contracts/libraries/Tick.sol";
   5 |     | import "@uniswap/v3-core/contracts/libraries/Oracle.sol";
   6 |     | import "@uniswap/v3-core/contracts/libraries/TickMath.sol";
   7 |     | import "@uniswap/v3-core/contracts/interfaces/IUniswapV3PoolDeployer.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title MockUniswapV3Pool, allows to set the price of the oracle
  11 |     |  * @notice observe() is the modified function to allow this.
  12 |     |  **/
  13 | *   | contract MockUniswapV3Pool {
  14 |     |     using Tick for mapping(int24 => Tick.Info);
  15 |     |     using Oracle for Oracle.Observation[65535];
  16 |     | 
  17 |     |     address public immutable factory;
  18 |     | 
  19 |     |     address public token0;
  20 |     | 
  21 |     |     address public token1;
  22 |     | 
  23 |     |     uint24 public immutable fee;
  24 |     | 
  25 |     |     int24 public immutable tickSpacing;
  26 |     | 
  27 |     |     uint128 public immutable maxLiquidityPerTick;
  28 |     | 
  29 |     |     // accumulated protocol fees in token0/token1 units
  30 |     |     struct ProtocolFees {
  31 |     |         uint128 token0;
  32 |     |         uint128 token1;
  33 |     |     }
  34 |     | 
  35 |     |     ProtocolFees public protocolFees;
  36 |     | 
  37 |     |     Oracle.Observation[65535] public observations;
  38 |     | 
  39 |     |     bool public fail_oracle_call;
  40 |     |     int24 public manual_ticks;
  41 |     |     uint256 public manual_sqrtPriceX96;
  42 |     | 
  43 | *   |     constructor() {
  44 | *   |         int24 _tickSpacing;
  45 | *   |         (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender)
  46 |     |             .parameters();
  47 | *   |         tickSpacing = _tickSpacing;
  48 |     | 
  49 | *   |         maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);
  50 |     |     }
  51 |     | 
  52 |     |     function observe(
  53 |     |         uint32[] calldata secondsAgos
  54 |     |     )
  55 |     |         external
  56 |     |         view
  57 |     |         returns (
  58 |     |             int56[] memory tickCumulatives,
  59 |     |             uint160[] memory secondsPerLiquidityCumulativeX128s
  60 |     |         )
  61 |     |     {
  62 |     |         require(!fail_oracle_call, "Oracle call failed");
  63 |     |         tickCumulatives = new int56[](secondsAgos.length);
  64 |     |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length); // not needed
  65 |     |         for (uint256 i = 0; i < secondsAgos.length; i++) {
  66 |     |             if (i == 0) {
  67 |     |                 tickCumulatives[i] = 0;
  68 |     |                 continue;
  69 |     |             }
  70 |     |             tickCumulatives[i] =
  71 |     |                 int56(manual_ticks) *
  72 |     |                 int56(uint56(secondsAgos[secondsAgos.length - 1 - i]));
  73 |     |             secondsPerLiquidityCumulativeX128s[i] = 1;
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     // sets price of oracle
  78 |     |     ///@dev decimal precision of price is the lower of the two tokens,
  79 |     |     ///@dev decimals is the precision of the token being quoted.
  80 | *   |     function setOraclePrice(uint256 price, uint8 decimals) external {
  81 | *   |         manual_sqrtPriceX96 = sqrt(((uint256(1 << 192)) * (10 ** decimals)) / (price));
  82 | *   |         manual_ticks = TickMath.getTickAtSqrtRatio(uint160(manual_sqrtPriceX96));
  83 |     |     }
  84 |     | 
  85 |     |     function setOracleFailure(bool fail) external {
  86 |     |         fail_oracle_call = fail;
  87 |     |     }
  88 |     | 
  89 |     |     // quick helper
  90 | *   |     function sqrt(uint256 x) private pure returns (uint256 y) {
  91 | *   |         uint256 z = (x + 1) / 2;
  92 | *   |         y = x;
  93 | *   |         while (z < y) {
  94 | *   |             y = z;
  95 | *   |             z = (x / z + z) / 2;
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 | *   |     function setToken0(address _token0) external {
 100 | *   |         token0 = _token0;
 101 |     |     }
 102 |     | 
 103 | *   |     function setToken1(address _token1) external {
 104 | *   |         token1 = _token1;
 105 |     |     }
 106 |     | }
 107 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/mocks/well/MockPump.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  *
  4 |     |  */
  5 |     | 
  6 |     | pragma solidity ^0.8.20;
  7 |     | 
  8 |     | import {IInstantaneousPump} from "contracts/interfaces/basin/pumps/IInstantaneousPump.sol";
  9 |     | import {ICumulativePump} from "contracts/interfaces/basin/pumps/ICumulativePump.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @title Mock Pump
 13 |     |  */
 14 |     | 
 15 | *   | contract MockPump is IInstantaneousPump, ICumulativePump {
 16 |     |     struct ReservesData {
 17 |     |         uint256[] instantaneousReserves;
 18 |     |         uint256[] cumulativeReserves;
 19 |     |         uint256[] cappedReserves;
 20 |     |     }
 21 |     | 
 22 |     |     mapping(address => ReservesData) reservesData;
 23 |     | 
 24 |     |     function setInstantaneousReserves(address well, uint[] memory _instantaneousReserves) external {
 25 |     |         reservesData[well].instantaneousReserves = _instantaneousReserves;
 26 |     |     }
 27 |     | 
 28 |     |     function readInstantaneousReserves(
 29 |     |         address well,
 30 |     |         bytes memory
 31 |     |     ) external view override returns (uint[] memory reserves) {
 32 |     |         return reservesData[well].instantaneousReserves;
 33 |     |     }
 34 |     | 
 35 |     |     function readCappedReserves(
 36 |     |         address well,
 37 |     |         bytes memory
 38 |     |     ) external view returns (uint[] memory reserves) {
 39 |     |         return reservesData[well].cappedReserves;
 40 |     |     }
 41 |     | 
 42 |     |     function update(address well, uint256[] memory _reserves, bytes memory data) external {
 43 |     |         _update(well, _reserves, data);
 44 |     |     }
 45 |     | 
 46 |     |     function updateNoBytes(address well, uint256[] memory _reserves) external {
 47 |     |         _update(well, _reserves, new bytes(0));
 48 |     |     }
 49 |     | 
 50 | *   |     function _update(address well, uint256[] memory _reserves, bytes memory data) internal {
 51 | *   |         reservesData[well].instantaneousReserves = _reserves;
 52 | *   |         reservesData[well].cumulativeReserves = _reserves;
 53 | *   |         reservesData[well].cappedReserves = _reserves;
 54 |     |     }
 55 |     | 
 56 |     |     // this function gets called from the well, msg.sender is the well
 57 | *   |     function update(uint256[] memory _reserves, bytes memory data) external {
 58 | *   |         _update(msg.sender, _reserves, data);
 59 |     |     }
 60 |     | 
 61 |     |     function setCumulativeReserves(address well, uint[] memory _cumulativeReserves) external {
 62 |     |         reservesData[well].cumulativeReserves = _cumulativeReserves;
 63 |     |     }
 64 |     | 
 65 |     |     function readCumulativeReserves(
 66 |     |         address well,
 67 |     |         bytes memory
 68 |     |     ) external view override returns (bytes memory) {
 69 |     |         return
 70 |     |             abi.encodePacked(
 71 |     |                 reservesData[well].cumulativeReserves[0],
 72 |     |                 reservesData[well].cumulativeReserves[1]
 73 |     |             );
 74 |     |     }
 75 |     | 
 76 |     |     function readTwaReserves(
 77 |     |         address well,
 78 |     |         bytes calldata,
 79 |     |         uint,
 80 |     |         bytes memory
 81 |     |     ) external view override returns (uint[] memory twaReserves, bytes memory _cumulativeReserves) {
 82 |     |         twaReserves = reservesData[well].cumulativeReserves;
 83 |     |         _cumulativeReserves = abi.encodePacked(twaReserves[0], twaReserves[1]);
 84 |     |     }
 85 |     | 
 86 |     |     function clearReserves(address well) external {
 87 |     |         delete reservesData[well];
 88 |     |     }
 89 |     | }
 90 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/pipeline/Pipeline.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import "../interfaces/IPipeline.sol";
   5 |     | import "../libraries/LibFunction.sol";
   6 |     | import "../libraries/LibClipboard.sol";
   7 |     | import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
   8 |     | import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title Pipeline
  12 |     |  * @notice Pipeline creates a sandbox to execute any series of function calls on any series of protocols through Pipe functions.
  13 |     |  * Any assets left in Pipeline between transactions can be transferred out by any account.
  14 |     |  * Users Pipe a series of PipeCalls that each execute a function call to another protocol through Pipeline.
  15 |     |  * https://evmpipeline.org
  16 |     |  **/
  17 |     | 
  18 | *   | contract Pipeline is IPipeline, ERC1155Holder, ERC721Holder {
  19 |     |     /**
  20 |     |      * @dev So Pipeline can receive Ether.
  21 |     |      */
  22 |     |     receive() external payable {}
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Returns the current version of Pipeline.
  26 |     |      */
  27 |     |     function version() external pure returns (string memory) {
  28 |     |         return "1.0.1";
  29 |     |     }
  30 |     | 
  31 |     |     /**
  32 |     |      * @notice Execute a single PipeCall.
  33 |     |      * Supports sending Ether through msg.value
  34 |     |      * @param p PipeCall to execute
  35 |     |      * @return result return value of PipeCall
  36 |     |      **/
  37 |     |     function pipe(PipeCall calldata p) external payable override returns (bytes memory result) {
  38 |     |         result = _pipe(p.target, p.data, msg.value);
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Execute a list of executes a list of PipeCalls.
  43 |     |      * @param pipes list of PipeCalls to execute
  44 |     |      * @return results list of return values for each PipeCall
  45 |     |      **/
  46 |     |     function multiPipe(
  47 |     |         PipeCall[] calldata pipes
  48 |     |     ) external payable override returns (bytes[] memory results) {
  49 |     |         results = new bytes[](pipes.length);
  50 |     |         for (uint256 i = 0; i < pipes.length; i++) {
  51 |     |             results[i] = _pipe(pipes[i].target, pipes[i].data, 0);
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Execute a list of AdvancedPipeCalls.
  57 |     |      * @param pipes list of AdvancedPipeCalls to execute
  58 |     |      * @return results list of return values for each AdvancedPipeCalls
  59 |     |      **/
  60 |     |     function advancedPipe(
  61 |     |         AdvancedPipeCall[] calldata pipes
  62 |     |     ) external payable override returns (bytes[] memory results) {
  63 |     |         results = new bytes[](pipes.length);
  64 |     |         for (uint256 i = 0; i < pipes.length; ++i) {
  65 |     |             results[i] = _advancedPipe(pipes[i], results);
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     // Execute function call using calldata
  70 |     |     function _pipe(
  71 |     |         address target,
  72 |     |         bytes calldata data,
  73 |     |         uint256 value
  74 |     |     ) private returns (bytes memory result) {
  75 |     |         bool success;
  76 |     |         (success, result) = target.call{value: value}(data);
  77 |     |         LibFunction.checkReturn(success, result);
  78 |     |     }
  79 |     | 
  80 |     |     // Execute function call using memory
  81 |     |     function _pipeMem(
  82 |     |         address target,
  83 |     |         bytes memory data,
  84 |     |         uint256 value
  85 |     |     ) private returns (bytes memory result) {
  86 |     |         bool success;
  87 |     |         (success, result) = target.call{value: value}(data);
  88 |     | 
  89 |     |         LibFunction.checkReturn(success, result);
  90 |     |     }
  91 |     | 
  92 |     |     // Execute an AdvancedPipeCall
  93 |     |     function _advancedPipe(
  94 |     |         AdvancedPipeCall calldata p,
  95 |     |         bytes[] memory returnData
  96 |     |     ) private returns (bytes memory result) {
  97 |     |         uint256 value = getEthValue(p.clipboard);
  98 |     |         // 0x00 -> Normal pipe: Standard function call
  99 |     |         // else > Advanced pipe: Copy return data into function call through buildAdvancedCalldata
 100 |     |         if (p.clipboard[0] == 0x00) {
 101 |     |             result = _pipe(p.target, p.callData, value);
 102 |     |         } else {
 103 |     |             result = LibClipboard.useClipboard(p.callData, p.clipboard, returnData);
 104 |     |             result = _pipeMem(p.target, result, value);
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     // Extracts Ether value from a Clipboard
 109 |     |     // clipboard[1] indicates whether there is an Ether value in the advanced data
 110 |     |     // if 0x00 -> No Ether value, return 0
 111 |     |     // else -> return the last 32 bytes of clipboard
 112 |     |     function getEthValue(bytes calldata clipboard) private pure returns (uint256 value) {
 113 |     |         if (clipboard[1] == 0x00) return 0;
 114 |     |         assembly {
 115 |     |             value := calldataload(sub(add(clipboard.offset, clipboard.length), 32))
 116 |     |         }
 117 |     |     }
 118 |     | }
 119 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/tokens/Bean.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import "./ERC20/BeanstalkERC20.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title Bean is the ERC-20 Stablecoin for Beanstalk.
 11 |     |  **/
 12 | *   | contract Bean is BeanstalkERC20 {
 13 | *   |     constructor() BeanstalkERC20(msg.sender, "Bean", "BEAN") {}
 14 |     | }
 15 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/contracts/tokens/ERC20/BeanstalkERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/access/AccessControl.sol";
  6 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  7 |     | import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev {ERC20} token, including:
 11 |     |  *
 12 |     |  *  - ability for holders to burn (destroy) their tokens
 13 |     |  *  - a minter role that allows for token minting (creation)
 14 |     |  *  - a pauser role that allows to stop all token transfers
 15 |     |  *
 16 |     |  * This contract uses {AccessControl} to lock permissioned functions using the
 17 |     |  * different roles - head to its documentation for details.
 18 |     |  *
 19 |     |  * The account that deploys the contract will be granted the minter and pauser
 20 |     |  * roles, as well as the default admin role, which will let it grant both minter
 21 |     |  * and pauser roles to other accounts.
 22 |     |  */
 23 | *   | contract BeanstalkERC20 is ERC20Burnable, AccessControl {
 24 | *   |     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
 25 |     | 
 26 |     |     /**
 27 |     |      * @dev Grants `DEFAULT_ADMIN_ROLE` and `MINTER_ROLE` to the
 28 |     |      * account that deploys the contract.
 29 |     |      * See {ERC20-constructor}.
 30 |     |      */
 31 | *   |     constructor(address admin, string memory name, string memory symbol) ERC20(name, symbol) {
 32 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, admin);
 33 | *   |         _grantRole(MINTER_ROLE, admin);
 34 |     |     }
 35 |     | 
 36 |     |     /**
 37 |     |      * @dev Creates `amount` new tokens for `to`.
 38 |     |      *
 39 |     |      * See {ERC20-_mint}.
 40 |     |      *
 41 |     |      * Requirements:
 42 |     |      *
 43 |     |      * - the caller must have the `MINTER_ROLE`.
 44 |     |      */
 45 | *   |     function mint(address to, uint256 amount) public virtual {
 46 | *   |         require(hasRole(MINTER_ROLE, _msgSender()), "!Minter");
 47 | *   |         _mint(to, amount);
 48 |     |     }
 49 |     | 
 50 |     |     /**
 51 |     |      * @dev Returns the number of decimals.
 52 |     |      */
 53 | *   |     function decimals() public view virtual override returns (uint8) {
 54 | *   |         return 6;
 55 |     |     }
 56 |     | }
 57 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     /// @dev Cheat code address.
  9 |     |     /// Calculated as `address(uint160(uint256(keccak256("hevm cheat code"))))`.
 10 | *   |     address internal constant VM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
 11 |     |     /// @dev console.sol and console2.sol work by executing a staticcall to this address.
 12 |     |     /// Calculated as `address(uint160(uint88(bytes11("console.log"))))`.
 13 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 14 |     |     /// @dev Used when deploying with create2.
 15 |     |     /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.
 16 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 17 |     |     /// @dev The default address for tx.origin and msg.sender.
 18 |     |     /// Calculated as `address(uint160(uint256(keccak256("foundry default caller"))))`.
 19 |     |     address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
 20 |     |     /// @dev The address of the first contract `CREATE`d by a running test contract.
 21 |     |     /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.
 22 |     |     /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.
 23 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 24 |     |     /// @dev Deterministic deployment address of the Multicall3 contract.
 25 |     |     /// Taken from https://www.multicall3.com.
 26 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 27 |     |     /// @dev The order of the secp256k1 curve.
 28 |     |     uint256 internal constant SECP256K1_ORDER =
 29 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 30 |     | 
 31 |     |     uint256 internal constant UINT256_MAX =
 32 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 33 |     | 
 34 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 35 |     |     StdStorage internal stdstore;
 36 |     | }
 37 |     | 
 38 |     | abstract contract TestBase is CommonBase {}
 39 |     | 
 40 |     | abstract contract ScriptBase is CommonBase {
 41 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 42 |     | }
 43 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | pragma experimental ABIEncoderV2;
   4 |     | 
   5 |     | import {Vm} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions {
   8 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     | 
  10 |     |     event log(string);
  11 |     |     event logs(bytes);
  12 |     | 
  13 |     |     event log_address(address);
  14 |     |     event log_bytes32(bytes32);
  15 |     |     event log_int(int256);
  16 |     |     event log_uint(uint256);
  17 |     |     event log_bytes(bytes);
  18 |     |     event log_string(string);
  19 |     | 
  20 |     |     event log_named_address(string key, address val);
  21 |     |     event log_named_bytes32(string key, bytes32 val);
  22 |     |     event log_named_decimal_int(string key, int256 val, uint256 decimals);
  23 |     |     event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
  24 |     |     event log_named_int(string key, int256 val);
  25 |     |     event log_named_uint(string key, uint256 val);
  26 |     |     event log_named_bytes(string key, bytes val);
  27 |     |     event log_named_string(string key, string val);
  28 |     | 
  29 |     |     event log_array(uint256[] val);
  30 |     |     event log_array(int256[] val);
  31 |     |     event log_array(address[] val);
  32 |     |     event log_named_array(string key, uint256[] val);
  33 |     |     event log_named_array(string key, int256[] val);
  34 |     |     event log_named_array(string key, address[] val);
  35 |     | 
  36 |     |     bool private _failed;
  37 |     | 
  38 |     |     function failed() public view returns (bool) {
  39 |     |         if (_failed) {
  40 |     |             return _failed;
  41 |     |         } else {
  42 |     |             return vm.load(address(vm), bytes32("failed")) != bytes32(0);
  43 |     |         }
  44 |     |     }
  45 |     | 
  46 |     |     function fail() internal virtual {
  47 |     |         vm.store(address(vm), bytes32("failed"), bytes32(uint256(1)));
  48 |     |         _failed = true;
  49 |     |     }
  50 |     | 
  51 |     |     function assertTrue(bool data) internal pure virtual {
  52 |     |         vm.assertTrue(data);
  53 |     |     }
  54 |     | 
  55 |     |     function assertTrue(bool data, string memory err) internal pure virtual {
  56 |     |         vm.assertTrue(data, err);
  57 |     |     }
  58 |     | 
  59 |     |     function assertFalse(bool data) internal pure virtual {
  60 |     |         vm.assertFalse(data);
  61 |     |     }
  62 |     | 
  63 |     |     function assertFalse(bool data, string memory err) internal pure virtual {
  64 |     |         vm.assertFalse(data, err);
  65 |     |     }
  66 |     | 
  67 |     |     function assertEq(bool left, bool right) internal pure virtual {
  68 |     |         vm.assertEq(left, right);
  69 |     |     }
  70 |     | 
  71 |     |     function assertEq(bool left, bool right, string memory err) internal pure virtual {
  72 |     |         vm.assertEq(left, right, err);
  73 |     |     }
  74 |     | 
  75 |     |     function assertEq(uint256 left, uint256 right) internal pure virtual {
  76 |     |         vm.assertEq(left, right);
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {
  80 |     |         vm.assertEq(left, right, err);
  81 |     |     }
  82 |     | 
  83 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
  84 |     |         vm.assertEqDecimal(left, right, decimals);
  85 |     |     }
  86 |     | 
  87 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
  88 |     |         vm.assertEqDecimal(left, right, decimals, err);
  89 |     |     }
  90 |     | 
  91 |     |     function assertEq(int256 left, int256 right) internal pure virtual {
  92 |     |         vm.assertEq(left, right);
  93 |     |     }
  94 |     | 
  95 |     |     function assertEq(int256 left, int256 right, string memory err) internal pure virtual {
  96 |     |         vm.assertEq(left, right, err);
  97 |     |     }
  98 |     | 
  99 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 100 |     |         vm.assertEqDecimal(left, right, decimals);
 101 |     |     }
 102 |     | 
 103 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 104 |     |         vm.assertEqDecimal(left, right, decimals, err);
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address left, address right) internal pure virtual {
 108 |     |         vm.assertEq(left, right);
 109 |     |     }
 110 |     | 
 111 |     |     function assertEq(address left, address right, string memory err) internal pure virtual {
 112 |     |         vm.assertEq(left, right, err);
 113 |     |     }
 114 |     | 
 115 |     |     function assertEq(bytes32 left, bytes32 right) internal pure virtual {
 116 |     |         vm.assertEq(left, right);
 117 |     |     }
 118 |     | 
 119 |     |     function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 120 |     |         vm.assertEq(left, right, err);
 121 |     |     }
 122 |     | 
 123 |     |     function assertEq32(bytes32 left, bytes32 right) internal pure virtual {
 124 |     |         assertEq(left, right);
 125 |     |     }
 126 |     | 
 127 |     |     function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 128 |     |         assertEq(left, right, err);
 129 |     |     }
 130 |     | 
 131 |     |     function assertEq(string memory left, string memory right) internal pure virtual {
 132 |     |         vm.assertEq(left, right);
 133 |     |     }
 134 |     | 
 135 |     |     function assertEq(string memory left, string memory right, string memory err) internal pure virtual {
 136 |     |         vm.assertEq(left, right, err);
 137 |     |     }
 138 |     | 
 139 |     |     function assertEq(bytes memory left, bytes memory right) internal pure virtual {
 140 |     |         vm.assertEq(left, right);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 144 |     |         vm.assertEq(left, right, err);
 145 |     |     }
 146 |     | 
 147 |     |     function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {
 148 |     |         vm.assertEq(left, right);
 149 |     |     }
 150 |     | 
 151 |     |     function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 152 |     |         vm.assertEq(left, right, err);
 153 |     |     }
 154 |     | 
 155 |     |     function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 156 |     |         vm.assertEq(left, right);
 157 |     |     }
 158 |     | 
 159 |     |     function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 160 |     |         vm.assertEq(left, right, err);
 161 |     |     }
 162 |     | 
 163 |     |     function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {
 164 |     |         vm.assertEq(left, right);
 165 |     |     }
 166 |     | 
 167 |     |     function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 168 |     |         vm.assertEq(left, right, err);
 169 |     |     }
 170 |     | 
 171 |     |     function assertEq(address[] memory left, address[] memory right) internal pure virtual {
 172 |     |         vm.assertEq(left, right);
 173 |     |     }
 174 |     | 
 175 |     |     function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 176 |     |         vm.assertEq(left, right, err);
 177 |     |     }
 178 |     | 
 179 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 180 |     |         vm.assertEq(left, right);
 181 |     |     }
 182 |     | 
 183 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 184 |     |         vm.assertEq(left, right, err);
 185 |     |     }
 186 |     | 
 187 |     |     function assertEq(string[] memory left, string[] memory right) internal pure virtual {
 188 |     |         vm.assertEq(left, right);
 189 |     |     }
 190 |     | 
 191 |     |     function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 192 |     |         vm.assertEq(left, right, err);
 193 |     |     }
 194 |     | 
 195 |     |     function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 196 |     |         vm.assertEq(left, right);
 197 |     |     }
 198 |     | 
 199 |     |     function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 200 |     |         vm.assertEq(left, right, err);
 201 |     |     }
 202 |     | 
 203 |     |     // Legacy helper
 204 |     |     function assertEqUint(uint256 left, uint256 right) internal pure virtual {
 205 |     |         assertEq(left, right);
 206 |     |     }
 207 |     | 
 208 |     |     function assertNotEq(bool left, bool right) internal pure virtual {
 209 |     |         vm.assertNotEq(left, right);
 210 |     |     }
 211 |     | 
 212 |     |     function assertNotEq(bool left, bool right, string memory err) internal pure virtual {
 213 |     |         vm.assertNotEq(left, right, err);
 214 |     |     }
 215 |     | 
 216 |     |     function assertNotEq(uint256 left, uint256 right) internal pure virtual {
 217 |     |         vm.assertNotEq(left, right);
 218 |     |     }
 219 |     | 
 220 |     |     function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {
 221 |     |         vm.assertNotEq(left, right, err);
 222 |     |     }
 223 |     | 
 224 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 225 |     |         vm.assertNotEqDecimal(left, right, decimals);
 226 |     |     }
 227 |     | 
 228 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)
 229 |     |         internal
 230 |     |         pure
 231 |     |         virtual
 232 |     |     {
 233 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 234 |     |     }
 235 |     | 
 236 |     |     function assertNotEq(int256 left, int256 right) internal pure virtual {
 237 |     |         vm.assertNotEq(left, right);
 238 |     |     }
 239 |     | 
 240 |     |     function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {
 241 |     |         vm.assertNotEq(left, right, err);
 242 |     |     }
 243 |     | 
 244 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 245 |     |         vm.assertNotEqDecimal(left, right, decimals);
 246 |     |     }
 247 |     | 
 248 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 249 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 250 |     |     }
 251 |     | 
 252 |     |     function assertNotEq(address left, address right) internal pure virtual {
 253 |     |         vm.assertNotEq(left, right);
 254 |     |     }
 255 |     | 
 256 |     |     function assertNotEq(address left, address right, string memory err) internal pure virtual {
 257 |     |         vm.assertNotEq(left, right, err);
 258 |     |     }
 259 |     | 
 260 |     |     function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {
 261 |     |         vm.assertNotEq(left, right);
 262 |     |     }
 263 |     | 
 264 |     |     function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 265 |     |         vm.assertNotEq(left, right, err);
 266 |     |     }
 267 |     | 
 268 |     |     function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {
 269 |     |         assertNotEq(left, right);
 270 |     |     }
 271 |     | 
 272 |     |     function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 273 |     |         assertNotEq(left, right, err);
 274 |     |     }
 275 |     | 
 276 |     |     function assertNotEq(string memory left, string memory right) internal pure virtual {
 277 |     |         vm.assertNotEq(left, right);
 278 |     |     }
 279 |     | 
 280 |     |     function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {
 281 |     |         vm.assertNotEq(left, right, err);
 282 |     |     }
 283 |     | 
 284 |     |     function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {
 285 |     |         vm.assertNotEq(left, right);
 286 |     |     }
 287 |     | 
 288 |     |     function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 289 |     |         vm.assertNotEq(left, right, err);
 290 |     |     }
 291 |     | 
 292 |     |     function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {
 293 |     |         vm.assertNotEq(left, right);
 294 |     |     }
 295 |     | 
 296 |     |     function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 297 |     |         vm.assertNotEq(left, right, err);
 298 |     |     }
 299 |     | 
 300 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 301 |     |         vm.assertNotEq(left, right);
 302 |     |     }
 303 |     | 
 304 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 305 |     |         vm.assertNotEq(left, right, err);
 306 |     |     }
 307 |     | 
 308 |     |     function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {
 309 |     |         vm.assertNotEq(left, right);
 310 |     |     }
 311 |     | 
 312 |     |     function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 313 |     |         vm.assertNotEq(left, right, err);
 314 |     |     }
 315 |     | 
 316 |     |     function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {
 317 |     |         vm.assertNotEq(left, right);
 318 |     |     }
 319 |     | 
 320 |     |     function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 321 |     |         vm.assertNotEq(left, right, err);
 322 |     |     }
 323 |     | 
 324 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 325 |     |         vm.assertNotEq(left, right);
 326 |     |     }
 327 |     | 
 328 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 329 |     |         vm.assertNotEq(left, right, err);
 330 |     |     }
 331 |     | 
 332 |     |     function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {
 333 |     |         vm.assertNotEq(left, right);
 334 |     |     }
 335 |     | 
 336 |     |     function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 337 |     |         vm.assertNotEq(left, right, err);
 338 |     |     }
 339 |     | 
 340 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 341 |     |         vm.assertNotEq(left, right);
 342 |     |     }
 343 |     | 
 344 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 345 |     |         vm.assertNotEq(left, right, err);
 346 |     |     }
 347 |     | 
 348 |     |     function assertLt(uint256 left, uint256 right) internal pure virtual {
 349 |     |         vm.assertLt(left, right);
 350 |     |     }
 351 |     | 
 352 |     |     function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {
 353 |     |         vm.assertLt(left, right, err);
 354 |     |     }
 355 |     | 
 356 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 357 |     |         vm.assertLtDecimal(left, right, decimals);
 358 |     |     }
 359 |     | 
 360 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 361 |     |         vm.assertLtDecimal(left, right, decimals, err);
 362 |     |     }
 363 |     | 
 364 |     |     function assertLt(int256 left, int256 right) internal pure virtual {
 365 |     |         vm.assertLt(left, right);
 366 |     |     }
 367 |     | 
 368 |     |     function assertLt(int256 left, int256 right, string memory err) internal pure virtual {
 369 |     |         vm.assertLt(left, right, err);
 370 |     |     }
 371 |     | 
 372 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 373 |     |         vm.assertLtDecimal(left, right, decimals);
 374 |     |     }
 375 |     | 
 376 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 377 |     |         vm.assertLtDecimal(left, right, decimals, err);
 378 |     |     }
 379 |     | 
 380 |     |     function assertGt(uint256 left, uint256 right) internal pure virtual {
 381 |     |         vm.assertGt(left, right);
 382 |     |     }
 383 |     | 
 384 |     |     function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {
 385 |     |         vm.assertGt(left, right, err);
 386 |     |     }
 387 |     | 
 388 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 389 |     |         vm.assertGtDecimal(left, right, decimals);
 390 |     |     }
 391 |     | 
 392 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 393 |     |         vm.assertGtDecimal(left, right, decimals, err);
 394 |     |     }
 395 |     | 
 396 |     |     function assertGt(int256 left, int256 right) internal pure virtual {
 397 |     |         vm.assertGt(left, right);
 398 |     |     }
 399 |     | 
 400 |     |     function assertGt(int256 left, int256 right, string memory err) internal pure virtual {
 401 |     |         vm.assertGt(left, right, err);
 402 |     |     }
 403 |     | 
 404 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 405 |     |         vm.assertGtDecimal(left, right, decimals);
 406 |     |     }
 407 |     | 
 408 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 409 |     |         vm.assertGtDecimal(left, right, decimals, err);
 410 |     |     }
 411 |     | 
 412 |     |     function assertLe(uint256 left, uint256 right) internal pure virtual {
 413 |     |         vm.assertLe(left, right);
 414 |     |     }
 415 |     | 
 416 |     |     function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {
 417 |     |         vm.assertLe(left, right, err);
 418 |     |     }
 419 |     | 
 420 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 421 |     |         vm.assertLeDecimal(left, right, decimals);
 422 |     |     }
 423 |     | 
 424 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 425 |     |         vm.assertLeDecimal(left, right, decimals, err);
 426 |     |     }
 427 |     | 
 428 |     |     function assertLe(int256 left, int256 right) internal pure virtual {
 429 |     |         vm.assertLe(left, right);
 430 |     |     }
 431 |     | 
 432 |     |     function assertLe(int256 left, int256 right, string memory err) internal pure virtual {
 433 |     |         vm.assertLe(left, right, err);
 434 |     |     }
 435 |     | 
 436 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 437 |     |         vm.assertLeDecimal(left, right, decimals);
 438 |     |     }
 439 |     | 
 440 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 441 |     |         vm.assertLeDecimal(left, right, decimals, err);
 442 |     |     }
 443 |     | 
 444 |     |     function assertGe(uint256 left, uint256 right) internal pure virtual {
 445 |     |         vm.assertGe(left, right);
 446 |     |     }
 447 |     | 
 448 |     |     function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {
 449 |     |         vm.assertGe(left, right, err);
 450 |     |     }
 451 |     | 
 452 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 453 |     |         vm.assertGeDecimal(left, right, decimals);
 454 |     |     }
 455 |     | 
 456 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 457 |     |         vm.assertGeDecimal(left, right, decimals, err);
 458 |     |     }
 459 |     | 
 460 |     |     function assertGe(int256 left, int256 right) internal pure virtual {
 461 |     |         vm.assertGe(left, right);
 462 |     |     }
 463 |     | 
 464 |     |     function assertGe(int256 left, int256 right, string memory err) internal pure virtual {
 465 |     |         vm.assertGe(left, right, err);
 466 |     |     }
 467 |     | 
 468 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 469 |     |         vm.assertGeDecimal(left, right, decimals);
 470 |     |     }
 471 |     | 
 472 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 473 |     |         vm.assertGeDecimal(left, right, decimals, err);
 474 |     |     }
 475 |     | 
 476 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {
 477 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 478 |     |     }
 479 |     | 
 480 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)
 481 |     |         internal
 482 |     |         pure
 483 |     |         virtual
 484 |     |     {
 485 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 486 |     |     }
 487 |     | 
 488 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)
 489 |     |         internal
 490 |     |         pure
 491 |     |         virtual
 492 |     |     {
 493 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 494 |     |     }
 495 |     | 
 496 |     |     function assertApproxEqAbsDecimal(
 497 |     |         uint256 left,
 498 |     |         uint256 right,
 499 |     |         uint256 maxDelta,
 500 |     |         uint256 decimals,
 501 |     |         string memory err
 502 |     |     ) internal pure virtual {
 503 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 504 |     |     }
 505 |     | 
 506 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {
 507 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 508 |     |     }
 509 |     | 
 510 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {
 511 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 512 |     |     }
 513 |     | 
 514 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)
 515 |     |         internal
 516 |     |         pure
 517 |     |         virtual
 518 |     |     {
 519 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 520 |     |     }
 521 |     | 
 522 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)
 523 |     |         internal
 524 |     |         pure
 525 |     |         virtual
 526 |     |     {
 527 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 528 |     |     }
 529 |     | 
 530 |     |     function assertApproxEqRel(
 531 |     |         uint256 left,
 532 |     |         uint256 right,
 533 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 534 |     |     ) internal pure virtual {
 535 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 536 |     |     }
 537 |     | 
 538 |     |     function assertApproxEqRel(
 539 |     |         uint256 left,
 540 |     |         uint256 right,
 541 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 542 |     |         string memory err
 543 |     |     ) internal pure virtual {
 544 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 545 |     |     }
 546 |     | 
 547 |     |     function assertApproxEqRelDecimal(
 548 |     |         uint256 left,
 549 |     |         uint256 right,
 550 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 551 |     |         uint256 decimals
 552 |     |     ) internal pure virtual {
 553 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 554 |     |     }
 555 |     | 
 556 |     |     function assertApproxEqRelDecimal(
 557 |     |         uint256 left,
 558 |     |         uint256 right,
 559 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 560 |     |         uint256 decimals,
 561 |     |         string memory err
 562 |     |     ) internal pure virtual {
 563 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 564 |     |     }
 565 |     | 
 566 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {
 567 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 568 |     |     }
 569 |     | 
 570 |     |     function assertApproxEqRel(
 571 |     |         int256 left,
 572 |     |         int256 right,
 573 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 574 |     |         string memory err
 575 |     |     ) internal pure virtual {
 576 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 577 |     |     }
 578 |     | 
 579 |     |     function assertApproxEqRelDecimal(
 580 |     |         int256 left,
 581 |     |         int256 right,
 582 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 583 |     |         uint256 decimals
 584 |     |     ) internal pure virtual {
 585 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 586 |     |     }
 587 |     | 
 588 |     |     function assertApproxEqRelDecimal(
 589 |     |         int256 left,
 590 |     |         int256 right,
 591 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 592 |     |         uint256 decimals,
 593 |     |         string memory err
 594 |     |     ) internal pure virtual {
 595 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 596 |     |     }
 597 |     | 
 598 |     |     // Inherited from DSTest, not used but kept for backwards-compatibility
 599 |     |     function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {
 600 |     |         return keccak256(left) == keccak256(right);
 601 |     |     }
 602 |     | 
 603 |     |     function assertEq0(bytes memory left, bytes memory right) internal pure virtual {
 604 |     |         assertEq(left, right);
 605 |     |     }
 606 |     | 
 607 |     |     function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 608 |     |         assertEq(left, right, err);
 609 |     |     }
 610 |     | 
 611 |     |     function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {
 612 |     |         assertNotEq(left, right);
 613 |     |     }
 614 |     | 
 615 |     |     function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 616 |     |         assertNotEq(left, right, err);
 617 |     |     }
 618 |     | 
 619 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 620 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 621 |     |     }
 622 |     | 
 623 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 624 |     |         internal
 625 |     |         virtual
 626 |     |     {
 627 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 628 |     |     }
 629 |     | 
 630 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 631 |     |         internal
 632 |     |         virtual
 633 |     |     {
 634 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 635 |     |     }
 636 |     | 
 637 |     |     function assertEqCall(
 638 |     |         address targetA,
 639 |     |         bytes memory callDataA,
 640 |     |         address targetB,
 641 |     |         bytes memory callDataB,
 642 |     |         bool strictRevertData
 643 |     |     ) internal virtual {
 644 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 645 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 646 |     | 
 647 |     |         if (successA && successB) {
 648 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 649 |     |         }
 650 |     | 
 651 |     |         if (!successA && !successB && strictRevertData) {
 652 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 653 |     |         }
 654 |     | 
 655 |     |         if (!successA && successB) {
 656 |     |             emit log("Error: Calls were not equal");
 657 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 658 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 659 |     |             revert("assertion failed");
 660 |     |         }
 661 |     | 
 662 |     |         if (successA && !successB) {
 663 |     |             emit log("Error: Calls were not equal");
 664 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 665 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 666 |     |             revert("assertion failed");
 667 |     |         }
 668 |     |     }
 669 |     | }
 670 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
   8 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
   9 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  10 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  11 |     |  * alias used in this contract, which can be found as the first argument to the
  12 |     |  * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.
  13 |     |  *
  14 |     |  * There are two main ways to use this contract:
  15 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  16 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  17 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  18 |     |  *
  19 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  20 |     |  * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  21 |     |  * `defaultRpcUrls`.
  22 |     |  *
  23 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  24 |     |  *
  25 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  26 |     |  * we want to retrieve the RPC URL for `mainnet`:
  27 |     |  *   - If you have specified data with `setChain`, it will return that.
  28 |     |  *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it
  29 |     |  *     is valid (e.g. a URL is specified, or an environment variable is given and exists).
  30 |     |  *   - If neither of the above conditions is met, the default data is returned.
  31 |     |  *
  32 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  33 |     |  */
  34 |     | abstract contract StdChains {
  35 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  36 |     | 
  37 |     |     bool private stdChainsInitialized;
  38 |     | 
  39 |     |     struct ChainData {
  40 |     |         string name;
  41 |     |         uint256 chainId;
  42 |     |         string rpcUrl;
  43 |     |     }
  44 |     | 
  45 |     |     struct Chain {
  46 |     |         // The chain name.
  47 |     |         string name;
  48 |     |         // The chain's Chain ID.
  49 |     |         uint256 chainId;
  50 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  51 |     |         string chainAlias;
  52 |     |         // A default RPC endpoint for this chain.
  53 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  54 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  55 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  56 |     |         string rpcUrl;
  57 |     |     }
  58 |     | 
  59 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  60 |     |     mapping(string => Chain) private chains;
  61 |     |     // Maps from the chain's alias to it's default RPC URL.
  62 |     |     mapping(string => string) private defaultRpcUrls;
  63 |     |     // Maps from a chain ID to it's alias.
  64 |     |     mapping(uint256 => string) private idToAlias;
  65 |     | 
  66 | *   |     bool private fallbackToDefaultRpcUrls = true;
  67 |     | 
  68 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  69 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  70 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  71 |     | 
  72 |     |         initializeStdChains();
  73 |     |         chain = chains[chainAlias];
  74 |     |         require(
  75 |     |             chain.chainId != 0,
  76 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  77 |     |         );
  78 |     | 
  79 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  80 |     |     }
  81 |     | 
  82 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  83 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  84 |     |         initializeStdChains();
  85 |     |         string memory chainAlias = idToAlias[chainId];
  86 |     | 
  87 |     |         chain = chains[chainAlias];
  88 |     | 
  89 |     |         require(
  90 |     |             chain.chainId != 0,
  91 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  92 |     |         );
  93 |     | 
  94 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  95 |     |     }
  96 |     | 
  97 |     |     // set chain info, with priority to argument's rpcUrl field.
  98 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
  99 |     |         require(
 100 |     |             bytes(chainAlias).length != 0,
 101 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 102 |     |         );
 103 |     | 
 104 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 105 |     | 
 106 |     |         initializeStdChains();
 107 |     |         string memory foundAlias = idToAlias[chain.chainId];
 108 |     | 
 109 |     |         require(
 110 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 111 |     |             string(
 112 |     |                 abi.encodePacked(
 113 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 114 |     |                     vm.toString(chain.chainId),
 115 |     |                     " already used by \"",
 116 |     |                     foundAlias,
 117 |     |                     "\"."
 118 |     |                 )
 119 |     |             )
 120 |     |         );
 121 |     | 
 122 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 123 |     |         delete idToAlias[oldChainId];
 124 |     | 
 125 |     |         chains[chainAlias] =
 126 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 127 |     |         idToAlias[chain.chainId] = chainAlias;
 128 |     |     }
 129 |     | 
 130 |     |     // set chain info, with priority to argument's rpcUrl field.
 131 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 132 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 133 |     |     }
 134 |     | 
 135 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 136 |     |         bytes memory strb = bytes(str);
 137 |     |         bytes memory copy = new bytes(strb.length);
 138 |     |         for (uint256 i = 0; i < strb.length; i++) {
 139 |     |             bytes1 b = strb[i];
 140 |     |             if (b >= 0x61 && b <= 0x7A) {
 141 |     |                 copy[i] = bytes1(uint8(b) - 32);
 142 |     |             } else {
 143 |     |                 copy[i] = b;
 144 |     |             }
 145 |     |         }
 146 |     |         return string(copy);
 147 |     |     }
 148 |     | 
 149 |     |     // lookup rpcUrl, in descending order of priority:
 150 |     |     // current -> config (foundry.toml) -> environment variable -> default
 151 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 152 |     |         private
 153 |     |         view
 154 |     |         returns (Chain memory)
 155 |     |     {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // Distinguish 'not found' from 'cannot read'
 167 |     |                 // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions
 168 |     |                 bytes memory oldNotFoundError =
 169 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 170 |     |                 bytes memory newNotFoundError = abi.encodeWithSignature(
 171 |     |                     "CheatcodeError(string)", string(abi.encodePacked("invalid rpc url: ", chainAlias))
 172 |     |                 );
 173 |     |                 bytes32 errHash = keccak256(err);
 174 |     |                 if (
 175 |     |                     (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))
 176 |     |                         || bytes(chain.rpcUrl).length == 0
 177 |     |                 ) {
 178 |     |                     /// @solidity memory-safe-assembly
 179 |     |                     assembly {
 180 |     |                         revert(add(32, err), mload(err))
 181 |     |                     }
 182 |     |                 }
 183 |     |             }
 184 |     |         }
 185 |     |         return chain;
 186 |     |     }
 187 |     | 
 188 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 189 |     |         fallbackToDefaultRpcUrls = useDefault;
 190 |     |     }
 191 |     | 
 192 |     |     function initializeStdChains() private {
 193 |     |         if (stdChainsInitialized) return;
 194 |     | 
 195 |     |         stdChainsInitialized = true;
 196 |     | 
 197 |     |         // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`
 198 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 199 |     |         setChainWithDefaultRpcUrl("mainnet", ChainData("Mainnet", 1, "https://eth.llamarpc.com"));
 200 |     |         setChainWithDefaultRpcUrl(
 201 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 202 |     |         );
 203 |     |         setChainWithDefaultRpcUrl("holesky", ChainData("Holesky", 17000, "https://rpc.holesky.ethpandaops.io"));
 204 |     |         setChainWithDefaultRpcUrl("hoodi", ChainData("Hoodi", 560048, "https://rpc.hoodi.ethpandaops.io"));
 205 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 206 |     |         setChainWithDefaultRpcUrl(
 207 |     |             "optimism_sepolia", ChainData("Optimism Sepolia", 11155420, "https://sepolia.optimism.io")
 208 |     |         );
 209 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 210 |     |         setChainWithDefaultRpcUrl(
 211 |     |             "arbitrum_one_sepolia", ChainData("Arbitrum One Sepolia", 421614, "https://sepolia-rollup.arbitrum.io/rpc")
 212 |     |         );
 213 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 214 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 215 |     |         setChainWithDefaultRpcUrl(
 216 |     |             "polygon_amoy", ChainData("Polygon Amoy", 80002, "https://rpc-amoy.polygon.technology")
 217 |     |         );
 218 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 219 |     |         setChainWithDefaultRpcUrl(
 220 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 221 |     |         );
 222 |     |         setChainWithDefaultRpcUrl(
 223 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 224 |     |         );
 225 |     |         setChainWithDefaultRpcUrl(
 226 |     |             "bnb_smart_chain_testnet",
 227 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 228 |     |         );
 229 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 230 |     |         setChainWithDefaultRpcUrl("moonbeam", ChainData("Moonbeam", 1284, "https://rpc.api.moonbeam.network"));
 231 |     |         setChainWithDefaultRpcUrl(
 232 |     |             "moonriver", ChainData("Moonriver", 1285, "https://rpc.api.moonriver.moonbeam.network")
 233 |     |         );
 234 |     |         setChainWithDefaultRpcUrl("moonbase", ChainData("Moonbase", 1287, "https://rpc.testnet.moonbeam.network"));
 235 |     |         setChainWithDefaultRpcUrl("base_sepolia", ChainData("Base Sepolia", 84532, "https://sepolia.base.org"));
 236 |     |         setChainWithDefaultRpcUrl("base", ChainData("Base", 8453, "https://mainnet.base.org"));
 237 |     |         setChainWithDefaultRpcUrl("blast_sepolia", ChainData("Blast Sepolia", 168587773, "https://sepolia.blast.io"));
 238 |     |         setChainWithDefaultRpcUrl("blast", ChainData("Blast", 81457, "https://rpc.blast.io"));
 239 |     |         setChainWithDefaultRpcUrl("fantom_opera", ChainData("Fantom Opera", 250, "https://rpc.ankr.com/fantom/"));
 240 |     |         setChainWithDefaultRpcUrl(
 241 |     |             "fantom_opera_testnet", ChainData("Fantom Opera Testnet", 4002, "https://rpc.ankr.com/fantom_testnet/")
 242 |     |         );
 243 |     |         setChainWithDefaultRpcUrl("fraxtal", ChainData("Fraxtal", 252, "https://rpc.frax.com"));
 244 |     |         setChainWithDefaultRpcUrl("fraxtal_testnet", ChainData("Fraxtal Testnet", 2522, "https://rpc.testnet.frax.com"));
 245 |     |         setChainWithDefaultRpcUrl(
 246 |     |             "berachain_bartio_testnet", ChainData("Berachain bArtio Testnet", 80084, "https://bartio.rpc.berachain.com")
 247 |     |         );
 248 |     |         setChainWithDefaultRpcUrl("flare", ChainData("Flare", 14, "https://flare-api.flare.network/ext/C/rpc"));
 249 |     |         setChainWithDefaultRpcUrl(
 250 |     |             "flare_coston2", ChainData("Flare Coston2", 114, "https://coston2-api.flare.network/ext/C/rpc")
 251 |     |         );
 252 |     | 
 253 |     |         setChainWithDefaultRpcUrl("mode", ChainData("Mode", 34443, "https://mode.drpc.org"));
 254 |     |         setChainWithDefaultRpcUrl("mode_sepolia", ChainData("Mode Sepolia", 919, "https://sepolia.mode.network"));
 255 |     | 
 256 |     |         setChainWithDefaultRpcUrl("zora", ChainData("Zora", 7777777, "https://zora.drpc.org"));
 257 |     |         setChainWithDefaultRpcUrl(
 258 |     |             "zora_sepolia", ChainData("Zora Sepolia", 999999999, "https://sepolia.rpc.zora.energy")
 259 |     |         );
 260 |     | 
 261 |     |         setChainWithDefaultRpcUrl("race", ChainData("Race", 6805, "https://racemainnet.io"));
 262 |     |         setChainWithDefaultRpcUrl("race_sepolia", ChainData("Race Sepolia", 6806, "https://racemainnet.io"));
 263 |     | 
 264 |     |         setChainWithDefaultRpcUrl("metal", ChainData("Metal", 1750, "https://metall2.drpc.org"));
 265 |     |         setChainWithDefaultRpcUrl("metal_sepolia", ChainData("Metal Sepolia", 1740, "https://testnet.rpc.metall2.com"));
 266 |     | 
 267 |     |         setChainWithDefaultRpcUrl("binary", ChainData("Binary", 624, "https://rpc.zero.thebinaryholdings.com"));
 268 |     |         setChainWithDefaultRpcUrl(
 269 |     |             "binary_sepolia", ChainData("Binary Sepolia", 625, "https://rpc.zero.thebinaryholdings.com")
 270 |     |         );
 271 |     | 
 272 |     |         setChainWithDefaultRpcUrl("orderly", ChainData("Orderly", 291, "https://rpc.orderly.network"));
 273 |     |         setChainWithDefaultRpcUrl(
 274 |     |             "orderly_sepolia", ChainData("Orderly Sepolia", 4460, "https://testnet-rpc.orderly.org")
 275 |     |         );
 276 |     |     }
 277 |     | 
 278 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 279 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 280 |     |         string memory rpcUrl = chain.rpcUrl;
 281 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 282 |     |         chain.rpcUrl = "";
 283 |     |         setChain(chainAlias, chain);
 284 |     |         chain.rpcUrl = rpcUrl; // restore argument
 285 |     |     }
 286 |     | }
 287 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {console2} from "./console2.sol";
   8 |     | import {Vm} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdCheatsSafe {
  11 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  12 |     | 
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     bool private gasMeteringOff;
  17 |     | 
  18 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  19 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  20 |     |     // and then converted to the one that is used by the user for better UX.
  21 |     | 
  22 |     |     struct RawTx1559 {
  23 |     |         string[] arguments;
  24 |     |         address contractAddress;
  25 |     |         string contractName;
  26 |     |         // json value name = function
  27 |     |         string functionSig;
  28 |     |         bytes32 hash;
  29 |     |         // json value name = tx
  30 |     |         RawTx1559Detail txDetail;
  31 |     |         // json value name = type
  32 |     |         string opcode;
  33 |     |     }
  34 |     | 
  35 |     |     struct RawTx1559Detail {
  36 |     |         AccessList[] accessList;
  37 |     |         bytes data;
  38 |     |         address from;
  39 |     |         bytes gas;
  40 |     |         bytes nonce;
  41 |     |         address to;
  42 |     |         bytes txType;
  43 |     |         bytes value;
  44 |     |     }
  45 |     | 
  46 |     |     struct Tx1559 {
  47 |     |         string[] arguments;
  48 |     |         address contractAddress;
  49 |     |         string contractName;
  50 |     |         string functionSig;
  51 |     |         bytes32 hash;
  52 |     |         Tx1559Detail txDetail;
  53 |     |         string opcode;
  54 |     |     }
  55 |     | 
  56 |     |     struct Tx1559Detail {
  57 |     |         AccessList[] accessList;
  58 |     |         bytes data;
  59 |     |         address from;
  60 |     |         uint256 gas;
  61 |     |         uint256 nonce;
  62 |     |         address to;
  63 |     |         uint256 txType;
  64 |     |         uint256 value;
  65 |     |     }
  66 |     | 
  67 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  68 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  69 |     |     // and then converted to the one that is used by the user for better UX.
  70 |     | 
  71 |     |     struct TxLegacy {
  72 |     |         string[] arguments;
  73 |     |         address contractAddress;
  74 |     |         string contractName;
  75 |     |         string functionSig;
  76 |     |         string hash;
  77 |     |         string opcode;
  78 |     |         TxDetailLegacy transaction;
  79 |     |     }
  80 |     | 
  81 |     |     struct TxDetailLegacy {
  82 |     |         AccessList[] accessList;
  83 |     |         uint256 chainId;
  84 |     |         bytes data;
  85 |     |         address from;
  86 |     |         uint256 gas;
  87 |     |         uint256 gasPrice;
  88 |     |         bytes32 hash;
  89 |     |         uint256 nonce;
  90 |     |         bytes1 opcode;
  91 |     |         bytes32 r;
  92 |     |         bytes32 s;
  93 |     |         uint256 txType;
  94 |     |         address to;
  95 |     |         uint8 v;
  96 |     |         uint256 value;
  97 |     |     }
  98 |     | 
  99 |     |     struct AccessList {
 100 |     |         address accessAddress;
 101 |     |         bytes32[] storageKeys;
 102 |     |     }
 103 |     | 
 104 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 105 |     |     // The Raw structs is what is parsed from the JSON
 106 |     |     // and then converted to the one that is used by the user for better UX.
 107 |     | 
 108 |     |     struct RawReceipt {
 109 |     |         bytes32 blockHash;
 110 |     |         bytes blockNumber;
 111 |     |         address contractAddress;
 112 |     |         bytes cumulativeGasUsed;
 113 |     |         bytes effectiveGasPrice;
 114 |     |         address from;
 115 |     |         bytes gasUsed;
 116 |     |         RawReceiptLog[] logs;
 117 |     |         bytes logsBloom;
 118 |     |         bytes status;
 119 |     |         address to;
 120 |     |         bytes32 transactionHash;
 121 |     |         bytes transactionIndex;
 122 |     |     }
 123 |     | 
 124 |     |     struct Receipt {
 125 |     |         bytes32 blockHash;
 126 |     |         uint256 blockNumber;
 127 |     |         address contractAddress;
 128 |     |         uint256 cumulativeGasUsed;
 129 |     |         uint256 effectiveGasPrice;
 130 |     |         address from;
 131 |     |         uint256 gasUsed;
 132 |     |         ReceiptLog[] logs;
 133 |     |         bytes logsBloom;
 134 |     |         uint256 status;
 135 |     |         address to;
 136 |     |         bytes32 transactionHash;
 137 |     |         uint256 transactionIndex;
 138 |     |     }
 139 |     | 
 140 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 141 |     |     // transactions conform to EIP1559.
 142 |     | 
 143 |     |     struct EIP1559ScriptArtifact {
 144 |     |         string[] libraries;
 145 |     |         string path;
 146 |     |         string[] pending;
 147 |     |         Receipt[] receipts;
 148 |     |         uint256 timestamp;
 149 |     |         Tx1559[] transactions;
 150 |     |         TxReturn[] txReturns;
 151 |     |     }
 152 |     | 
 153 |     |     struct RawEIP1559ScriptArtifact {
 154 |     |         string[] libraries;
 155 |     |         string path;
 156 |     |         string[] pending;
 157 |     |         RawReceipt[] receipts;
 158 |     |         TxReturn[] txReturns;
 159 |     |         uint256 timestamp;
 160 |     |         RawTx1559[] transactions;
 161 |     |     }
 162 |     | 
 163 |     |     struct RawReceiptLog {
 164 |     |         // json value = address
 165 |     |         address logAddress;
 166 |     |         bytes32 blockHash;
 167 |     |         bytes blockNumber;
 168 |     |         bytes data;
 169 |     |         bytes logIndex;
 170 |     |         bool removed;
 171 |     |         bytes32[] topics;
 172 |     |         bytes32 transactionHash;
 173 |     |         bytes transactionIndex;
 174 |     |         bytes transactionLogIndex;
 175 |     |     }
 176 |     | 
 177 |     |     struct ReceiptLog {
 178 |     |         // json value = address
 179 |     |         address logAddress;
 180 |     |         bytes32 blockHash;
 181 |     |         uint256 blockNumber;
 182 |     |         bytes data;
 183 |     |         uint256 logIndex;
 184 |     |         bytes32[] topics;
 185 |     |         uint256 transactionIndex;
 186 |     |         uint256 transactionLogIndex;
 187 |     |         bool removed;
 188 |     |     }
 189 |     | 
 190 |     |     struct TxReturn {
 191 |     |         string internalType;
 192 |     |         string value;
 193 |     |     }
 194 |     | 
 195 |     |     struct Account {
 196 |     |         address addr;
 197 |     |         uint256 key;
 198 |     |     }
 199 |     | 
 200 |     |     enum AddressType {
 201 |     |         Payable,
 202 |     |         NonPayable,
 203 |     |         ZeroAddress,
 204 |     |         Precompile,
 205 |     |         ForgeAddress
 206 |     |     }
 207 |     | 
 208 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 209 |     |     function assumeNotBlacklisted(address token, address addr) internal view virtual {
 210 |     |         // Nothing to check if `token` is not a contract.
 211 |     |         uint256 tokenCodeSize;
 212 |     |         assembly {
 213 |     |             tokenCodeSize := extcodesize(token)
 214 |     |         }
 215 |     |         require(tokenCodeSize > 0, "StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.");
 216 |     | 
 217 |     |         bool success;
 218 |     |         bytes memory returnData;
 219 |     | 
 220 |     |         // 4-byte selector for `isBlacklisted(address)`, used by USDC.
 221 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));
 222 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 223 |     | 
 224 |     |         // 4-byte selector for `isBlackListed(address)`, used by USDT.
 225 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));
 226 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 227 |     |     }
 228 |     | 
 229 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 230 |     |     // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for
 231 |     |     // backwards compatibility, since this name was used in the original PR which already has
 232 |     |     // a release. This function can be removed in a future release once we want a breaking change.
 233 |     |     function assumeNoBlacklisted(address token, address addr) internal view virtual {
 234 |     |         assumeNotBlacklisted(token, addr);
 235 |     |     }
 236 |     | 
 237 |     |     function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {
 238 |     |         if (addressType == AddressType.Payable) {
 239 |     |             assumeNotPayable(addr);
 240 |     |         } else if (addressType == AddressType.NonPayable) {
 241 |     |             assumePayable(addr);
 242 |     |         } else if (addressType == AddressType.ZeroAddress) {
 243 |     |             assumeNotZeroAddress(addr);
 244 |     |         } else if (addressType == AddressType.Precompile) {
 245 |     |             assumeNotPrecompile(addr);
 246 |     |         } else if (addressType == AddressType.ForgeAddress) {
 247 |     |             assumeNotForgeAddress(addr);
 248 |     |         }
 249 |     |     }
 250 |     | 
 251 |     |     function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {
 252 |     |         assumeAddressIsNot(addr, addressType1);
 253 |     |         assumeAddressIsNot(addr, addressType2);
 254 |     |     }
 255 |     | 
 256 |     |     function assumeAddressIsNot(
 257 |     |         address addr,
 258 |     |         AddressType addressType1,
 259 |     |         AddressType addressType2,
 260 |     |         AddressType addressType3
 261 |     |     ) internal virtual {
 262 |     |         assumeAddressIsNot(addr, addressType1);
 263 |     |         assumeAddressIsNot(addr, addressType2);
 264 |     |         assumeAddressIsNot(addr, addressType3);
 265 |     |     }
 266 |     | 
 267 |     |     function assumeAddressIsNot(
 268 |     |         address addr,
 269 |     |         AddressType addressType1,
 270 |     |         AddressType addressType2,
 271 |     |         AddressType addressType3,
 272 |     |         AddressType addressType4
 273 |     |     ) internal virtual {
 274 |     |         assumeAddressIsNot(addr, addressType1);
 275 |     |         assumeAddressIsNot(addr, addressType2);
 276 |     |         assumeAddressIsNot(addr, addressType3);
 277 |     |         assumeAddressIsNot(addr, addressType4);
 278 |     |     }
 279 |     | 
 280 |     |     // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to
 281 |     |     // `addr` and checking the `success` return value.
 282 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 283 |     |     // implemented by `addr`, which should be taken into account when this function is used.
 284 |     |     function _isPayable(address addr) private returns (bool) {
 285 |     |         require(
 286 |     |             addr.balance < UINT256_MAX,
 287 |     |             "StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds"
 288 |     |         );
 289 |     |         uint256 origBalanceTest = address(this).balance;
 290 |     |         uint256 origBalanceAddr = address(addr).balance;
 291 |     | 
 292 |     |         vm.deal(address(this), 1);
 293 |     |         (bool success,) = payable(addr).call{value: 1}("");
 294 |     | 
 295 |     |         // reset balances
 296 |     |         vm.deal(address(this), origBalanceTest);
 297 |     |         vm.deal(addr, origBalanceAddr);
 298 |     | 
 299 |     |         return success;
 300 |     |     }
 301 |     | 
 302 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 303 |     |     // implemented by `addr`, which should be taken into account when this function is used. See the
 304 |     |     // `_isPayable` method for more information.
 305 |     |     function assumePayable(address addr) internal virtual {
 306 |     |         vm.assume(_isPayable(addr));
 307 |     |     }
 308 |     | 
 309 |     |     function assumeNotPayable(address addr) internal virtual {
 310 |     |         vm.assume(!_isPayable(addr));
 311 |     |     }
 312 |     | 
 313 |     |     function assumeNotZeroAddress(address addr) internal pure virtual {
 314 |     |         vm.assume(addr != address(0));
 315 |     |     }
 316 |     | 
 317 |     |     function assumeNotPrecompile(address addr) internal pure virtual {
 318 |     |         assumeNotPrecompile(addr, _pureChainId());
 319 |     |     }
 320 |     | 
 321 |     |     function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {
 322 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 323 |     |         // address), but the same rationale for excluding them applies so we include those too.
 324 |     | 
 325 |     |         // These are reserved by Ethereum and may be on all EVM-compatible chains.
 326 |     |         vm.assume(addr < address(0x1) || addr > address(0xff));
 327 |     | 
 328 |     |         // forgefmt: disable-start
 329 |     |         if (chainId == 10 || chainId == 420) {
 330 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 331 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 332 |     |         } else if (chainId == 42161 || chainId == 421613) {
 333 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 334 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 335 |     |         } else if (chainId == 43114 || chainId == 43113) {
 336 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 337 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 338 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 339 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 340 |     |         }
 341 |     |         // forgefmt: disable-end
 342 |     |     }
 343 |     | 
 344 |     |     function assumeNotForgeAddress(address addr) internal pure virtual {
 345 |     |         // vm, console, and Create2Deployer addresses
 346 |     |         vm.assume(
 347 |     |             addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67
 348 |     |                 && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C
 349 |     |         );
 350 |     |     }
 351 |     | 
 352 |     |     function assumeUnusedAddress(address addr) internal view virtual {
 353 |     |         uint256 size;
 354 |     |         assembly {
 355 |     |             size := extcodesize(addr)
 356 |     |         }
 357 |     |         vm.assume(size == 0);
 358 |     | 
 359 |     |         assumeNotPrecompile(addr);
 360 |     |         assumeNotZeroAddress(addr);
 361 |     |         assumeNotForgeAddress(addr);
 362 |     |     }
 363 |     | 
 364 |     |     function readEIP1559ScriptArtifact(string memory path)
 365 |     |         internal
 366 |     |         view
 367 |     |         virtual
 368 |     |         returns (EIP1559ScriptArtifact memory)
 369 |     |     {
 370 |     |         string memory data = vm.readFile(path);
 371 |     |         bytes memory parsedData = vm.parseJson(data);
 372 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 373 |     |         EIP1559ScriptArtifact memory artifact;
 374 |     |         artifact.libraries = rawArtifact.libraries;
 375 |     |         artifact.path = rawArtifact.path;
 376 |     |         artifact.timestamp = rawArtifact.timestamp;
 377 |     |         artifact.pending = rawArtifact.pending;
 378 |     |         artifact.txReturns = rawArtifact.txReturns;
 379 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 380 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 381 |     |         return artifact;
 382 |     |     }
 383 |     | 
 384 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 385 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 386 |     |         for (uint256 i; i < rawTxs.length; i++) {
 387 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 388 |     |         }
 389 |     |         return txs;
 390 |     |     }
 391 |     | 
 392 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 393 |     |         Tx1559 memory transaction;
 394 |     |         transaction.arguments = rawTx.arguments;
 395 |     |         transaction.contractName = rawTx.contractName;
 396 |     |         transaction.functionSig = rawTx.functionSig;
 397 |     |         transaction.hash = rawTx.hash;
 398 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 399 |     |         transaction.opcode = rawTx.opcode;
 400 |     |         return transaction;
 401 |     |     }
 402 |     | 
 403 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 404 |     |         internal
 405 |     |         pure
 406 |     |         virtual
 407 |     |         returns (Tx1559Detail memory)
 408 |     |     {
 409 |     |         Tx1559Detail memory txDetail;
 410 |     |         txDetail.data = rawDetail.data;
 411 |     |         txDetail.from = rawDetail.from;
 412 |     |         txDetail.to = rawDetail.to;
 413 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 414 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 415 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 416 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 417 |     |         txDetail.accessList = rawDetail.accessList;
 418 |     |         return txDetail;
 419 |     |     }
 420 |     | 
 421 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 422 |     |         string memory deployData = vm.readFile(path);
 423 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 424 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 425 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 426 |     |     }
 427 |     | 
 428 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 429 |     |         string memory deployData = vm.readFile(path);
 430 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 431 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 432 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 433 |     |         return rawToConvertedEIPTx1559(rawTx);
 434 |     |     }
 435 |     | 
 436 |     |     // Analogous to readTransactions, but for receipts.
 437 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 438 |     |         string memory deployData = vm.readFile(path);
 439 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 440 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 441 |     |         return rawToConvertedReceipts(rawReceipts);
 442 |     |     }
 443 |     | 
 444 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 445 |     |         string memory deployData = vm.readFile(path);
 446 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 447 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 448 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 449 |     |         return rawToConvertedReceipt(rawReceipt);
 450 |     |     }
 451 |     | 
 452 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 453 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 454 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 455 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 456 |     |         }
 457 |     |         return receipts;
 458 |     |     }
 459 |     | 
 460 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 461 |     |         Receipt memory receipt;
 462 |     |         receipt.blockHash = rawReceipt.blockHash;
 463 |     |         receipt.to = rawReceipt.to;
 464 |     |         receipt.from = rawReceipt.from;
 465 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 466 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 467 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 468 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 469 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 470 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 471 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 472 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 473 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 474 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 475 |     |         return receipt;
 476 |     |     }
 477 |     | 
 478 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 479 |     |         internal
 480 |     |         pure
 481 |     |         virtual
 482 |     |         returns (ReceiptLog[] memory)
 483 |     |     {
 484 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 485 |     |         for (uint256 i; i < rawLogs.length; i++) {
 486 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 487 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 488 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 489 |     |             logs[i].data = rawLogs[i].data;
 490 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 491 |     |             logs[i].topics = rawLogs[i].topics;
 492 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 493 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 494 |     |             logs[i].removed = rawLogs[i].removed;
 495 |     |         }
 496 |     |         return logs;
 497 |     |     }
 498 |     | 
 499 |     |     // Deploy a contract by fetching the contract bytecode from
 500 |     |     // the artifacts directory
 501 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 502 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 503 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 504 |     |         /// @solidity memory-safe-assembly
 505 |     |         assembly {
 506 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 507 |     |         }
 508 |     | 
 509 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 510 |     |     }
 511 |     | 
 512 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 513 |     |         bytes memory bytecode = vm.getCode(what);
 514 |     |         /// @solidity memory-safe-assembly
 515 |     |         assembly {
 516 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 517 |     |         }
 518 |     | 
 519 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 520 |     |     }
 521 |     | 
 522 |     |     /// @dev deploy contract with value on construction
 523 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 524 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 525 |     |         /// @solidity memory-safe-assembly
 526 |     |         assembly {
 527 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 528 |     |         }
 529 |     | 
 530 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 531 |     |     }
 532 |     | 
 533 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 534 |     |         bytes memory bytecode = vm.getCode(what);
 535 |     |         /// @solidity memory-safe-assembly
 536 |     |         assembly {
 537 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 538 |     |         }
 539 |     | 
 540 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 541 |     |     }
 542 |     | 
 543 |     |     // creates a labeled address and the corresponding private key
 544 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 545 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 546 |     |         addr = vm.addr(privateKey);
 547 |     |         vm.label(addr, name);
 548 |     |     }
 549 |     | 
 550 |     |     // creates a labeled address
 551 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 552 |     |         (addr,) = makeAddrAndKey(name);
 553 |     |     }
 554 |     | 
 555 |     |     // Destroys an account immediately, sending the balance to beneficiary.
 556 |     |     // Destroying means: balance will be zero, code will be empty, and nonce will be 0
 557 |     |     // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce
 558 |     |     // only after tx ends, this will run immediately.
 559 |     |     function destroyAccount(address who, address beneficiary) internal virtual {
 560 |     |         uint256 currBalance = who.balance;
 561 |     |         vm.etch(who, abi.encode());
 562 |     |         vm.deal(who, 0);
 563 |     |         vm.resetNonce(who);
 564 |     | 
 565 |     |         uint256 beneficiaryBalance = beneficiary.balance;
 566 |     |         vm.deal(beneficiary, currBalance + beneficiaryBalance);
 567 |     |     }
 568 |     | 
 569 |     |     // creates a struct containing both a labeled address and the corresponding private key
 570 |     |     function makeAccount(string memory name) internal virtual returns (Account memory account) {
 571 |     |         (account.addr, account.key) = makeAddrAndKey(name);
 572 |     |     }
 573 |     | 
 574 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 575 |     |         internal
 576 |     |         virtual
 577 |     |         returns (address who, uint256 privateKey)
 578 |     |     {
 579 |     |         privateKey = vm.deriveKey(mnemonic, index);
 580 |     |         who = vm.rememberKey(privateKey);
 581 |     |     }
 582 |     | 
 583 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 584 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 585 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 586 |     |     }
 587 |     | 
 588 |     |     function isFork() internal view virtual returns (bool status) {
 589 |     |         try vm.activeFork() {
 590 |     |             status = true;
 591 |     |         } catch (bytes memory) {}
 592 |     |     }
 593 |     | 
 594 |     |     modifier skipWhenForking() {
 595 |     |         if (!isFork()) {
 596 |     |             _;
 597 |     |         }
 598 |     |     }
 599 |     | 
 600 |     |     modifier skipWhenNotForking() {
 601 |     |         if (isFork()) {
 602 |     |             _;
 603 |     |         }
 604 |     |     }
 605 |     | 
 606 |     |     modifier noGasMetering() {
 607 |     |         vm.pauseGasMetering();
 608 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 609 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 610 |     |         // it back on until we exit the top level function that used the modifier
 611 |     |         //
 612 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 613 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 614 |     |         // so we only turn metering back on at the end of the funcA
 615 |     |         bool gasStartedOff = gasMeteringOff;
 616 |     |         gasMeteringOff = true;
 617 |     | 
 618 |     |         _;
 619 |     | 
 620 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 621 |     |         if (!gasStartedOff) {
 622 |     |             gasMeteringOff = false;
 623 |     |             vm.resumeGasMetering();
 624 |     |         }
 625 |     |     }
 626 |     | 
 627 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 628 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 629 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 630 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 631 |     |     function _viewChainId() private view returns (uint256 chainId) {
 632 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 633 |     |         assembly {
 634 |     |             chainId := chainid()
 635 |     |         }
 636 |     | 
 637 |     |         address(this); // Silence warnings in older Solc versions.
 638 |     |     }
 639 |     | 
 640 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 641 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 642 |     |         function() internal pure returns (uint256) pureChainId;
 643 |     |         assembly {
 644 |     |             pureChainId := fnIn
 645 |     |         }
 646 |     |         chainId = pureChainId();
 647 |     |     }
 648 |     | }
 649 |     | 
 650 |     | // Wrappers around cheatcodes to avoid footguns
 651 |     | abstract contract StdCheats is StdCheatsSafe {
 652 |     |     using stdStorage for StdStorage;
 653 |     | 
 654 |     |     StdStorage private stdstore;
 655 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 656 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
 657 |     | 
 658 |     |     // Skip forward or rewind time by the specified number of seconds
 659 |     |     function skip(uint256 time) internal virtual {
 660 |     |         vm.warp(vm.getBlockTimestamp() + time);
 661 |     |     }
 662 |     | 
 663 |     |     function rewind(uint256 time) internal virtual {
 664 |     |         vm.warp(vm.getBlockTimestamp() - time);
 665 |     |     }
 666 |     | 
 667 |     |     // Setup a prank from an address that has some ether
 668 |     |     function hoax(address msgSender) internal virtual {
 669 |     |         vm.deal(msgSender, 1 << 128);
 670 |     |         vm.prank(msgSender);
 671 |     |     }
 672 |     | 
 673 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 674 |     |         vm.deal(msgSender, give);
 675 |     |         vm.prank(msgSender);
 676 |     |     }
 677 |     | 
 678 |     |     function hoax(address msgSender, address origin) internal virtual {
 679 |     |         vm.deal(msgSender, 1 << 128);
 680 |     |         vm.prank(msgSender, origin);
 681 |     |     }
 682 |     | 
 683 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 684 |     |         vm.deal(msgSender, give);
 685 |     |         vm.prank(msgSender, origin);
 686 |     |     }
 687 |     | 
 688 |     |     // Start perpetual prank from an address that has some ether
 689 |     |     function startHoax(address msgSender) internal virtual {
 690 |     |         vm.deal(msgSender, 1 << 128);
 691 |     |         vm.startPrank(msgSender);
 692 |     |     }
 693 |     | 
 694 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 695 |     |         vm.deal(msgSender, give);
 696 |     |         vm.startPrank(msgSender);
 697 |     |     }
 698 |     | 
 699 |     |     // Start perpetual prank from an address that has some ether
 700 |     |     // tx.origin is set to the origin parameter
 701 |     |     function startHoax(address msgSender, address origin) internal virtual {
 702 |     |         vm.deal(msgSender, 1 << 128);
 703 |     |         vm.startPrank(msgSender, origin);
 704 |     |     }
 705 |     | 
 706 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 707 |     |         vm.deal(msgSender, give);
 708 |     |         vm.startPrank(msgSender, origin);
 709 |     |     }
 710 |     | 
 711 |     |     function changePrank(address msgSender) internal virtual {
 712 |     |         console2_log_StdCheats("changePrank is deprecated. Please use vm.startPrank instead.");
 713 |     |         vm.stopPrank();
 714 |     |         vm.startPrank(msgSender);
 715 |     |     }
 716 |     | 
 717 |     |     function changePrank(address msgSender, address txOrigin) internal virtual {
 718 |     |         vm.stopPrank();
 719 |     |         vm.startPrank(msgSender, txOrigin);
 720 |     |     }
 721 |     | 
 722 |     |     // The same as Vm's `deal`
 723 |     |     // Use the alternative signature for ERC20 tokens
 724 |     |     function deal(address to, uint256 give) internal virtual {
 725 |     |         vm.deal(to, give);
 726 |     |     }
 727 |     | 
 728 |     |     // Set the balance of an account for any ERC20 token
 729 |     |     // Use the alternative signature to update `totalSupply`
 730 |     |     function deal(address token, address to, uint256 give) internal virtual {
 731 |     |         deal(token, to, give, false);
 732 |     |     }
 733 |     | 
 734 |     |     // Set the balance of an account for any ERC1155 token
 735 |     |     // Use the alternative signature to update `totalSupply`
 736 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 737 |     |         dealERC1155(token, to, id, give, false);
 738 |     |     }
 739 |     | 
 740 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 741 |     |         // get current balance
 742 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 743 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 744 |     | 
 745 |     |         // update balance
 746 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 747 |     | 
 748 |     |         // update total supply
 749 |     |         if (adjust) {
 750 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));
 751 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 752 |     |             if (give < prevBal) {
 753 |     |                 totSup -= (prevBal - give);
 754 |     |             } else {
 755 |     |                 totSup += (give - prevBal);
 756 |     |             }
 757 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 758 |     |         }
 759 |     |     }
 760 |     | 
 761 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 762 |     |         // get current balance
 763 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));
 764 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 765 |     | 
 766 |     |         // update balance
 767 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 768 |     | 
 769 |     |         // update total supply
 770 |     |         if (adjust) {
 771 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));
 772 |     |             require(
 773 |     |                 totSupData.length != 0,
 774 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 775 |     |             );
 776 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 777 |     |             if (give < prevBal) {
 778 |     |                 totSup -= (prevBal - give);
 779 |     |             } else {
 780 |     |                 totSup += (give - prevBal);
 781 |     |             }
 782 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 783 |     |         }
 784 |     |     }
 785 |     | 
 786 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 787 |     |         // check if token id is already minted and the actual owner.
 788 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 789 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 790 |     | 
 791 |     |         // get owner current balance
 792 |     |         (, bytes memory fromBalData) =
 793 |     |             token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 794 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 795 |     | 
 796 |     |         // get new user current balance
 797 |     |         (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 798 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 799 |     | 
 800 |     |         // update balances
 801 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 802 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 803 |     | 
 804 |     |         // update owner
 805 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 806 |     |     }
 807 |     | 
 808 |     |     function deployCodeTo(string memory what, address where) internal virtual {
 809 |     |         deployCodeTo(what, "", 0, where);
 810 |     |     }
 811 |     | 
 812 |     |     function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {
 813 |     |         deployCodeTo(what, args, 0, where);
 814 |     |     }
 815 |     | 
 816 |     |     function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {
 817 |     |         bytes memory creationCode = vm.getCode(what);
 818 |     |         vm.etch(where, abi.encodePacked(creationCode, args));
 819 |     |         (bool success, bytes memory runtimeBytecode) = where.call{value: value}("");
 820 |     |         require(success, "StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.");
 821 |     |         vm.etch(where, runtimeBytecode);
 822 |     |     }
 823 |     | 
 824 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 825 |     |     function console2_log_StdCheats(string memory p0) private view {
 826 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string)", p0));
 827 |     |         status;
 828 |     |     }
 829 |     | }
 830 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdConstants.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
  5 |     | import {Vm} from "./Vm.sol";
  6 |     | 
  7 | *   | library StdConstants {
  8 |     |     /// @dev Cheat code address.
  9 |     |     /// Calculated as `address(uint160(uint256(keccak256("hevm cheat code"))))`.
 10 |     |     Vm internal constant VM = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 11 |     |     /// @dev console.sol and console2.sol work by executing a staticcall to this address.
 12 |     |     /// Calculated as `address(uint160(uint88(bytes11("console.log"))))`.
 13 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 14 |     |     /// @dev Used when deploying with create2.
 15 |     |     /// Taken from https://github.com/Arachnid/deterministic-deployment-proxy.
 16 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 17 |     |     /// @dev The default address for tx.origin and msg.sender.
 18 |     |     /// Calculated as `address(uint160(uint256(keccak256("foundry default caller"))))`.
 19 |     |     address internal constant DEFAULT_SENDER = 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38;
 20 |     |     /// @dev The address of the first contract `CREATE`d by a running test contract.
 21 |     |     /// When running tests, each test contract is `CREATE`d by `DEFAULT_SENDER` with nonce 1.
 22 |     |     /// Calculated as `VM.computeCreateAddress(VM.computeCreateAddress(DEFAULT_SENDER, 1), 1)`.
 23 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 24 |     |     /// @dev Deterministic deployment address of the Multicall3 contract.
 25 |     |     /// Taken from https://www.multicall3.com.
 26 |     |     IMulticall3 internal constant MULTICALL3_ADDRESS = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
 27 |     |     /// @dev The order of the secp256k1 curve.
 28 |     |     uint256 internal constant SECP256K1_ORDER =
 29 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 30 |     | }
 31 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdInvariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | abstract contract StdInvariant {
   7 |     |     struct FuzzSelector {
   8 |     |         address addr;
   9 |     |         bytes4[] selectors;
  10 |     |     }
  11 |     | 
  12 |     |     struct FuzzArtifactSelector {
  13 |     |         string artifact;
  14 |     |         bytes4[] selectors;
  15 |     |     }
  16 |     | 
  17 |     |     struct FuzzInterface {
  18 |     |         address addr;
  19 |     |         string[] artifacts;
  20 |     |     }
  21 |     | 
  22 |     |     address[] private _excludedContracts;
  23 |     |     address[] private _excludedSenders;
  24 |     |     address[] private _targetedContracts;
  25 |     |     address[] private _targetedSenders;
  26 |     | 
  27 |     |     string[] private _excludedArtifacts;
  28 |     |     string[] private _targetedArtifacts;
  29 |     | 
  30 |     |     FuzzArtifactSelector[] private _targetedArtifactSelectors;
  31 |     | 
  32 |     |     FuzzSelector[] private _excludedSelectors;
  33 |     |     FuzzSelector[] private _targetedSelectors;
  34 |     | 
  35 |     |     FuzzInterface[] private _targetedInterfaces;
  36 |     | 
  37 |     |     // Functions for users:
  38 |     |     // These are intended to be called in tests.
  39 |     | 
  40 |     |     function excludeContract(address newExcludedContract_) internal {
  41 |     |         _excludedContracts.push(newExcludedContract_);
  42 |     |     }
  43 |     | 
  44 |     |     function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {
  45 |     |         _excludedSelectors.push(newExcludedSelector_);
  46 |     |     }
  47 |     | 
  48 |     |     function excludeSender(address newExcludedSender_) internal {
  49 |     |         _excludedSenders.push(newExcludedSender_);
  50 |     |     }
  51 |     | 
  52 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
  53 |     |         _excludedArtifacts.push(newExcludedArtifact_);
  54 |     |     }
  55 |     | 
  56 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
  57 |     |         _targetedArtifacts.push(newTargetedArtifact_);
  58 |     |     }
  59 |     | 
  60 |     |     function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {
  61 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
  62 |     |     }
  63 |     | 
  64 |     |     function targetContract(address newTargetedContract_) internal {
  65 |     |         _targetedContracts.push(newTargetedContract_);
  66 |     |     }
  67 |     | 
  68 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
  69 |     |         _targetedSelectors.push(newTargetedSelector_);
  70 |     |     }
  71 |     | 
  72 |     |     function targetSender(address newTargetedSender_) internal {
  73 |     |         _targetedSenders.push(newTargetedSender_);
  74 |     |     }
  75 |     | 
  76 |     |     function targetInterface(FuzzInterface memory newTargetedInterface_) internal {
  77 |     |         _targetedInterfaces.push(newTargetedInterface_);
  78 |     |     }
  79 |     | 
  80 |     |     // Functions for forge:
  81 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
  82 |     | 
  83 |     |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
  84 |     |         excludedArtifacts_ = _excludedArtifacts;
  85 |     |     }
  86 |     | 
  87 |     |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
  88 |     |         excludedContracts_ = _excludedContracts;
  89 |     |     }
  90 |     | 
  91 |     |     function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {
  92 |     |         excludedSelectors_ = _excludedSelectors;
  93 |     |     }
  94 |     | 
  95 |     |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
  96 |     |         excludedSenders_ = _excludedSenders;
  97 |     |     }
  98 |     | 
  99 |     |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
 100 |     |         targetedArtifacts_ = _targetedArtifacts;
 101 |     |     }
 102 |     | 
 103 |     |     function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {
 104 |     |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
 105 |     |     }
 106 |     | 
 107 |     |     function targetContracts() public view returns (address[] memory targetedContracts_) {
 108 |     |         targetedContracts_ = _targetedContracts;
 109 |     |     }
 110 |     | 
 111 |     |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
 112 |     |         targetedSelectors_ = _targetedSelectors;
 113 |     |     }
 114 |     | 
 115 |     |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 116 |     |         targetedSenders_ = _targetedSenders;
 117 |     |     }
 118 |     | 
 119 |     |     function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {
 120 |     |         targetedInterfaces_ = _targetedInterfaces;
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("<some_path>");
  13 |     | // json.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 | *   | library stdJson {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function keyExists(string memory json, string memory key) internal view returns (bool) {
  29 |     |         return vm.keyExistsJson(json, key);
  30 |     |     }
  31 |     | 
  32 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseJson(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseJsonUint(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseJsonUintArray(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseJsonInt(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseJsonIntArray(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseJsonBytes32(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseJsonBytes32Array(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseJsonString(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseJsonStringArray(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseJsonAddress(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseJsonAddressArray(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseJsonBool(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseJsonBoolArray(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseJsonBytes(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseJsonBytesArray(json, key);
  90 |     |     }
  91 |     | 
  92 |     |     function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {
  93 |     |         return keyExists(json, key) ? readUint(json, key) : defaultValue;
  94 |     |     }
  95 |     | 
  96 |     |     function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)
  97 |     |         internal
  98 |     |         view
  99 |     |         returns (uint256[] memory)
 100 |     |     {
 101 |     |         return keyExists(json, key) ? readUintArray(json, key) : defaultValue;
 102 |     |     }
 103 |     | 
 104 |     |     function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {
 105 |     |         return keyExists(json, key) ? readInt(json, key) : defaultValue;
 106 |     |     }
 107 |     | 
 108 |     |     function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (int256[] memory)
 112 |     |     {
 113 |     |         return keyExists(json, key) ? readIntArray(json, key) : defaultValue;
 114 |     |     }
 115 |     | 
 116 |     |     function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)
 117 |     |         internal
 118 |     |         view
 119 |     |         returns (bytes32)
 120 |     |     {
 121 |     |         return keyExists(json, key) ? readBytes32(json, key) : defaultValue;
 122 |     |     }
 123 |     | 
 124 |     |     function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)
 125 |     |         internal
 126 |     |         view
 127 |     |         returns (bytes32[] memory)
 128 |     |     {
 129 |     |         return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;
 130 |     |     }
 131 |     | 
 132 |     |     function readStringOr(string memory json, string memory key, string memory defaultValue)
 133 |     |         internal
 134 |     |         view
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return keyExists(json, key) ? readString(json, key) : defaultValue;
 138 |     |     }
 139 |     | 
 140 |     |     function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)
 141 |     |         internal
 142 |     |         view
 143 |     |         returns (string[] memory)
 144 |     |     {
 145 |     |         return keyExists(json, key) ? readStringArray(json, key) : defaultValue;
 146 |     |     }
 147 |     | 
 148 |     |     function readAddressOr(string memory json, string memory key, address defaultValue)
 149 |     |         internal
 150 |     |         view
 151 |     |         returns (address)
 152 |     |     {
 153 |     |         return keyExists(json, key) ? readAddress(json, key) : defaultValue;
 154 |     |     }
 155 |     | 
 156 |     |     function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)
 157 |     |         internal
 158 |     |         view
 159 |     |         returns (address[] memory)
 160 |     |     {
 161 |     |         return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;
 162 |     |     }
 163 |     | 
 164 |     |     function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {
 165 |     |         return keyExists(json, key) ? readBool(json, key) : defaultValue;
 166 |     |     }
 167 |     | 
 168 |     |     function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)
 169 |     |         internal
 170 |     |         view
 171 |     |         returns (bool[] memory)
 172 |     |     {
 173 |     |         return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;
 174 |     |     }
 175 |     | 
 176 |     |     function readBytesOr(string memory json, string memory key, bytes memory defaultValue)
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (bytes memory)
 180 |     |     {
 181 |     |         return keyExists(json, key) ? readBytes(json, key) : defaultValue;
 182 |     |     }
 183 |     | 
 184 |     |     function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (bytes[] memory)
 188 |     |     {
 189 |     |         return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;
 190 |     |     }
 191 |     | 
 192 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
 193 |     |         return vm.serializeJson(jsonKey, rootObject);
 194 |     |     }
 195 |     | 
 196 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
 197 |     |         return vm.serializeBool(jsonKey, key, value);
 198 |     |     }
 199 |     | 
 200 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 201 |     |         internal
 202 |     |         returns (string memory)
 203 |     |     {
 204 |     |         return vm.serializeBool(jsonKey, key, value);
 205 |     |     }
 206 |     | 
 207 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 208 |     |         return vm.serializeUint(jsonKey, key, value);
 209 |     |     }
 210 |     | 
 211 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 212 |     |         internal
 213 |     |         returns (string memory)
 214 |     |     {
 215 |     |         return vm.serializeUint(jsonKey, key, value);
 216 |     |     }
 217 |     | 
 218 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 219 |     |         return vm.serializeInt(jsonKey, key, value);
 220 |     |     }
 221 |     | 
 222 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 223 |     |         internal
 224 |     |         returns (string memory)
 225 |     |     {
 226 |     |         return vm.serializeInt(jsonKey, key, value);
 227 |     |     }
 228 |     | 
 229 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 230 |     |         return vm.serializeAddress(jsonKey, key, value);
 231 |     |     }
 232 |     | 
 233 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 234 |     |         internal
 235 |     |         returns (string memory)
 236 |     |     {
 237 |     |         return vm.serializeAddress(jsonKey, key, value);
 238 |     |     }
 239 |     | 
 240 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 241 |     |         return vm.serializeBytes32(jsonKey, key, value);
 242 |     |     }
 243 |     | 
 244 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 245 |     |         internal
 246 |     |         returns (string memory)
 247 |     |     {
 248 |     |         return vm.serializeBytes32(jsonKey, key, value);
 249 |     |     }
 250 |     | 
 251 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 252 |     |         return vm.serializeBytes(jsonKey, key, value);
 253 |     |     }
 254 |     | 
 255 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 256 |     |         internal
 257 |     |         returns (string memory)
 258 |     |     {
 259 |     |         return vm.serializeBytes(jsonKey, key, value);
 260 |     |     }
 261 |     | 
 262 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 263 |     |         internal
 264 |     |         returns (string memory)
 265 |     |     {
 266 |     |         return vm.serializeString(jsonKey, key, value);
 267 |     |     }
 268 |     | 
 269 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 270 |     |         internal
 271 |     |         returns (string memory)
 272 |     |     {
 273 |     |         return vm.serializeString(jsonKey, key, value);
 274 |     |     }
 275 |     | 
 276 |     |     function write(string memory jsonKey, string memory path) internal {
 277 |     |         vm.writeJson(jsonKey, path);
 278 |     |     }
 279 |     | 
 280 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 281 |     |         vm.writeJson(jsonKey, path, valueKey);
 282 |     |     }
 283 |     | }
 284 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 | *   | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct FindData {
   7 |     |     uint256 slot;
   8 |     |     uint256 offsetLeft;
   9 |     |     uint256 offsetRight;
  10 |     |     bool found;
  11 |     | }
  12 |     | 
  13 |     | struct StdStorage {
  14 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;
  15 |     |     bytes32[] _keys;
  16 |     |     bytes4 _sig;
  17 |     |     uint256 _depth;
  18 |     |     address _target;
  19 |     |     bytes32 _set;
  20 |     |     bool _enable_packed_slots;
  21 |     |     bytes _calldata;
  22 |     | }
  23 |     | 
  24 | *   | library stdStorageSafe {
  25 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  26 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  27 |     | 
  28 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  29 |     |     uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  30 |     | 
  31 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  32 |     |         return bytes4(keccak256(bytes(sigStr)));
  33 |     |     }
  34 |     | 
  35 |     |     function getCallParams(StdStorage storage self) internal view returns (bytes memory) {
  36 |     |         if (self._calldata.length == 0) {
  37 |     |             return flatten(self._keys);
  38 |     |         } else {
  39 |     |             return self._calldata;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     // Calls target contract with configured parameters
  44 |     |     function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {
  45 |     |         bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));
  46 |     |         (bool success, bytes memory rdat) = self._target.staticcall(cald);
  47 |     |         bytes32 result = bytesToBytes32(rdat, 32 * self._depth);
  48 |     | 
  49 |     |         return (success, result);
  50 |     |     }
  51 |     | 
  52 |     |     // Tries mutating slot value to determine if the targeted value is stored in it.
  53 |     |     // If current value is 0, then we are setting slot value to type(uint256).max
  54 |     |     // Otherwise, we set it to 0. That way, return value should always be affected.
  55 |     |     function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {
  56 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  57 |     |         (bool success, bytes32 prevReturnValue) = callTarget(self);
  58 |     | 
  59 |     |         bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);
  60 |     |         vm.store(self._target, slot, testVal);
  61 |     | 
  62 |     |         (, bytes32 newReturnValue) = callTarget(self);
  63 |     | 
  64 |     |         vm.store(self._target, slot, prevSlotValue);
  65 |     | 
  66 |     |         return (success && (prevReturnValue != newReturnValue));
  67 |     |     }
  68 |     | 
  69 |     |     // Tries setting one of the bits in slot to 1 until return value changes.
  70 |     |     // Index of resulted bit is an offset packed slot has from left/right side
  71 |     |     function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {
  72 |     |         for (uint256 offset = 0; offset < 256; offset++) {
  73 |     |             uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);
  74 |     |             vm.store(self._target, slot, bytes32(valueToPut));
  75 |     | 
  76 |     |             (bool success, bytes32 data) = callTarget(self);
  77 |     | 
  78 |     |             if (success && (uint256(data) > 0)) {
  79 |     |                 return (true, offset);
  80 |     |             }
  81 |     |         }
  82 |     |         return (false, 0);
  83 |     |     }
  84 |     | 
  85 |     |     function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {
  86 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  87 |     | 
  88 |     |         (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);
  89 |     |         (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);
  90 |     | 
  91 |     |         // `findOffset` may mutate slot value, so we are setting it to initial value
  92 |     |         vm.store(self._target, slot, prevSlotValue);
  93 |     |         return (foundLeft && foundRight, offsetLeft, offsetRight);
  94 |     |     }
  95 |     | 
  96 |     |     function find(StdStorage storage self) internal returns (FindData storage) {
  97 |     |         return find(self, true);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
 101 |     |     // slot complexity:
 102 |     |     //  if flat, will be bytes32(uint256(uint));
 103 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
 104 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
 105 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
 106 |     |     function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {
 107 |     |         address who = self._target;
 108 |     |         bytes4 fsig = self._sig;
 109 |     |         uint256 field_depth = self._depth;
 110 |     |         bytes memory params = getCallParams(self);
 111 |     | 
 112 |     |         // calldata to test against
 113 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 114 |     |             if (_clear) {
 115 |     |                 clear(self);
 116 |     |             }
 117 |     |             return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 118 |     |         }
 119 |     |         vm.record();
 120 |     |         (, bytes32 callResult) = callTarget(self);
 121 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
 122 |     | 
 123 |     |         if (reads.length == 0) {
 124 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
 125 |     |         } else {
 126 |     |             for (uint256 i = reads.length; --i >= 0;) {
 127 |     |                 bytes32 prev = vm.load(who, reads[i]);
 128 |     |                 if (prev == bytes32(0)) {
 129 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
 130 |     |                 }
 131 |     | 
 132 |     |                 if (!checkSlotMutatesCall(self, reads[i])) {
 133 |     |                     continue;
 134 |     |                 }
 135 |     | 
 136 |     |                 (uint256 offsetLeft, uint256 offsetRight) = (0, 0);
 137 |     | 
 138 |     |                 if (self._enable_packed_slots) {
 139 |     |                     bool found;
 140 |     |                     (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);
 141 |     |                     if (!found) {
 142 |     |                         continue;
 143 |     |                     }
 144 |     |                 }
 145 |     | 
 146 |     |                 // Check that value between found offsets is equal to the current call result
 147 |     |                 uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;
 148 |     | 
 149 |     |                 if (uint256(callResult) != curVal) {
 150 |     |                     continue;
 151 |     |                 }
 152 |     | 
 153 |     |                 emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));
 154 |     |                 self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =
 155 |     |                     FindData(uint256(reads[i]), offsetLeft, offsetRight, true);
 156 |     |                 break;
 157 |     |             }
 158 |     |         }
 159 |     | 
 160 |     |         require(
 161 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,
 162 |     |             "stdStorage find(StdStorage): Slot(s) not found."
 163 |     |         );
 164 |     | 
 165 |     |         if (_clear) {
 166 |     |             clear(self);
 167 |     |         }
 168 |     |         return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 169 |     |     }
 170 |     | 
 171 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 172 |     |         self._target = _target;
 173 |     |         return self;
 174 |     |     }
 175 |     | 
 176 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 177 |     |         self._sig = _sig;
 178 |     |         return self;
 179 |     |     }
 180 |     | 
 181 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 182 |     |         self._sig = sigs(_sig);
 183 |     |         return self;
 184 |     |     }
 185 |     | 
 186 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 187 |     |         self._calldata = _calldata;
 188 |     |         return self;
 189 |     |     }
 190 |     | 
 191 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 192 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 193 |     |         return self;
 194 |     |     }
 195 |     | 
 196 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 197 |     |         self._keys.push(bytes32(amt));
 198 |     |         return self;
 199 |     |     }
 200 |     | 
 201 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 202 |     |         self._keys.push(key);
 203 |     |         return self;
 204 |     |     }
 205 |     | 
 206 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 207 |     |         self._enable_packed_slots = true;
 208 |     |         return self;
 209 |     |     }
 210 |     | 
 211 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 212 |     |         self._depth = _depth;
 213 |     |         return self;
 214 |     |     }
 215 |     | 
 216 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 217 |     |         FindData storage data = find(self, false);
 218 |     |         uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);
 219 |     |         uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;
 220 |     |         clear(self);
 221 |     |         return abi.encode(value);
 222 |     |     }
 223 |     | 
 224 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 225 |     |         return abi.decode(read(self), (bytes32));
 226 |     |     }
 227 |     | 
 228 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 229 |     |         int256 v = read_int(self);
 230 |     |         if (v == 0) return false;
 231 |     |         if (v == 1) return true;
 232 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 233 |     |     }
 234 |     | 
 235 |     |     function read_address(StdStorage storage self) internal returns (address) {
 236 |     |         return abi.decode(read(self), (address));
 237 |     |     }
 238 |     | 
 239 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 240 |     |         return abi.decode(read(self), (uint256));
 241 |     |     }
 242 |     | 
 243 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 244 |     |         return abi.decode(read(self), (int256));
 245 |     |     }
 246 |     | 
 247 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 248 |     |         address who = self._target;
 249 |     |         uint256 field_depth = self._depth;
 250 |     |         vm.startMappingRecording();
 251 |     |         uint256 child = find(self, true).slot - field_depth;
 252 |     |         (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 253 |     |         if (!found) {
 254 |     |             revert(
 255 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 256 |     |             );
 257 |     |         }
 258 |     |         return (uint256(parent_slot), key);
 259 |     |     }
 260 |     | 
 261 |     |     function root(StdStorage storage self) internal returns (uint256) {
 262 |     |         address who = self._target;
 263 |     |         uint256 field_depth = self._depth;
 264 |     |         vm.startMappingRecording();
 265 |     |         uint256 child = find(self, true).slot - field_depth;
 266 |     |         bool found;
 267 |     |         bytes32 root_slot;
 268 |     |         bytes32 parent_slot;
 269 |     |         (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 270 |     |         if (!found) {
 271 |     |             revert(
 272 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 273 |     |             );
 274 |     |         }
 275 |     |         while (found) {
 276 |     |             root_slot = parent_slot;
 277 |     |             (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));
 278 |     |         }
 279 |     |         return uint256(root_slot);
 280 |     |     }
 281 |     | 
 282 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 283 |     |         bytes32 out;
 284 |     | 
 285 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 286 |     |         for (uint256 i = 0; i < max; i++) {
 287 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 288 |     |         }
 289 |     |         return out;
 290 |     |     }
 291 |     | 
 292 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 293 |     |         bytes memory result = new bytes(b.length * 32);
 294 |     |         for (uint256 i = 0; i < b.length; i++) {
 295 |     |             bytes32 k = b[i];
 296 |     |             /// @solidity memory-safe-assembly
 297 |     |             assembly {
 298 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 299 |     |             }
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     function clear(StdStorage storage self) internal {
 306 |     |         delete self._target;
 307 |     |         delete self._sig;
 308 |     |         delete self._keys;
 309 |     |         delete self._depth;
 310 |     |         delete self._enable_packed_slots;
 311 |     |         delete self._calldata;
 312 |     |     }
 313 |     | 
 314 |     |     // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`
 315 |     |     // (slotValue & mask) >> offsetRight will be the value of the given packed variable
 316 |     |     function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {
 317 |     |         // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;
 318 |     |         // using assembly because (1 << 256) causes overflow
 319 |     |         assembly {
 320 |     |             mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))
 321 |     |         }
 322 |     |     }
 323 |     | 
 324 |     |     // Returns slot value with updated packed variable.
 325 |     |     function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)
 326 |     |         internal
 327 |     |         pure
 328 |     |         returns (bytes32 newValue)
 329 |     |     {
 330 |     |         return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));
 331 |     |     }
 332 |     | }
 333 |     | 
 334 | *   | library stdStorage {
 335 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 336 |     | 
 337 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 338 |     |         return stdStorageSafe.sigs(sigStr);
 339 |     |     }
 340 |     | 
 341 |     |     function find(StdStorage storage self) internal returns (uint256) {
 342 |     |         return find(self, true);
 343 |     |     }
 344 |     | 
 345 |     |     function find(StdStorage storage self, bool _clear) internal returns (uint256) {
 346 |     |         return stdStorageSafe.find(self, _clear).slot;
 347 |     |     }
 348 |     | 
 349 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 350 |     |         return stdStorageSafe.target(self, _target);
 351 |     |     }
 352 |     | 
 353 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 354 |     |         return stdStorageSafe.sig(self, _sig);
 355 |     |     }
 356 |     | 
 357 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 358 |     |         return stdStorageSafe.sig(self, _sig);
 359 |     |     }
 360 |     | 
 361 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 362 |     |         return stdStorageSafe.with_key(self, who);
 363 |     |     }
 364 |     | 
 365 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 366 |     |         return stdStorageSafe.with_key(self, amt);
 367 |     |     }
 368 |     | 
 369 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 370 |     |         return stdStorageSafe.with_key(self, key);
 371 |     |     }
 372 |     | 
 373 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 374 |     |         return stdStorageSafe.with_calldata(self, _calldata);
 375 |     |     }
 376 |     | 
 377 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 378 |     |         return stdStorageSafe.enable_packed_slots(self);
 379 |     |     }
 380 |     | 
 381 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 382 |     |         return stdStorageSafe.depth(self, _depth);
 383 |     |     }
 384 |     | 
 385 |     |     function clear(StdStorage storage self) internal {
 386 |     |         stdStorageSafe.clear(self);
 387 |     |     }
 388 |     | 
 389 |     |     function checked_write(StdStorage storage self, address who) internal {
 390 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 391 |     |     }
 392 |     | 
 393 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 394 |     |         checked_write(self, bytes32(amt));
 395 |     |     }
 396 |     | 
 397 |     |     function checked_write_int(StdStorage storage self, int256 val) internal {
 398 |     |         checked_write(self, bytes32(uint256(val)));
 399 |     |     }
 400 |     | 
 401 |     |     function checked_write(StdStorage storage self, bool write) internal {
 402 |     |         bytes32 t;
 403 |     |         /// @solidity memory-safe-assembly
 404 |     |         assembly {
 405 |     |             t := write
 406 |     |         }
 407 |     |         checked_write(self, t);
 408 |     |     }
 409 |     | 
 410 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 411 |     |         address who = self._target;
 412 |     |         bytes4 fsig = self._sig;
 413 |     |         uint256 field_depth = self._depth;
 414 |     |         bytes memory params = stdStorageSafe.getCallParams(self);
 415 |     | 
 416 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 417 |     |             find(self, false);
 418 |     |         }
 419 |     |         FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 420 |     |         if ((data.offsetLeft + data.offsetRight) > 0) {
 421 |     |             uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));
 422 |     |             require(
 423 |     |                 uint256(set) < maxVal,
 424 |     |                 string(
 425 |     |                     abi.encodePacked(
 426 |     |                         "stdStorage find(StdStorage): Packed slot. We can't fit value greater than ",
 427 |     |                         vm.toString(maxVal)
 428 |     |                     )
 429 |     |                 )
 430 |     |             );
 431 |     |         }
 432 |     |         bytes32 curVal = vm.load(who, bytes32(data.slot));
 433 |     |         bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);
 434 |     | 
 435 |     |         vm.store(who, bytes32(data.slot), valToSet);
 436 |     | 
 437 |     |         (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);
 438 |     | 
 439 |     |         if (!success || callResult != set) {
 440 |     |             vm.store(who, bytes32(data.slot), curVal);
 441 |     |             revert("stdStorage find(StdStorage): Failed to write value.");
 442 |     |         }
 443 |     |         clear(self);
 444 |     |     }
 445 |     | 
 446 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 447 |     |         return stdStorageSafe.read_bytes32(self);
 448 |     |     }
 449 |     | 
 450 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 451 |     |         return stdStorageSafe.read_bool(self);
 452 |     |     }
 453 |     | 
 454 |     |     function read_address(StdStorage storage self) internal returns (address) {
 455 |     |         return stdStorageSafe.read_address(self);
 456 |     |     }
 457 |     | 
 458 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 459 |     |         return stdStorageSafe.read_uint(self);
 460 |     |     }
 461 |     | 
 462 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 463 |     |         return stdStorageSafe.read_int(self);
 464 |     |     }
 465 |     | 
 466 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 467 |     |         return stdStorageSafe.parent(self);
 468 |     |     }
 469 |     | 
 470 |     |     function root(StdStorage storage self) internal returns (uint256) {
 471 |     |         return stdStorageSafe.root(self);
 472 |     |     }
 473 |     | }
 474 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 | *   | library StdStyle {
   7 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdToml.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing TOML files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdToml for string;
  12 |     | // string memory toml = vm.readFile("<some_path>");
  13 |     | // toml.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdToml for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 | *   | library stdToml {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function keyExists(string memory toml, string memory key) internal view returns (bool) {
  29 |     |         return vm.keyExistsToml(toml, key);
  30 |     |     }
  31 |     | 
  32 |     |     function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {
  33 |     |         return vm.parseToml(toml, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUint(string memory toml, string memory key) internal pure returns (uint256) {
  37 |     |         return vm.parseTomlUint(toml, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {
  41 |     |         return vm.parseTomlUintArray(toml, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readInt(string memory toml, string memory key) internal pure returns (int256) {
  45 |     |         return vm.parseTomlInt(toml, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {
  49 |     |         return vm.parseTomlIntArray(toml, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {
  53 |     |         return vm.parseTomlBytes32(toml, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {
  57 |     |         return vm.parseTomlBytes32Array(toml, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readString(string memory toml, string memory key) internal pure returns (string memory) {
  61 |     |         return vm.parseTomlString(toml, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {
  65 |     |         return vm.parseTomlStringArray(toml, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddress(string memory toml, string memory key) internal pure returns (address) {
  69 |     |         return vm.parseTomlAddress(toml, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {
  73 |     |         return vm.parseTomlAddressArray(toml, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBool(string memory toml, string memory key) internal pure returns (bool) {
  77 |     |         return vm.parseTomlBool(toml, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {
  81 |     |         return vm.parseTomlBoolArray(toml, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {
  85 |     |         return vm.parseTomlBytes(toml, key);
  86 |     |     }
  87 |     | 
  88 |     |     function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {
  89 |     |         return vm.parseTomlBytesArray(toml, key);
  90 |     |     }
  91 |     | 
  92 |     |     function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {
  93 |     |         return keyExists(toml, key) ? readUint(toml, key) : defaultValue;
  94 |     |     }
  95 |     | 
  96 |     |     function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)
  97 |     |         internal
  98 |     |         view
  99 |     |         returns (uint256[] memory)
 100 |     |     {
 101 |     |         return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;
 102 |     |     }
 103 |     | 
 104 |     |     function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {
 105 |     |         return keyExists(toml, key) ? readInt(toml, key) : defaultValue;
 106 |     |     }
 107 |     | 
 108 |     |     function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)
 109 |     |         internal
 110 |     |         view
 111 |     |         returns (int256[] memory)
 112 |     |     {
 113 |     |         return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;
 114 |     |     }
 115 |     | 
 116 |     |     function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)
 117 |     |         internal
 118 |     |         view
 119 |     |         returns (bytes32)
 120 |     |     {
 121 |     |         return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;
 122 |     |     }
 123 |     | 
 124 |     |     function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)
 125 |     |         internal
 126 |     |         view
 127 |     |         returns (bytes32[] memory)
 128 |     |     {
 129 |     |         return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;
 130 |     |     }
 131 |     | 
 132 |     |     function readStringOr(string memory toml, string memory key, string memory defaultValue)
 133 |     |         internal
 134 |     |         view
 135 |     |         returns (string memory)
 136 |     |     {
 137 |     |         return keyExists(toml, key) ? readString(toml, key) : defaultValue;
 138 |     |     }
 139 |     | 
 140 |     |     function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)
 141 |     |         internal
 142 |     |         view
 143 |     |         returns (string[] memory)
 144 |     |     {
 145 |     |         return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;
 146 |     |     }
 147 |     | 
 148 |     |     function readAddressOr(string memory toml, string memory key, address defaultValue)
 149 |     |         internal
 150 |     |         view
 151 |     |         returns (address)
 152 |     |     {
 153 |     |         return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;
 154 |     |     }
 155 |     | 
 156 |     |     function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)
 157 |     |         internal
 158 |     |         view
 159 |     |         returns (address[] memory)
 160 |     |     {
 161 |     |         return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;
 162 |     |     }
 163 |     | 
 164 |     |     function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {
 165 |     |         return keyExists(toml, key) ? readBool(toml, key) : defaultValue;
 166 |     |     }
 167 |     | 
 168 |     |     function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)
 169 |     |         internal
 170 |     |         view
 171 |     |         returns (bool[] memory)
 172 |     |     {
 173 |     |         return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;
 174 |     |     }
 175 |     | 
 176 |     |     function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (bytes memory)
 180 |     |     {
 181 |     |         return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;
 182 |     |     }
 183 |     | 
 184 |     |     function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)
 185 |     |         internal
 186 |     |         view
 187 |     |         returns (bytes[] memory)
 188 |     |     {
 189 |     |         return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;
 190 |     |     }
 191 |     | 
 192 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
 193 |     |         return vm.serializeJson(jsonKey, rootObject);
 194 |     |     }
 195 |     | 
 196 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
 197 |     |         return vm.serializeBool(jsonKey, key, value);
 198 |     |     }
 199 |     | 
 200 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
 201 |     |         internal
 202 |     |         returns (string memory)
 203 |     |     {
 204 |     |         return vm.serializeBool(jsonKey, key, value);
 205 |     |     }
 206 |     | 
 207 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 208 |     |         return vm.serializeUint(jsonKey, key, value);
 209 |     |     }
 210 |     | 
 211 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 212 |     |         internal
 213 |     |         returns (string memory)
 214 |     |     {
 215 |     |         return vm.serializeUint(jsonKey, key, value);
 216 |     |     }
 217 |     | 
 218 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 219 |     |         return vm.serializeInt(jsonKey, key, value);
 220 |     |     }
 221 |     | 
 222 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 223 |     |         internal
 224 |     |         returns (string memory)
 225 |     |     {
 226 |     |         return vm.serializeInt(jsonKey, key, value);
 227 |     |     }
 228 |     | 
 229 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 230 |     |         return vm.serializeAddress(jsonKey, key, value);
 231 |     |     }
 232 |     | 
 233 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 234 |     |         internal
 235 |     |         returns (string memory)
 236 |     |     {
 237 |     |         return vm.serializeAddress(jsonKey, key, value);
 238 |     |     }
 239 |     | 
 240 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 241 |     |         return vm.serializeBytes32(jsonKey, key, value);
 242 |     |     }
 243 |     | 
 244 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 245 |     |         internal
 246 |     |         returns (string memory)
 247 |     |     {
 248 |     |         return vm.serializeBytes32(jsonKey, key, value);
 249 |     |     }
 250 |     | 
 251 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 252 |     |         return vm.serializeBytes(jsonKey, key, value);
 253 |     |     }
 254 |     | 
 255 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 256 |     |         internal
 257 |     |         returns (string memory)
 258 |     |     {
 259 |     |         return vm.serializeBytes(jsonKey, key, value);
 260 |     |     }
 261 |     | 
 262 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 263 |     |         internal
 264 |     |         returns (string memory)
 265 |     |     {
 266 |     |         return vm.serializeString(jsonKey, key, value);
 267 |     |     }
 268 |     | 
 269 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 270 |     |         internal
 271 |     |         returns (string memory)
 272 |     |     {
 273 |     |         return vm.serializeString(jsonKey, key, value);
 274 |     |     }
 275 |     | 
 276 |     |     function write(string memory jsonKey, string memory path) internal {
 277 |     |         vm.writeToml(jsonKey, path);
 278 |     |     }
 279 |     | 
 280 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 281 |     |         vm.writeToml(jsonKey, path, valueKey);
 282 |     |     }
 283 |     | }
 284 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | import {VmSafe} from "./Vm.sol";
   8 |     | 
   9 |     | abstract contract StdUtils {
  10 |     |     /*//////////////////////////////////////////////////////////////////////////
  11 |     |                                      CONSTANTS
  12 |     |     //////////////////////////////////////////////////////////////////////////*/
  13 |     | 
  14 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  15 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  16 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  17 |     |     uint256 private constant INT256_MIN_ABS =
  18 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  19 |     |     uint256 private constant SECP256K1_ORDER =
  20 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
  21 |     |     uint256 private constant UINT256_MAX =
  22 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  23 |     | 
  24 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  25 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////////////////
  28 |     |                                  INTERNAL FUNCTIONS
  29 |     |     //////////////////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  32 |     |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  33 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  34 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  35 |     |         if (x >= min && x <= max) return x;
  36 |     | 
  37 |     |         uint256 size = max - min + 1;
  38 |     | 
  39 |     |         // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  40 |     |         // This helps ensure coverage of the min/max values.
  41 |     |         if (x <= 3 && size > x) return min + x;
  42 |     |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  43 |     | 
  44 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  45 |     |         if (x > max) {
  46 |     |             uint256 diff = x - max;
  47 |     |             uint256 rem = diff % size;
  48 |     |             if (rem == 0) return max;
  49 |     |             result = min + rem - 1;
  50 |     |         } else if (x < min) {
  51 |     |             uint256 diff = min - x;
  52 |     |             uint256 rem = diff % size;
  53 |     |             if (rem == 0) return min;
  54 |     |             result = max - rem + 1;
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  59 |     |         result = _bound(x, min, max);
  60 |     |         console2_log_StdUtils("Bound result", result);
  61 |     |     }
  62 |     | 
  63 |     |     function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  64 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  65 |     | 
  66 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  67 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  68 |     |         // uint256:     0     ~ (2**256 - 1)
  69 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  70 |     |         //
  71 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  72 |     |         // So, use `~uint256(x) + 1` instead.
  73 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  74 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  75 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  76 |     | 
  77 |     |         uint256 y = _bound(_x, _min, _max);
  78 |     | 
  79 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  80 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  81 |     |     }
  82 |     | 
  83 |     |     function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  84 |     |         result = _bound(x, min, max);
  85 |     |         console2_log_StdUtils("Bound result", vm.toString(result));
  86 |     |     }
  87 |     | 
  88 |     |     function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {
  89 |     |         result = _bound(privateKey, 1, SECP256K1_ORDER - 1);
  90 |     |     }
  91 |     | 
  92 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  93 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  94 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  95 |     |     }
  96 |     | 
  97 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
  98 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
  99 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
 100 |     |         console2_log_StdUtils("computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.");
 101 |     |         return vm.computeCreateAddress(deployer, nonce);
 102 |     |     }
 103 |     | 
 104 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 105 |     |         internal
 106 |     |         pure
 107 |     |         virtual
 108 |     |         returns (address)
 109 |     |     {
 110 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 111 |     |         return vm.computeCreate2Address(salt, initcodeHash, deployer);
 112 |     |     }
 113 |     | 
 114 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 115 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 116 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 117 |     |         return vm.computeCreate2Address(salt, initCodeHash);
 118 |     |     }
 119 |     | 
 120 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 121 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 122 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 123 |     |         return hashInitCode(creationCode, "");
 124 |     |     }
 125 |     | 
 126 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 127 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 128 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 129 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 130 |     |         return keccak256(abi.encodePacked(creationCode, args));
 131 |     |     }
 132 |     | 
 133 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 134 |     |     function getTokenBalances(address token, address[] memory addresses)
 135 |     |         internal
 136 |     |         virtual
 137 |     |         returns (uint256[] memory balances)
 138 |     |     {
 139 |     |         uint256 tokenCodeSize;
 140 |     |         assembly {
 141 |     |             tokenCodeSize := extcodesize(token)
 142 |     |         }
 143 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 144 |     | 
 145 |     |         // ABI encode the aggregate call to Multicall3.
 146 |     |         uint256 length = addresses.length;
 147 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 148 |     |         for (uint256 i = 0; i < length; ++i) {
 149 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 150 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 151 |     |         }
 152 |     | 
 153 |     |         // Make the aggregate call.
 154 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 155 |     | 
 156 |     |         // ABI decode the return data and return the balances.
 157 |     |         balances = new uint256[](length);
 158 |     |         for (uint256 i = 0; i < length; ++i) {
 159 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     /*//////////////////////////////////////////////////////////////////////////
 164 |     |                                  PRIVATE FUNCTIONS
 165 |     |     //////////////////////////////////////////////////////////////////////////*/
 166 |     | 
 167 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 168 |     |         return address(uint160(uint256(bytesValue)));
 169 |     |     }
 170 |     | 
 171 |     |     // This section is used to prevent the compilation of console, which shortens the compilation time when console is
 172 |     |     // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid
 173 |     |     // any breaking changes to function signatures.
 174 |     |     function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)
 175 |     |         internal
 176 |     |         pure
 177 |     |         returns (function(bytes memory) internal pure fnOut)
 178 |     |     {
 179 |     |         assembly {
 180 |     |             fnOut := fnIn
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     function _sendLogPayload(bytes memory payload) internal pure {
 185 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
 186 |     |     }
 187 |     | 
 188 |     |     function _sendLogPayloadView(bytes memory payload) private view {
 189 |     |         uint256 payloadLength = payload.length;
 190 |     |         address consoleAddress = CONSOLE2_ADDRESS;
 191 |     |         /// @solidity memory-safe-assembly
 192 |     |         assembly {
 193 |     |             let payloadStart := add(payload, 32)
 194 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     function console2_log_StdUtils(string memory p0) private pure {
 199 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
 200 |     |     }
 201 |     | 
 202 |     |     function console2_log_StdUtils(string memory p0, uint256 p1) private pure {
 203 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 204 |     |     }
 205 |     | 
 206 |     |     function console2_log_StdUtils(string memory p0, string memory p1) private pure {
 207 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
 208 |     |     }
 209 |     | }
 210 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | // 💬 ABOUT
  7 |     | // Forge Std's default Test.
  8 |     | 
  9 |     | // 🧩 MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {safeconsole} from "./safeconsole.sol";
 13 |     | import {StdAssertions} from "./StdAssertions.sol";
 14 |     | import {StdChains} from "./StdChains.sol";
 15 |     | import {StdCheats} from "./StdCheats.sol";
 16 |     | import {StdConstants} from "./StdConstants.sol";
 17 |     | import {stdError} from "./StdError.sol";
 18 |     | import {StdInvariant} from "./StdInvariant.sol";
 19 |     | import {stdJson} from "./StdJson.sol";
 20 |     | import {stdMath} from "./StdMath.sol";
 21 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 22 |     | import {StdStyle} from "./StdStyle.sol";
 23 |     | import {stdToml} from "./StdToml.sol";
 24 |     | import {StdUtils} from "./StdUtils.sol";
 25 |     | import {Vm} from "./Vm.sol";
 26 |     | 
 27 |     | // 📦 BOILERPLATE
 28 |     | import {TestBase} from "./Base.sol";
 29 |     | 
 30 |     | // ⭐️ TEST
 31 |     | abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {
 32 |     |     // Note: IS_TEST() must return true.
 33 | *   |     bool public IS_TEST = true;
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/Vm.sol
    1 |     | // Automatically @generated by scripts/vm.py. Do not modify manually.
    2 |     | 
    3 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
    4 |     | pragma solidity >=0.6.2 <0.9.0;
    5 |     | pragma experimental ABIEncoderV2;
    6 |     | 
    7 |     | /// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may
    8 |     | /// result in Script simulations differing from on-chain execution. It is recommended to only use
    9 |     | /// these cheats in scripts.
   10 |     | interface VmSafe {
   11 |     |     /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
   12 |     |     enum CallerMode {
   13 |     |         // No caller modification is currently active.
   14 |     |         None,
   15 |     |         // A one time broadcast triggered by a `vm.broadcast()` call is currently active.
   16 |     |         Broadcast,
   17 |     |         // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
   18 |     |         RecurrentBroadcast,
   19 |     |         // A one time prank triggered by a `vm.prank()` call is currently active.
   20 |     |         Prank,
   21 |     |         // A recurrent prank triggered by a `vm.startPrank()` call is currently active.
   22 |     |         RecurrentPrank
   23 |     |     }
   24 |     | 
   25 |     |     /// The kind of account access that occurred.
   26 |     |     enum AccountAccessKind {
   27 |     |         // The account was called.
   28 |     |         Call,
   29 |     |         // The account was called via delegatecall.
   30 |     |         DelegateCall,
   31 |     |         // The account was called via callcode.
   32 |     |         CallCode,
   33 |     |         // The account was called via staticcall.
   34 |     |         StaticCall,
   35 |     |         // The account was created.
   36 |     |         Create,
   37 |     |         // The account was selfdestructed.
   38 |     |         SelfDestruct,
   39 |     |         // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
   40 |     |         Resume,
   41 |     |         // The account's balance was read.
   42 |     |         Balance,
   43 |     |         // The account's codesize was read.
   44 |     |         Extcodesize,
   45 |     |         // The account's codehash was read.
   46 |     |         Extcodehash,
   47 |     |         // The account's code was copied.
   48 |     |         Extcodecopy
   49 |     |     }
   50 |     | 
   51 |     |     /// Forge execution contexts.
   52 |     |     enum ForgeContext {
   53 |     |         // Test group execution context (test, coverage or snapshot).
   54 |     |         TestGroup,
   55 |     |         // `forge test` execution context.
   56 |     |         Test,
   57 |     |         // `forge coverage` execution context.
   58 |     |         Coverage,
   59 |     |         // `forge snapshot` execution context.
   60 |     |         Snapshot,
   61 |     |         // Script group execution context (dry run, broadcast or resume).
   62 |     |         ScriptGroup,
   63 |     |         // `forge script` execution context.
   64 |     |         ScriptDryRun,
   65 |     |         // `forge script --broadcast` execution context.
   66 |     |         ScriptBroadcast,
   67 |     |         // `forge script --resume` execution context.
   68 |     |         ScriptResume,
   69 |     |         // Unknown `forge` execution context.
   70 |     |         Unknown
   71 |     |     }
   72 |     | 
   73 |     |     /// The transaction type (`txType`) of the broadcast.
   74 |     |     enum BroadcastTxType {
   75 |     |         // Represents a CALL broadcast tx.
   76 |     |         Call,
   77 |     |         // Represents a CREATE broadcast tx.
   78 |     |         Create,
   79 |     |         // Represents a CREATE2 broadcast tx.
   80 |     |         Create2
   81 |     |     }
   82 |     | 
   83 |     |     /// An Ethereum log. Returned by `getRecordedLogs`.
   84 |     |     struct Log {
   85 |     |         // The topics of the log, including the signature, if any.
   86 |     |         bytes32[] topics;
   87 |     |         // The raw data of the log.
   88 |     |         bytes data;
   89 |     |         // The address of the log's emitter.
   90 |     |         address emitter;
   91 |     |     }
   92 |     | 
   93 |     |     /// An RPC URL and its alias. Returned by `rpcUrlStructs`.
   94 |     |     struct Rpc {
   95 |     |         // The alias of the RPC URL.
   96 |     |         string key;
   97 |     |         // The RPC URL.
   98 |     |         string url;
   99 |     |     }
  100 |     | 
  101 |     |     /// An RPC log object. Returned by `eth_getLogs`.
  102 |     |     struct EthGetLogs {
  103 |     |         // The address of the log's emitter.
  104 |     |         address emitter;
  105 |     |         // The topics of the log, including the signature, if any.
  106 |     |         bytes32[] topics;
  107 |     |         // The raw data of the log.
  108 |     |         bytes data;
  109 |     |         // The block hash.
  110 |     |         bytes32 blockHash;
  111 |     |         // The block number.
  112 |     |         uint64 blockNumber;
  113 |     |         // The transaction hash.
  114 |     |         bytes32 transactionHash;
  115 |     |         // The transaction index in the block.
  116 |     |         uint64 transactionIndex;
  117 |     |         // The log index.
  118 |     |         uint256 logIndex;
  119 |     |         // Whether the log was removed.
  120 |     |         bool removed;
  121 |     |     }
  122 |     | 
  123 |     |     /// A single entry in a directory listing. Returned by `readDir`.
  124 |     |     struct DirEntry {
  125 |     |         // The error message, if any.
  126 |     |         string errorMessage;
  127 |     |         // The path of the entry.
  128 |     |         string path;
  129 |     |         // The depth of the entry.
  130 |     |         uint64 depth;
  131 |     |         // Whether the entry is a directory.
  132 |     |         bool isDir;
  133 |     |         // Whether the entry is a symlink.
  134 |     |         bool isSymlink;
  135 |     |     }
  136 |     | 
  137 |     |     /// Metadata information about a file.
  138 |     |     /// This structure is returned from the `fsMetadata` function and represents known
  139 |     |     /// metadata about a file such as its permissions, size, modification
  140 |     |     /// times, etc.
  141 |     |     struct FsMetadata {
  142 |     |         // True if this metadata is for a directory.
  143 |     |         bool isDir;
  144 |     |         // True if this metadata is for a symlink.
  145 |     |         bool isSymlink;
  146 |     |         // The size of the file, in bytes, this metadata is for.
  147 |     |         uint256 length;
  148 |     |         // True if this metadata is for a readonly (unwritable) file.
  149 |     |         bool readOnly;
  150 |     |         // The last modification time listed in this metadata.
  151 |     |         uint256 modified;
  152 |     |         // The last access time of this metadata.
  153 |     |         uint256 accessed;
  154 |     |         // The creation time listed in this metadata.
  155 |     |         uint256 created;
  156 |     |     }
  157 |     | 
  158 |     |     /// A wallet with a public and private key.
  159 |     |     struct Wallet {
  160 |     |         // The wallet's address.
  161 |     |         address addr;
  162 |     |         // The wallet's public key `X`.
  163 |     |         uint256 publicKeyX;
  164 |     |         // The wallet's public key `Y`.
  165 |     |         uint256 publicKeyY;
  166 |     |         // The wallet's private key.
  167 |     |         uint256 privateKey;
  168 |     |     }
  169 |     | 
  170 |     |     /// The result of a `tryFfi` call.
  171 |     |     struct FfiResult {
  172 |     |         // The exit code of the call.
  173 |     |         int32 exitCode;
  174 |     |         // The optionally hex-decoded `stdout` data.
  175 |     |         bytes stdout;
  176 |     |         // The `stderr` data.
  177 |     |         bytes stderr;
  178 |     |     }
  179 |     | 
  180 |     |     /// Information on the chain and fork.
  181 |     |     struct ChainInfo {
  182 |     |         // The fork identifier. Set to zero if no fork is active.
  183 |     |         uint256 forkId;
  184 |     |         // The chain ID of the current fork.
  185 |     |         uint256 chainId;
  186 |     |     }
  187 |     | 
  188 |     |     /// Information about a blockchain.
  189 |     |     struct Chain {
  190 |     |         // The chain name.
  191 |     |         string name;
  192 |     |         // The chain's Chain ID.
  193 |     |         uint256 chainId;
  194 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  195 |     |         string chainAlias;
  196 |     |         // A default RPC endpoint for this chain.
  197 |     |         string rpcUrl;
  198 |     |     }
  199 |     | 
  200 |     |     /// The result of a `stopAndReturnStateDiff` call.
  201 |     |     struct AccountAccess {
  202 |     |         // The chain and fork the access occurred.
  203 |     |         ChainInfo chainInfo;
  204 |     |         // The kind of account access that determines what the account is.
  205 |     |         // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
  206 |     |         // If kind is Create, then the account is the newly created account.
  207 |     |         // If kind is SelfDestruct, then the account is the selfdestruct recipient.
  208 |     |         // If kind is a Resume, then account represents a account context that has resumed.
  209 |     |         AccountAccessKind kind;
  210 |     |         // The account that was accessed.
  211 |     |         // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
  212 |     |         address account;
  213 |     |         // What accessed the account.
  214 |     |         address accessor;
  215 |     |         // If the account was initialized or empty prior to the access.
  216 |     |         // An account is considered initialized if it has code, a
  217 |     |         // non-zero nonce, or a non-zero balance.
  218 |     |         bool initialized;
  219 |     |         // The previous balance of the accessed account.
  220 |     |         uint256 oldBalance;
  221 |     |         // The potential new balance of the accessed account.
  222 |     |         // That is, all balance changes are recorded here, even if reverts occurred.
  223 |     |         uint256 newBalance;
  224 |     |         // Code of the account deployed by CREATE.
  225 |     |         bytes deployedCode;
  226 |     |         // Value passed along with the account access
  227 |     |         uint256 value;
  228 |     |         // Input data provided to the CREATE or CALL
  229 |     |         bytes data;
  230 |     |         // If this access reverted in either the current or parent context.
  231 |     |         bool reverted;
  232 |     |         // An ordered list of storage accesses made during an account access operation.
  233 |     |         StorageAccess[] storageAccesses;
  234 |     |         // Call depth traversed during the recording of state differences
  235 |     |         uint64 depth;
  236 |     |     }
  237 |     | 
  238 |     |     /// The storage accessed during an `AccountAccess`.
  239 |     |     struct StorageAccess {
  240 |     |         // The account whose storage was accessed.
  241 |     |         address account;
  242 |     |         // The slot that was accessed.
  243 |     |         bytes32 slot;
  244 |     |         // If the access was a write.
  245 |     |         bool isWrite;
  246 |     |         // The previous value of the slot.
  247 |     |         bytes32 previousValue;
  248 |     |         // The new value of the slot.
  249 |     |         bytes32 newValue;
  250 |     |         // If the access was reverted.
  251 |     |         bool reverted;
  252 |     |     }
  253 |     | 
  254 |     |     /// Gas used. Returned by `lastCallGas`.
  255 |     |     struct Gas {
  256 |     |         // The gas limit of the call.
  257 |     |         uint64 gasLimit;
  258 |     |         // The total gas used.
  259 |     |         uint64 gasTotalUsed;
  260 |     |         // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>
  261 |     |         uint64 gasMemoryUsed;
  262 |     |         // The amount of gas refunded.
  263 |     |         int64 gasRefunded;
  264 |     |         // The amount of gas remaining.
  265 |     |         uint64 gasRemaining;
  266 |     |     }
  267 |     | 
  268 |     |     /// The result of the `stopDebugTraceRecording` call
  269 |     |     struct DebugStep {
  270 |     |         // The stack before executing the step of the run.
  271 |     |         // stack\[0\] represents the top of the stack.
  272 |     |         // and only stack data relevant to the opcode execution is contained.
  273 |     |         uint256[] stack;
  274 |     |         // The memory input data before executing the step of the run.
  275 |     |         // only input data relevant to the opcode execution is contained.
  276 |     |         // e.g. for MLOAD, it will have memory\[offset:offset+32\] copied here.
  277 |     |         // the offset value can be get by the stack data.
  278 |     |         bytes memoryInput;
  279 |     |         // The opcode that was accessed.
  280 |     |         uint8 opcode;
  281 |     |         // The call depth of the step.
  282 |     |         uint64 depth;
  283 |     |         // Whether the call end up with out of gas error.
  284 |     |         bool isOutOfGas;
  285 |     |         // The contract address where the opcode is running
  286 |     |         address contractAddr;
  287 |     |     }
  288 |     | 
  289 |     |     /// Represents a transaction's broadcast details.
  290 |     |     struct BroadcastTxSummary {
  291 |     |         // The hash of the transaction that was broadcasted
  292 |     |         bytes32 txHash;
  293 |     |         // Represent the type of transaction among CALL, CREATE, CREATE2
  294 |     |         BroadcastTxType txType;
  295 |     |         // The address of the contract that was called or created.
  296 |     |         // This is address of the contract that is created if the txType is CREATE or CREATE2.
  297 |     |         address contractAddress;
  298 |     |         // The block number the transaction landed in.
  299 |     |         uint64 blockNumber;
  300 |     |         // Status of the transaction, retrieved from the transaction receipt.
  301 |     |         bool success;
  302 |     |     }
  303 |     | 
  304 |     |     /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.
  305 |     |     struct SignedDelegation {
  306 |     |         // The y-parity of the recovered secp256k1 signature (0 or 1).
  307 |     |         uint8 v;
  308 |     |         // First 32 bytes of the signature.
  309 |     |         bytes32 r;
  310 |     |         // Second 32 bytes of the signature.
  311 |     |         bytes32 s;
  312 |     |         // The current nonce of the authority account at signing time.
  313 |     |         // Used to ensure signature can't be replayed after account nonce changes.
  314 |     |         uint64 nonce;
  315 |     |         // Address of the contract implementation that will be delegated to.
  316 |     |         // Gets encoded into delegation code: 0xef0100 || implementation.
  317 |     |         address implementation;
  318 |     |     }
  319 |     | 
  320 |     |     /// Represents a "potential" revert reason from a single subsequent call when using `vm.assumeNoReverts`.
  321 |     |     /// Reverts that match will result in a FOUNDRY::ASSUME rejection, whereas unmatched reverts will be surfaced
  322 |     |     /// as normal.
  323 |     |     struct PotentialRevert {
  324 |     |         // The allowed origin of the revert opcode; address(0) allows reverts from any address
  325 |     |         address reverter;
  326 |     |         // When true, only matches on the beginning of the revert data, otherwise, matches on entire revert data
  327 |     |         bool partialMatch;
  328 |     |         // The data to use to match encountered reverts
  329 |     |         bytes revertData;
  330 |     |     }
  331 |     | 
  332 |     |     /// An EIP-2930 access list item.
  333 |     |     struct AccessListItem {
  334 |     |         // The address to be added in access list.
  335 |     |         address target;
  336 |     |         // The storage keys to be added in access list.
  337 |     |         bytes32[] storageKeys;
  338 |     |     }
  339 |     | 
  340 |     |     // ======== Crypto ========
  341 |     | 
  342 |     |     /// Derives a private key from the name, labels the account with that name, and returns the wallet.
  343 |     |     function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);
  344 |     | 
  345 |     |     /// Generates a wallet from the private key and returns the wallet.
  346 |     |     function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
  347 |     | 
  348 |     |     /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.
  349 |     |     function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);
  350 |     | 
  351 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  352 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  353 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
  354 |     | 
  355 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
  356 |     |     /// at `{derivationPath}{index}`.
  357 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
  358 |     |         external
  359 |     |         pure
  360 |     |         returns (uint256 privateKey);
  361 |     | 
  362 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  363 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
  364 |     |     function deriveKey(string calldata mnemonic, uint32 index, string calldata language)
  365 |     |         external
  366 |     |         pure
  367 |     |         returns (uint256 privateKey);
  368 |     | 
  369 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
  370 |     |     /// at `{derivationPath}{index}`.
  371 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)
  372 |     |         external
  373 |     |         pure
  374 |     |         returns (uint256 privateKey);
  375 |     | 
  376 |     |     /// Derives secp256r1 public key from the provided `privateKey`.
  377 |     |     function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);
  378 |     | 
  379 |     |     /// Adds a private key to the local forge wallet and returns the address.
  380 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
  381 |     | 
  382 |     |     /// Derive a set number of wallets from a mnemonic at the derivation path `m/44'/60'/0'/0/{0..count}`.
  383 |     |     /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.
  384 |     |     function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)
  385 |     |         external
  386 |     |         returns (address[] memory keyAddrs);
  387 |     | 
  388 |     |     /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44'/60'/0'/0/{0..count}`.
  389 |     |     /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.
  390 |     |     function rememberKeys(
  391 |     |         string calldata mnemonic,
  392 |     |         string calldata derivationPath,
  393 |     |         string calldata language,
  394 |     |         uint32 count
  395 |     |     ) external returns (address[] memory keyAddrs);
  396 |     | 
  397 |     |     /// Signs data with a `Wallet`.
  398 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  399 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  400 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  401 |     |     function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);
  402 |     | 
  403 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  404 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  405 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  406 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  407 |     |     function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  408 |     | 
  409 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  410 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  411 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  412 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  413 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  414 |     |     /// if exactly one signer is provided to the script, that signer is used.
  415 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  416 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  417 |     |     function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  418 |     | 
  419 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  420 |     |     /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the
  421 |     |     /// signature's `s` value, and the recovery id `v` in a single bytes32.
  422 |     |     /// This format reduces the signature size from 65 to 64 bytes.
  423 |     |     /// Raises error if none of the signers passed into the script have provided address.
  424 |     |     function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
  425 |     | 
  426 |     |     /// Signs `digest` with `privateKey` using the secp256r1 curve.
  427 |     |     function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
  428 |     | 
  429 |     |     /// Signs data with a `Wallet`.
  430 |     |     function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
  431 |     | 
  432 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  433 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  434 |     | 
  435 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  436 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  437 |     |     /// if exactly one signer is provided to the script, that signer is used.
  438 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  439 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  440 |     |     function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  441 |     | 
  442 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  443 |     |     /// Raises error if none of the signers passed into the script have provided address.
  444 |     |     function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  445 |     | 
  446 |     |     // ======== Environment ========
  447 |     | 
  448 |     |     /// Gets the environment variable `name` and parses it as `address`.
  449 |     |     /// Reverts if the variable was not found or could not be parsed.
  450 |     |     function envAddress(string calldata name) external view returns (address value);
  451 |     | 
  452 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  453 |     |     /// Reverts if the variable was not found or could not be parsed.
  454 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  455 |     | 
  456 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  457 |     |     /// Reverts if the variable was not found or could not be parsed.
  458 |     |     function envBool(string calldata name) external view returns (bool value);
  459 |     | 
  460 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  461 |     |     /// Reverts if the variable was not found or could not be parsed.
  462 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  463 |     | 
  464 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  465 |     |     /// Reverts if the variable was not found or could not be parsed.
  466 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  467 |     | 
  468 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  469 |     |     /// Reverts if the variable was not found or could not be parsed.
  470 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  471 |     | 
  472 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  473 |     |     /// Reverts if the variable was not found or could not be parsed.
  474 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  475 |     | 
  476 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  477 |     |     /// Reverts if the variable was not found or could not be parsed.
  478 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  479 |     | 
  480 |     |     /// Gets the environment variable `name` and returns true if it exists, else returns false.
  481 |     |     function envExists(string calldata name) external view returns (bool result);
  482 |     | 
  483 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  484 |     |     /// Reverts if the variable was not found or could not be parsed.
  485 |     |     function envInt(string calldata name) external view returns (int256 value);
  486 |     | 
  487 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  488 |     |     /// Reverts if the variable was not found or could not be parsed.
  489 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  490 |     | 
  491 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  492 |     |     /// Reverts if the variable could not be parsed.
  493 |     |     /// Returns `defaultValue` if the variable was not found.
  494 |     |     function envOr(string calldata name, bool defaultValue) external view returns (bool value);
  495 |     | 
  496 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  497 |     |     /// Reverts if the variable could not be parsed.
  498 |     |     /// Returns `defaultValue` if the variable was not found.
  499 |     |     function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);
  500 |     | 
  501 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  502 |     |     /// Reverts if the variable could not be parsed.
  503 |     |     /// Returns `defaultValue` if the variable was not found.
  504 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  505 |     |         external
  506 |     |         view
  507 |     |         returns (address[] memory value);
  508 |     | 
  509 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  510 |     |     /// Reverts if the variable could not be parsed.
  511 |     |     /// Returns `defaultValue` if the variable was not found.
  512 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  513 |     |         external
  514 |     |         view
  515 |     |         returns (bytes32[] memory value);
  516 |     | 
  517 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  518 |     |     /// Reverts if the variable could not be parsed.
  519 |     |     /// Returns `defaultValue` if the variable was not found.
  520 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  521 |     |         external
  522 |     |         view
  523 |     |         returns (string[] memory value);
  524 |     | 
  525 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  526 |     |     /// Reverts if the variable could not be parsed.
  527 |     |     /// Returns `defaultValue` if the variable was not found.
  528 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  529 |     |         external
  530 |     |         view
  531 |     |         returns (bytes[] memory value);
  532 |     | 
  533 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  534 |     |     /// Reverts if the variable could not be parsed.
  535 |     |     /// Returns `defaultValue` if the variable was not found.
  536 |     |     function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);
  537 |     | 
  538 |     |     /// Gets the environment variable `name` and parses it as `address`.
  539 |     |     /// Reverts if the variable could not be parsed.
  540 |     |     /// Returns `defaultValue` if the variable was not found.
  541 |     |     function envOr(string calldata name, address defaultValue) external view returns (address value);
  542 |     | 
  543 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  544 |     |     /// Reverts if the variable could not be parsed.
  545 |     |     /// Returns `defaultValue` if the variable was not found.
  546 |     |     function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);
  547 |     | 
  548 |     |     /// Gets the environment variable `name` and parses it as `string`.
  549 |     |     /// Reverts if the variable could not be parsed.
  550 |     |     /// Returns `defaultValue` if the variable was not found.
  551 |     |     function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);
  552 |     | 
  553 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  554 |     |     /// Reverts if the variable could not be parsed.
  555 |     |     /// Returns `defaultValue` if the variable was not found.
  556 |     |     function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);
  557 |     | 
  558 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  559 |     |     /// Reverts if the variable could not be parsed.
  560 |     |     /// Returns `defaultValue` if the variable was not found.
  561 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  562 |     |         external
  563 |     |         view
  564 |     |         returns (bool[] memory value);
  565 |     | 
  566 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  567 |     |     /// Reverts if the variable could not be parsed.
  568 |     |     /// Returns `defaultValue` if the variable was not found.
  569 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  570 |     |         external
  571 |     |         view
  572 |     |         returns (uint256[] memory value);
  573 |     | 
  574 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  575 |     |     /// Reverts if the variable could not be parsed.
  576 |     |     /// Returns `defaultValue` if the variable was not found.
  577 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  578 |     |         external
  579 |     |         view
  580 |     |         returns (int256[] memory value);
  581 |     | 
  582 |     |     /// Gets the environment variable `name` and parses it as `string`.
  583 |     |     /// Reverts if the variable was not found or could not be parsed.
  584 |     |     function envString(string calldata name) external view returns (string memory value);
  585 |     | 
  586 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  587 |     |     /// Reverts if the variable was not found or could not be parsed.
  588 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  589 |     | 
  590 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  591 |     |     /// Reverts if the variable was not found or could not be parsed.
  592 |     |     function envUint(string calldata name) external view returns (uint256 value);
  593 |     | 
  594 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  595 |     |     /// Reverts if the variable was not found or could not be parsed.
  596 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  597 |     | 
  598 |     |     /// Returns true if `forge` command was executed in given context.
  599 |     |     function isContext(ForgeContext context) external view returns (bool result);
  600 |     | 
  601 |     |     /// Sets environment variables.
  602 |     |     function setEnv(string calldata name, string calldata value) external;
  603 |     | 
  604 |     |     // ======== EVM ========
  605 |     | 
  606 |     |     /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.
  607 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  608 |     | 
  609 |     |     /// Gets the address for a given private key.
  610 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  611 |     | 
  612 |     |     /// Gets all the logs according to specified filter.
  613 |     |     function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)
  614 |     |         external
  615 |     |         returns (EthGetLogs[] memory logs);
  616 |     | 
  617 |     |     /// Gets the current `block.blobbasefee`.
  618 |     |     /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,
  619 |     |     /// and as a result will get optimized out by the compiler.
  620 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  621 |     |     function getBlobBaseFee() external view returns (uint256 blobBaseFee);
  622 |     | 
  623 |     |     /// Gets the current `block.number`.
  624 |     |     /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
  625 |     |     /// and as a result will get optimized out by the compiler.
  626 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  627 |     |     function getBlockNumber() external view returns (uint256 height);
  628 |     | 
  629 |     |     /// Gets the current `block.timestamp`.
  630 |     |     /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
  631 |     |     /// and as a result will get optimized out by the compiler.
  632 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  633 |     |     function getBlockTimestamp() external view returns (uint256 timestamp);
  634 |     | 
  635 |     |     /// Gets the map key and parent of a mapping at a given slot, for a given address.
  636 |     |     function getMappingKeyAndParentOf(address target, bytes32 elementSlot)
  637 |     |         external
  638 |     |         returns (bool found, bytes32 key, bytes32 parent);
  639 |     | 
  640 |     |     /// Gets the number of elements in the mapping at the given slot, for a given address.
  641 |     |     function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
  642 |     | 
  643 |     |     /// Gets the elements at index idx of the mapping at the given slot, for a given address. The
  644 |     |     /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).
  645 |     |     function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
  646 |     | 
  647 |     |     /// Gets the nonce of an account.
  648 |     |     function getNonce(address account) external view returns (uint64 nonce);
  649 |     | 
  650 |     |     /// Get the nonce of a `Wallet`.
  651 |     |     function getNonce(Wallet calldata wallet) external returns (uint64 nonce);
  652 |     | 
  653 |     |     /// Gets all the recorded logs.
  654 |     |     function getRecordedLogs() external returns (Log[] memory logs);
  655 |     | 
  656 |     |     /// Returns state diffs from current `vm.startStateDiffRecording` session.
  657 |     |     function getStateDiff() external view returns (string memory diff);
  658 |     | 
  659 |     |     /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.
  660 |     |     function getStateDiffJson() external view returns (string memory diff);
  661 |     | 
  662 |     |     /// Gets the gas used in the last call from the callee perspective.
  663 |     |     function lastCallGas() external view returns (Gas memory gas);
  664 |     | 
  665 |     |     /// Loads a storage slot from an address.
  666 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  667 |     | 
  668 |     |     /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
  669 |     |     function pauseGasMetering() external;
  670 |     | 
  671 |     |     /// Records all storage reads and writes.
  672 |     |     function record() external;
  673 |     | 
  674 |     |     /// Record all the transaction logs.
  675 |     |     function recordLogs() external;
  676 |     | 
  677 |     |     /// Reset gas metering (i.e. gas usage is set to gas limit).
  678 |     |     function resetGasMetering() external;
  679 |     | 
  680 |     |     /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
  681 |     |     function resumeGasMetering() external;
  682 |     | 
  683 |     |     /// Performs an Ethereum JSON-RPC request to the current fork URL.
  684 |     |     function rpc(string calldata method, string calldata params) external returns (bytes memory data);
  685 |     | 
  686 |     |     /// Performs an Ethereum JSON-RPC request to the given endpoint.
  687 |     |     function rpc(string calldata urlOrAlias, string calldata method, string calldata params)
  688 |     |         external
  689 |     |         returns (bytes memory data);
  690 |     | 
  691 |     |     /// Records the debug trace during the run.
  692 |     |     function startDebugTraceRecording() external;
  693 |     | 
  694 |     |     /// Starts recording all map SSTOREs for later retrieval.
  695 |     |     function startMappingRecording() external;
  696 |     | 
  697 |     |     /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
  698 |     |     /// along with the context of the calls
  699 |     |     function startStateDiffRecording() external;
  700 |     | 
  701 |     |     /// Stop debug trace recording and returns the recorded debug trace.
  702 |     |     function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);
  703 |     | 
  704 |     |     /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
  705 |     |     function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
  706 |     | 
  707 |     |     /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.
  708 |     |     function stopMappingRecording() external;
  709 |     | 
  710 |     |     // ======== Filesystem ========
  711 |     | 
  712 |     |     /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
  713 |     |     /// `path` is relative to the project root.
  714 |     |     function closeFile(string calldata path) external;
  715 |     | 
  716 |     |     /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
  717 |     |     /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
  718 |     |     /// Both `from` and `to` are relative to the project root.
  719 |     |     function copyFile(string calldata from, string calldata to) external returns (uint64 copied);
  720 |     | 
  721 |     |     /// Creates a new, empty directory at the provided path.
  722 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  723 |     |     /// - User lacks permissions to modify `path`.
  724 |     |     /// - A parent of the given path doesn't exist and `recursive` is false.
  725 |     |     /// - `path` already exists and `recursive` is false.
  726 |     |     /// `path` is relative to the project root.
  727 |     |     function createDir(string calldata path, bool recursive) external;
  728 |     | 
  729 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  730 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  731 |     |     function deployCode(string calldata artifactPath) external returns (address deployedAddress);
  732 |     | 
  733 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  734 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  735 |     |     /// Additionally accepts abi-encoded constructor arguments.
  736 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs)
  737 |     |         external
  738 |     |         returns (address deployedAddress);
  739 |     | 
  740 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  741 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  742 |     |     /// Additionally accepts `msg.value`.
  743 |     |     function deployCode(string calldata artifactPath, uint256 value) external returns (address deployedAddress);
  744 |     | 
  745 |     |     /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the
  746 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  747 |     |     /// Additionally accepts abi-encoded constructor arguments and `msg.value`.
  748 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value)
  749 |     |         external
  750 |     |         returns (address deployedAddress);
  751 |     | 
  752 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  753 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  754 |     |     function deployCode(string calldata artifactPath, bytes32 salt) external returns (address deployedAddress);
  755 |     | 
  756 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  757 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  758 |     |     /// Additionally accepts abi-encoded constructor arguments.
  759 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, bytes32 salt)
  760 |     |         external
  761 |     |         returns (address deployedAddress);
  762 |     | 
  763 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  764 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  765 |     |     /// Additionally accepts `msg.value`.
  766 |     |     function deployCode(string calldata artifactPath, uint256 value, bytes32 salt)
  767 |     |         external
  768 |     |         returns (address deployedAddress);
  769 |     | 
  770 |     |     /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the
  771 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  772 |     |     /// Additionally accepts abi-encoded constructor arguments and `msg.value`.
  773 |     |     function deployCode(string calldata artifactPath, bytes calldata constructorArgs, uint256 value, bytes32 salt)
  774 |     |         external
  775 |     |         returns (address deployedAddress);
  776 |     | 
  777 |     |     /// Returns true if the given path points to an existing entity, else returns false.
  778 |     |     function exists(string calldata path) external view returns (bool result);
  779 |     | 
  780 |     |     /// Performs a foreign function call via the terminal.
  781 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  782 |     | 
  783 |     |     /// Given a path, query the file system to get information about a file, directory, etc.
  784 |     |     function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);
  785 |     | 
  786 |     |     /// Gets the artifact path from code (aka. creation code).
  787 |     |     function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);
  788 |     | 
  789 |     |     /// Gets the artifact path from deployed code (aka. runtime code).
  790 |     |     function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);
  791 |     | 
  792 |     |     /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.
  793 |     |     /// For example:
  794 |     |     /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.
  795 |     |     /// The most recent call can be fetched by passing `txType` as `CALL`.
  796 |     |     function getBroadcast(string calldata contractName, uint64 chainId, BroadcastTxType txType)
  797 |     |         external
  798 |     |         view
  799 |     |         returns (BroadcastTxSummary memory);
  800 |     | 
  801 |     |     /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.
  802 |     |     /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.
  803 |     |     function getBroadcasts(string calldata contractName, uint64 chainId, BroadcastTxType txType)
  804 |     |         external
  805 |     |         view
  806 |     |         returns (BroadcastTxSummary[] memory);
  807 |     | 
  808 |     |     /// Returns all broadcasts for the given contract on `chainId`.
  809 |     |     /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.
  810 |     |     function getBroadcasts(string calldata contractName, uint64 chainId)
  811 |     |         external
  812 |     |         view
  813 |     |         returns (BroadcastTxSummary[] memory);
  814 |     | 
  815 |     |     /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  816 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  817 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  818 |     | 
  819 |     |     /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  820 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  821 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
  822 |     | 
  823 |     |     /// Returns the most recent deployment for the current `chainId`.
  824 |     |     function getDeployment(string calldata contractName) external view returns (address deployedAddress);
  825 |     | 
  826 |     |     /// Returns the most recent deployment for the given contract on `chainId`
  827 |     |     function getDeployment(string calldata contractName, uint64 chainId)
  828 |     |         external
  829 |     |         view
  830 |     |         returns (address deployedAddress);
  831 |     | 
  832 |     |     /// Returns all deployments for the given contract on `chainId`
  833 |     |     /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.
  834 |     |     /// The most recent deployment is the first element, and the oldest is the last.
  835 |     |     function getDeployments(string calldata contractName, uint64 chainId)
  836 |     |         external
  837 |     |         view
  838 |     |         returns (address[] memory deployedAddresses);
  839 |     | 
  840 |     |     /// Returns true if the path exists on disk and is pointing at a directory, else returns false.
  841 |     |     function isDir(string calldata path) external view returns (bool result);
  842 |     | 
  843 |     |     /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.
  844 |     |     function isFile(string calldata path) external view returns (bool result);
  845 |     | 
  846 |     |     /// Get the path of the current project root.
  847 |     |     function projectRoot() external view returns (string memory path);
  848 |     | 
  849 |     |     /// Prompts the user for a string value in the terminal.
  850 |     |     function prompt(string calldata promptText) external returns (string memory input);
  851 |     | 
  852 |     |     /// Prompts the user for an address in the terminal.
  853 |     |     function promptAddress(string calldata promptText) external returns (address);
  854 |     | 
  855 |     |     /// Prompts the user for a hidden string value in the terminal.
  856 |     |     function promptSecret(string calldata promptText) external returns (string memory input);
  857 |     | 
  858 |     |     /// Prompts the user for hidden uint256 in the terminal (usually pk).
  859 |     |     function promptSecretUint(string calldata promptText) external returns (uint256);
  860 |     | 
  861 |     |     /// Prompts the user for uint256 in the terminal.
  862 |     |     function promptUint(string calldata promptText) external returns (uint256);
  863 |     | 
  864 |     |     /// Reads the directory at the given path recursively, up to `maxDepth`.
  865 |     |     /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
  866 |     |     /// Follows symbolic links if `followLinks` is true.
  867 |     |     function readDir(string calldata path) external view returns (DirEntry[] memory entries);
  868 |     | 
  869 |     |     /// See `readDir(string)`.
  870 |     |     function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
  871 |     | 
  872 |     |     /// See `readDir(string)`.
  873 |     |     function readDir(string calldata path, uint64 maxDepth, bool followLinks)
  874 |     |         external
  875 |     |         view
  876 |     |         returns (DirEntry[] memory entries);
  877 |     | 
  878 |     |     /// Reads the entire content of file to string. `path` is relative to the project root.
  879 |     |     function readFile(string calldata path) external view returns (string memory data);
  880 |     | 
  881 |     |     /// Reads the entire content of file as binary. `path` is relative to the project root.
  882 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
  883 |     | 
  884 |     |     /// Reads next line of file to string.
  885 |     |     function readLine(string calldata path) external view returns (string memory line);
  886 |     | 
  887 |     |     /// Reads a symbolic link, returning the path that the link points to.
  888 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  889 |     |     /// - `path` is not a symbolic link.
  890 |     |     /// - `path` does not exist.
  891 |     |     function readLink(string calldata linkPath) external view returns (string memory targetPath);
  892 |     | 
  893 |     |     /// Removes a directory at the provided path.
  894 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  895 |     |     /// - `path` doesn't exist.
  896 |     |     /// - `path` isn't a directory.
  897 |     |     /// - User lacks permissions to modify `path`.
  898 |     |     /// - The directory is not empty and `recursive` is false.
  899 |     |     /// `path` is relative to the project root.
  900 |     |     function removeDir(string calldata path, bool recursive) external;
  901 |     | 
  902 |     |     /// Removes a file from the filesystem.
  903 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  904 |     |     /// - `path` points to a directory.
  905 |     |     /// - The file doesn't exist.
  906 |     |     /// - The user lacks permissions to remove the file.
  907 |     |     /// `path` is relative to the project root.
  908 |     |     function removeFile(string calldata path) external;
  909 |     | 
  910 |     |     /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
  911 |     |     function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);
  912 |     | 
  913 |     |     /// Returns the time since unix epoch in milliseconds.
  914 |     |     function unixTime() external view returns (uint256 milliseconds);
  915 |     | 
  916 |     |     /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
  917 |     |     /// `path` is relative to the project root.
  918 |     |     function writeFile(string calldata path, string calldata data) external;
  919 |     | 
  920 |     |     /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
  921 |     |     /// `path` is relative to the project root.
  922 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
  923 |     | 
  924 |     |     /// Writes line to file, creating a file if it does not exist.
  925 |     |     /// `path` is relative to the project root.
  926 |     |     function writeLine(string calldata path, string calldata data) external;
  927 |     | 
  928 |     |     // ======== JSON ========
  929 |     | 
  930 |     |     /// Checks if `key` exists in a JSON object.
  931 |     |     function keyExistsJson(string calldata json, string calldata key) external view returns (bool);
  932 |     | 
  933 |     |     /// Parses a string of JSON data at `key` and coerces it to `address`.
  934 |     |     function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);
  935 |     | 
  936 |     |     /// Parses a string of JSON data at `key` and coerces it to `address[]`.
  937 |     |     function parseJsonAddressArray(string calldata json, string calldata key)
  938 |     |         external
  939 |     |         pure
  940 |     |         returns (address[] memory);
  941 |     | 
  942 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool`.
  943 |     |     function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);
  944 |     | 
  945 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool[]`.
  946 |     |     function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);
  947 |     | 
  948 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes`.
  949 |     |     function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);
  950 |     | 
  951 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32`.
  952 |     |     function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);
  953 |     | 
  954 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
  955 |     |     function parseJsonBytes32Array(string calldata json, string calldata key)
  956 |     |         external
  957 |     |         pure
  958 |     |         returns (bytes32[] memory);
  959 |     | 
  960 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.
  961 |     |     function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);
  962 |     | 
  963 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256`.
  964 |     |     function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);
  965 |     | 
  966 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256[]`.
  967 |     |     function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);
  968 |     | 
  969 |     |     /// Returns an array of all the keys in a JSON object.
  970 |     |     function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
  971 |     | 
  972 |     |     /// Parses a string of JSON data at `key` and coerces it to `string`.
  973 |     |     function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);
  974 |     | 
  975 |     |     /// Parses a string of JSON data at `key` and coerces it to `string[]`.
  976 |     |     function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);
  977 |     | 
  978 |     |     /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.
  979 |     |     function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)
  980 |     |         external
  981 |     |         pure
  982 |     |         returns (bytes memory);
  983 |     | 
  984 |     |     /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.
  985 |     |     function parseJsonType(string calldata json, string calldata typeDescription)
  986 |     |         external
  987 |     |         pure
  988 |     |         returns (bytes memory);
  989 |     | 
  990 |     |     /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.
  991 |     |     function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)
  992 |     |         external
  993 |     |         pure
  994 |     |         returns (bytes memory);
  995 |     | 
  996 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256`.
  997 |     |     function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);
  998 |     | 
  999 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.
 1000 |     |     function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);
 1001 |     | 
 1002 |     |     /// ABI-encodes a JSON object.
 1003 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
 1004 |     | 
 1005 |     |     /// ABI-encodes a JSON object at `key`.
 1006 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
 1007 |     | 
 1008 |     |     /// See `serializeJson`.
 1009 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
 1010 |     |         external
 1011 |     |         returns (string memory json);
 1012 |     | 
 1013 |     |     /// See `serializeJson`.
 1014 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
 1015 |     |         external
 1016 |     |         returns (string memory json);
 1017 |     | 
 1018 |     |     /// See `serializeJson`.
 1019 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
 1020 |     |         external
 1021 |     |         returns (string memory json);
 1022 |     | 
 1023 |     |     /// See `serializeJson`.
 1024 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
 1025 |     |         external
 1026 |     |         returns (string memory json);
 1027 |     | 
 1028 |     |     /// See `serializeJson`.
 1029 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
 1030 |     |         external
 1031 |     |         returns (string memory json);
 1032 |     | 
 1033 |     |     /// See `serializeJson`.
 1034 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
 1035 |     |         external
 1036 |     |         returns (string memory json);
 1037 |     | 
 1038 |     |     /// See `serializeJson`.
 1039 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
 1040 |     |         external
 1041 |     |         returns (string memory json);
 1042 |     | 
 1043 |     |     /// See `serializeJson`.
 1044 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
 1045 |     |         external
 1046 |     |         returns (string memory json);
 1047 |     | 
 1048 |     |     /// See `serializeJson`.
 1049 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
 1050 |     |         external
 1051 |     |         returns (string memory json);
 1052 |     | 
 1053 |     |     /// See `serializeJson`.
 1054 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
 1055 |     |         external
 1056 |     |         returns (string memory json);
 1057 |     | 
 1058 |     |     /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
 1059 |     |     /// Returns the stringified version of the specific JSON file up to that moment.
 1060 |     |     function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);
 1061 |     | 
 1062 |     |     /// See `serializeJson`.
 1063 |     |     function serializeJsonType(string calldata typeDescription, bytes calldata value)
 1064 |     |         external
 1065 |     |         pure
 1066 |     |         returns (string memory json);
 1067 |     | 
 1068 |     |     /// See `serializeJson`.
 1069 |     |     function serializeJsonType(
 1070 |     |         string calldata objectKey,
 1071 |     |         string calldata valueKey,
 1072 |     |         string calldata typeDescription,
 1073 |     |         bytes calldata value
 1074 |     |     ) external returns (string memory json);
 1075 |     | 
 1076 |     |     /// See `serializeJson`.
 1077 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
 1078 |     |         external
 1079 |     |         returns (string memory json);
 1080 |     | 
 1081 |     |     /// See `serializeJson`.
 1082 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
 1083 |     |         external
 1084 |     |         returns (string memory json);
 1085 |     | 
 1086 |     |     /// See `serializeJson`.
 1087 |     |     function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)
 1088 |     |         external
 1089 |     |         returns (string memory json);
 1090 |     | 
 1091 |     |     /// See `serializeJson`.
 1092 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
 1093 |     |         external
 1094 |     |         returns (string memory json);
 1095 |     | 
 1096 |     |     /// See `serializeJson`.
 1097 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
 1098 |     |         external
 1099 |     |         returns (string memory json);
 1100 |     | 
 1101 |     |     /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.
 1102 |     |     function writeJson(string calldata json, string calldata path) external;
 1103 |     | 
 1104 |     |     /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>
 1105 |     |     /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
 1106 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
 1107 |     | 
 1108 |     |     /// Checks if `key` exists in a JSON object
 1109 |     |     /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
 1110 |     |     function keyExists(string calldata json, string calldata key) external view returns (bool);
 1111 |     | 
 1112 |     |     // ======== Scripting ========
 1113 |     | 
 1114 |     |     /// Attach an EIP-4844 blob to the next call
 1115 |     |     function attachBlob(bytes calldata blob) external;
 1116 |     | 
 1117 |     |     /// Designate the next call as an EIP-7702 transaction
 1118 |     |     function attachDelegation(SignedDelegation calldata signedDelegation) external;
 1119 |     | 
 1120 |     |     /// Takes a signed transaction and broadcasts it to the network.
 1121 |     |     function broadcastRawTransaction(bytes calldata data) external;
 1122 |     | 
 1123 |     |     /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.
 1124 |     |     /// Broadcasting address is determined by checking the following in order:
 1125 |     |     /// 1. If `--sender` argument was provided, that address is used.
 1126 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
 1127 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
 1128 |     |     function broadcast() external;
 1129 |     | 
 1130 |     |     /// Has the next call (at this call depth only) create a transaction with the address provided
 1131 |     |     /// as the sender that can later be signed and sent onchain.
 1132 |     |     function broadcast(address signer) external;
 1133 |     | 
 1134 |     |     /// Has the next call (at this call depth only) create a transaction with the private key
 1135 |     |     /// provided as the sender that can later be signed and sent onchain.
 1136 |     |     function broadcast(uint256 privateKey) external;
 1137 |     | 
 1138 |     |     /// Returns addresses of available unlocked wallets in the script environment.
 1139 |     |     function getWallets() external returns (address[] memory wallets);
 1140 |     | 
 1141 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction
 1142 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey)
 1143 |     |         external
 1144 |     |         returns (SignedDelegation memory signedDelegation);
 1145 |     | 
 1146 |     |     /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction for specific nonce
 1147 |     |     function signAndAttachDelegation(address implementation, uint256 privateKey, uint64 nonce)
 1148 |     |         external
 1149 |     |         returns (SignedDelegation memory signedDelegation);
 1150 |     | 
 1151 |     |     /// Sign an EIP-7702 authorization for delegation
 1152 |     |     function signDelegation(address implementation, uint256 privateKey)
 1153 |     |         external
 1154 |     |         returns (SignedDelegation memory signedDelegation);
 1155 |     | 
 1156 |     |     /// Sign an EIP-7702 authorization for delegation for specific nonce
 1157 |     |     function signDelegation(address implementation, uint256 privateKey, uint64 nonce)
 1158 |     |         external
 1159 |     |         returns (SignedDelegation memory signedDelegation);
 1160 |     | 
 1161 |     |     /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.
 1162 |     |     /// Broadcasting address is determined by checking the following in order:
 1163 |     |     /// 1. If `--sender` argument was provided, that address is used.
 1164 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
 1165 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
 1166 |     |     function startBroadcast() external;
 1167 |     | 
 1168 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the address
 1169 |     |     /// provided that can later be signed and sent onchain.
 1170 |     |     function startBroadcast(address signer) external;
 1171 |     | 
 1172 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the private key
 1173 |     |     /// provided that can later be signed and sent onchain.
 1174 |     |     function startBroadcast(uint256 privateKey) external;
 1175 |     | 
 1176 |     |     /// Stops collecting onchain transactions.
 1177 |     |     function stopBroadcast() external;
 1178 |     | 
 1179 |     |     // ======== String ========
 1180 |     | 
 1181 |     |     /// Returns true if `search` is found in `subject`, false otherwise.
 1182 |     |     function contains(string calldata subject, string calldata search) external returns (bool result);
 1183 |     | 
 1184 |     |     /// Returns the index of the first occurrence of a `key` in an `input` string.
 1185 |     |     /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.
 1186 |     |     /// Returns 0 in case of an empty `key`.
 1187 |     |     function indexOf(string calldata input, string calldata key) external pure returns (uint256);
 1188 |     | 
 1189 |     |     /// Parses the given `string` into an `address`.
 1190 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
 1191 |     | 
 1192 |     |     /// Parses the given `string` into a `bool`.
 1193 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
 1194 |     | 
 1195 |     |     /// Parses the given `string` into `bytes`.
 1196 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
 1197 |     | 
 1198 |     |     /// Parses the given `string` into a `bytes32`.
 1199 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
 1200 |     | 
 1201 |     |     /// Parses the given `string` into a `int256`.
 1202 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
 1203 |     | 
 1204 |     |     /// Parses the given `string` into a `uint256`.
 1205 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
 1206 |     | 
 1207 |     |     /// Replaces occurrences of `from` in the given `string` with `to`.
 1208 |     |     function replace(string calldata input, string calldata from, string calldata to)
 1209 |     |         external
 1210 |     |         pure
 1211 |     |         returns (string memory output);
 1212 |     | 
 1213 |     |     /// Splits the given `string` into an array of strings divided by the `delimiter`.
 1214 |     |     function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);
 1215 |     | 
 1216 |     |     /// Converts the given `string` value to Lowercase.
 1217 |     |     function toLowercase(string calldata input) external pure returns (string memory output);
 1218 |     | 
 1219 |     |     /// Converts the given value to a `string`.
 1220 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
 1221 |     | 
 1222 |     |     /// Converts the given value to a `string`.
 1223 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
 1224 |     | 
 1225 |     |     /// Converts the given value to a `string`.
 1226 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
 1227 |     | 
 1228 |     |     /// Converts the given value to a `string`.
 1229 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
 1230 |     | 
 1231 |     |     /// Converts the given value to a `string`.
 1232 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
 1233 |     | 
 1234 |     |     /// Converts the given value to a `string`.
 1235 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
 1236 |     | 
 1237 |     |     /// Converts the given `string` value to Uppercase.
 1238 |     |     function toUppercase(string calldata input) external pure returns (string memory output);
 1239 |     | 
 1240 |     |     /// Trims leading and trailing whitespace from the given `string` value.
 1241 |     |     function trim(string calldata input) external pure returns (string memory output);
 1242 |     | 
 1243 |     |     // ======== Testing ========
 1244 |     | 
 1245 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1246 |     |     /// Formats values with decimals in failure message.
 1247 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
 1248 |     | 
 1249 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1250 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1251 |     |     function assertApproxEqAbsDecimal(
 1252 |     |         uint256 left,
 1253 |     |         uint256 right,
 1254 |     |         uint256 maxDelta,
 1255 |     |         uint256 decimals,
 1256 |     |         string calldata error
 1257 |     |     ) external pure;
 1258 |     | 
 1259 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1260 |     |     /// Formats values with decimals in failure message.
 1261 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
 1262 |     | 
 1263 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1264 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1265 |     |     function assertApproxEqAbsDecimal(
 1266 |     |         int256 left,
 1267 |     |         int256 right,
 1268 |     |         uint256 maxDelta,
 1269 |     |         uint256 decimals,
 1270 |     |         string calldata error
 1271 |     |     ) external pure;
 1272 |     | 
 1273 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1274 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
 1275 |     | 
 1276 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
 1277 |     |     /// Includes error message into revert string on failure.
 1278 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;
 1279 |     | 
 1280 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1281 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
 1282 |     | 
 1283 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
 1284 |     |     /// Includes error message into revert string on failure.
 1285 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;
 1286 |     | 
 1287 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1288 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1289 |     |     /// Formats values with decimals in failure message.
 1290 |     |     function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)
 1291 |     |         external
 1292 |     |         pure;
 1293 |     | 
 1294 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1295 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1296 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1297 |     |     function assertApproxEqRelDecimal(
 1298 |     |         uint256 left,
 1299 |     |         uint256 right,
 1300 |     |         uint256 maxPercentDelta,
 1301 |     |         uint256 decimals,
 1302 |     |         string calldata error
 1303 |     |     ) external pure;
 1304 |     | 
 1305 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1306 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1307 |     |     /// Formats values with decimals in failure message.
 1308 |     |     function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)
 1309 |     |         external
 1310 |     |         pure;
 1311 |     | 
 1312 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1313 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1314 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1315 |     |     function assertApproxEqRelDecimal(
 1316 |     |         int256 left,
 1317 |     |         int256 right,
 1318 |     |         uint256 maxPercentDelta,
 1319 |     |         uint256 decimals,
 1320 |     |         string calldata error
 1321 |     |     ) external pure;
 1322 |     | 
 1323 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1324 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1325 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
 1326 |     | 
 1327 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1328 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1329 |     |     /// Includes error message into revert string on failure.
 1330 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)
 1331 |     |         external
 1332 |     |         pure;
 1333 |     | 
 1334 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1335 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1336 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
 1337 |     | 
 1338 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
 1339 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
 1340 |     |     /// Includes error message into revert string on failure.
 1341 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)
 1342 |     |         external
 1343 |     |         pure;
 1344 |     | 
 1345 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
 1346 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1347 |     | 
 1348 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
 1349 |     |     /// Includes error message into revert string on failure.
 1350 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1351 |     | 
 1352 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
 1353 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1354 |     | 
 1355 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
 1356 |     |     /// Includes error message into revert string on failure.
 1357 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1358 |     | 
 1359 |     |     /// Asserts that two `bool` values are equal.
 1360 |     |     function assertEq(bool left, bool right) external pure;
 1361 |     | 
 1362 |     |     /// Asserts that two `bool` values are equal and includes error message into revert string on failure.
 1363 |     |     function assertEq(bool left, bool right, string calldata error) external pure;
 1364 |     | 
 1365 |     |     /// Asserts that two `string` values are equal.
 1366 |     |     function assertEq(string calldata left, string calldata right) external pure;
 1367 |     | 
 1368 |     |     /// Asserts that two `string` values are equal and includes error message into revert string on failure.
 1369 |     |     function assertEq(string calldata left, string calldata right, string calldata error) external pure;
 1370 |     | 
 1371 |     |     /// Asserts that two `bytes` values are equal.
 1372 |     |     function assertEq(bytes calldata left, bytes calldata right) external pure;
 1373 |     | 
 1374 |     |     /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.
 1375 |     |     function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1376 |     | 
 1377 |     |     /// Asserts that two arrays of `bool` values are equal.
 1378 |     |     function assertEq(bool[] calldata left, bool[] calldata right) external pure;
 1379 |     | 
 1380 |     |     /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
 1381 |     |     function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1382 |     | 
 1383 |     |     /// Asserts that two arrays of `uint256 values are equal.
 1384 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1385 |     | 
 1386 |     |     /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
 1387 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1388 |     | 
 1389 |     |     /// Asserts that two arrays of `int256` values are equal.
 1390 |     |     function assertEq(int256[] calldata left, int256[] calldata right) external pure;
 1391 |     | 
 1392 |     |     /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
 1393 |     |     function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1394 |     | 
 1395 |     |     /// Asserts that two `uint256` values are equal.
 1396 |     |     function assertEq(uint256 left, uint256 right) external pure;
 1397 |     | 
 1398 |     |     /// Asserts that two arrays of `address` values are equal.
 1399 |     |     function assertEq(address[] calldata left, address[] calldata right) external pure;
 1400 |     | 
 1401 |     |     /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
 1402 |     |     function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1403 |     | 
 1404 |     |     /// Asserts that two arrays of `bytes32` values are equal.
 1405 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1406 |     | 
 1407 |     |     /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
 1408 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1409 |     | 
 1410 |     |     /// Asserts that two arrays of `string` values are equal.
 1411 |     |     function assertEq(string[] calldata left, string[] calldata right) external pure;
 1412 |     | 
 1413 |     |     /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
 1414 |     |     function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1415 |     | 
 1416 |     |     /// Asserts that two arrays of `bytes` values are equal.
 1417 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1418 |     | 
 1419 |     |     /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
 1420 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1421 |     | 
 1422 |     |     /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.
 1423 |     |     function assertEq(uint256 left, uint256 right, string calldata error) external pure;
 1424 |     | 
 1425 |     |     /// Asserts that two `int256` values are equal.
 1426 |     |     function assertEq(int256 left, int256 right) external pure;
 1427 |     | 
 1428 |     |     /// Asserts that two `int256` values are equal and includes error message into revert string on failure.
 1429 |     |     function assertEq(int256 left, int256 right, string calldata error) external pure;
 1430 |     | 
 1431 |     |     /// Asserts that two `address` values are equal.
 1432 |     |     function assertEq(address left, address right) external pure;
 1433 |     | 
 1434 |     |     /// Asserts that two `address` values are equal and includes error message into revert string on failure.
 1435 |     |     function assertEq(address left, address right, string calldata error) external pure;
 1436 |     | 
 1437 |     |     /// Asserts that two `bytes32` values are equal.
 1438 |     |     function assertEq(bytes32 left, bytes32 right) external pure;
 1439 |     | 
 1440 |     |     /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
 1441 |     |     function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1442 |     | 
 1443 |     |     /// Asserts that the given condition is false.
 1444 |     |     function assertFalse(bool condition) external pure;
 1445 |     | 
 1446 |     |     /// Asserts that the given condition is false and includes error message into revert string on failure.
 1447 |     |     function assertFalse(bool condition, string calldata error) external pure;
 1448 |     | 
 1449 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1450 |     |     /// Formats values with decimals in failure message.
 1451 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1452 |     | 
 1453 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1454 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1455 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1456 |     | 
 1457 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1458 |     |     /// Formats values with decimals in failure message.
 1459 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1460 |     | 
 1461 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1462 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1463 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1464 |     | 
 1465 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1466 |     |     function assertGe(uint256 left, uint256 right) external pure;
 1467 |     | 
 1468 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1469 |     |     /// Includes error message into revert string on failure.
 1470 |     |     function assertGe(uint256 left, uint256 right, string calldata error) external pure;
 1471 |     | 
 1472 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1473 |     |     function assertGe(int256 left, int256 right) external pure;
 1474 |     | 
 1475 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1476 |     |     /// Includes error message into revert string on failure.
 1477 |     |     function assertGe(int256 left, int256 right, string calldata error) external pure;
 1478 |     | 
 1479 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1480 |     |     /// Formats values with decimals in failure message.
 1481 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1482 |     | 
 1483 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1484 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1485 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1486 |     | 
 1487 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1488 |     |     /// Formats values with decimals in failure message.
 1489 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1490 |     | 
 1491 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1492 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1493 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1494 |     | 
 1495 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1496 |     |     function assertGt(uint256 left, uint256 right) external pure;
 1497 |     | 
 1498 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1499 |     |     /// Includes error message into revert string on failure.
 1500 |     |     function assertGt(uint256 left, uint256 right, string calldata error) external pure;
 1501 |     | 
 1502 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1503 |     |     function assertGt(int256 left, int256 right) external pure;
 1504 |     | 
 1505 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1506 |     |     /// Includes error message into revert string on failure.
 1507 |     |     function assertGt(int256 left, int256 right, string calldata error) external pure;
 1508 |     | 
 1509 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1510 |     |     /// Formats values with decimals in failure message.
 1511 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1512 |     | 
 1513 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1514 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1515 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1516 |     | 
 1517 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1518 |     |     /// Formats values with decimals in failure message.
 1519 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1520 |     | 
 1521 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1522 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1523 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1524 |     | 
 1525 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1526 |     |     function assertLe(uint256 left, uint256 right) external pure;
 1527 |     | 
 1528 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1529 |     |     /// Includes error message into revert string on failure.
 1530 |     |     function assertLe(uint256 left, uint256 right, string calldata error) external pure;
 1531 |     | 
 1532 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1533 |     |     function assertLe(int256 left, int256 right) external pure;
 1534 |     | 
 1535 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1536 |     |     /// Includes error message into revert string on failure.
 1537 |     |     function assertLe(int256 left, int256 right, string calldata error) external pure;
 1538 |     | 
 1539 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1540 |     |     /// Formats values with decimals in failure message.
 1541 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1542 |     | 
 1543 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1544 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1545 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1546 |     | 
 1547 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1548 |     |     /// Formats values with decimals in failure message.
 1549 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1550 |     | 
 1551 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1552 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1553 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1554 |     | 
 1555 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1556 |     |     function assertLt(uint256 left, uint256 right) external pure;
 1557 |     | 
 1558 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1559 |     |     /// Includes error message into revert string on failure.
 1560 |     |     function assertLt(uint256 left, uint256 right, string calldata error) external pure;
 1561 |     | 
 1562 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1563 |     |     function assertLt(int256 left, int256 right) external pure;
 1564 |     | 
 1565 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1566 |     |     /// Includes error message into revert string on failure.
 1567 |     |     function assertLt(int256 left, int256 right, string calldata error) external pure;
 1568 |     | 
 1569 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1570 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1571 |     | 
 1572 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1573 |     |     /// Includes error message into revert string on failure.
 1574 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1575 |     | 
 1576 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1577 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1578 |     | 
 1579 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1580 |     |     /// Includes error message into revert string on failure.
 1581 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1582 |     | 
 1583 |     |     /// Asserts that two `bool` values are not equal.
 1584 |     |     function assertNotEq(bool left, bool right) external pure;
 1585 |     | 
 1586 |     |     /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.
 1587 |     |     function assertNotEq(bool left, bool right, string calldata error) external pure;
 1588 |     | 
 1589 |     |     /// Asserts that two `string` values are not equal.
 1590 |     |     function assertNotEq(string calldata left, string calldata right) external pure;
 1591 |     | 
 1592 |     |     /// Asserts that two `string` values are not equal and includes error message into revert string on failure.
 1593 |     |     function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;
 1594 |     | 
 1595 |     |     /// Asserts that two `bytes` values are not equal.
 1596 |     |     function assertNotEq(bytes calldata left, bytes calldata right) external pure;
 1597 |     | 
 1598 |     |     /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
 1599 |     |     function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1600 |     | 
 1601 |     |     /// Asserts that two arrays of `bool` values are not equal.
 1602 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;
 1603 |     | 
 1604 |     |     /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
 1605 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1606 |     | 
 1607 |     |     /// Asserts that two arrays of `uint256` values are not equal.
 1608 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1609 |     | 
 1610 |     |     /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
 1611 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1612 |     | 
 1613 |     |     /// Asserts that two arrays of `int256` values are not equal.
 1614 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;
 1615 |     | 
 1616 |     |     /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
 1617 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1618 |     | 
 1619 |     |     /// Asserts that two `uint256` values are not equal.
 1620 |     |     function assertNotEq(uint256 left, uint256 right) external pure;
 1621 |     | 
 1622 |     |     /// Asserts that two arrays of `address` values are not equal.
 1623 |     |     function assertNotEq(address[] calldata left, address[] calldata right) external pure;
 1624 |     | 
 1625 |     |     /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
 1626 |     |     function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1627 |     | 
 1628 |     |     /// Asserts that two arrays of `bytes32` values are not equal.
 1629 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1630 |     | 
 1631 |     |     /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
 1632 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1633 |     | 
 1634 |     |     /// Asserts that two arrays of `string` values are not equal.
 1635 |     |     function assertNotEq(string[] calldata left, string[] calldata right) external pure;
 1636 |     | 
 1637 |     |     /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
 1638 |     |     function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1639 |     | 
 1640 |     |     /// Asserts that two arrays of `bytes` values are not equal.
 1641 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1642 |     | 
 1643 |     |     /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
 1644 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1645 |     | 
 1646 |     |     /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
 1647 |     |     function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;
 1648 |     | 
 1649 |     |     /// Asserts that two `int256` values are not equal.
 1650 |     |     function assertNotEq(int256 left, int256 right) external pure;
 1651 |     | 
 1652 |     |     /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.
 1653 |     |     function assertNotEq(int256 left, int256 right, string calldata error) external pure;
 1654 |     | 
 1655 |     |     /// Asserts that two `address` values are not equal.
 1656 |     |     function assertNotEq(address left, address right) external pure;
 1657 |     | 
 1658 |     |     /// Asserts that two `address` values are not equal and includes error message into revert string on failure.
 1659 |     |     function assertNotEq(address left, address right, string calldata error) external pure;
 1660 |     | 
 1661 |     |     /// Asserts that two `bytes32` values are not equal.
 1662 |     |     function assertNotEq(bytes32 left, bytes32 right) external pure;
 1663 |     | 
 1664 |     |     /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
 1665 |     |     function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1666 |     | 
 1667 |     |     /// Asserts that the given condition is true.
 1668 |     |     function assertTrue(bool condition) external pure;
 1669 |     | 
 1670 |     |     /// Asserts that the given condition is true and includes error message into revert string on failure.
 1671 |     |     function assertTrue(bool condition, string calldata error) external pure;
 1672 |     | 
 1673 |     |     /// If the condition is false, discard this run's fuzz inputs and generate new ones.
 1674 |     |     function assume(bool condition) external pure;
 1675 |     | 
 1676 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverted.
 1677 |     |     function assumeNoRevert() external pure;
 1678 |     | 
 1679 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverts with the potential revert parameters.
 1680 |     |     function assumeNoRevert(PotentialRevert calldata potentialRevert) external pure;
 1681 |     | 
 1682 |     |     /// Discard this run's fuzz inputs and generate new ones if next call reverts with the any of the potential revert parameters.
 1683 |     |     function assumeNoRevert(PotentialRevert[] calldata potentialReverts) external pure;
 1684 |     | 
 1685 |     |     /// Writes a breakpoint to jump to in the debugger.
 1686 |     |     function breakpoint(string calldata char) external pure;
 1687 |     | 
 1688 |     |     /// Writes a conditional breakpoint to jump to in the debugger.
 1689 |     |     function breakpoint(string calldata char, bool value) external pure;
 1690 |     | 
 1691 |     |     /// Returns true if the current Foundry version is greater than or equal to the given version.
 1692 |     |     /// The given version string must be in the format `major.minor.patch`.
 1693 |     |     /// This is equivalent to `foundryVersionCmp(version) >= 0`.
 1694 |     |     function foundryVersionAtLeast(string calldata version) external view returns (bool);
 1695 |     | 
 1696 |     |     /// Compares the current Foundry version with the given version string.
 1697 |     |     /// The given version string must be in the format `major.minor.patch`.
 1698 |     |     /// Returns:
 1699 |     |     /// -1 if current Foundry version is less than the given version
 1700 |     |     /// 0 if current Foundry version equals the given version
 1701 |     |     /// 1 if current Foundry version is greater than the given version
 1702 |     |     /// This result can then be used with a comparison operator against `0`.
 1703 |     |     /// For example, to check if the current Foundry version is greater than or equal to `1.0.0`:
 1704 |     |     /// `if (foundryVersionCmp("1.0.0") >= 0) { ... }`
 1705 |     |     function foundryVersionCmp(string calldata version) external view returns (int256);
 1706 |     | 
 1707 |     |     /// Returns a Chain struct for specific alias
 1708 |     |     function getChain(string calldata chainAlias) external view returns (Chain memory chain);
 1709 |     | 
 1710 |     |     /// Returns a Chain struct for specific chainId
 1711 |     |     function getChain(uint256 chainId) external view returns (Chain memory chain);
 1712 |     | 
 1713 |     |     /// Returns the Foundry version.
 1714 |     |     /// Format: <cargo_version>-<tag>+<git_sha_short>.<unix_build_timestamp>.<profile>
 1715 |     |     /// Sample output: 0.3.0-nightly+3cb96bde9b.1737036656.debug
 1716 |     |     /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.
 1717 |     |     /// For reliable version comparisons, use UNIX format (e.g., >= 1700000000)
 1718 |     |     /// to compare timestamps while ignoring minor time differences.
 1719 |     |     function getFoundryVersion() external view returns (string memory version);
 1720 |     | 
 1721 |     |     /// Returns the RPC url for the given alias.
 1722 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 1723 |     | 
 1724 |     |     /// Returns all rpc urls and their aliases as structs.
 1725 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 1726 |     | 
 1727 |     |     /// Returns all rpc urls and their aliases `[alias, url][]`.
 1728 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 1729 |     | 
 1730 |     |     /// Suspends execution of the main thread for `duration` milliseconds.
 1731 |     |     function sleep(uint256 duration) external;
 1732 |     | 
 1733 |     |     // ======== Toml ========
 1734 |     | 
 1735 |     |     /// Checks if `key` exists in a TOML table.
 1736 |     |     function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);
 1737 |     | 
 1738 |     |     /// Parses a string of TOML data at `key` and coerces it to `address`.
 1739 |     |     function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);
 1740 |     | 
 1741 |     |     /// Parses a string of TOML data at `key` and coerces it to `address[]`.
 1742 |     |     function parseTomlAddressArray(string calldata toml, string calldata key)
 1743 |     |         external
 1744 |     |         pure
 1745 |     |         returns (address[] memory);
 1746 |     | 
 1747 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool`.
 1748 |     |     function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);
 1749 |     | 
 1750 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool[]`.
 1751 |     |     function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);
 1752 |     | 
 1753 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes`.
 1754 |     |     function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);
 1755 |     | 
 1756 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32`.
 1757 |     |     function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);
 1758 |     | 
 1759 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
 1760 |     |     function parseTomlBytes32Array(string calldata toml, string calldata key)
 1761 |     |         external
 1762 |     |         pure
 1763 |     |         returns (bytes32[] memory);
 1764 |     | 
 1765 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.
 1766 |     |     function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);
 1767 |     | 
 1768 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256`.
 1769 |     |     function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);
 1770 |     | 
 1771 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256[]`.
 1772 |     |     function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);
 1773 |     | 
 1774 |     |     /// Returns an array of all the keys in a TOML table.
 1775 |     |     function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);
 1776 |     | 
 1777 |     |     /// Parses a string of TOML data at `key` and coerces it to `string`.
 1778 |     |     function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);
 1779 |     | 
 1780 |     |     /// Parses a string of TOML data at `key` and coerces it to `string[]`.
 1781 |     |     function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);
 1782 |     | 
 1783 |     |     /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.
 1784 |     |     function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)
 1785 |     |         external
 1786 |     |         pure
 1787 |     |         returns (bytes memory);
 1788 |     | 
 1789 |     |     /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.
 1790 |     |     function parseTomlType(string calldata toml, string calldata typeDescription)
 1791 |     |         external
 1792 |     |         pure
 1793 |     |         returns (bytes memory);
 1794 |     | 
 1795 |     |     /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.
 1796 |     |     function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)
 1797 |     |         external
 1798 |     |         pure
 1799 |     |         returns (bytes memory);
 1800 |     | 
 1801 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256`.
 1802 |     |     function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);
 1803 |     | 
 1804 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.
 1805 |     |     function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);
 1806 |     | 
 1807 |     |     /// ABI-encodes a TOML table.
 1808 |     |     function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);
 1809 |     | 
 1810 |     |     /// ABI-encodes a TOML table at `key`.
 1811 |     |     function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);
 1812 |     | 
 1813 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
 1814 |     |     function writeToml(string calldata json, string calldata path) external;
 1815 |     | 
 1816 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>
 1817 |     |     /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
 1818 |     |     function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
 1819 |     | 
 1820 |     |     // ======== Utilities ========
 1821 |     | 
 1822 |     |     /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
 1823 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)
 1824 |     |         external
 1825 |     |         pure
 1826 |     |         returns (address);
 1827 |     | 
 1828 |     |     /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
 1829 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
 1830 |     | 
 1831 |     |     /// Compute the address a contract will be deployed at for a given deployer address and nonce.
 1832 |     |     function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
 1833 |     | 
 1834 |     |     /// Utility cheatcode to copy storage of `from` contract to another `to` contract.
 1835 |     |     function copyStorage(address from, address to) external;
 1836 |     | 
 1837 |     |     /// Returns ENS namehash for provided string.
 1838 |     |     function ensNamehash(string calldata name) external pure returns (bytes32);
 1839 |     | 
 1840 |     |     /// Gets the label for the specified address.
 1841 |     |     function getLabel(address account) external view returns (string memory currentLabel);
 1842 |     | 
 1843 |     |     /// Labels an address in call traces.
 1844 |     |     function label(address account, string calldata newLabel) external;
 1845 |     | 
 1846 |     |     /// Pauses collection of call traces. Useful in cases when you want to skip tracing of
 1847 |     |     /// complex calls which are not useful for debugging.
 1848 |     |     function pauseTracing() external view;
 1849 |     | 
 1850 |     |     /// Returns a random `address`.
 1851 |     |     function randomAddress() external returns (address);
 1852 |     | 
 1853 |     |     /// Returns a random `bool`.
 1854 |     |     function randomBool() external view returns (bool);
 1855 |     | 
 1856 |     |     /// Returns a random byte array value of the given length.
 1857 |     |     function randomBytes(uint256 len) external view returns (bytes memory);
 1858 |     | 
 1859 |     |     /// Returns a random fixed-size byte array of length 4.
 1860 |     |     function randomBytes4() external view returns (bytes4);
 1861 |     | 
 1862 |     |     /// Returns a random fixed-size byte array of length 8.
 1863 |     |     function randomBytes8() external view returns (bytes8);
 1864 |     | 
 1865 |     |     /// Returns a random `int256` value.
 1866 |     |     function randomInt() external view returns (int256);
 1867 |     | 
 1868 |     |     /// Returns a random `int256` value of given bits.
 1869 |     |     function randomInt(uint256 bits) external view returns (int256);
 1870 |     | 
 1871 |     |     /// Returns a random uint256 value.
 1872 |     |     function randomUint() external returns (uint256);
 1873 |     | 
 1874 |     |     /// Returns random uint256 value between the provided range (=min..=max).
 1875 |     |     function randomUint(uint256 min, uint256 max) external returns (uint256);
 1876 |     | 
 1877 |     |     /// Returns a random `uint256` value of given bits.
 1878 |     |     function randomUint(uint256 bits) external view returns (uint256);
 1879 |     | 
 1880 |     |     /// Unpauses collection of call traces.
 1881 |     |     function resumeTracing() external view;
 1882 |     | 
 1883 |     |     /// Utility cheatcode to set arbitrary storage for given target address.
 1884 |     |     function setArbitraryStorage(address target) external;
 1885 |     | 
 1886 |     |     /// Utility cheatcode to set arbitrary storage for given target address and overwrite
 1887 |     |     /// any storage slots that have been previously set.
 1888 |     |     function setArbitraryStorage(address target, bool overwrite) external;
 1889 |     | 
 1890 |     |     /// Randomly shuffles an array.
 1891 |     |     function shuffle(uint256[] calldata array) external returns (uint256[] memory);
 1892 |     | 
 1893 |     |     /// Sorts an array in ascending order.
 1894 |     |     function sort(uint256[] calldata array) external returns (uint256[] memory);
 1895 |     | 
 1896 |     |     /// Encodes a `bytes` value to a base64url string.
 1897 |     |     function toBase64URL(bytes calldata data) external pure returns (string memory);
 1898 |     | 
 1899 |     |     /// Encodes a `string` value to a base64url string.
 1900 |     |     function toBase64URL(string calldata data) external pure returns (string memory);
 1901 |     | 
 1902 |     |     /// Encodes a `bytes` value to a base64 string.
 1903 |     |     function toBase64(bytes calldata data) external pure returns (string memory);
 1904 |     | 
 1905 |     |     /// Encodes a `string` value to a base64 string.
 1906 |     |     function toBase64(string calldata data) external pure returns (string memory);
 1907 |     | }
 1908 |     | 
 1909 |     | /// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used
 1910 |     | /// in tests, but it is not recommended to use these cheats in scripts.
 1911 |     | interface Vm is VmSafe {
 1912 |     |     // ======== EVM ========
 1913 |     | 
 1914 |     |     /// Utility cheatcode to set an EIP-2930 access list for all subsequent transactions.
 1915 |     |     function accessList(AccessListItem[] calldata access) external;
 1916 |     | 
 1917 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 1918 |     |     function activeFork() external view returns (uint256 forkId);
 1919 |     | 
 1920 |     |     /// In forking mode, explicitly grant the given address cheatcode access.
 1921 |     |     function allowCheatcodes(address account) external;
 1922 |     | 
 1923 |     |     /// Sets `block.blobbasefee`
 1924 |     |     function blobBaseFee(uint256 newBlobBaseFee) external;
 1925 |     | 
 1926 |     |     /// Sets the blobhashes in the transaction.
 1927 |     |     /// Not available on EVM versions before Cancun.
 1928 |     |     /// If used on unsupported EVM versions it will revert.
 1929 |     |     function blobhashes(bytes32[] calldata hashes) external;
 1930 |     | 
 1931 |     |     /// Sets `block.chainid`.
 1932 |     |     function chainId(uint256 newChainId) external;
 1933 |     | 
 1934 |     |     /// Clears all mocked calls.
 1935 |     |     function clearMockedCalls() external;
 1936 |     | 
 1937 |     |     /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.
 1938 |     |     function cloneAccount(address source, address target) external;
 1939 |     | 
 1940 |     |     /// Sets `block.coinbase`.
 1941 |     |     function coinbase(address newCoinbase) external;
 1942 |     | 
 1943 |     |     /// Marks the slots of an account and the account address as cold.
 1944 |     |     function cool(address target) external;
 1945 |     | 
 1946 |     |     /// Utility cheatcode to mark specific storage slot as cold, simulating no prior read.
 1947 |     |     function coolSlot(address target, bytes32 slot) external;
 1948 |     | 
 1949 |     |     /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
 1950 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1951 |     | 
 1952 |     |     /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.
 1953 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1954 |     | 
 1955 |     |     /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,
 1956 |     |     /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
 1957 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1958 |     | 
 1959 |     |     /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
 1960 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1961 |     | 
 1962 |     |     /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
 1963 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1964 |     | 
 1965 |     |     /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,
 1966 |     |     /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.
 1967 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1968 |     | 
 1969 |     |     /// Sets an address' balance.
 1970 |     |     function deal(address account, uint256 newBalance) external;
 1971 |     | 
 1972 |     |     /// Removes the snapshot with the given ID created by `snapshot`.
 1973 |     |     /// Takes the snapshot ID to delete.
 1974 |     |     /// Returns `true` if the snapshot was successfully deleted.
 1975 |     |     /// Returns `false` if the snapshot does not exist.
 1976 |     |     function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);
 1977 |     | 
 1978 |     |     /// Removes _all_ snapshots previously created by `snapshot`.
 1979 |     |     function deleteStateSnapshots() external;
 1980 |     | 
 1981 |     |     /// Sets `block.difficulty`.
 1982 |     |     /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
 1983 |     |     /// Reverts if used on unsupported EVM versions.
 1984 |     |     function difficulty(uint256 newDifficulty) external;
 1985 |     | 
 1986 |     |     /// Dump a genesis JSON file's `allocs` to disk.
 1987 |     |     function dumpState(string calldata pathToStateJson) external;
 1988 |     | 
 1989 |     |     /// Sets an address' code.
 1990 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 1991 |     | 
 1992 |     |     /// Sets `block.basefee`.
 1993 |     |     function fee(uint256 newBasefee) external;
 1994 |     | 
 1995 |     |     /// Gets the blockhashes from the current transaction.
 1996 |     |     /// Not available on EVM versions before Cancun.
 1997 |     |     /// If used on unsupported EVM versions it will revert.
 1998 |     |     function getBlobhashes() external view returns (bytes32[] memory hashes);
 1999 |     | 
 2000 |     |     /// Returns true if the account is marked as persistent.
 2001 |     |     function isPersistent(address account) external view returns (bool persistent);
 2002 |     | 
 2003 |     |     /// Load a genesis JSON file's `allocs` into the in-memory EVM state.
 2004 |     |     function loadAllocs(string calldata pathToAllocsJson) external;
 2005 |     | 
 2006 |     |     /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 2007 |     |     /// Meaning, changes made to the state of this account will be kept when switching forks.
 2008 |     |     function makePersistent(address account) external;
 2009 |     | 
 2010 |     |     /// See `makePersistent(address)`.
 2011 |     |     function makePersistent(address account0, address account1) external;
 2012 |     | 
 2013 |     |     /// See `makePersistent(address)`.
 2014 |     |     function makePersistent(address account0, address account1, address account2) external;
 2015 |     | 
 2016 |     |     /// See `makePersistent(address)`.
 2017 |     |     function makePersistent(address[] calldata accounts) external;
 2018 |     | 
 2019 |     |     /// Reverts a call to an address with specified revert data.
 2020 |     |     function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;
 2021 |     | 
 2022 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 2023 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)
 2024 |     |         external;
 2025 |     | 
 2026 |     |     /// Reverts a call to an address with specified revert data.
 2027 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2028 |     |     function mockCallRevert(address callee, bytes4 data, bytes calldata revertData) external;
 2029 |     | 
 2030 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 2031 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2032 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes4 data, bytes calldata revertData) external;
 2033 |     | 
 2034 |     |     /// Mocks a call to an address, returning specified data.
 2035 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 2036 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 2037 |     |     /// function will be mocked.
 2038 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 2039 |     | 
 2040 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 2041 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 2042 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 2043 |     | 
 2044 |     |     /// Mocks a call to an address, returning specified data.
 2045 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 2046 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 2047 |     |     /// function will be mocked.
 2048 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2049 |     |     function mockCall(address callee, bytes4 data, bytes calldata returnData) external;
 2050 |     | 
 2051 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 2052 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 2053 |     |     /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.
 2054 |     |     function mockCall(address callee, uint256 msgValue, bytes4 data, bytes calldata returnData) external;
 2055 |     | 
 2056 |     |     /// Mocks multiple calls to an address, returning specified data for each call.
 2057 |     |     function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;
 2058 |     | 
 2059 |     |     /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.
 2060 |     |     function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;
 2061 |     | 
 2062 |     |     /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls
 2063 |     |     /// `target` with the same calldata. This functionality is similar to a delegate call made to
 2064 |     |     /// `target` contract from `callee`.
 2065 |     |     /// Can be used to substitute a call to a function with another implementation that captures
 2066 |     |     /// the primary logic of the original function but is easier to reason about.
 2067 |     |     /// If calldata is not a strict match then partial match by selector is attempted.
 2068 |     |     function mockFunction(address callee, address target, bytes calldata data) external;
 2069 |     | 
 2070 |     |     /// Utility cheatcode to remove any EIP-2930 access list set by `accessList` cheatcode.
 2071 |     |     function noAccessList() external;
 2072 |     | 
 2073 |     |     /// Sets the *next* call's `msg.sender` to be the input address.
 2074 |     |     function prank(address msgSender) external;
 2075 |     | 
 2076 |     |     /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 2077 |     |     function prank(address msgSender, address txOrigin) external;
 2078 |     | 
 2079 |     |     /// Sets the *next* delegate call's `msg.sender` to be the input address.
 2080 |     |     function prank(address msgSender, bool delegateCall) external;
 2081 |     | 
 2082 |     |     /// Sets the *next* delegate call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 2083 |     |     function prank(address msgSender, address txOrigin, bool delegateCall) external;
 2084 |     | 
 2085 |     |     /// Sets `block.prevrandao`.
 2086 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 2087 |     |     /// If used on unsupported EVM versions it will revert.
 2088 |     |     function prevrandao(bytes32 newPrevrandao) external;
 2089 |     | 
 2090 |     |     /// Sets `block.prevrandao`.
 2091 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 2092 |     |     /// If used on unsupported EVM versions it will revert.
 2093 |     |     function prevrandao(uint256 newPrevrandao) external;
 2094 |     | 
 2095 |     |     /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
 2096 |     |     function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);
 2097 |     | 
 2098 |     |     /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
 2099 |     |     function resetNonce(address account) external;
 2100 |     | 
 2101 |     |     /// Revert the state of the EVM to a previous snapshot
 2102 |     |     /// Takes the snapshot ID to revert to.
 2103 |     |     /// Returns `true` if the snapshot was successfully reverted.
 2104 |     |     /// Returns `false` if the snapshot does not exist.
 2105 |     |     /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.
 2106 |     |     function revertToState(uint256 snapshotId) external returns (bool success);
 2107 |     | 
 2108 |     |     /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
 2109 |     |     /// Takes the snapshot ID to revert to.
 2110 |     |     /// Returns `true` if the snapshot was successfully reverted and deleted.
 2111 |     |     /// Returns `false` if the snapshot does not exist.
 2112 |     |     function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);
 2113 |     | 
 2114 |     |     /// Revokes persistent status from the address, previously added via `makePersistent`.
 2115 |     |     function revokePersistent(address account) external;
 2116 |     | 
 2117 |     |     /// See `revokePersistent(address)`.
 2118 |     |     function revokePersistent(address[] calldata accounts) external;
 2119 |     | 
 2120 |     |     /// Sets `block.height`.
 2121 |     |     function roll(uint256 newHeight) external;
 2122 |     | 
 2123 |     |     /// Updates the currently active fork to given block number
 2124 |     |     /// This is similar to `roll` but for the currently active fork.
 2125 |     |     function rollFork(uint256 blockNumber) external;
 2126 |     | 
 2127 |     |     /// Updates the currently active fork to given transaction. This will `rollFork` with the number
 2128 |     |     /// of the block the transaction was mined in and replays all transaction mined before it in the block.
 2129 |     |     function rollFork(bytes32 txHash) external;
 2130 |     | 
 2131 |     |     /// Updates the given fork to given block number.
 2132 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 2133 |     | 
 2134 |     |     /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
 2135 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 2136 |     | 
 2137 |     |     /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 2138 |     |     function selectFork(uint256 forkId) external;
 2139 |     | 
 2140 |     |     /// Set blockhash for the current block.
 2141 |     |     /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.
 2142 |     |     function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;
 2143 |     | 
 2144 |     |     /// Sets the nonce of an account. Must be higher than the current nonce of the account.
 2145 |     |     function setNonce(address account, uint64 newNonce) external;
 2146 |     | 
 2147 |     |     /// Sets the nonce of an account to an arbitrary value.
 2148 |     |     function setNonceUnsafe(address account, uint64 newNonce) external;
 2149 |     | 
 2150 |     |     /// Snapshot capture the gas usage of the last call by name from the callee perspective.
 2151 |     |     function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);
 2152 |     | 
 2153 |     |     /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.
 2154 |     |     function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);
 2155 |     | 
 2156 |     |     /// Snapshot the current state of the evm.
 2157 |     |     /// Returns the ID of the snapshot that was created.
 2158 |     |     /// To revert a snapshot use `revertToState`.
 2159 |     |     function snapshotState() external returns (uint256 snapshotId);
 2160 |     | 
 2161 |     |     /// Snapshot capture an arbitrary numerical value by name.
 2162 |     |     /// The group name is derived from the contract name.
 2163 |     |     function snapshotValue(string calldata name, uint256 value) external;
 2164 |     | 
 2165 |     |     /// Snapshot capture an arbitrary numerical value by name in a group.
 2166 |     |     function snapshotValue(string calldata group, string calldata name, uint256 value) external;
 2167 |     | 
 2168 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
 2169 |     |     function startPrank(address msgSender) external;
 2170 |     | 
 2171 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 2172 |     |     function startPrank(address msgSender, address txOrigin) external;
 2173 |     | 
 2174 |     |     /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called.
 2175 |     |     function startPrank(address msgSender, bool delegateCall) external;
 2176 |     | 
 2177 |     |     /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 2178 |     |     function startPrank(address msgSender, address txOrigin, bool delegateCall) external;
 2179 |     | 
 2180 |     |     /// Start a snapshot capture of the current gas usage by name.
 2181 |     |     /// The group name is derived from the contract name.
 2182 |     |     function startSnapshotGas(string calldata name) external;
 2183 |     | 
 2184 |     |     /// Start a snapshot capture of the current gas usage by name in a group.
 2185 |     |     function startSnapshotGas(string calldata group, string calldata name) external;
 2186 |     | 
 2187 |     |     /// Resets subsequent calls' `msg.sender` to be `address(this)`.
 2188 |     |     function stopPrank() external;
 2189 |     | 
 2190 |     |     /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.
 2191 |     |     function stopSnapshotGas() external returns (uint256 gasUsed);
 2192 |     | 
 2193 |     |     /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.
 2194 |     |     /// The group name is derived from the contract name.
 2195 |     |     function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);
 2196 |     | 
 2197 |     |     /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.
 2198 |     |     function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);
 2199 |     | 
 2200 |     |     /// Stores a value to an address' storage slot.
 2201 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 2202 |     | 
 2203 |     |     /// Fetches the given transaction from the active fork and executes it on the current state.
 2204 |     |     function transact(bytes32 txHash) external;
 2205 |     | 
 2206 |     |     /// Fetches the given transaction from the given fork and executes it on the current state.
 2207 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 2208 |     | 
 2209 |     |     /// Sets `tx.gasprice`.
 2210 |     |     function txGasPrice(uint256 newGasPrice) external;
 2211 |     | 
 2212 |     |     /// Utility cheatcode to mark specific storage slot as warm, simulating a prior read.
 2213 |     |     function warmSlot(address target, bytes32 slot) external;
 2214 |     | 
 2215 |     |     /// Sets `block.timestamp`.
 2216 |     |     function warp(uint256 newTimestamp) external;
 2217 |     | 
 2218 |     |     /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.
 2219 |     |     function deleteSnapshot(uint256 snapshotId) external returns (bool success);
 2220 |     | 
 2221 |     |     /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.
 2222 |     |     function deleteSnapshots() external;
 2223 |     | 
 2224 |     |     /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.
 2225 |     |     function revertToAndDelete(uint256 snapshotId) external returns (bool success);
 2226 |     | 
 2227 |     |     /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.
 2228 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 2229 |     | 
 2230 |     |     /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.
 2231 |     |     function snapshot() external returns (uint256 snapshotId);
 2232 |     | 
 2233 |     |     // ======== Testing ========
 2234 |     | 
 2235 |     |     /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 2236 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 2237 |     | 
 2238 |     |     /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 2239 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)
 2240 |     |         external;
 2241 |     | 
 2242 |     |     /// Expects a call to an address with the specified calldata.
 2243 |     |     /// Calldata can either be a strict or a partial match.
 2244 |     |     function expectCall(address callee, bytes calldata data) external;
 2245 |     | 
 2246 |     |     /// Expects given number of calls to an address with the specified calldata.
 2247 |     |     function expectCall(address callee, bytes calldata data, uint64 count) external;
 2248 |     | 
 2249 |     |     /// Expects a call to an address with the specified `msg.value` and calldata.
 2250 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 2251 |     | 
 2252 |     |     /// Expects given number of calls to an address with the specified `msg.value` and calldata.
 2253 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;
 2254 |     | 
 2255 |     |     /// Expect a call to an address with the specified `msg.value`, gas, and calldata.
 2256 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 2257 |     | 
 2258 |     |     /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
 2259 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;
 2260 |     | 
 2261 |     |     /// Expects the deployment of the specified bytecode by the specified address using the CREATE opcode
 2262 |     |     function expectCreate(bytes calldata bytecode, address deployer) external;
 2263 |     | 
 2264 |     |     /// Expects the deployment of the specified bytecode by the specified address using the CREATE2 opcode
 2265 |     |     function expectCreate2(bytes calldata bytecode, address deployer) external;
 2266 |     | 
 2267 |     |     /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 2268 |     |     /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if
 2269 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 2270 |     |     function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)
 2271 |     |         external;
 2272 |     | 
 2273 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2274 |     |     function expectEmitAnonymous(
 2275 |     |         bool checkTopic0,
 2276 |     |         bool checkTopic1,
 2277 |     |         bool checkTopic2,
 2278 |     |         bool checkTopic3,
 2279 |     |         bool checkData,
 2280 |     |         address emitter
 2281 |     |     ) external;
 2282 |     | 
 2283 |     |     /// Prepare an expected anonymous log with all topic and data checks enabled.
 2284 |     |     /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if
 2285 |     |     /// logs were emitted in the expected order with the expected topics and data.
 2286 |     |     function expectEmitAnonymous() external;
 2287 |     | 
 2288 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2289 |     |     function expectEmitAnonymous(address emitter) external;
 2290 |     | 
 2291 |     |     /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 2292 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 2293 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 2294 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 2295 |     | 
 2296 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2297 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 2298 |     |         external;
 2299 |     | 
 2300 |     |     /// Prepare an expected log with all topic and data checks enabled.
 2301 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 2302 |     |     /// logs were emitted in the expected order with the expected topics and data.
 2303 |     |     function expectEmit() external;
 2304 |     | 
 2305 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 2306 |     |     function expectEmit(address emitter) external;
 2307 |     | 
 2308 |     |     /// Expect a given number of logs with the provided topics.
 2309 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, uint64 count) external;
 2310 |     | 
 2311 |     |     /// Expect a given number of logs from a specific emitter with the provided topics.
 2312 |     |     function expectEmit(
 2313 |     |         bool checkTopic1,
 2314 |     |         bool checkTopic2,
 2315 |     |         bool checkTopic3,
 2316 |     |         bool checkData,
 2317 |     |         address emitter,
 2318 |     |         uint64 count
 2319 |     |     ) external;
 2320 |     | 
 2321 |     |     /// Expect a given number of logs with all topic and data checks enabled.
 2322 |     |     function expectEmit(uint64 count) external;
 2323 |     | 
 2324 |     |     /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.
 2325 |     |     function expectEmit(address emitter, uint64 count) external;
 2326 |     | 
 2327 |     |     /// Expects an error on next call that starts with the revert data.
 2328 |     |     function expectPartialRevert(bytes4 revertData) external;
 2329 |     | 
 2330 |     |     /// Expects an error on next call to reverter address, that starts with the revert data.
 2331 |     |     function expectPartialRevert(bytes4 revertData, address reverter) external;
 2332 |     | 
 2333 |     |     /// Expects an error on next call with any revert data.
 2334 |     |     function expectRevert() external;
 2335 |     | 
 2336 |     |     /// Expects an error on next call that exactly matches the revert data.
 2337 |     |     function expectRevert(bytes4 revertData) external;
 2338 |     | 
 2339 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.
 2340 |     |     function expectRevert(bytes4 revertData, address reverter, uint64 count) external;
 2341 |     | 
 2342 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.
 2343 |     |     function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;
 2344 |     | 
 2345 |     |     /// Expects an error on next call that exactly matches the revert data.
 2346 |     |     function expectRevert(bytes calldata revertData) external;
 2347 |     | 
 2348 |     |     /// Expects an error with any revert data on next call to reverter address.
 2349 |     |     function expectRevert(address reverter) external;
 2350 |     | 
 2351 |     |     /// Expects an error from reverter address on next call, with any revert data.
 2352 |     |     function expectRevert(bytes4 revertData, address reverter) external;
 2353 |     | 
 2354 |     |     /// Expects an error from reverter address on next call, that exactly matches the revert data.
 2355 |     |     function expectRevert(bytes calldata revertData, address reverter) external;
 2356 |     | 
 2357 |     |     /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.
 2358 |     |     function expectRevert(uint64 count) external;
 2359 |     | 
 2360 |     |     /// Expects a `count` number of reverts from the upcoming calls that match the revert data.
 2361 |     |     function expectRevert(bytes4 revertData, uint64 count) external;
 2362 |     | 
 2363 |     |     /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.
 2364 |     |     function expectRevert(bytes calldata revertData, uint64 count) external;
 2365 |     | 
 2366 |     |     /// Expects a `count` number of reverts from the upcoming calls from the reverter address.
 2367 |     |     function expectRevert(address reverter, uint64 count) external;
 2368 |     | 
 2369 |     |     /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other
 2370 |     |     /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
 2371 |     |     function expectSafeMemory(uint64 min, uint64 max) external;
 2372 |     | 
 2373 |     |     /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.
 2374 |     |     /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
 2375 |     |     /// to the set.
 2376 |     |     function expectSafeMemoryCall(uint64 min, uint64 max) external;
 2377 |     | 
 2378 |     |     /// Marks a test as skipped. Must be called at the top level of a test.
 2379 |     |     function skip(bool skipTest) external;
 2380 |     | 
 2381 |     |     /// Marks a test as skipped with a reason. Must be called at the top level of a test.
 2382 |     |     function skip(bool skipTest, string calldata reason) external;
 2383 |     | 
 2384 |     |     /// Stops all safe memory expectation in the current subcontext.
 2385 |     |     function stopExpectSafeMemory() external;
 2386 |     | 
 2387 |     |     // ======== Utilities ========
 2388 |     | 
 2389 |     |     /// Causes the next contract creation (via new) to fail and return its initcode in the returndata buffer.
 2390 |     |     /// This allows type-safe access to the initcode payload that would be used for contract creation.
 2391 |     |     /// Example usage:
 2392 |     |     /// vm.interceptInitcode();
 2393 |     |     /// bytes memory initcode;
 2394 |     |     /// try new MyContract(param1, param2) { assert(false); }
 2395 |     |     /// catch (bytes memory interceptedInitcode) { initcode = interceptedInitcode; }
 2396 |     |     function interceptInitcode() external;
 2397 |     | }
 2398 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 | *   | library console {
    5 |     |     address constant CONSOLE_ADDRESS =
    6 | *   |         0x000000000000000000636F6e736F6c652e6c6f67;
    7 |     | 
    8 | *   |     function _sendLogPayloadImplementation(bytes memory payload) internal view {
    9 | *   |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 | *   |         assembly {
   12 | *   |             pop(
   13 | *   |                 staticcall(
   14 | *   |                     gas(),
   15 | *   |                     consoleAddress,
   16 | *   |                     add(payload, 32),
   17 | *   |                     mload(payload),
   18 | *   |                     0,
   19 | *   |                     0
   20 |     |                 )
   21 |     |             )
   22 |     |         }
   23 |     |     }
   24 |     | 
   25 | *   |     function _castToPure(
   26 |     |       function(bytes memory) internal view fnIn
   27 | *   |     ) internal pure returns (function(bytes memory) pure fnOut) {
   28 |     |         assembly {
   29 | *   |             fnOut := fnIn
   30 |     |         }
   31 |     |     }
   32 |     | 
   33 | *   |     function _sendLogPayload(bytes memory payload) internal pure {
   34 | *   |         _castToPure(_sendLogPayloadImplementation)(payload);
   35 |     |     }
   36 |     | 
   37 |     |     function log() internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   39 |     |     }
   40 |     | 
   41 |     |     function logInt(int256 p0) internal pure {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logUint(uint256 p0) internal pure {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logString(string memory p0) internal pure {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBool(bool p0) internal pure {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logAddress(address p0) internal pure {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes(bytes memory p0) internal pure {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes1(bytes1 p0) internal pure {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes2(bytes2 p0) internal pure {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes3(bytes3 p0) internal pure {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes4(bytes4 p0) internal pure {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes5(bytes5 p0) internal pure {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes6(bytes6 p0) internal pure {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes7(bytes7 p0) internal pure {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes8(bytes8 p0) internal pure {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes9(bytes9 p0) internal pure {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes10(bytes10 p0) internal pure {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes11(bytes11 p0) internal pure {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes12(bytes12 p0) internal pure {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes13(bytes13 p0) internal pure {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes14(bytes14 p0) internal pure {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes15(bytes15 p0) internal pure {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes16(bytes16 p0) internal pure {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes17(bytes17 p0) internal pure {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes18(bytes18 p0) internal pure {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes19(bytes19 p0) internal pure {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes20(bytes20 p0) internal pure {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes21(bytes21 p0) internal pure {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes22(bytes22 p0) internal pure {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes23(bytes23 p0) internal pure {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes24(bytes24 p0) internal pure {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes25(bytes25 p0) internal pure {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes26(bytes26 p0) internal pure {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes27(bytes27 p0) internal pure {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function logBytes28(bytes28 p0) internal pure {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function logBytes29(bytes29 p0) internal pure {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function logBytes30(bytes30 p0) internal pure {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function logBytes31(bytes31 p0) internal pure {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function logBytes32(bytes32 p0) internal pure {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint256 p0) internal pure {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  195 |     |     }
  196 |     | 
  197 |     |     function log(int256 p0) internal pure {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
  199 |     |     }
  200 |     | 
  201 | *   |     function log(string memory p0) internal pure {
  202 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  203 |     |     }
  204 |     | 
  205 |     |     function log(bool p0) internal pure {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  207 |     |     }
  208 |     | 
  209 |     |     function log(address p0) internal pure {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  211 |     |     }
  212 |     | 
  213 |     |     function log(uint256 p0, uint256 p1) internal pure {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(uint256 p0, string memory p1) internal pure {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(uint256 p0, bool p1) internal pure {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(uint256 p0, address p1) internal pure {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  227 |     |     }
  228 |     | 
  229 | *   |     function log(string memory p0, uint256 p1) internal pure {
  230 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(string memory p0, int256 p1) internal pure {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,int256)", p0, p1));
  235 |     |     }
  236 |     | 
  237 | *   |     function log(string memory p0, string memory p1) internal pure {
  238 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(string memory p0, bool p1) internal pure {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(string memory p0, address p1) internal pure {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(bool p0, uint256 p1) internal pure {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(bool p0, string memory p1) internal pure {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  255 |     |     }
  256 |     | 
  257 |     |     function log(bool p0, bool p1) internal pure {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  259 |     |     }
  260 |     | 
  261 |     |     function log(bool p0, address p1) internal pure {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  263 |     |     }
  264 |     | 
  265 |     |     function log(address p0, uint256 p1) internal pure {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  267 |     |     }
  268 |     | 
  269 |     |     function log(address p0, string memory p1) internal pure {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  271 |     |     }
  272 |     | 
  273 |     |     function log(address p0, bool p1) internal pure {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  275 |     |     }
  276 |     | 
  277 |     |     function log(address p0, address p1) internal pure {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal pure {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal pure {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint256 p0, string memory p1, string memory p2) internal pure {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint256 p0, string memory p1, bool p2) internal pure {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint256 p0, string memory p1, address p2) internal pure {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(uint256 p0, bool p1, string memory p2) internal pure {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(uint256 p0, address p1, string memory p2) internal pure {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal pure {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, uint256 p1, string memory p2) internal pure {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, uint256 p1, bool p2) internal pure {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, uint256 p1, address p2) internal pure {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, string memory p1, uint256 p2) internal pure {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, bool p1, uint256 p2) internal pure {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(string memory p0, address p1, uint256 p2) internal pure {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(string memory p0, address p1, address p2) internal pure {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, uint256 p1, string memory p2) internal pure {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, string memory p1, uint256 p2) internal pure {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(bool p0, bool p1, address p2) internal pure {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(bool p0, address p1, bool p2) internal pure {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(bool p0, address p1, address p2) internal pure {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, uint256 p1, string memory p2) internal pure {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, uint256 p1, address p2) internal pure {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, string memory p1, uint256 p2) internal pure {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, string memory p1, address p2) internal pure {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  511 |     |     }
  512 |     | 
  513 |     |     function log(address p0, bool p1, bool p2) internal pure {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  515 |     |     }
  516 |     | 
  517 |     |     function log(address p0, bool p1, address p2) internal pure {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  519 |     |     }
  520 |     | 
  521 |     |     function log(address p0, address p1, uint256 p2) internal pure {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  523 |     |     }
  524 |     | 
  525 |     |     function log(address p0, address p1, string memory p2) internal pure {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  527 |     |     }
  528 |     | 
  529 |     |     function log(address p0, address p1, bool p2) internal pure {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  531 |     |     }
  532 |     | 
  533 |     |     function log(address p0, address p1, address p2) internal pure {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal pure {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal pure {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal pure {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal pure {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal pure {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal pure {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal pure {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal pure {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal pure {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal pure {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal pure {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal pure {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1535 |     |     }
 1536 |     | 
 1537 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1538 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1539 |     |     }
 1540 |     | 
 1541 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1542 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1543 |     |     }
 1544 |     | 
 1545 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
 1546 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1547 |     |     }
 1548 |     | 
 1549 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1550 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1551 |     |     }
 1552 |     | 
 1553 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1554 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1555 |     |     }
 1556 |     | 
 1557 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1558 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1559 |     |     }
 1560 |     | }
 1561 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/console2.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.4.22 <0.9.0;
 3 |     | 
 4 |     | import {console as console2} from "./console.sol";
 5 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/forge-std/src/safeconsole.sol
     1 |     | // SPDX-License-Identifier: MIT
     2 |     | pragma solidity >=0.6.2 <0.9.0;
     3 |     | 
     4 |     | /// @author philogy <https://github.com/philogy>
     5 |     | /// @dev Code generated automatically by script.
     6 | *   | library safeconsole {
     7 |     |     uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;
     8 |     | 
     9 |     |     // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)
    10 |     |     // for the view-to-pure log trick.
    11 |     |     function _sendLogPayload(uint256 offset, uint256 size) private pure {
    12 |     |         function(uint256, uint256) internal view fnIn = _sendLogPayloadView;
    13 |     |         function(uint256, uint256) internal pure pureSendLogPayload;
    14 |     |         /// @solidity memory-safe-assembly
    15 |     |         assembly {
    16 |     |             pureSendLogPayload := fnIn
    17 |     |         }
    18 |     |         pureSendLogPayload(offset, size);
    19 |     |     }
    20 |     | 
    21 |     |     function _sendLogPayloadView(uint256 offset, uint256 size) private view {
    22 |     |         /// @solidity memory-safe-assembly
    23 |     |         assembly {
    24 |     |             pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))
    25 |     |         }
    26 |     |     }
    27 |     | 
    28 |     |     function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {
    29 |     |         function(uint256, uint256, uint256) internal view fnIn = _memcopyView;
    30 |     |         function(uint256, uint256, uint256) internal pure pureMemcopy;
    31 |     |         /// @solidity memory-safe-assembly
    32 |     |         assembly {
    33 |     |             pureMemcopy := fnIn
    34 |     |         }
    35 |     |         pureMemcopy(fromOffset, toOffset, length);
    36 |     |     }
    37 |     | 
    38 |     |     function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {
    39 |     |         /// @solidity memory-safe-assembly
    40 |     |         assembly {
    41 |     |             pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))
    42 |     |         }
    43 |     |     }
    44 |     | 
    45 |     |     function logMemory(uint256 offset, uint256 length) internal pure {
    46 |     |         if (offset >= 0x60) {
    47 |     |             // Sufficient memory before slice to prepare call header.
    48 |     |             bytes32 m0;
    49 |     |             bytes32 m1;
    50 |     |             bytes32 m2;
    51 |     |             /// @solidity memory-safe-assembly
    52 |     |             assembly {
    53 |     |                 m0 := mload(sub(offset, 0x60))
    54 |     |                 m1 := mload(sub(offset, 0x40))
    55 |     |                 m2 := mload(sub(offset, 0x20))
    56 |     |                 // Selector of `log(bytes)`.
    57 |     |                 mstore(sub(offset, 0x60), 0x0be77f56)
    58 |     |                 mstore(sub(offset, 0x40), 0x20)
    59 |     |                 mstore(sub(offset, 0x20), length)
    60 |     |             }
    61 |     |             _sendLogPayload(offset - 0x44, length + 0x44);
    62 |     |             /// @solidity memory-safe-assembly
    63 |     |             assembly {
    64 |     |                 mstore(sub(offset, 0x60), m0)
    65 |     |                 mstore(sub(offset, 0x40), m1)
    66 |     |                 mstore(sub(offset, 0x20), m2)
    67 |     |             }
    68 |     |         } else {
    69 |     |             // Insufficient space, so copy slice forward, add header and reverse.
    70 |     |             bytes32 m0;
    71 |     |             bytes32 m1;
    72 |     |             bytes32 m2;
    73 |     |             uint256 endOffset = offset + length;
    74 |     |             /// @solidity memory-safe-assembly
    75 |     |             assembly {
    76 |     |                 m0 := mload(add(endOffset, 0x00))
    77 |     |                 m1 := mload(add(endOffset, 0x20))
    78 |     |                 m2 := mload(add(endOffset, 0x40))
    79 |     |             }
    80 |     |             _memcopy(offset, offset + 0x60, length);
    81 |     |             /// @solidity memory-safe-assembly
    82 |     |             assembly {
    83 |     |                 // Selector of `log(bytes)`.
    84 |     |                 mstore(add(offset, 0x00), 0x0be77f56)
    85 |     |                 mstore(add(offset, 0x20), 0x20)
    86 |     |                 mstore(add(offset, 0x40), length)
    87 |     |             }
    88 |     |             _sendLogPayload(offset + 0x1c, length + 0x44);
    89 |     |             _memcopy(offset + 0x60, offset, length);
    90 |     |             /// @solidity memory-safe-assembly
    91 |     |             assembly {
    92 |     |                 mstore(add(endOffset, 0x00), m0)
    93 |     |                 mstore(add(endOffset, 0x20), m1)
    94 |     |                 mstore(add(endOffset, 0x40), m2)
    95 |     |             }
    96 |     |         }
    97 |     |     }
    98 |     | 
    99 |     |     function log(address p0) internal pure {
   100 |     |         bytes32 m0;
   101 |     |         bytes32 m1;
   102 |     |         /// @solidity memory-safe-assembly
   103 |     |         assembly {
   104 |     |             m0 := mload(0x00)
   105 |     |             m1 := mload(0x20)
   106 |     |             // Selector of `log(address)`.
   107 |     |             mstore(0x00, 0x2c2ecbc2)
   108 |     |             mstore(0x20, p0)
   109 |     |         }
   110 |     |         _sendLogPayload(0x1c, 0x24);
   111 |     |         /// @solidity memory-safe-assembly
   112 |     |         assembly {
   113 |     |             mstore(0x00, m0)
   114 |     |             mstore(0x20, m1)
   115 |     |         }
   116 |     |     }
   117 |     | 
   118 |     |     function log(bool p0) internal pure {
   119 |     |         bytes32 m0;
   120 |     |         bytes32 m1;
   121 |     |         /// @solidity memory-safe-assembly
   122 |     |         assembly {
   123 |     |             m0 := mload(0x00)
   124 |     |             m1 := mload(0x20)
   125 |     |             // Selector of `log(bool)`.
   126 |     |             mstore(0x00, 0x32458eed)
   127 |     |             mstore(0x20, p0)
   128 |     |         }
   129 |     |         _sendLogPayload(0x1c, 0x24);
   130 |     |         /// @solidity memory-safe-assembly
   131 |     |         assembly {
   132 |     |             mstore(0x00, m0)
   133 |     |             mstore(0x20, m1)
   134 |     |         }
   135 |     |     }
   136 |     | 
   137 |     |     function log(uint256 p0) internal pure {
   138 |     |         bytes32 m0;
   139 |     |         bytes32 m1;
   140 |     |         /// @solidity memory-safe-assembly
   141 |     |         assembly {
   142 |     |             m0 := mload(0x00)
   143 |     |             m1 := mload(0x20)
   144 |     |             // Selector of `log(uint256)`.
   145 |     |             mstore(0x00, 0xf82c50f1)
   146 |     |             mstore(0x20, p0)
   147 |     |         }
   148 |     |         _sendLogPayload(0x1c, 0x24);
   149 |     |         /// @solidity memory-safe-assembly
   150 |     |         assembly {
   151 |     |             mstore(0x00, m0)
   152 |     |             mstore(0x20, m1)
   153 |     |         }
   154 |     |     }
   155 |     | 
   156 |     |     function log(bytes32 p0) internal pure {
   157 |     |         bytes32 m0;
   158 |     |         bytes32 m1;
   159 |     |         bytes32 m2;
   160 |     |         bytes32 m3;
   161 |     |         /// @solidity memory-safe-assembly
   162 |     |         assembly {
   163 |     |             function writeString(pos, w) {
   164 |     |                 let length := 0
   165 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   166 |     |                 mstore(pos, length)
   167 |     |                 let shift := sub(256, shl(3, length))
   168 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   169 |     |             }
   170 |     |             m0 := mload(0x00)
   171 |     |             m1 := mload(0x20)
   172 |     |             m2 := mload(0x40)
   173 |     |             m3 := mload(0x60)
   174 |     |             // Selector of `log(string)`.
   175 |     |             mstore(0x00, 0x41304fac)
   176 |     |             mstore(0x20, 0x20)
   177 |     |             writeString(0x40, p0)
   178 |     |         }
   179 |     |         _sendLogPayload(0x1c, 0x64);
   180 |     |         /// @solidity memory-safe-assembly
   181 |     |         assembly {
   182 |     |             mstore(0x00, m0)
   183 |     |             mstore(0x20, m1)
   184 |     |             mstore(0x40, m2)
   185 |     |             mstore(0x60, m3)
   186 |     |         }
   187 |     |     }
   188 |     | 
   189 |     |     function log(address p0, address p1) internal pure {
   190 |     |         bytes32 m0;
   191 |     |         bytes32 m1;
   192 |     |         bytes32 m2;
   193 |     |         /// @solidity memory-safe-assembly
   194 |     |         assembly {
   195 |     |             m0 := mload(0x00)
   196 |     |             m1 := mload(0x20)
   197 |     |             m2 := mload(0x40)
   198 |     |             // Selector of `log(address,address)`.
   199 |     |             mstore(0x00, 0xdaf0d4aa)
   200 |     |             mstore(0x20, p0)
   201 |     |             mstore(0x40, p1)
   202 |     |         }
   203 |     |         _sendLogPayload(0x1c, 0x44);
   204 |     |         /// @solidity memory-safe-assembly
   205 |     |         assembly {
   206 |     |             mstore(0x00, m0)
   207 |     |             mstore(0x20, m1)
   208 |     |             mstore(0x40, m2)
   209 |     |         }
   210 |     |     }
   211 |     | 
   212 |     |     function log(address p0, bool p1) internal pure {
   213 |     |         bytes32 m0;
   214 |     |         bytes32 m1;
   215 |     |         bytes32 m2;
   216 |     |         /// @solidity memory-safe-assembly
   217 |     |         assembly {
   218 |     |             m0 := mload(0x00)
   219 |     |             m1 := mload(0x20)
   220 |     |             m2 := mload(0x40)
   221 |     |             // Selector of `log(address,bool)`.
   222 |     |             mstore(0x00, 0x75b605d3)
   223 |     |             mstore(0x20, p0)
   224 |     |             mstore(0x40, p1)
   225 |     |         }
   226 |     |         _sendLogPayload(0x1c, 0x44);
   227 |     |         /// @solidity memory-safe-assembly
   228 |     |         assembly {
   229 |     |             mstore(0x00, m0)
   230 |     |             mstore(0x20, m1)
   231 |     |             mstore(0x40, m2)
   232 |     |         }
   233 |     |     }
   234 |     | 
   235 |     |     function log(address p0, uint256 p1) internal pure {
   236 |     |         bytes32 m0;
   237 |     |         bytes32 m1;
   238 |     |         bytes32 m2;
   239 |     |         /// @solidity memory-safe-assembly
   240 |     |         assembly {
   241 |     |             m0 := mload(0x00)
   242 |     |             m1 := mload(0x20)
   243 |     |             m2 := mload(0x40)
   244 |     |             // Selector of `log(address,uint256)`.
   245 |     |             mstore(0x00, 0x8309e8a8)
   246 |     |             mstore(0x20, p0)
   247 |     |             mstore(0x40, p1)
   248 |     |         }
   249 |     |         _sendLogPayload(0x1c, 0x44);
   250 |     |         /// @solidity memory-safe-assembly
   251 |     |         assembly {
   252 |     |             mstore(0x00, m0)
   253 |     |             mstore(0x20, m1)
   254 |     |             mstore(0x40, m2)
   255 |     |         }
   256 |     |     }
   257 |     | 
   258 |     |     function log(address p0, bytes32 p1) internal pure {
   259 |     |         bytes32 m0;
   260 |     |         bytes32 m1;
   261 |     |         bytes32 m2;
   262 |     |         bytes32 m3;
   263 |     |         bytes32 m4;
   264 |     |         /// @solidity memory-safe-assembly
   265 |     |         assembly {
   266 |     |             function writeString(pos, w) {
   267 |     |                 let length := 0
   268 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   269 |     |                 mstore(pos, length)
   270 |     |                 let shift := sub(256, shl(3, length))
   271 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   272 |     |             }
   273 |     |             m0 := mload(0x00)
   274 |     |             m1 := mload(0x20)
   275 |     |             m2 := mload(0x40)
   276 |     |             m3 := mload(0x60)
   277 |     |             m4 := mload(0x80)
   278 |     |             // Selector of `log(address,string)`.
   279 |     |             mstore(0x00, 0x759f86bb)
   280 |     |             mstore(0x20, p0)
   281 |     |             mstore(0x40, 0x40)
   282 |     |             writeString(0x60, p1)
   283 |     |         }
   284 |     |         _sendLogPayload(0x1c, 0x84);
   285 |     |         /// @solidity memory-safe-assembly
   286 |     |         assembly {
   287 |     |             mstore(0x00, m0)
   288 |     |             mstore(0x20, m1)
   289 |     |             mstore(0x40, m2)
   290 |     |             mstore(0x60, m3)
   291 |     |             mstore(0x80, m4)
   292 |     |         }
   293 |     |     }
   294 |     | 
   295 |     |     function log(bool p0, address p1) internal pure {
   296 |     |         bytes32 m0;
   297 |     |         bytes32 m1;
   298 |     |         bytes32 m2;
   299 |     |         /// @solidity memory-safe-assembly
   300 |     |         assembly {
   301 |     |             m0 := mload(0x00)
   302 |     |             m1 := mload(0x20)
   303 |     |             m2 := mload(0x40)
   304 |     |             // Selector of `log(bool,address)`.
   305 |     |             mstore(0x00, 0x853c4849)
   306 |     |             mstore(0x20, p0)
   307 |     |             mstore(0x40, p1)
   308 |     |         }
   309 |     |         _sendLogPayload(0x1c, 0x44);
   310 |     |         /// @solidity memory-safe-assembly
   311 |     |         assembly {
   312 |     |             mstore(0x00, m0)
   313 |     |             mstore(0x20, m1)
   314 |     |             mstore(0x40, m2)
   315 |     |         }
   316 |     |     }
   317 |     | 
   318 |     |     function log(bool p0, bool p1) internal pure {
   319 |     |         bytes32 m0;
   320 |     |         bytes32 m1;
   321 |     |         bytes32 m2;
   322 |     |         /// @solidity memory-safe-assembly
   323 |     |         assembly {
   324 |     |             m0 := mload(0x00)
   325 |     |             m1 := mload(0x20)
   326 |     |             m2 := mload(0x40)
   327 |     |             // Selector of `log(bool,bool)`.
   328 |     |             mstore(0x00, 0x2a110e83)
   329 |     |             mstore(0x20, p0)
   330 |     |             mstore(0x40, p1)
   331 |     |         }
   332 |     |         _sendLogPayload(0x1c, 0x44);
   333 |     |         /// @solidity memory-safe-assembly
   334 |     |         assembly {
   335 |     |             mstore(0x00, m0)
   336 |     |             mstore(0x20, m1)
   337 |     |             mstore(0x40, m2)
   338 |     |         }
   339 |     |     }
   340 |     | 
   341 |     |     function log(bool p0, uint256 p1) internal pure {
   342 |     |         bytes32 m0;
   343 |     |         bytes32 m1;
   344 |     |         bytes32 m2;
   345 |     |         /// @solidity memory-safe-assembly
   346 |     |         assembly {
   347 |     |             m0 := mload(0x00)
   348 |     |             m1 := mload(0x20)
   349 |     |             m2 := mload(0x40)
   350 |     |             // Selector of `log(bool,uint256)`.
   351 |     |             mstore(0x00, 0x399174d3)
   352 |     |             mstore(0x20, p0)
   353 |     |             mstore(0x40, p1)
   354 |     |         }
   355 |     |         _sendLogPayload(0x1c, 0x44);
   356 |     |         /// @solidity memory-safe-assembly
   357 |     |         assembly {
   358 |     |             mstore(0x00, m0)
   359 |     |             mstore(0x20, m1)
   360 |     |             mstore(0x40, m2)
   361 |     |         }
   362 |     |     }
   363 |     | 
   364 |     |     function log(bool p0, bytes32 p1) internal pure {
   365 |     |         bytes32 m0;
   366 |     |         bytes32 m1;
   367 |     |         bytes32 m2;
   368 |     |         bytes32 m3;
   369 |     |         bytes32 m4;
   370 |     |         /// @solidity memory-safe-assembly
   371 |     |         assembly {
   372 |     |             function writeString(pos, w) {
   373 |     |                 let length := 0
   374 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   375 |     |                 mstore(pos, length)
   376 |     |                 let shift := sub(256, shl(3, length))
   377 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   378 |     |             }
   379 |     |             m0 := mload(0x00)
   380 |     |             m1 := mload(0x20)
   381 |     |             m2 := mload(0x40)
   382 |     |             m3 := mload(0x60)
   383 |     |             m4 := mload(0x80)
   384 |     |             // Selector of `log(bool,string)`.
   385 |     |             mstore(0x00, 0x8feac525)
   386 |     |             mstore(0x20, p0)
   387 |     |             mstore(0x40, 0x40)
   388 |     |             writeString(0x60, p1)
   389 |     |         }
   390 |     |         _sendLogPayload(0x1c, 0x84);
   391 |     |         /// @solidity memory-safe-assembly
   392 |     |         assembly {
   393 |     |             mstore(0x00, m0)
   394 |     |             mstore(0x20, m1)
   395 |     |             mstore(0x40, m2)
   396 |     |             mstore(0x60, m3)
   397 |     |             mstore(0x80, m4)
   398 |     |         }
   399 |     |     }
   400 |     | 
   401 |     |     function log(uint256 p0, address p1) internal pure {
   402 |     |         bytes32 m0;
   403 |     |         bytes32 m1;
   404 |     |         bytes32 m2;
   405 |     |         /// @solidity memory-safe-assembly
   406 |     |         assembly {
   407 |     |             m0 := mload(0x00)
   408 |     |             m1 := mload(0x20)
   409 |     |             m2 := mload(0x40)
   410 |     |             // Selector of `log(uint256,address)`.
   411 |     |             mstore(0x00, 0x69276c86)
   412 |     |             mstore(0x20, p0)
   413 |     |             mstore(0x40, p1)
   414 |     |         }
   415 |     |         _sendLogPayload(0x1c, 0x44);
   416 |     |         /// @solidity memory-safe-assembly
   417 |     |         assembly {
   418 |     |             mstore(0x00, m0)
   419 |     |             mstore(0x20, m1)
   420 |     |             mstore(0x40, m2)
   421 |     |         }
   422 |     |     }
   423 |     | 
   424 |     |     function log(uint256 p0, bool p1) internal pure {
   425 |     |         bytes32 m0;
   426 |     |         bytes32 m1;
   427 |     |         bytes32 m2;
   428 |     |         /// @solidity memory-safe-assembly
   429 |     |         assembly {
   430 |     |             m0 := mload(0x00)
   431 |     |             m1 := mload(0x20)
   432 |     |             m2 := mload(0x40)
   433 |     |             // Selector of `log(uint256,bool)`.
   434 |     |             mstore(0x00, 0x1c9d7eb3)
   435 |     |             mstore(0x20, p0)
   436 |     |             mstore(0x40, p1)
   437 |     |         }
   438 |     |         _sendLogPayload(0x1c, 0x44);
   439 |     |         /// @solidity memory-safe-assembly
   440 |     |         assembly {
   441 |     |             mstore(0x00, m0)
   442 |     |             mstore(0x20, m1)
   443 |     |             mstore(0x40, m2)
   444 |     |         }
   445 |     |     }
   446 |     | 
   447 |     |     function log(uint256 p0, uint256 p1) internal pure {
   448 |     |         bytes32 m0;
   449 |     |         bytes32 m1;
   450 |     |         bytes32 m2;
   451 |     |         /// @solidity memory-safe-assembly
   452 |     |         assembly {
   453 |     |             m0 := mload(0x00)
   454 |     |             m1 := mload(0x20)
   455 |     |             m2 := mload(0x40)
   456 |     |             // Selector of `log(uint256,uint256)`.
   457 |     |             mstore(0x00, 0xf666715a)
   458 |     |             mstore(0x20, p0)
   459 |     |             mstore(0x40, p1)
   460 |     |         }
   461 |     |         _sendLogPayload(0x1c, 0x44);
   462 |     |         /// @solidity memory-safe-assembly
   463 |     |         assembly {
   464 |     |             mstore(0x00, m0)
   465 |     |             mstore(0x20, m1)
   466 |     |             mstore(0x40, m2)
   467 |     |         }
   468 |     |     }
   469 |     | 
   470 |     |     function log(uint256 p0, bytes32 p1) internal pure {
   471 |     |         bytes32 m0;
   472 |     |         bytes32 m1;
   473 |     |         bytes32 m2;
   474 |     |         bytes32 m3;
   475 |     |         bytes32 m4;
   476 |     |         /// @solidity memory-safe-assembly
   477 |     |         assembly {
   478 |     |             function writeString(pos, w) {
   479 |     |                 let length := 0
   480 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   481 |     |                 mstore(pos, length)
   482 |     |                 let shift := sub(256, shl(3, length))
   483 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   484 |     |             }
   485 |     |             m0 := mload(0x00)
   486 |     |             m1 := mload(0x20)
   487 |     |             m2 := mload(0x40)
   488 |     |             m3 := mload(0x60)
   489 |     |             m4 := mload(0x80)
   490 |     |             // Selector of `log(uint256,string)`.
   491 |     |             mstore(0x00, 0x643fd0df)
   492 |     |             mstore(0x20, p0)
   493 |     |             mstore(0x40, 0x40)
   494 |     |             writeString(0x60, p1)
   495 |     |         }
   496 |     |         _sendLogPayload(0x1c, 0x84);
   497 |     |         /// @solidity memory-safe-assembly
   498 |     |         assembly {
   499 |     |             mstore(0x00, m0)
   500 |     |             mstore(0x20, m1)
   501 |     |             mstore(0x40, m2)
   502 |     |             mstore(0x60, m3)
   503 |     |             mstore(0x80, m4)
   504 |     |         }
   505 |     |     }
   506 |     | 
   507 |     |     function log(bytes32 p0, address p1) internal pure {
   508 |     |         bytes32 m0;
   509 |     |         bytes32 m1;
   510 |     |         bytes32 m2;
   511 |     |         bytes32 m3;
   512 |     |         bytes32 m4;
   513 |     |         /// @solidity memory-safe-assembly
   514 |     |         assembly {
   515 |     |             function writeString(pos, w) {
   516 |     |                 let length := 0
   517 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   518 |     |                 mstore(pos, length)
   519 |     |                 let shift := sub(256, shl(3, length))
   520 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   521 |     |             }
   522 |     |             m0 := mload(0x00)
   523 |     |             m1 := mload(0x20)
   524 |     |             m2 := mload(0x40)
   525 |     |             m3 := mload(0x60)
   526 |     |             m4 := mload(0x80)
   527 |     |             // Selector of `log(string,address)`.
   528 |     |             mstore(0x00, 0x319af333)
   529 |     |             mstore(0x20, 0x40)
   530 |     |             mstore(0x40, p1)
   531 |     |             writeString(0x60, p0)
   532 |     |         }
   533 |     |         _sendLogPayload(0x1c, 0x84);
   534 |     |         /// @solidity memory-safe-assembly
   535 |     |         assembly {
   536 |     |             mstore(0x00, m0)
   537 |     |             mstore(0x20, m1)
   538 |     |             mstore(0x40, m2)
   539 |     |             mstore(0x60, m3)
   540 |     |             mstore(0x80, m4)
   541 |     |         }
   542 |     |     }
   543 |     | 
   544 |     |     function log(bytes32 p0, bool p1) internal pure {
   545 |     |         bytes32 m0;
   546 |     |         bytes32 m1;
   547 |     |         bytes32 m2;
   548 |     |         bytes32 m3;
   549 |     |         bytes32 m4;
   550 |     |         /// @solidity memory-safe-assembly
   551 |     |         assembly {
   552 |     |             function writeString(pos, w) {
   553 |     |                 let length := 0
   554 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   555 |     |                 mstore(pos, length)
   556 |     |                 let shift := sub(256, shl(3, length))
   557 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   558 |     |             }
   559 |     |             m0 := mload(0x00)
   560 |     |             m1 := mload(0x20)
   561 |     |             m2 := mload(0x40)
   562 |     |             m3 := mload(0x60)
   563 |     |             m4 := mload(0x80)
   564 |     |             // Selector of `log(string,bool)`.
   565 |     |             mstore(0x00, 0xc3b55635)
   566 |     |             mstore(0x20, 0x40)
   567 |     |             mstore(0x40, p1)
   568 |     |             writeString(0x60, p0)
   569 |     |         }
   570 |     |         _sendLogPayload(0x1c, 0x84);
   571 |     |         /// @solidity memory-safe-assembly
   572 |     |         assembly {
   573 |     |             mstore(0x00, m0)
   574 |     |             mstore(0x20, m1)
   575 |     |             mstore(0x40, m2)
   576 |     |             mstore(0x60, m3)
   577 |     |             mstore(0x80, m4)
   578 |     |         }
   579 |     |     }
   580 |     | 
   581 |     |     function log(bytes32 p0, uint256 p1) internal pure {
   582 |     |         bytes32 m0;
   583 |     |         bytes32 m1;
   584 |     |         bytes32 m2;
   585 |     |         bytes32 m3;
   586 |     |         bytes32 m4;
   587 |     |         /// @solidity memory-safe-assembly
   588 |     |         assembly {
   589 |     |             function writeString(pos, w) {
   590 |     |                 let length := 0
   591 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   592 |     |                 mstore(pos, length)
   593 |     |                 let shift := sub(256, shl(3, length))
   594 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   595 |     |             }
   596 |     |             m0 := mload(0x00)
   597 |     |             m1 := mload(0x20)
   598 |     |             m2 := mload(0x40)
   599 |     |             m3 := mload(0x60)
   600 |     |             m4 := mload(0x80)
   601 |     |             // Selector of `log(string,uint256)`.
   602 |     |             mstore(0x00, 0xb60e72cc)
   603 |     |             mstore(0x20, 0x40)
   604 |     |             mstore(0x40, p1)
   605 |     |             writeString(0x60, p0)
   606 |     |         }
   607 |     |         _sendLogPayload(0x1c, 0x84);
   608 |     |         /// @solidity memory-safe-assembly
   609 |     |         assembly {
   610 |     |             mstore(0x00, m0)
   611 |     |             mstore(0x20, m1)
   612 |     |             mstore(0x40, m2)
   613 |     |             mstore(0x60, m3)
   614 |     |             mstore(0x80, m4)
   615 |     |         }
   616 |     |     }
   617 |     | 
   618 |     |     function log(bytes32 p0, bytes32 p1) internal pure {
   619 |     |         bytes32 m0;
   620 |     |         bytes32 m1;
   621 |     |         bytes32 m2;
   622 |     |         bytes32 m3;
   623 |     |         bytes32 m4;
   624 |     |         bytes32 m5;
   625 |     |         bytes32 m6;
   626 |     |         /// @solidity memory-safe-assembly
   627 |     |         assembly {
   628 |     |             function writeString(pos, w) {
   629 |     |                 let length := 0
   630 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   631 |     |                 mstore(pos, length)
   632 |     |                 let shift := sub(256, shl(3, length))
   633 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   634 |     |             }
   635 |     |             m0 := mload(0x00)
   636 |     |             m1 := mload(0x20)
   637 |     |             m2 := mload(0x40)
   638 |     |             m3 := mload(0x60)
   639 |     |             m4 := mload(0x80)
   640 |     |             m5 := mload(0xa0)
   641 |     |             m6 := mload(0xc0)
   642 |     |             // Selector of `log(string,string)`.
   643 |     |             mstore(0x00, 0x4b5c4277)
   644 |     |             mstore(0x20, 0x40)
   645 |     |             mstore(0x40, 0x80)
   646 |     |             writeString(0x60, p0)
   647 |     |             writeString(0xa0, p1)
   648 |     |         }
   649 |     |         _sendLogPayload(0x1c, 0xc4);
   650 |     |         /// @solidity memory-safe-assembly
   651 |     |         assembly {
   652 |     |             mstore(0x00, m0)
   653 |     |             mstore(0x20, m1)
   654 |     |             mstore(0x40, m2)
   655 |     |             mstore(0x60, m3)
   656 |     |             mstore(0x80, m4)
   657 |     |             mstore(0xa0, m5)
   658 |     |             mstore(0xc0, m6)
   659 |     |         }
   660 |     |     }
   661 |     | 
   662 |     |     function log(address p0, address p1, address p2) internal pure {
   663 |     |         bytes32 m0;
   664 |     |         bytes32 m1;
   665 |     |         bytes32 m2;
   666 |     |         bytes32 m3;
   667 |     |         /// @solidity memory-safe-assembly
   668 |     |         assembly {
   669 |     |             m0 := mload(0x00)
   670 |     |             m1 := mload(0x20)
   671 |     |             m2 := mload(0x40)
   672 |     |             m3 := mload(0x60)
   673 |     |             // Selector of `log(address,address,address)`.
   674 |     |             mstore(0x00, 0x018c84c2)
   675 |     |             mstore(0x20, p0)
   676 |     |             mstore(0x40, p1)
   677 |     |             mstore(0x60, p2)
   678 |     |         }
   679 |     |         _sendLogPayload(0x1c, 0x64);
   680 |     |         /// @solidity memory-safe-assembly
   681 |     |         assembly {
   682 |     |             mstore(0x00, m0)
   683 |     |             mstore(0x20, m1)
   684 |     |             mstore(0x40, m2)
   685 |     |             mstore(0x60, m3)
   686 |     |         }
   687 |     |     }
   688 |     | 
   689 |     |     function log(address p0, address p1, bool p2) internal pure {
   690 |     |         bytes32 m0;
   691 |     |         bytes32 m1;
   692 |     |         bytes32 m2;
   693 |     |         bytes32 m3;
   694 |     |         /// @solidity memory-safe-assembly
   695 |     |         assembly {
   696 |     |             m0 := mload(0x00)
   697 |     |             m1 := mload(0x20)
   698 |     |             m2 := mload(0x40)
   699 |     |             m3 := mload(0x60)
   700 |     |             // Selector of `log(address,address,bool)`.
   701 |     |             mstore(0x00, 0xf2a66286)
   702 |     |             mstore(0x20, p0)
   703 |     |             mstore(0x40, p1)
   704 |     |             mstore(0x60, p2)
   705 |     |         }
   706 |     |         _sendLogPayload(0x1c, 0x64);
   707 |     |         /// @solidity memory-safe-assembly
   708 |     |         assembly {
   709 |     |             mstore(0x00, m0)
   710 |     |             mstore(0x20, m1)
   711 |     |             mstore(0x40, m2)
   712 |     |             mstore(0x60, m3)
   713 |     |         }
   714 |     |     }
   715 |     | 
   716 |     |     function log(address p0, address p1, uint256 p2) internal pure {
   717 |     |         bytes32 m0;
   718 |     |         bytes32 m1;
   719 |     |         bytes32 m2;
   720 |     |         bytes32 m3;
   721 |     |         /// @solidity memory-safe-assembly
   722 |     |         assembly {
   723 |     |             m0 := mload(0x00)
   724 |     |             m1 := mload(0x20)
   725 |     |             m2 := mload(0x40)
   726 |     |             m3 := mload(0x60)
   727 |     |             // Selector of `log(address,address,uint256)`.
   728 |     |             mstore(0x00, 0x17fe6185)
   729 |     |             mstore(0x20, p0)
   730 |     |             mstore(0x40, p1)
   731 |     |             mstore(0x60, p2)
   732 |     |         }
   733 |     |         _sendLogPayload(0x1c, 0x64);
   734 |     |         /// @solidity memory-safe-assembly
   735 |     |         assembly {
   736 |     |             mstore(0x00, m0)
   737 |     |             mstore(0x20, m1)
   738 |     |             mstore(0x40, m2)
   739 |     |             mstore(0x60, m3)
   740 |     |         }
   741 |     |     }
   742 |     | 
   743 |     |     function log(address p0, address p1, bytes32 p2) internal pure {
   744 |     |         bytes32 m0;
   745 |     |         bytes32 m1;
   746 |     |         bytes32 m2;
   747 |     |         bytes32 m3;
   748 |     |         bytes32 m4;
   749 |     |         bytes32 m5;
   750 |     |         /// @solidity memory-safe-assembly
   751 |     |         assembly {
   752 |     |             function writeString(pos, w) {
   753 |     |                 let length := 0
   754 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   755 |     |                 mstore(pos, length)
   756 |     |                 let shift := sub(256, shl(3, length))
   757 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   758 |     |             }
   759 |     |             m0 := mload(0x00)
   760 |     |             m1 := mload(0x20)
   761 |     |             m2 := mload(0x40)
   762 |     |             m3 := mload(0x60)
   763 |     |             m4 := mload(0x80)
   764 |     |             m5 := mload(0xa0)
   765 |     |             // Selector of `log(address,address,string)`.
   766 |     |             mstore(0x00, 0x007150be)
   767 |     |             mstore(0x20, p0)
   768 |     |             mstore(0x40, p1)
   769 |     |             mstore(0x60, 0x60)
   770 |     |             writeString(0x80, p2)
   771 |     |         }
   772 |     |         _sendLogPayload(0x1c, 0xa4);
   773 |     |         /// @solidity memory-safe-assembly
   774 |     |         assembly {
   775 |     |             mstore(0x00, m0)
   776 |     |             mstore(0x20, m1)
   777 |     |             mstore(0x40, m2)
   778 |     |             mstore(0x60, m3)
   779 |     |             mstore(0x80, m4)
   780 |     |             mstore(0xa0, m5)
   781 |     |         }
   782 |     |     }
   783 |     | 
   784 |     |     function log(address p0, bool p1, address p2) internal pure {
   785 |     |         bytes32 m0;
   786 |     |         bytes32 m1;
   787 |     |         bytes32 m2;
   788 |     |         bytes32 m3;
   789 |     |         /// @solidity memory-safe-assembly
   790 |     |         assembly {
   791 |     |             m0 := mload(0x00)
   792 |     |             m1 := mload(0x20)
   793 |     |             m2 := mload(0x40)
   794 |     |             m3 := mload(0x60)
   795 |     |             // Selector of `log(address,bool,address)`.
   796 |     |             mstore(0x00, 0xf11699ed)
   797 |     |             mstore(0x20, p0)
   798 |     |             mstore(0x40, p1)
   799 |     |             mstore(0x60, p2)
   800 |     |         }
   801 |     |         _sendLogPayload(0x1c, 0x64);
   802 |     |         /// @solidity memory-safe-assembly
   803 |     |         assembly {
   804 |     |             mstore(0x00, m0)
   805 |     |             mstore(0x20, m1)
   806 |     |             mstore(0x40, m2)
   807 |     |             mstore(0x60, m3)
   808 |     |         }
   809 |     |     }
   810 |     | 
   811 |     |     function log(address p0, bool p1, bool p2) internal pure {
   812 |     |         bytes32 m0;
   813 |     |         bytes32 m1;
   814 |     |         bytes32 m2;
   815 |     |         bytes32 m3;
   816 |     |         /// @solidity memory-safe-assembly
   817 |     |         assembly {
   818 |     |             m0 := mload(0x00)
   819 |     |             m1 := mload(0x20)
   820 |     |             m2 := mload(0x40)
   821 |     |             m3 := mload(0x60)
   822 |     |             // Selector of `log(address,bool,bool)`.
   823 |     |             mstore(0x00, 0xeb830c92)
   824 |     |             mstore(0x20, p0)
   825 |     |             mstore(0x40, p1)
   826 |     |             mstore(0x60, p2)
   827 |     |         }
   828 |     |         _sendLogPayload(0x1c, 0x64);
   829 |     |         /// @solidity memory-safe-assembly
   830 |     |         assembly {
   831 |     |             mstore(0x00, m0)
   832 |     |             mstore(0x20, m1)
   833 |     |             mstore(0x40, m2)
   834 |     |             mstore(0x60, m3)
   835 |     |         }
   836 |     |     }
   837 |     | 
   838 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
   839 |     |         bytes32 m0;
   840 |     |         bytes32 m1;
   841 |     |         bytes32 m2;
   842 |     |         bytes32 m3;
   843 |     |         /// @solidity memory-safe-assembly
   844 |     |         assembly {
   845 |     |             m0 := mload(0x00)
   846 |     |             m1 := mload(0x20)
   847 |     |             m2 := mload(0x40)
   848 |     |             m3 := mload(0x60)
   849 |     |             // Selector of `log(address,bool,uint256)`.
   850 |     |             mstore(0x00, 0x9c4f99fb)
   851 |     |             mstore(0x20, p0)
   852 |     |             mstore(0x40, p1)
   853 |     |             mstore(0x60, p2)
   854 |     |         }
   855 |     |         _sendLogPayload(0x1c, 0x64);
   856 |     |         /// @solidity memory-safe-assembly
   857 |     |         assembly {
   858 |     |             mstore(0x00, m0)
   859 |     |             mstore(0x20, m1)
   860 |     |             mstore(0x40, m2)
   861 |     |             mstore(0x60, m3)
   862 |     |         }
   863 |     |     }
   864 |     | 
   865 |     |     function log(address p0, bool p1, bytes32 p2) internal pure {
   866 |     |         bytes32 m0;
   867 |     |         bytes32 m1;
   868 |     |         bytes32 m2;
   869 |     |         bytes32 m3;
   870 |     |         bytes32 m4;
   871 |     |         bytes32 m5;
   872 |     |         /// @solidity memory-safe-assembly
   873 |     |         assembly {
   874 |     |             function writeString(pos, w) {
   875 |     |                 let length := 0
   876 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   877 |     |                 mstore(pos, length)
   878 |     |                 let shift := sub(256, shl(3, length))
   879 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   880 |     |             }
   881 |     |             m0 := mload(0x00)
   882 |     |             m1 := mload(0x20)
   883 |     |             m2 := mload(0x40)
   884 |     |             m3 := mload(0x60)
   885 |     |             m4 := mload(0x80)
   886 |     |             m5 := mload(0xa0)
   887 |     |             // Selector of `log(address,bool,string)`.
   888 |     |             mstore(0x00, 0x212255cc)
   889 |     |             mstore(0x20, p0)
   890 |     |             mstore(0x40, p1)
   891 |     |             mstore(0x60, 0x60)
   892 |     |             writeString(0x80, p2)
   893 |     |         }
   894 |     |         _sendLogPayload(0x1c, 0xa4);
   895 |     |         /// @solidity memory-safe-assembly
   896 |     |         assembly {
   897 |     |             mstore(0x00, m0)
   898 |     |             mstore(0x20, m1)
   899 |     |             mstore(0x40, m2)
   900 |     |             mstore(0x60, m3)
   901 |     |             mstore(0x80, m4)
   902 |     |             mstore(0xa0, m5)
   903 |     |         }
   904 |     |     }
   905 |     | 
   906 |     |     function log(address p0, uint256 p1, address p2) internal pure {
   907 |     |         bytes32 m0;
   908 |     |         bytes32 m1;
   909 |     |         bytes32 m2;
   910 |     |         bytes32 m3;
   911 |     |         /// @solidity memory-safe-assembly
   912 |     |         assembly {
   913 |     |             m0 := mload(0x00)
   914 |     |             m1 := mload(0x20)
   915 |     |             m2 := mload(0x40)
   916 |     |             m3 := mload(0x60)
   917 |     |             // Selector of `log(address,uint256,address)`.
   918 |     |             mstore(0x00, 0x7bc0d848)
   919 |     |             mstore(0x20, p0)
   920 |     |             mstore(0x40, p1)
   921 |     |             mstore(0x60, p2)
   922 |     |         }
   923 |     |         _sendLogPayload(0x1c, 0x64);
   924 |     |         /// @solidity memory-safe-assembly
   925 |     |         assembly {
   926 |     |             mstore(0x00, m0)
   927 |     |             mstore(0x20, m1)
   928 |     |             mstore(0x40, m2)
   929 |     |             mstore(0x60, m3)
   930 |     |         }
   931 |     |     }
   932 |     | 
   933 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
   934 |     |         bytes32 m0;
   935 |     |         bytes32 m1;
   936 |     |         bytes32 m2;
   937 |     |         bytes32 m3;
   938 |     |         /// @solidity memory-safe-assembly
   939 |     |         assembly {
   940 |     |             m0 := mload(0x00)
   941 |     |             m1 := mload(0x20)
   942 |     |             m2 := mload(0x40)
   943 |     |             m3 := mload(0x60)
   944 |     |             // Selector of `log(address,uint256,bool)`.
   945 |     |             mstore(0x00, 0x678209a8)
   946 |     |             mstore(0x20, p0)
   947 |     |             mstore(0x40, p1)
   948 |     |             mstore(0x60, p2)
   949 |     |         }
   950 |     |         _sendLogPayload(0x1c, 0x64);
   951 |     |         /// @solidity memory-safe-assembly
   952 |     |         assembly {
   953 |     |             mstore(0x00, m0)
   954 |     |             mstore(0x20, m1)
   955 |     |             mstore(0x40, m2)
   956 |     |             mstore(0x60, m3)
   957 |     |         }
   958 |     |     }
   959 |     | 
   960 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
   961 |     |         bytes32 m0;
   962 |     |         bytes32 m1;
   963 |     |         bytes32 m2;
   964 |     |         bytes32 m3;
   965 |     |         /// @solidity memory-safe-assembly
   966 |     |         assembly {
   967 |     |             m0 := mload(0x00)
   968 |     |             m1 := mload(0x20)
   969 |     |             m2 := mload(0x40)
   970 |     |             m3 := mload(0x60)
   971 |     |             // Selector of `log(address,uint256,uint256)`.
   972 |     |             mstore(0x00, 0xb69bcaf6)
   973 |     |             mstore(0x20, p0)
   974 |     |             mstore(0x40, p1)
   975 |     |             mstore(0x60, p2)
   976 |     |         }
   977 |     |         _sendLogPayload(0x1c, 0x64);
   978 |     |         /// @solidity memory-safe-assembly
   979 |     |         assembly {
   980 |     |             mstore(0x00, m0)
   981 |     |             mstore(0x20, m1)
   982 |     |             mstore(0x40, m2)
   983 |     |             mstore(0x60, m3)
   984 |     |         }
   985 |     |     }
   986 |     | 
   987 |     |     function log(address p0, uint256 p1, bytes32 p2) internal pure {
   988 |     |         bytes32 m0;
   989 |     |         bytes32 m1;
   990 |     |         bytes32 m2;
   991 |     |         bytes32 m3;
   992 |     |         bytes32 m4;
   993 |     |         bytes32 m5;
   994 |     |         /// @solidity memory-safe-assembly
   995 |     |         assembly {
   996 |     |             function writeString(pos, w) {
   997 |     |                 let length := 0
   998 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   999 |     |                 mstore(pos, length)
  1000 |     |                 let shift := sub(256, shl(3, length))
  1001 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1002 |     |             }
  1003 |     |             m0 := mload(0x00)
  1004 |     |             m1 := mload(0x20)
  1005 |     |             m2 := mload(0x40)
  1006 |     |             m3 := mload(0x60)
  1007 |     |             m4 := mload(0x80)
  1008 |     |             m5 := mload(0xa0)
  1009 |     |             // Selector of `log(address,uint256,string)`.
  1010 |     |             mstore(0x00, 0xa1f2e8aa)
  1011 |     |             mstore(0x20, p0)
  1012 |     |             mstore(0x40, p1)
  1013 |     |             mstore(0x60, 0x60)
  1014 |     |             writeString(0x80, p2)
  1015 |     |         }
  1016 |     |         _sendLogPayload(0x1c, 0xa4);
  1017 |     |         /// @solidity memory-safe-assembly
  1018 |     |         assembly {
  1019 |     |             mstore(0x00, m0)
  1020 |     |             mstore(0x20, m1)
  1021 |     |             mstore(0x40, m2)
  1022 |     |             mstore(0x60, m3)
  1023 |     |             mstore(0x80, m4)
  1024 |     |             mstore(0xa0, m5)
  1025 |     |         }
  1026 |     |     }
  1027 |     | 
  1028 |     |     function log(address p0, bytes32 p1, address p2) internal pure {
  1029 |     |         bytes32 m0;
  1030 |     |         bytes32 m1;
  1031 |     |         bytes32 m2;
  1032 |     |         bytes32 m3;
  1033 |     |         bytes32 m4;
  1034 |     |         bytes32 m5;
  1035 |     |         /// @solidity memory-safe-assembly
  1036 |     |         assembly {
  1037 |     |             function writeString(pos, w) {
  1038 |     |                 let length := 0
  1039 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1040 |     |                 mstore(pos, length)
  1041 |     |                 let shift := sub(256, shl(3, length))
  1042 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1043 |     |             }
  1044 |     |             m0 := mload(0x00)
  1045 |     |             m1 := mload(0x20)
  1046 |     |             m2 := mload(0x40)
  1047 |     |             m3 := mload(0x60)
  1048 |     |             m4 := mload(0x80)
  1049 |     |             m5 := mload(0xa0)
  1050 |     |             // Selector of `log(address,string,address)`.
  1051 |     |             mstore(0x00, 0xf08744e8)
  1052 |     |             mstore(0x20, p0)
  1053 |     |             mstore(0x40, 0x60)
  1054 |     |             mstore(0x60, p2)
  1055 |     |             writeString(0x80, p1)
  1056 |     |         }
  1057 |     |         _sendLogPayload(0x1c, 0xa4);
  1058 |     |         /// @solidity memory-safe-assembly
  1059 |     |         assembly {
  1060 |     |             mstore(0x00, m0)
  1061 |     |             mstore(0x20, m1)
  1062 |     |             mstore(0x40, m2)
  1063 |     |             mstore(0x60, m3)
  1064 |     |             mstore(0x80, m4)
  1065 |     |             mstore(0xa0, m5)
  1066 |     |         }
  1067 |     |     }
  1068 |     | 
  1069 |     |     function log(address p0, bytes32 p1, bool p2) internal pure {
  1070 |     |         bytes32 m0;
  1071 |     |         bytes32 m1;
  1072 |     |         bytes32 m2;
  1073 |     |         bytes32 m3;
  1074 |     |         bytes32 m4;
  1075 |     |         bytes32 m5;
  1076 |     |         /// @solidity memory-safe-assembly
  1077 |     |         assembly {
  1078 |     |             function writeString(pos, w) {
  1079 |     |                 let length := 0
  1080 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1081 |     |                 mstore(pos, length)
  1082 |     |                 let shift := sub(256, shl(3, length))
  1083 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1084 |     |             }
  1085 |     |             m0 := mload(0x00)
  1086 |     |             m1 := mload(0x20)
  1087 |     |             m2 := mload(0x40)
  1088 |     |             m3 := mload(0x60)
  1089 |     |             m4 := mload(0x80)
  1090 |     |             m5 := mload(0xa0)
  1091 |     |             // Selector of `log(address,string,bool)`.
  1092 |     |             mstore(0x00, 0xcf020fb1)
  1093 |     |             mstore(0x20, p0)
  1094 |     |             mstore(0x40, 0x60)
  1095 |     |             mstore(0x60, p2)
  1096 |     |             writeString(0x80, p1)
  1097 |     |         }
  1098 |     |         _sendLogPayload(0x1c, 0xa4);
  1099 |     |         /// @solidity memory-safe-assembly
  1100 |     |         assembly {
  1101 |     |             mstore(0x00, m0)
  1102 |     |             mstore(0x20, m1)
  1103 |     |             mstore(0x40, m2)
  1104 |     |             mstore(0x60, m3)
  1105 |     |             mstore(0x80, m4)
  1106 |     |             mstore(0xa0, m5)
  1107 |     |         }
  1108 |     |     }
  1109 |     | 
  1110 |     |     function log(address p0, bytes32 p1, uint256 p2) internal pure {
  1111 |     |         bytes32 m0;
  1112 |     |         bytes32 m1;
  1113 |     |         bytes32 m2;
  1114 |     |         bytes32 m3;
  1115 |     |         bytes32 m4;
  1116 |     |         bytes32 m5;
  1117 |     |         /// @solidity memory-safe-assembly
  1118 |     |         assembly {
  1119 |     |             function writeString(pos, w) {
  1120 |     |                 let length := 0
  1121 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1122 |     |                 mstore(pos, length)
  1123 |     |                 let shift := sub(256, shl(3, length))
  1124 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1125 |     |             }
  1126 |     |             m0 := mload(0x00)
  1127 |     |             m1 := mload(0x20)
  1128 |     |             m2 := mload(0x40)
  1129 |     |             m3 := mload(0x60)
  1130 |     |             m4 := mload(0x80)
  1131 |     |             m5 := mload(0xa0)
  1132 |     |             // Selector of `log(address,string,uint256)`.
  1133 |     |             mstore(0x00, 0x67dd6ff1)
  1134 |     |             mstore(0x20, p0)
  1135 |     |             mstore(0x40, 0x60)
  1136 |     |             mstore(0x60, p2)
  1137 |     |             writeString(0x80, p1)
  1138 |     |         }
  1139 |     |         _sendLogPayload(0x1c, 0xa4);
  1140 |     |         /// @solidity memory-safe-assembly
  1141 |     |         assembly {
  1142 |     |             mstore(0x00, m0)
  1143 |     |             mstore(0x20, m1)
  1144 |     |             mstore(0x40, m2)
  1145 |     |             mstore(0x60, m3)
  1146 |     |             mstore(0x80, m4)
  1147 |     |             mstore(0xa0, m5)
  1148 |     |         }
  1149 |     |     }
  1150 |     | 
  1151 |     |     function log(address p0, bytes32 p1, bytes32 p2) internal pure {
  1152 |     |         bytes32 m0;
  1153 |     |         bytes32 m1;
  1154 |     |         bytes32 m2;
  1155 |     |         bytes32 m3;
  1156 |     |         bytes32 m4;
  1157 |     |         bytes32 m5;
  1158 |     |         bytes32 m6;
  1159 |     |         bytes32 m7;
  1160 |     |         /// @solidity memory-safe-assembly
  1161 |     |         assembly {
  1162 |     |             function writeString(pos, w) {
  1163 |     |                 let length := 0
  1164 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1165 |     |                 mstore(pos, length)
  1166 |     |                 let shift := sub(256, shl(3, length))
  1167 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1168 |     |             }
  1169 |     |             m0 := mload(0x00)
  1170 |     |             m1 := mload(0x20)
  1171 |     |             m2 := mload(0x40)
  1172 |     |             m3 := mload(0x60)
  1173 |     |             m4 := mload(0x80)
  1174 |     |             m5 := mload(0xa0)
  1175 |     |             m6 := mload(0xc0)
  1176 |     |             m7 := mload(0xe0)
  1177 |     |             // Selector of `log(address,string,string)`.
  1178 |     |             mstore(0x00, 0xfb772265)
  1179 |     |             mstore(0x20, p0)
  1180 |     |             mstore(0x40, 0x60)
  1181 |     |             mstore(0x60, 0xa0)
  1182 |     |             writeString(0x80, p1)
  1183 |     |             writeString(0xc0, p2)
  1184 |     |         }
  1185 |     |         _sendLogPayload(0x1c, 0xe4);
  1186 |     |         /// @solidity memory-safe-assembly
  1187 |     |         assembly {
  1188 |     |             mstore(0x00, m0)
  1189 |     |             mstore(0x20, m1)
  1190 |     |             mstore(0x40, m2)
  1191 |     |             mstore(0x60, m3)
  1192 |     |             mstore(0x80, m4)
  1193 |     |             mstore(0xa0, m5)
  1194 |     |             mstore(0xc0, m6)
  1195 |     |             mstore(0xe0, m7)
  1196 |     |         }
  1197 |     |     }
  1198 |     | 
  1199 |     |     function log(bool p0, address p1, address p2) internal pure {
  1200 |     |         bytes32 m0;
  1201 |     |         bytes32 m1;
  1202 |     |         bytes32 m2;
  1203 |     |         bytes32 m3;
  1204 |     |         /// @solidity memory-safe-assembly
  1205 |     |         assembly {
  1206 |     |             m0 := mload(0x00)
  1207 |     |             m1 := mload(0x20)
  1208 |     |             m2 := mload(0x40)
  1209 |     |             m3 := mload(0x60)
  1210 |     |             // Selector of `log(bool,address,address)`.
  1211 |     |             mstore(0x00, 0xd2763667)
  1212 |     |             mstore(0x20, p0)
  1213 |     |             mstore(0x40, p1)
  1214 |     |             mstore(0x60, p2)
  1215 |     |         }
  1216 |     |         _sendLogPayload(0x1c, 0x64);
  1217 |     |         /// @solidity memory-safe-assembly
  1218 |     |         assembly {
  1219 |     |             mstore(0x00, m0)
  1220 |     |             mstore(0x20, m1)
  1221 |     |             mstore(0x40, m2)
  1222 |     |             mstore(0x60, m3)
  1223 |     |         }
  1224 |     |     }
  1225 |     | 
  1226 |     |     function log(bool p0, address p1, bool p2) internal pure {
  1227 |     |         bytes32 m0;
  1228 |     |         bytes32 m1;
  1229 |     |         bytes32 m2;
  1230 |     |         bytes32 m3;
  1231 |     |         /// @solidity memory-safe-assembly
  1232 |     |         assembly {
  1233 |     |             m0 := mload(0x00)
  1234 |     |             m1 := mload(0x20)
  1235 |     |             m2 := mload(0x40)
  1236 |     |             m3 := mload(0x60)
  1237 |     |             // Selector of `log(bool,address,bool)`.
  1238 |     |             mstore(0x00, 0x18c9c746)
  1239 |     |             mstore(0x20, p0)
  1240 |     |             mstore(0x40, p1)
  1241 |     |             mstore(0x60, p2)
  1242 |     |         }
  1243 |     |         _sendLogPayload(0x1c, 0x64);
  1244 |     |         /// @solidity memory-safe-assembly
  1245 |     |         assembly {
  1246 |     |             mstore(0x00, m0)
  1247 |     |             mstore(0x20, m1)
  1248 |     |             mstore(0x40, m2)
  1249 |     |             mstore(0x60, m3)
  1250 |     |         }
  1251 |     |     }
  1252 |     | 
  1253 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  1254 |     |         bytes32 m0;
  1255 |     |         bytes32 m1;
  1256 |     |         bytes32 m2;
  1257 |     |         bytes32 m3;
  1258 |     |         /// @solidity memory-safe-assembly
  1259 |     |         assembly {
  1260 |     |             m0 := mload(0x00)
  1261 |     |             m1 := mload(0x20)
  1262 |     |             m2 := mload(0x40)
  1263 |     |             m3 := mload(0x60)
  1264 |     |             // Selector of `log(bool,address,uint256)`.
  1265 |     |             mstore(0x00, 0x5f7b9afb)
  1266 |     |             mstore(0x20, p0)
  1267 |     |             mstore(0x40, p1)
  1268 |     |             mstore(0x60, p2)
  1269 |     |         }
  1270 |     |         _sendLogPayload(0x1c, 0x64);
  1271 |     |         /// @solidity memory-safe-assembly
  1272 |     |         assembly {
  1273 |     |             mstore(0x00, m0)
  1274 |     |             mstore(0x20, m1)
  1275 |     |             mstore(0x40, m2)
  1276 |     |             mstore(0x60, m3)
  1277 |     |         }
  1278 |     |     }
  1279 |     | 
  1280 |     |     function log(bool p0, address p1, bytes32 p2) internal pure {
  1281 |     |         bytes32 m0;
  1282 |     |         bytes32 m1;
  1283 |     |         bytes32 m2;
  1284 |     |         bytes32 m3;
  1285 |     |         bytes32 m4;
  1286 |     |         bytes32 m5;
  1287 |     |         /// @solidity memory-safe-assembly
  1288 |     |         assembly {
  1289 |     |             function writeString(pos, w) {
  1290 |     |                 let length := 0
  1291 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1292 |     |                 mstore(pos, length)
  1293 |     |                 let shift := sub(256, shl(3, length))
  1294 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1295 |     |             }
  1296 |     |             m0 := mload(0x00)
  1297 |     |             m1 := mload(0x20)
  1298 |     |             m2 := mload(0x40)
  1299 |     |             m3 := mload(0x60)
  1300 |     |             m4 := mload(0x80)
  1301 |     |             m5 := mload(0xa0)
  1302 |     |             // Selector of `log(bool,address,string)`.
  1303 |     |             mstore(0x00, 0xde9a9270)
  1304 |     |             mstore(0x20, p0)
  1305 |     |             mstore(0x40, p1)
  1306 |     |             mstore(0x60, 0x60)
  1307 |     |             writeString(0x80, p2)
  1308 |     |         }
  1309 |     |         _sendLogPayload(0x1c, 0xa4);
  1310 |     |         /// @solidity memory-safe-assembly
  1311 |     |         assembly {
  1312 |     |             mstore(0x00, m0)
  1313 |     |             mstore(0x20, m1)
  1314 |     |             mstore(0x40, m2)
  1315 |     |             mstore(0x60, m3)
  1316 |     |             mstore(0x80, m4)
  1317 |     |             mstore(0xa0, m5)
  1318 |     |         }
  1319 |     |     }
  1320 |     | 
  1321 |     |     function log(bool p0, bool p1, address p2) internal pure {
  1322 |     |         bytes32 m0;
  1323 |     |         bytes32 m1;
  1324 |     |         bytes32 m2;
  1325 |     |         bytes32 m3;
  1326 |     |         /// @solidity memory-safe-assembly
  1327 |     |         assembly {
  1328 |     |             m0 := mload(0x00)
  1329 |     |             m1 := mload(0x20)
  1330 |     |             m2 := mload(0x40)
  1331 |     |             m3 := mload(0x60)
  1332 |     |             // Selector of `log(bool,bool,address)`.
  1333 |     |             mstore(0x00, 0x1078f68d)
  1334 |     |             mstore(0x20, p0)
  1335 |     |             mstore(0x40, p1)
  1336 |     |             mstore(0x60, p2)
  1337 |     |         }
  1338 |     |         _sendLogPayload(0x1c, 0x64);
  1339 |     |         /// @solidity memory-safe-assembly
  1340 |     |         assembly {
  1341 |     |             mstore(0x00, m0)
  1342 |     |             mstore(0x20, m1)
  1343 |     |             mstore(0x40, m2)
  1344 |     |             mstore(0x60, m3)
  1345 |     |         }
  1346 |     |     }
  1347 |     | 
  1348 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  1349 |     |         bytes32 m0;
  1350 |     |         bytes32 m1;
  1351 |     |         bytes32 m2;
  1352 |     |         bytes32 m3;
  1353 |     |         /// @solidity memory-safe-assembly
  1354 |     |         assembly {
  1355 |     |             m0 := mload(0x00)
  1356 |     |             m1 := mload(0x20)
  1357 |     |             m2 := mload(0x40)
  1358 |     |             m3 := mload(0x60)
  1359 |     |             // Selector of `log(bool,bool,bool)`.
  1360 |     |             mstore(0x00, 0x50709698)
  1361 |     |             mstore(0x20, p0)
  1362 |     |             mstore(0x40, p1)
  1363 |     |             mstore(0x60, p2)
  1364 |     |         }
  1365 |     |         _sendLogPayload(0x1c, 0x64);
  1366 |     |         /// @solidity memory-safe-assembly
  1367 |     |         assembly {
  1368 |     |             mstore(0x00, m0)
  1369 |     |             mstore(0x20, m1)
  1370 |     |             mstore(0x40, m2)
  1371 |     |             mstore(0x60, m3)
  1372 |     |         }
  1373 |     |     }
  1374 |     | 
  1375 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  1376 |     |         bytes32 m0;
  1377 |     |         bytes32 m1;
  1378 |     |         bytes32 m2;
  1379 |     |         bytes32 m3;
  1380 |     |         /// @solidity memory-safe-assembly
  1381 |     |         assembly {
  1382 |     |             m0 := mload(0x00)
  1383 |     |             m1 := mload(0x20)
  1384 |     |             m2 := mload(0x40)
  1385 |     |             m3 := mload(0x60)
  1386 |     |             // Selector of `log(bool,bool,uint256)`.
  1387 |     |             mstore(0x00, 0x12f21602)
  1388 |     |             mstore(0x20, p0)
  1389 |     |             mstore(0x40, p1)
  1390 |     |             mstore(0x60, p2)
  1391 |     |         }
  1392 |     |         _sendLogPayload(0x1c, 0x64);
  1393 |     |         /// @solidity memory-safe-assembly
  1394 |     |         assembly {
  1395 |     |             mstore(0x00, m0)
  1396 |     |             mstore(0x20, m1)
  1397 |     |             mstore(0x40, m2)
  1398 |     |             mstore(0x60, m3)
  1399 |     |         }
  1400 |     |     }
  1401 |     | 
  1402 |     |     function log(bool p0, bool p1, bytes32 p2) internal pure {
  1403 |     |         bytes32 m0;
  1404 |     |         bytes32 m1;
  1405 |     |         bytes32 m2;
  1406 |     |         bytes32 m3;
  1407 |     |         bytes32 m4;
  1408 |     |         bytes32 m5;
  1409 |     |         /// @solidity memory-safe-assembly
  1410 |     |         assembly {
  1411 |     |             function writeString(pos, w) {
  1412 |     |                 let length := 0
  1413 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1414 |     |                 mstore(pos, length)
  1415 |     |                 let shift := sub(256, shl(3, length))
  1416 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1417 |     |             }
  1418 |     |             m0 := mload(0x00)
  1419 |     |             m1 := mload(0x20)
  1420 |     |             m2 := mload(0x40)
  1421 |     |             m3 := mload(0x60)
  1422 |     |             m4 := mload(0x80)
  1423 |     |             m5 := mload(0xa0)
  1424 |     |             // Selector of `log(bool,bool,string)`.
  1425 |     |             mstore(0x00, 0x2555fa46)
  1426 |     |             mstore(0x20, p0)
  1427 |     |             mstore(0x40, p1)
  1428 |     |             mstore(0x60, 0x60)
  1429 |     |             writeString(0x80, p2)
  1430 |     |         }
  1431 |     |         _sendLogPayload(0x1c, 0xa4);
  1432 |     |         /// @solidity memory-safe-assembly
  1433 |     |         assembly {
  1434 |     |             mstore(0x00, m0)
  1435 |     |             mstore(0x20, m1)
  1436 |     |             mstore(0x40, m2)
  1437 |     |             mstore(0x60, m3)
  1438 |     |             mstore(0x80, m4)
  1439 |     |             mstore(0xa0, m5)
  1440 |     |         }
  1441 |     |     }
  1442 |     | 
  1443 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  1444 |     |         bytes32 m0;
  1445 |     |         bytes32 m1;
  1446 |     |         bytes32 m2;
  1447 |     |         bytes32 m3;
  1448 |     |         /// @solidity memory-safe-assembly
  1449 |     |         assembly {
  1450 |     |             m0 := mload(0x00)
  1451 |     |             m1 := mload(0x20)
  1452 |     |             m2 := mload(0x40)
  1453 |     |             m3 := mload(0x60)
  1454 |     |             // Selector of `log(bool,uint256,address)`.
  1455 |     |             mstore(0x00, 0x088ef9d2)
  1456 |     |             mstore(0x20, p0)
  1457 |     |             mstore(0x40, p1)
  1458 |     |             mstore(0x60, p2)
  1459 |     |         }
  1460 |     |         _sendLogPayload(0x1c, 0x64);
  1461 |     |         /// @solidity memory-safe-assembly
  1462 |     |         assembly {
  1463 |     |             mstore(0x00, m0)
  1464 |     |             mstore(0x20, m1)
  1465 |     |             mstore(0x40, m2)
  1466 |     |             mstore(0x60, m3)
  1467 |     |         }
  1468 |     |     }
  1469 |     | 
  1470 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  1471 |     |         bytes32 m0;
  1472 |     |         bytes32 m1;
  1473 |     |         bytes32 m2;
  1474 |     |         bytes32 m3;
  1475 |     |         /// @solidity memory-safe-assembly
  1476 |     |         assembly {
  1477 |     |             m0 := mload(0x00)
  1478 |     |             m1 := mload(0x20)
  1479 |     |             m2 := mload(0x40)
  1480 |     |             m3 := mload(0x60)
  1481 |     |             // Selector of `log(bool,uint256,bool)`.
  1482 |     |             mstore(0x00, 0xe8defba9)
  1483 |     |             mstore(0x20, p0)
  1484 |     |             mstore(0x40, p1)
  1485 |     |             mstore(0x60, p2)
  1486 |     |         }
  1487 |     |         _sendLogPayload(0x1c, 0x64);
  1488 |     |         /// @solidity memory-safe-assembly
  1489 |     |         assembly {
  1490 |     |             mstore(0x00, m0)
  1491 |     |             mstore(0x20, m1)
  1492 |     |             mstore(0x40, m2)
  1493 |     |             mstore(0x60, m3)
  1494 |     |         }
  1495 |     |     }
  1496 |     | 
  1497 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  1498 |     |         bytes32 m0;
  1499 |     |         bytes32 m1;
  1500 |     |         bytes32 m2;
  1501 |     |         bytes32 m3;
  1502 |     |         /// @solidity memory-safe-assembly
  1503 |     |         assembly {
  1504 |     |             m0 := mload(0x00)
  1505 |     |             m1 := mload(0x20)
  1506 |     |             m2 := mload(0x40)
  1507 |     |             m3 := mload(0x60)
  1508 |     |             // Selector of `log(bool,uint256,uint256)`.
  1509 |     |             mstore(0x00, 0x37103367)
  1510 |     |             mstore(0x20, p0)
  1511 |     |             mstore(0x40, p1)
  1512 |     |             mstore(0x60, p2)
  1513 |     |         }
  1514 |     |         _sendLogPayload(0x1c, 0x64);
  1515 |     |         /// @solidity memory-safe-assembly
  1516 |     |         assembly {
  1517 |     |             mstore(0x00, m0)
  1518 |     |             mstore(0x20, m1)
  1519 |     |             mstore(0x40, m2)
  1520 |     |             mstore(0x60, m3)
  1521 |     |         }
  1522 |     |     }
  1523 |     | 
  1524 |     |     function log(bool p0, uint256 p1, bytes32 p2) internal pure {
  1525 |     |         bytes32 m0;
  1526 |     |         bytes32 m1;
  1527 |     |         bytes32 m2;
  1528 |     |         bytes32 m3;
  1529 |     |         bytes32 m4;
  1530 |     |         bytes32 m5;
  1531 |     |         /// @solidity memory-safe-assembly
  1532 |     |         assembly {
  1533 |     |             function writeString(pos, w) {
  1534 |     |                 let length := 0
  1535 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1536 |     |                 mstore(pos, length)
  1537 |     |                 let shift := sub(256, shl(3, length))
  1538 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1539 |     |             }
  1540 |     |             m0 := mload(0x00)
  1541 |     |             m1 := mload(0x20)
  1542 |     |             m2 := mload(0x40)
  1543 |     |             m3 := mload(0x60)
  1544 |     |             m4 := mload(0x80)
  1545 |     |             m5 := mload(0xa0)
  1546 |     |             // Selector of `log(bool,uint256,string)`.
  1547 |     |             mstore(0x00, 0xc3fc3970)
  1548 |     |             mstore(0x20, p0)
  1549 |     |             mstore(0x40, p1)
  1550 |     |             mstore(0x60, 0x60)
  1551 |     |             writeString(0x80, p2)
  1552 |     |         }
  1553 |     |         _sendLogPayload(0x1c, 0xa4);
  1554 |     |         /// @solidity memory-safe-assembly
  1555 |     |         assembly {
  1556 |     |             mstore(0x00, m0)
  1557 |     |             mstore(0x20, m1)
  1558 |     |             mstore(0x40, m2)
  1559 |     |             mstore(0x60, m3)
  1560 |     |             mstore(0x80, m4)
  1561 |     |             mstore(0xa0, m5)
  1562 |     |         }
  1563 |     |     }
  1564 |     | 
  1565 |     |     function log(bool p0, bytes32 p1, address p2) internal pure {
  1566 |     |         bytes32 m0;
  1567 |     |         bytes32 m1;
  1568 |     |         bytes32 m2;
  1569 |     |         bytes32 m3;
  1570 |     |         bytes32 m4;
  1571 |     |         bytes32 m5;
  1572 |     |         /// @solidity memory-safe-assembly
  1573 |     |         assembly {
  1574 |     |             function writeString(pos, w) {
  1575 |     |                 let length := 0
  1576 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1577 |     |                 mstore(pos, length)
  1578 |     |                 let shift := sub(256, shl(3, length))
  1579 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1580 |     |             }
  1581 |     |             m0 := mload(0x00)
  1582 |     |             m1 := mload(0x20)
  1583 |     |             m2 := mload(0x40)
  1584 |     |             m3 := mload(0x60)
  1585 |     |             m4 := mload(0x80)
  1586 |     |             m5 := mload(0xa0)
  1587 |     |             // Selector of `log(bool,string,address)`.
  1588 |     |             mstore(0x00, 0x9591b953)
  1589 |     |             mstore(0x20, p0)
  1590 |     |             mstore(0x40, 0x60)
  1591 |     |             mstore(0x60, p2)
  1592 |     |             writeString(0x80, p1)
  1593 |     |         }
  1594 |     |         _sendLogPayload(0x1c, 0xa4);
  1595 |     |         /// @solidity memory-safe-assembly
  1596 |     |         assembly {
  1597 |     |             mstore(0x00, m0)
  1598 |     |             mstore(0x20, m1)
  1599 |     |             mstore(0x40, m2)
  1600 |     |             mstore(0x60, m3)
  1601 |     |             mstore(0x80, m4)
  1602 |     |             mstore(0xa0, m5)
  1603 |     |         }
  1604 |     |     }
  1605 |     | 
  1606 |     |     function log(bool p0, bytes32 p1, bool p2) internal pure {
  1607 |     |         bytes32 m0;
  1608 |     |         bytes32 m1;
  1609 |     |         bytes32 m2;
  1610 |     |         bytes32 m3;
  1611 |     |         bytes32 m4;
  1612 |     |         bytes32 m5;
  1613 |     |         /// @solidity memory-safe-assembly
  1614 |     |         assembly {
  1615 |     |             function writeString(pos, w) {
  1616 |     |                 let length := 0
  1617 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1618 |     |                 mstore(pos, length)
  1619 |     |                 let shift := sub(256, shl(3, length))
  1620 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1621 |     |             }
  1622 |     |             m0 := mload(0x00)
  1623 |     |             m1 := mload(0x20)
  1624 |     |             m2 := mload(0x40)
  1625 |     |             m3 := mload(0x60)
  1626 |     |             m4 := mload(0x80)
  1627 |     |             m5 := mload(0xa0)
  1628 |     |             // Selector of `log(bool,string,bool)`.
  1629 |     |             mstore(0x00, 0xdbb4c247)
  1630 |     |             mstore(0x20, p0)
  1631 |     |             mstore(0x40, 0x60)
  1632 |     |             mstore(0x60, p2)
  1633 |     |             writeString(0x80, p1)
  1634 |     |         }
  1635 |     |         _sendLogPayload(0x1c, 0xa4);
  1636 |     |         /// @solidity memory-safe-assembly
  1637 |     |         assembly {
  1638 |     |             mstore(0x00, m0)
  1639 |     |             mstore(0x20, m1)
  1640 |     |             mstore(0x40, m2)
  1641 |     |             mstore(0x60, m3)
  1642 |     |             mstore(0x80, m4)
  1643 |     |             mstore(0xa0, m5)
  1644 |     |         }
  1645 |     |     }
  1646 |     | 
  1647 |     |     function log(bool p0, bytes32 p1, uint256 p2) internal pure {
  1648 |     |         bytes32 m0;
  1649 |     |         bytes32 m1;
  1650 |     |         bytes32 m2;
  1651 |     |         bytes32 m3;
  1652 |     |         bytes32 m4;
  1653 |     |         bytes32 m5;
  1654 |     |         /// @solidity memory-safe-assembly
  1655 |     |         assembly {
  1656 |     |             function writeString(pos, w) {
  1657 |     |                 let length := 0
  1658 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1659 |     |                 mstore(pos, length)
  1660 |     |                 let shift := sub(256, shl(3, length))
  1661 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1662 |     |             }
  1663 |     |             m0 := mload(0x00)
  1664 |     |             m1 := mload(0x20)
  1665 |     |             m2 := mload(0x40)
  1666 |     |             m3 := mload(0x60)
  1667 |     |             m4 := mload(0x80)
  1668 |     |             m5 := mload(0xa0)
  1669 |     |             // Selector of `log(bool,string,uint256)`.
  1670 |     |             mstore(0x00, 0x1093ee11)
  1671 |     |             mstore(0x20, p0)
  1672 |     |             mstore(0x40, 0x60)
  1673 |     |             mstore(0x60, p2)
  1674 |     |             writeString(0x80, p1)
  1675 |     |         }
  1676 |     |         _sendLogPayload(0x1c, 0xa4);
  1677 |     |         /// @solidity memory-safe-assembly
  1678 |     |         assembly {
  1679 |     |             mstore(0x00, m0)
  1680 |     |             mstore(0x20, m1)
  1681 |     |             mstore(0x40, m2)
  1682 |     |             mstore(0x60, m3)
  1683 |     |             mstore(0x80, m4)
  1684 |     |             mstore(0xa0, m5)
  1685 |     |         }
  1686 |     |     }
  1687 |     | 
  1688 |     |     function log(bool p0, bytes32 p1, bytes32 p2) internal pure {
  1689 |     |         bytes32 m0;
  1690 |     |         bytes32 m1;
  1691 |     |         bytes32 m2;
  1692 |     |         bytes32 m3;
  1693 |     |         bytes32 m4;
  1694 |     |         bytes32 m5;
  1695 |     |         bytes32 m6;
  1696 |     |         bytes32 m7;
  1697 |     |         /// @solidity memory-safe-assembly
  1698 |     |         assembly {
  1699 |     |             function writeString(pos, w) {
  1700 |     |                 let length := 0
  1701 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1702 |     |                 mstore(pos, length)
  1703 |     |                 let shift := sub(256, shl(3, length))
  1704 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1705 |     |             }
  1706 |     |             m0 := mload(0x00)
  1707 |     |             m1 := mload(0x20)
  1708 |     |             m2 := mload(0x40)
  1709 |     |             m3 := mload(0x60)
  1710 |     |             m4 := mload(0x80)
  1711 |     |             m5 := mload(0xa0)
  1712 |     |             m6 := mload(0xc0)
  1713 |     |             m7 := mload(0xe0)
  1714 |     |             // Selector of `log(bool,string,string)`.
  1715 |     |             mstore(0x00, 0xb076847f)
  1716 |     |             mstore(0x20, p0)
  1717 |     |             mstore(0x40, 0x60)
  1718 |     |             mstore(0x60, 0xa0)
  1719 |     |             writeString(0x80, p1)
  1720 |     |             writeString(0xc0, p2)
  1721 |     |         }
  1722 |     |         _sendLogPayload(0x1c, 0xe4);
  1723 |     |         /// @solidity memory-safe-assembly
  1724 |     |         assembly {
  1725 |     |             mstore(0x00, m0)
  1726 |     |             mstore(0x20, m1)
  1727 |     |             mstore(0x40, m2)
  1728 |     |             mstore(0x60, m3)
  1729 |     |             mstore(0x80, m4)
  1730 |     |             mstore(0xa0, m5)
  1731 |     |             mstore(0xc0, m6)
  1732 |     |             mstore(0xe0, m7)
  1733 |     |         }
  1734 |     |     }
  1735 |     | 
  1736 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  1737 |     |         bytes32 m0;
  1738 |     |         bytes32 m1;
  1739 |     |         bytes32 m2;
  1740 |     |         bytes32 m3;
  1741 |     |         /// @solidity memory-safe-assembly
  1742 |     |         assembly {
  1743 |     |             m0 := mload(0x00)
  1744 |     |             m1 := mload(0x20)
  1745 |     |             m2 := mload(0x40)
  1746 |     |             m3 := mload(0x60)
  1747 |     |             // Selector of `log(uint256,address,address)`.
  1748 |     |             mstore(0x00, 0xbcfd9be0)
  1749 |     |             mstore(0x20, p0)
  1750 |     |             mstore(0x40, p1)
  1751 |     |             mstore(0x60, p2)
  1752 |     |         }
  1753 |     |         _sendLogPayload(0x1c, 0x64);
  1754 |     |         /// @solidity memory-safe-assembly
  1755 |     |         assembly {
  1756 |     |             mstore(0x00, m0)
  1757 |     |             mstore(0x20, m1)
  1758 |     |             mstore(0x40, m2)
  1759 |     |             mstore(0x60, m3)
  1760 |     |         }
  1761 |     |     }
  1762 |     | 
  1763 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  1764 |     |         bytes32 m0;
  1765 |     |         bytes32 m1;
  1766 |     |         bytes32 m2;
  1767 |     |         bytes32 m3;
  1768 |     |         /// @solidity memory-safe-assembly
  1769 |     |         assembly {
  1770 |     |             m0 := mload(0x00)
  1771 |     |             m1 := mload(0x20)
  1772 |     |             m2 := mload(0x40)
  1773 |     |             m3 := mload(0x60)
  1774 |     |             // Selector of `log(uint256,address,bool)`.
  1775 |     |             mstore(0x00, 0x9b6ec042)
  1776 |     |             mstore(0x20, p0)
  1777 |     |             mstore(0x40, p1)
  1778 |     |             mstore(0x60, p2)
  1779 |     |         }
  1780 |     |         _sendLogPayload(0x1c, 0x64);
  1781 |     |         /// @solidity memory-safe-assembly
  1782 |     |         assembly {
  1783 |     |             mstore(0x00, m0)
  1784 |     |             mstore(0x20, m1)
  1785 |     |             mstore(0x40, m2)
  1786 |     |             mstore(0x60, m3)
  1787 |     |         }
  1788 |     |     }
  1789 |     | 
  1790 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  1791 |     |         bytes32 m0;
  1792 |     |         bytes32 m1;
  1793 |     |         bytes32 m2;
  1794 |     |         bytes32 m3;
  1795 |     |         /// @solidity memory-safe-assembly
  1796 |     |         assembly {
  1797 |     |             m0 := mload(0x00)
  1798 |     |             m1 := mload(0x20)
  1799 |     |             m2 := mload(0x40)
  1800 |     |             m3 := mload(0x60)
  1801 |     |             // Selector of `log(uint256,address,uint256)`.
  1802 |     |             mstore(0x00, 0x5a9b5ed5)
  1803 |     |             mstore(0x20, p0)
  1804 |     |             mstore(0x40, p1)
  1805 |     |             mstore(0x60, p2)
  1806 |     |         }
  1807 |     |         _sendLogPayload(0x1c, 0x64);
  1808 |     |         /// @solidity memory-safe-assembly
  1809 |     |         assembly {
  1810 |     |             mstore(0x00, m0)
  1811 |     |             mstore(0x20, m1)
  1812 |     |             mstore(0x40, m2)
  1813 |     |             mstore(0x60, m3)
  1814 |     |         }
  1815 |     |     }
  1816 |     | 
  1817 |     |     function log(uint256 p0, address p1, bytes32 p2) internal pure {
  1818 |     |         bytes32 m0;
  1819 |     |         bytes32 m1;
  1820 |     |         bytes32 m2;
  1821 |     |         bytes32 m3;
  1822 |     |         bytes32 m4;
  1823 |     |         bytes32 m5;
  1824 |     |         /// @solidity memory-safe-assembly
  1825 |     |         assembly {
  1826 |     |             function writeString(pos, w) {
  1827 |     |                 let length := 0
  1828 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1829 |     |                 mstore(pos, length)
  1830 |     |                 let shift := sub(256, shl(3, length))
  1831 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1832 |     |             }
  1833 |     |             m0 := mload(0x00)
  1834 |     |             m1 := mload(0x20)
  1835 |     |             m2 := mload(0x40)
  1836 |     |             m3 := mload(0x60)
  1837 |     |             m4 := mload(0x80)
  1838 |     |             m5 := mload(0xa0)
  1839 |     |             // Selector of `log(uint256,address,string)`.
  1840 |     |             mstore(0x00, 0x63cb41f9)
  1841 |     |             mstore(0x20, p0)
  1842 |     |             mstore(0x40, p1)
  1843 |     |             mstore(0x60, 0x60)
  1844 |     |             writeString(0x80, p2)
  1845 |     |         }
  1846 |     |         _sendLogPayload(0x1c, 0xa4);
  1847 |     |         /// @solidity memory-safe-assembly
  1848 |     |         assembly {
  1849 |     |             mstore(0x00, m0)
  1850 |     |             mstore(0x20, m1)
  1851 |     |             mstore(0x40, m2)
  1852 |     |             mstore(0x60, m3)
  1853 |     |             mstore(0x80, m4)
  1854 |     |             mstore(0xa0, m5)
  1855 |     |         }
  1856 |     |     }
  1857 |     | 
  1858 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  1859 |     |         bytes32 m0;
  1860 |     |         bytes32 m1;
  1861 |     |         bytes32 m2;
  1862 |     |         bytes32 m3;
  1863 |     |         /// @solidity memory-safe-assembly
  1864 |     |         assembly {
  1865 |     |             m0 := mload(0x00)
  1866 |     |             m1 := mload(0x20)
  1867 |     |             m2 := mload(0x40)
  1868 |     |             m3 := mload(0x60)
  1869 |     |             // Selector of `log(uint256,bool,address)`.
  1870 |     |             mstore(0x00, 0x35085f7b)
  1871 |     |             mstore(0x20, p0)
  1872 |     |             mstore(0x40, p1)
  1873 |     |             mstore(0x60, p2)
  1874 |     |         }
  1875 |     |         _sendLogPayload(0x1c, 0x64);
  1876 |     |         /// @solidity memory-safe-assembly
  1877 |     |         assembly {
  1878 |     |             mstore(0x00, m0)
  1879 |     |             mstore(0x20, m1)
  1880 |     |             mstore(0x40, m2)
  1881 |     |             mstore(0x60, m3)
  1882 |     |         }
  1883 |     |     }
  1884 |     | 
  1885 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  1886 |     |         bytes32 m0;
  1887 |     |         bytes32 m1;
  1888 |     |         bytes32 m2;
  1889 |     |         bytes32 m3;
  1890 |     |         /// @solidity memory-safe-assembly
  1891 |     |         assembly {
  1892 |     |             m0 := mload(0x00)
  1893 |     |             m1 := mload(0x20)
  1894 |     |             m2 := mload(0x40)
  1895 |     |             m3 := mload(0x60)
  1896 |     |             // Selector of `log(uint256,bool,bool)`.
  1897 |     |             mstore(0x00, 0x20718650)
  1898 |     |             mstore(0x20, p0)
  1899 |     |             mstore(0x40, p1)
  1900 |     |             mstore(0x60, p2)
  1901 |     |         }
  1902 |     |         _sendLogPayload(0x1c, 0x64);
  1903 |     |         /// @solidity memory-safe-assembly
  1904 |     |         assembly {
  1905 |     |             mstore(0x00, m0)
  1906 |     |             mstore(0x20, m1)
  1907 |     |             mstore(0x40, m2)
  1908 |     |             mstore(0x60, m3)
  1909 |     |         }
  1910 |     |     }
  1911 |     | 
  1912 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  1913 |     |         bytes32 m0;
  1914 |     |         bytes32 m1;
  1915 |     |         bytes32 m2;
  1916 |     |         bytes32 m3;
  1917 |     |         /// @solidity memory-safe-assembly
  1918 |     |         assembly {
  1919 |     |             m0 := mload(0x00)
  1920 |     |             m1 := mload(0x20)
  1921 |     |             m2 := mload(0x40)
  1922 |     |             m3 := mload(0x60)
  1923 |     |             // Selector of `log(uint256,bool,uint256)`.
  1924 |     |             mstore(0x00, 0x20098014)
  1925 |     |             mstore(0x20, p0)
  1926 |     |             mstore(0x40, p1)
  1927 |     |             mstore(0x60, p2)
  1928 |     |         }
  1929 |     |         _sendLogPayload(0x1c, 0x64);
  1930 |     |         /// @solidity memory-safe-assembly
  1931 |     |         assembly {
  1932 |     |             mstore(0x00, m0)
  1933 |     |             mstore(0x20, m1)
  1934 |     |             mstore(0x40, m2)
  1935 |     |             mstore(0x60, m3)
  1936 |     |         }
  1937 |     |     }
  1938 |     | 
  1939 |     |     function log(uint256 p0, bool p1, bytes32 p2) internal pure {
  1940 |     |         bytes32 m0;
  1941 |     |         bytes32 m1;
  1942 |     |         bytes32 m2;
  1943 |     |         bytes32 m3;
  1944 |     |         bytes32 m4;
  1945 |     |         bytes32 m5;
  1946 |     |         /// @solidity memory-safe-assembly
  1947 |     |         assembly {
  1948 |     |             function writeString(pos, w) {
  1949 |     |                 let length := 0
  1950 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1951 |     |                 mstore(pos, length)
  1952 |     |                 let shift := sub(256, shl(3, length))
  1953 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1954 |     |             }
  1955 |     |             m0 := mload(0x00)
  1956 |     |             m1 := mload(0x20)
  1957 |     |             m2 := mload(0x40)
  1958 |     |             m3 := mload(0x60)
  1959 |     |             m4 := mload(0x80)
  1960 |     |             m5 := mload(0xa0)
  1961 |     |             // Selector of `log(uint256,bool,string)`.
  1962 |     |             mstore(0x00, 0x85775021)
  1963 |     |             mstore(0x20, p0)
  1964 |     |             mstore(0x40, p1)
  1965 |     |             mstore(0x60, 0x60)
  1966 |     |             writeString(0x80, p2)
  1967 |     |         }
  1968 |     |         _sendLogPayload(0x1c, 0xa4);
  1969 |     |         /// @solidity memory-safe-assembly
  1970 |     |         assembly {
  1971 |     |             mstore(0x00, m0)
  1972 |     |             mstore(0x20, m1)
  1973 |     |             mstore(0x40, m2)
  1974 |     |             mstore(0x60, m3)
  1975 |     |             mstore(0x80, m4)
  1976 |     |             mstore(0xa0, m5)
  1977 |     |         }
  1978 |     |     }
  1979 |     | 
  1980 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  1981 |     |         bytes32 m0;
  1982 |     |         bytes32 m1;
  1983 |     |         bytes32 m2;
  1984 |     |         bytes32 m3;
  1985 |     |         /// @solidity memory-safe-assembly
  1986 |     |         assembly {
  1987 |     |             m0 := mload(0x00)
  1988 |     |             m1 := mload(0x20)
  1989 |     |             m2 := mload(0x40)
  1990 |     |             m3 := mload(0x60)
  1991 |     |             // Selector of `log(uint256,uint256,address)`.
  1992 |     |             mstore(0x00, 0x5c96b331)
  1993 |     |             mstore(0x20, p0)
  1994 |     |             mstore(0x40, p1)
  1995 |     |             mstore(0x60, p2)
  1996 |     |         }
  1997 |     |         _sendLogPayload(0x1c, 0x64);
  1998 |     |         /// @solidity memory-safe-assembly
  1999 |     |         assembly {
  2000 |     |             mstore(0x00, m0)
  2001 |     |             mstore(0x20, m1)
  2002 |     |             mstore(0x40, m2)
  2003 |     |             mstore(0x60, m3)
  2004 |     |         }
  2005 |     |     }
  2006 |     | 
  2007 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  2008 |     |         bytes32 m0;
  2009 |     |         bytes32 m1;
  2010 |     |         bytes32 m2;
  2011 |     |         bytes32 m3;
  2012 |     |         /// @solidity memory-safe-assembly
  2013 |     |         assembly {
  2014 |     |             m0 := mload(0x00)
  2015 |     |             m1 := mload(0x20)
  2016 |     |             m2 := mload(0x40)
  2017 |     |             m3 := mload(0x60)
  2018 |     |             // Selector of `log(uint256,uint256,bool)`.
  2019 |     |             mstore(0x00, 0x4766da72)
  2020 |     |             mstore(0x20, p0)
  2021 |     |             mstore(0x40, p1)
  2022 |     |             mstore(0x60, p2)
  2023 |     |         }
  2024 |     |         _sendLogPayload(0x1c, 0x64);
  2025 |     |         /// @solidity memory-safe-assembly
  2026 |     |         assembly {
  2027 |     |             mstore(0x00, m0)
  2028 |     |             mstore(0x20, m1)
  2029 |     |             mstore(0x40, m2)
  2030 |     |             mstore(0x60, m3)
  2031 |     |         }
  2032 |     |     }
  2033 |     | 
  2034 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  2035 |     |         bytes32 m0;
  2036 |     |         bytes32 m1;
  2037 |     |         bytes32 m2;
  2038 |     |         bytes32 m3;
  2039 |     |         /// @solidity memory-safe-assembly
  2040 |     |         assembly {
  2041 |     |             m0 := mload(0x00)
  2042 |     |             m1 := mload(0x20)
  2043 |     |             m2 := mload(0x40)
  2044 |     |             m3 := mload(0x60)
  2045 |     |             // Selector of `log(uint256,uint256,uint256)`.
  2046 |     |             mstore(0x00, 0xd1ed7a3c)
  2047 |     |             mstore(0x20, p0)
  2048 |     |             mstore(0x40, p1)
  2049 |     |             mstore(0x60, p2)
  2050 |     |         }
  2051 |     |         _sendLogPayload(0x1c, 0x64);
  2052 |     |         /// @solidity memory-safe-assembly
  2053 |     |         assembly {
  2054 |     |             mstore(0x00, m0)
  2055 |     |             mstore(0x20, m1)
  2056 |     |             mstore(0x40, m2)
  2057 |     |             mstore(0x60, m3)
  2058 |     |         }
  2059 |     |     }
  2060 |     | 
  2061 |     |     function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {
  2062 |     |         bytes32 m0;
  2063 |     |         bytes32 m1;
  2064 |     |         bytes32 m2;
  2065 |     |         bytes32 m3;
  2066 |     |         bytes32 m4;
  2067 |     |         bytes32 m5;
  2068 |     |         /// @solidity memory-safe-assembly
  2069 |     |         assembly {
  2070 |     |             function writeString(pos, w) {
  2071 |     |                 let length := 0
  2072 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2073 |     |                 mstore(pos, length)
  2074 |     |                 let shift := sub(256, shl(3, length))
  2075 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2076 |     |             }
  2077 |     |             m0 := mload(0x00)
  2078 |     |             m1 := mload(0x20)
  2079 |     |             m2 := mload(0x40)
  2080 |     |             m3 := mload(0x60)
  2081 |     |             m4 := mload(0x80)
  2082 |     |             m5 := mload(0xa0)
  2083 |     |             // Selector of `log(uint256,uint256,string)`.
  2084 |     |             mstore(0x00, 0x71d04af2)
  2085 |     |             mstore(0x20, p0)
  2086 |     |             mstore(0x40, p1)
  2087 |     |             mstore(0x60, 0x60)
  2088 |     |             writeString(0x80, p2)
  2089 |     |         }
  2090 |     |         _sendLogPayload(0x1c, 0xa4);
  2091 |     |         /// @solidity memory-safe-assembly
  2092 |     |         assembly {
  2093 |     |             mstore(0x00, m0)
  2094 |     |             mstore(0x20, m1)
  2095 |     |             mstore(0x40, m2)
  2096 |     |             mstore(0x60, m3)
  2097 |     |             mstore(0x80, m4)
  2098 |     |             mstore(0xa0, m5)
  2099 |     |         }
  2100 |     |     }
  2101 |     | 
  2102 |     |     function log(uint256 p0, bytes32 p1, address p2) internal pure {
  2103 |     |         bytes32 m0;
  2104 |     |         bytes32 m1;
  2105 |     |         bytes32 m2;
  2106 |     |         bytes32 m3;
  2107 |     |         bytes32 m4;
  2108 |     |         bytes32 m5;
  2109 |     |         /// @solidity memory-safe-assembly
  2110 |     |         assembly {
  2111 |     |             function writeString(pos, w) {
  2112 |     |                 let length := 0
  2113 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2114 |     |                 mstore(pos, length)
  2115 |     |                 let shift := sub(256, shl(3, length))
  2116 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2117 |     |             }
  2118 |     |             m0 := mload(0x00)
  2119 |     |             m1 := mload(0x20)
  2120 |     |             m2 := mload(0x40)
  2121 |     |             m3 := mload(0x60)
  2122 |     |             m4 := mload(0x80)
  2123 |     |             m5 := mload(0xa0)
  2124 |     |             // Selector of `log(uint256,string,address)`.
  2125 |     |             mstore(0x00, 0x7afac959)
  2126 |     |             mstore(0x20, p0)
  2127 |     |             mstore(0x40, 0x60)
  2128 |     |             mstore(0x60, p2)
  2129 |     |             writeString(0x80, p1)
  2130 |     |         }
  2131 |     |         _sendLogPayload(0x1c, 0xa4);
  2132 |     |         /// @solidity memory-safe-assembly
  2133 |     |         assembly {
  2134 |     |             mstore(0x00, m0)
  2135 |     |             mstore(0x20, m1)
  2136 |     |             mstore(0x40, m2)
  2137 |     |             mstore(0x60, m3)
  2138 |     |             mstore(0x80, m4)
  2139 |     |             mstore(0xa0, m5)
  2140 |     |         }
  2141 |     |     }
  2142 |     | 
  2143 |     |     function log(uint256 p0, bytes32 p1, bool p2) internal pure {
  2144 |     |         bytes32 m0;
  2145 |     |         bytes32 m1;
  2146 |     |         bytes32 m2;
  2147 |     |         bytes32 m3;
  2148 |     |         bytes32 m4;
  2149 |     |         bytes32 m5;
  2150 |     |         /// @solidity memory-safe-assembly
  2151 |     |         assembly {
  2152 |     |             function writeString(pos, w) {
  2153 |     |                 let length := 0
  2154 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2155 |     |                 mstore(pos, length)
  2156 |     |                 let shift := sub(256, shl(3, length))
  2157 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2158 |     |             }
  2159 |     |             m0 := mload(0x00)
  2160 |     |             m1 := mload(0x20)
  2161 |     |             m2 := mload(0x40)
  2162 |     |             m3 := mload(0x60)
  2163 |     |             m4 := mload(0x80)
  2164 |     |             m5 := mload(0xa0)
  2165 |     |             // Selector of `log(uint256,string,bool)`.
  2166 |     |             mstore(0x00, 0x4ceda75a)
  2167 |     |             mstore(0x20, p0)
  2168 |     |             mstore(0x40, 0x60)
  2169 |     |             mstore(0x60, p2)
  2170 |     |             writeString(0x80, p1)
  2171 |     |         }
  2172 |     |         _sendLogPayload(0x1c, 0xa4);
  2173 |     |         /// @solidity memory-safe-assembly
  2174 |     |         assembly {
  2175 |     |             mstore(0x00, m0)
  2176 |     |             mstore(0x20, m1)
  2177 |     |             mstore(0x40, m2)
  2178 |     |             mstore(0x60, m3)
  2179 |     |             mstore(0x80, m4)
  2180 |     |             mstore(0xa0, m5)
  2181 |     |         }
  2182 |     |     }
  2183 |     | 
  2184 |     |     function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {
  2185 |     |         bytes32 m0;
  2186 |     |         bytes32 m1;
  2187 |     |         bytes32 m2;
  2188 |     |         bytes32 m3;
  2189 |     |         bytes32 m4;
  2190 |     |         bytes32 m5;
  2191 |     |         /// @solidity memory-safe-assembly
  2192 |     |         assembly {
  2193 |     |             function writeString(pos, w) {
  2194 |     |                 let length := 0
  2195 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2196 |     |                 mstore(pos, length)
  2197 |     |                 let shift := sub(256, shl(3, length))
  2198 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2199 |     |             }
  2200 |     |             m0 := mload(0x00)
  2201 |     |             m1 := mload(0x20)
  2202 |     |             m2 := mload(0x40)
  2203 |     |             m3 := mload(0x60)
  2204 |     |             m4 := mload(0x80)
  2205 |     |             m5 := mload(0xa0)
  2206 |     |             // Selector of `log(uint256,string,uint256)`.
  2207 |     |             mstore(0x00, 0x37aa7d4c)
  2208 |     |             mstore(0x20, p0)
  2209 |     |             mstore(0x40, 0x60)
  2210 |     |             mstore(0x60, p2)
  2211 |     |             writeString(0x80, p1)
  2212 |     |         }
  2213 |     |         _sendLogPayload(0x1c, 0xa4);
  2214 |     |         /// @solidity memory-safe-assembly
  2215 |     |         assembly {
  2216 |     |             mstore(0x00, m0)
  2217 |     |             mstore(0x20, m1)
  2218 |     |             mstore(0x40, m2)
  2219 |     |             mstore(0x60, m3)
  2220 |     |             mstore(0x80, m4)
  2221 |     |             mstore(0xa0, m5)
  2222 |     |         }
  2223 |     |     }
  2224 |     | 
  2225 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {
  2226 |     |         bytes32 m0;
  2227 |     |         bytes32 m1;
  2228 |     |         bytes32 m2;
  2229 |     |         bytes32 m3;
  2230 |     |         bytes32 m4;
  2231 |     |         bytes32 m5;
  2232 |     |         bytes32 m6;
  2233 |     |         bytes32 m7;
  2234 |     |         /// @solidity memory-safe-assembly
  2235 |     |         assembly {
  2236 |     |             function writeString(pos, w) {
  2237 |     |                 let length := 0
  2238 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2239 |     |                 mstore(pos, length)
  2240 |     |                 let shift := sub(256, shl(3, length))
  2241 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2242 |     |             }
  2243 |     |             m0 := mload(0x00)
  2244 |     |             m1 := mload(0x20)
  2245 |     |             m2 := mload(0x40)
  2246 |     |             m3 := mload(0x60)
  2247 |     |             m4 := mload(0x80)
  2248 |     |             m5 := mload(0xa0)
  2249 |     |             m6 := mload(0xc0)
  2250 |     |             m7 := mload(0xe0)
  2251 |     |             // Selector of `log(uint256,string,string)`.
  2252 |     |             mstore(0x00, 0xb115611f)
  2253 |     |             mstore(0x20, p0)
  2254 |     |             mstore(0x40, 0x60)
  2255 |     |             mstore(0x60, 0xa0)
  2256 |     |             writeString(0x80, p1)
  2257 |     |             writeString(0xc0, p2)
  2258 |     |         }
  2259 |     |         _sendLogPayload(0x1c, 0xe4);
  2260 |     |         /// @solidity memory-safe-assembly
  2261 |     |         assembly {
  2262 |     |             mstore(0x00, m0)
  2263 |     |             mstore(0x20, m1)
  2264 |     |             mstore(0x40, m2)
  2265 |     |             mstore(0x60, m3)
  2266 |     |             mstore(0x80, m4)
  2267 |     |             mstore(0xa0, m5)
  2268 |     |             mstore(0xc0, m6)
  2269 |     |             mstore(0xe0, m7)
  2270 |     |         }
  2271 |     |     }
  2272 |     | 
  2273 |     |     function log(bytes32 p0, address p1, address p2) internal pure {
  2274 |     |         bytes32 m0;
  2275 |     |         bytes32 m1;
  2276 |     |         bytes32 m2;
  2277 |     |         bytes32 m3;
  2278 |     |         bytes32 m4;
  2279 |     |         bytes32 m5;
  2280 |     |         /// @solidity memory-safe-assembly
  2281 |     |         assembly {
  2282 |     |             function writeString(pos, w) {
  2283 |     |                 let length := 0
  2284 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2285 |     |                 mstore(pos, length)
  2286 |     |                 let shift := sub(256, shl(3, length))
  2287 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2288 |     |             }
  2289 |     |             m0 := mload(0x00)
  2290 |     |             m1 := mload(0x20)
  2291 |     |             m2 := mload(0x40)
  2292 |     |             m3 := mload(0x60)
  2293 |     |             m4 := mload(0x80)
  2294 |     |             m5 := mload(0xa0)
  2295 |     |             // Selector of `log(string,address,address)`.
  2296 |     |             mstore(0x00, 0xfcec75e0)
  2297 |     |             mstore(0x20, 0x60)
  2298 |     |             mstore(0x40, p1)
  2299 |     |             mstore(0x60, p2)
  2300 |     |             writeString(0x80, p0)
  2301 |     |         }
  2302 |     |         _sendLogPayload(0x1c, 0xa4);
  2303 |     |         /// @solidity memory-safe-assembly
  2304 |     |         assembly {
  2305 |     |             mstore(0x00, m0)
  2306 |     |             mstore(0x20, m1)
  2307 |     |             mstore(0x40, m2)
  2308 |     |             mstore(0x60, m3)
  2309 |     |             mstore(0x80, m4)
  2310 |     |             mstore(0xa0, m5)
  2311 |     |         }
  2312 |     |     }
  2313 |     | 
  2314 |     |     function log(bytes32 p0, address p1, bool p2) internal pure {
  2315 |     |         bytes32 m0;
  2316 |     |         bytes32 m1;
  2317 |     |         bytes32 m2;
  2318 |     |         bytes32 m3;
  2319 |     |         bytes32 m4;
  2320 |     |         bytes32 m5;
  2321 |     |         /// @solidity memory-safe-assembly
  2322 |     |         assembly {
  2323 |     |             function writeString(pos, w) {
  2324 |     |                 let length := 0
  2325 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2326 |     |                 mstore(pos, length)
  2327 |     |                 let shift := sub(256, shl(3, length))
  2328 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2329 |     |             }
  2330 |     |             m0 := mload(0x00)
  2331 |     |             m1 := mload(0x20)
  2332 |     |             m2 := mload(0x40)
  2333 |     |             m3 := mload(0x60)
  2334 |     |             m4 := mload(0x80)
  2335 |     |             m5 := mload(0xa0)
  2336 |     |             // Selector of `log(string,address,bool)`.
  2337 |     |             mstore(0x00, 0xc91d5ed4)
  2338 |     |             mstore(0x20, 0x60)
  2339 |     |             mstore(0x40, p1)
  2340 |     |             mstore(0x60, p2)
  2341 |     |             writeString(0x80, p0)
  2342 |     |         }
  2343 |     |         _sendLogPayload(0x1c, 0xa4);
  2344 |     |         /// @solidity memory-safe-assembly
  2345 |     |         assembly {
  2346 |     |             mstore(0x00, m0)
  2347 |     |             mstore(0x20, m1)
  2348 |     |             mstore(0x40, m2)
  2349 |     |             mstore(0x60, m3)
  2350 |     |             mstore(0x80, m4)
  2351 |     |             mstore(0xa0, m5)
  2352 |     |         }
  2353 |     |     }
  2354 |     | 
  2355 |     |     function log(bytes32 p0, address p1, uint256 p2) internal pure {
  2356 |     |         bytes32 m0;
  2357 |     |         bytes32 m1;
  2358 |     |         bytes32 m2;
  2359 |     |         bytes32 m3;
  2360 |     |         bytes32 m4;
  2361 |     |         bytes32 m5;
  2362 |     |         /// @solidity memory-safe-assembly
  2363 |     |         assembly {
  2364 |     |             function writeString(pos, w) {
  2365 |     |                 let length := 0
  2366 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2367 |     |                 mstore(pos, length)
  2368 |     |                 let shift := sub(256, shl(3, length))
  2369 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2370 |     |             }
  2371 |     |             m0 := mload(0x00)
  2372 |     |             m1 := mload(0x20)
  2373 |     |             m2 := mload(0x40)
  2374 |     |             m3 := mload(0x60)
  2375 |     |             m4 := mload(0x80)
  2376 |     |             m5 := mload(0xa0)
  2377 |     |             // Selector of `log(string,address,uint256)`.
  2378 |     |             mstore(0x00, 0x0d26b925)
  2379 |     |             mstore(0x20, 0x60)
  2380 |     |             mstore(0x40, p1)
  2381 |     |             mstore(0x60, p2)
  2382 |     |             writeString(0x80, p0)
  2383 |     |         }
  2384 |     |         _sendLogPayload(0x1c, 0xa4);
  2385 |     |         /// @solidity memory-safe-assembly
  2386 |     |         assembly {
  2387 |     |             mstore(0x00, m0)
  2388 |     |             mstore(0x20, m1)
  2389 |     |             mstore(0x40, m2)
  2390 |     |             mstore(0x60, m3)
  2391 |     |             mstore(0x80, m4)
  2392 |     |             mstore(0xa0, m5)
  2393 |     |         }
  2394 |     |     }
  2395 |     | 
  2396 |     |     function log(bytes32 p0, address p1, bytes32 p2) internal pure {
  2397 |     |         bytes32 m0;
  2398 |     |         bytes32 m1;
  2399 |     |         bytes32 m2;
  2400 |     |         bytes32 m3;
  2401 |     |         bytes32 m4;
  2402 |     |         bytes32 m5;
  2403 |     |         bytes32 m6;
  2404 |     |         bytes32 m7;
  2405 |     |         /// @solidity memory-safe-assembly
  2406 |     |         assembly {
  2407 |     |             function writeString(pos, w) {
  2408 |     |                 let length := 0
  2409 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2410 |     |                 mstore(pos, length)
  2411 |     |                 let shift := sub(256, shl(3, length))
  2412 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2413 |     |             }
  2414 |     |             m0 := mload(0x00)
  2415 |     |             m1 := mload(0x20)
  2416 |     |             m2 := mload(0x40)
  2417 |     |             m3 := mload(0x60)
  2418 |     |             m4 := mload(0x80)
  2419 |     |             m5 := mload(0xa0)
  2420 |     |             m6 := mload(0xc0)
  2421 |     |             m7 := mload(0xe0)
  2422 |     |             // Selector of `log(string,address,string)`.
  2423 |     |             mstore(0x00, 0xe0e9ad4f)
  2424 |     |             mstore(0x20, 0x60)
  2425 |     |             mstore(0x40, p1)
  2426 |     |             mstore(0x60, 0xa0)
  2427 |     |             writeString(0x80, p0)
  2428 |     |             writeString(0xc0, p2)
  2429 |     |         }
  2430 |     |         _sendLogPayload(0x1c, 0xe4);
  2431 |     |         /// @solidity memory-safe-assembly
  2432 |     |         assembly {
  2433 |     |             mstore(0x00, m0)
  2434 |     |             mstore(0x20, m1)
  2435 |     |             mstore(0x40, m2)
  2436 |     |             mstore(0x60, m3)
  2437 |     |             mstore(0x80, m4)
  2438 |     |             mstore(0xa0, m5)
  2439 |     |             mstore(0xc0, m6)
  2440 |     |             mstore(0xe0, m7)
  2441 |     |         }
  2442 |     |     }
  2443 |     | 
  2444 |     |     function log(bytes32 p0, bool p1, address p2) internal pure {
  2445 |     |         bytes32 m0;
  2446 |     |         bytes32 m1;
  2447 |     |         bytes32 m2;
  2448 |     |         bytes32 m3;
  2449 |     |         bytes32 m4;
  2450 |     |         bytes32 m5;
  2451 |     |         /// @solidity memory-safe-assembly
  2452 |     |         assembly {
  2453 |     |             function writeString(pos, w) {
  2454 |     |                 let length := 0
  2455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2456 |     |                 mstore(pos, length)
  2457 |     |                 let shift := sub(256, shl(3, length))
  2458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2459 |     |             }
  2460 |     |             m0 := mload(0x00)
  2461 |     |             m1 := mload(0x20)
  2462 |     |             m2 := mload(0x40)
  2463 |     |             m3 := mload(0x60)
  2464 |     |             m4 := mload(0x80)
  2465 |     |             m5 := mload(0xa0)
  2466 |     |             // Selector of `log(string,bool,address)`.
  2467 |     |             mstore(0x00, 0x932bbb38)
  2468 |     |             mstore(0x20, 0x60)
  2469 |     |             mstore(0x40, p1)
  2470 |     |             mstore(0x60, p2)
  2471 |     |             writeString(0x80, p0)
  2472 |     |         }
  2473 |     |         _sendLogPayload(0x1c, 0xa4);
  2474 |     |         /// @solidity memory-safe-assembly
  2475 |     |         assembly {
  2476 |     |             mstore(0x00, m0)
  2477 |     |             mstore(0x20, m1)
  2478 |     |             mstore(0x40, m2)
  2479 |     |             mstore(0x60, m3)
  2480 |     |             mstore(0x80, m4)
  2481 |     |             mstore(0xa0, m5)
  2482 |     |         }
  2483 |     |     }
  2484 |     | 
  2485 |     |     function log(bytes32 p0, bool p1, bool p2) internal pure {
  2486 |     |         bytes32 m0;
  2487 |     |         bytes32 m1;
  2488 |     |         bytes32 m2;
  2489 |     |         bytes32 m3;
  2490 |     |         bytes32 m4;
  2491 |     |         bytes32 m5;
  2492 |     |         /// @solidity memory-safe-assembly
  2493 |     |         assembly {
  2494 |     |             function writeString(pos, w) {
  2495 |     |                 let length := 0
  2496 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2497 |     |                 mstore(pos, length)
  2498 |     |                 let shift := sub(256, shl(3, length))
  2499 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2500 |     |             }
  2501 |     |             m0 := mload(0x00)
  2502 |     |             m1 := mload(0x20)
  2503 |     |             m2 := mload(0x40)
  2504 |     |             m3 := mload(0x60)
  2505 |     |             m4 := mload(0x80)
  2506 |     |             m5 := mload(0xa0)
  2507 |     |             // Selector of `log(string,bool,bool)`.
  2508 |     |             mstore(0x00, 0x850b7ad6)
  2509 |     |             mstore(0x20, 0x60)
  2510 |     |             mstore(0x40, p1)
  2511 |     |             mstore(0x60, p2)
  2512 |     |             writeString(0x80, p0)
  2513 |     |         }
  2514 |     |         _sendLogPayload(0x1c, 0xa4);
  2515 |     |         /// @solidity memory-safe-assembly
  2516 |     |         assembly {
  2517 |     |             mstore(0x00, m0)
  2518 |     |             mstore(0x20, m1)
  2519 |     |             mstore(0x40, m2)
  2520 |     |             mstore(0x60, m3)
  2521 |     |             mstore(0x80, m4)
  2522 |     |             mstore(0xa0, m5)
  2523 |     |         }
  2524 |     |     }
  2525 |     | 
  2526 |     |     function log(bytes32 p0, bool p1, uint256 p2) internal pure {
  2527 |     |         bytes32 m0;
  2528 |     |         bytes32 m1;
  2529 |     |         bytes32 m2;
  2530 |     |         bytes32 m3;
  2531 |     |         bytes32 m4;
  2532 |     |         bytes32 m5;
  2533 |     |         /// @solidity memory-safe-assembly
  2534 |     |         assembly {
  2535 |     |             function writeString(pos, w) {
  2536 |     |                 let length := 0
  2537 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2538 |     |                 mstore(pos, length)
  2539 |     |                 let shift := sub(256, shl(3, length))
  2540 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2541 |     |             }
  2542 |     |             m0 := mload(0x00)
  2543 |     |             m1 := mload(0x20)
  2544 |     |             m2 := mload(0x40)
  2545 |     |             m3 := mload(0x60)
  2546 |     |             m4 := mload(0x80)
  2547 |     |             m5 := mload(0xa0)
  2548 |     |             // Selector of `log(string,bool,uint256)`.
  2549 |     |             mstore(0x00, 0xc95958d6)
  2550 |     |             mstore(0x20, 0x60)
  2551 |     |             mstore(0x40, p1)
  2552 |     |             mstore(0x60, p2)
  2553 |     |             writeString(0x80, p0)
  2554 |     |         }
  2555 |     |         _sendLogPayload(0x1c, 0xa4);
  2556 |     |         /// @solidity memory-safe-assembly
  2557 |     |         assembly {
  2558 |     |             mstore(0x00, m0)
  2559 |     |             mstore(0x20, m1)
  2560 |     |             mstore(0x40, m2)
  2561 |     |             mstore(0x60, m3)
  2562 |     |             mstore(0x80, m4)
  2563 |     |             mstore(0xa0, m5)
  2564 |     |         }
  2565 |     |     }
  2566 |     | 
  2567 |     |     function log(bytes32 p0, bool p1, bytes32 p2) internal pure {
  2568 |     |         bytes32 m0;
  2569 |     |         bytes32 m1;
  2570 |     |         bytes32 m2;
  2571 |     |         bytes32 m3;
  2572 |     |         bytes32 m4;
  2573 |     |         bytes32 m5;
  2574 |     |         bytes32 m6;
  2575 |     |         bytes32 m7;
  2576 |     |         /// @solidity memory-safe-assembly
  2577 |     |         assembly {
  2578 |     |             function writeString(pos, w) {
  2579 |     |                 let length := 0
  2580 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2581 |     |                 mstore(pos, length)
  2582 |     |                 let shift := sub(256, shl(3, length))
  2583 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2584 |     |             }
  2585 |     |             m0 := mload(0x00)
  2586 |     |             m1 := mload(0x20)
  2587 |     |             m2 := mload(0x40)
  2588 |     |             m3 := mload(0x60)
  2589 |     |             m4 := mload(0x80)
  2590 |     |             m5 := mload(0xa0)
  2591 |     |             m6 := mload(0xc0)
  2592 |     |             m7 := mload(0xe0)
  2593 |     |             // Selector of `log(string,bool,string)`.
  2594 |     |             mstore(0x00, 0xe298f47d)
  2595 |     |             mstore(0x20, 0x60)
  2596 |     |             mstore(0x40, p1)
  2597 |     |             mstore(0x60, 0xa0)
  2598 |     |             writeString(0x80, p0)
  2599 |     |             writeString(0xc0, p2)
  2600 |     |         }
  2601 |     |         _sendLogPayload(0x1c, 0xe4);
  2602 |     |         /// @solidity memory-safe-assembly
  2603 |     |         assembly {
  2604 |     |             mstore(0x00, m0)
  2605 |     |             mstore(0x20, m1)
  2606 |     |             mstore(0x40, m2)
  2607 |     |             mstore(0x60, m3)
  2608 |     |             mstore(0x80, m4)
  2609 |     |             mstore(0xa0, m5)
  2610 |     |             mstore(0xc0, m6)
  2611 |     |             mstore(0xe0, m7)
  2612 |     |         }
  2613 |     |     }
  2614 |     | 
  2615 |     |     function log(bytes32 p0, uint256 p1, address p2) internal pure {
  2616 |     |         bytes32 m0;
  2617 |     |         bytes32 m1;
  2618 |     |         bytes32 m2;
  2619 |     |         bytes32 m3;
  2620 |     |         bytes32 m4;
  2621 |     |         bytes32 m5;
  2622 |     |         /// @solidity memory-safe-assembly
  2623 |     |         assembly {
  2624 |     |             function writeString(pos, w) {
  2625 |     |                 let length := 0
  2626 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2627 |     |                 mstore(pos, length)
  2628 |     |                 let shift := sub(256, shl(3, length))
  2629 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2630 |     |             }
  2631 |     |             m0 := mload(0x00)
  2632 |     |             m1 := mload(0x20)
  2633 |     |             m2 := mload(0x40)
  2634 |     |             m3 := mload(0x60)
  2635 |     |             m4 := mload(0x80)
  2636 |     |             m5 := mload(0xa0)
  2637 |     |             // Selector of `log(string,uint256,address)`.
  2638 |     |             mstore(0x00, 0x1c7ec448)
  2639 |     |             mstore(0x20, 0x60)
  2640 |     |             mstore(0x40, p1)
  2641 |     |             mstore(0x60, p2)
  2642 |     |             writeString(0x80, p0)
  2643 |     |         }
  2644 |     |         _sendLogPayload(0x1c, 0xa4);
  2645 |     |         /// @solidity memory-safe-assembly
  2646 |     |         assembly {
  2647 |     |             mstore(0x00, m0)
  2648 |     |             mstore(0x20, m1)
  2649 |     |             mstore(0x40, m2)
  2650 |     |             mstore(0x60, m3)
  2651 |     |             mstore(0x80, m4)
  2652 |     |             mstore(0xa0, m5)
  2653 |     |         }
  2654 |     |     }
  2655 |     | 
  2656 |     |     function log(bytes32 p0, uint256 p1, bool p2) internal pure {
  2657 |     |         bytes32 m0;
  2658 |     |         bytes32 m1;
  2659 |     |         bytes32 m2;
  2660 |     |         bytes32 m3;
  2661 |     |         bytes32 m4;
  2662 |     |         bytes32 m5;
  2663 |     |         /// @solidity memory-safe-assembly
  2664 |     |         assembly {
  2665 |     |             function writeString(pos, w) {
  2666 |     |                 let length := 0
  2667 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2668 |     |                 mstore(pos, length)
  2669 |     |                 let shift := sub(256, shl(3, length))
  2670 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2671 |     |             }
  2672 |     |             m0 := mload(0x00)
  2673 |     |             m1 := mload(0x20)
  2674 |     |             m2 := mload(0x40)
  2675 |     |             m3 := mload(0x60)
  2676 |     |             m4 := mload(0x80)
  2677 |     |             m5 := mload(0xa0)
  2678 |     |             // Selector of `log(string,uint256,bool)`.
  2679 |     |             mstore(0x00, 0xca7733b1)
  2680 |     |             mstore(0x20, 0x60)
  2681 |     |             mstore(0x40, p1)
  2682 |     |             mstore(0x60, p2)
  2683 |     |             writeString(0x80, p0)
  2684 |     |         }
  2685 |     |         _sendLogPayload(0x1c, 0xa4);
  2686 |     |         /// @solidity memory-safe-assembly
  2687 |     |         assembly {
  2688 |     |             mstore(0x00, m0)
  2689 |     |             mstore(0x20, m1)
  2690 |     |             mstore(0x40, m2)
  2691 |     |             mstore(0x60, m3)
  2692 |     |             mstore(0x80, m4)
  2693 |     |             mstore(0xa0, m5)
  2694 |     |         }
  2695 |     |     }
  2696 |     | 
  2697 |     |     function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {
  2698 |     |         bytes32 m0;
  2699 |     |         bytes32 m1;
  2700 |     |         bytes32 m2;
  2701 |     |         bytes32 m3;
  2702 |     |         bytes32 m4;
  2703 |     |         bytes32 m5;
  2704 |     |         /// @solidity memory-safe-assembly
  2705 |     |         assembly {
  2706 |     |             function writeString(pos, w) {
  2707 |     |                 let length := 0
  2708 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2709 |     |                 mstore(pos, length)
  2710 |     |                 let shift := sub(256, shl(3, length))
  2711 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2712 |     |             }
  2713 |     |             m0 := mload(0x00)
  2714 |     |             m1 := mload(0x20)
  2715 |     |             m2 := mload(0x40)
  2716 |     |             m3 := mload(0x60)
  2717 |     |             m4 := mload(0x80)
  2718 |     |             m5 := mload(0xa0)
  2719 |     |             // Selector of `log(string,uint256,uint256)`.
  2720 |     |             mstore(0x00, 0xca47c4eb)
  2721 |     |             mstore(0x20, 0x60)
  2722 |     |             mstore(0x40, p1)
  2723 |     |             mstore(0x60, p2)
  2724 |     |             writeString(0x80, p0)
  2725 |     |         }
  2726 |     |         _sendLogPayload(0x1c, 0xa4);
  2727 |     |         /// @solidity memory-safe-assembly
  2728 |     |         assembly {
  2729 |     |             mstore(0x00, m0)
  2730 |     |             mstore(0x20, m1)
  2731 |     |             mstore(0x40, m2)
  2732 |     |             mstore(0x60, m3)
  2733 |     |             mstore(0x80, m4)
  2734 |     |             mstore(0xa0, m5)
  2735 |     |         }
  2736 |     |     }
  2737 |     | 
  2738 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {
  2739 |     |         bytes32 m0;
  2740 |     |         bytes32 m1;
  2741 |     |         bytes32 m2;
  2742 |     |         bytes32 m3;
  2743 |     |         bytes32 m4;
  2744 |     |         bytes32 m5;
  2745 |     |         bytes32 m6;
  2746 |     |         bytes32 m7;
  2747 |     |         /// @solidity memory-safe-assembly
  2748 |     |         assembly {
  2749 |     |             function writeString(pos, w) {
  2750 |     |                 let length := 0
  2751 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2752 |     |                 mstore(pos, length)
  2753 |     |                 let shift := sub(256, shl(3, length))
  2754 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2755 |     |             }
  2756 |     |             m0 := mload(0x00)
  2757 |     |             m1 := mload(0x20)
  2758 |     |             m2 := mload(0x40)
  2759 |     |             m3 := mload(0x60)
  2760 |     |             m4 := mload(0x80)
  2761 |     |             m5 := mload(0xa0)
  2762 |     |             m6 := mload(0xc0)
  2763 |     |             m7 := mload(0xe0)
  2764 |     |             // Selector of `log(string,uint256,string)`.
  2765 |     |             mstore(0x00, 0x5970e089)
  2766 |     |             mstore(0x20, 0x60)
  2767 |     |             mstore(0x40, p1)
  2768 |     |             mstore(0x60, 0xa0)
  2769 |     |             writeString(0x80, p0)
  2770 |     |             writeString(0xc0, p2)
  2771 |     |         }
  2772 |     |         _sendLogPayload(0x1c, 0xe4);
  2773 |     |         /// @solidity memory-safe-assembly
  2774 |     |         assembly {
  2775 |     |             mstore(0x00, m0)
  2776 |     |             mstore(0x20, m1)
  2777 |     |             mstore(0x40, m2)
  2778 |     |             mstore(0x60, m3)
  2779 |     |             mstore(0x80, m4)
  2780 |     |             mstore(0xa0, m5)
  2781 |     |             mstore(0xc0, m6)
  2782 |     |             mstore(0xe0, m7)
  2783 |     |         }
  2784 |     |     }
  2785 |     | 
  2786 |     |     function log(bytes32 p0, bytes32 p1, address p2) internal pure {
  2787 |     |         bytes32 m0;
  2788 |     |         bytes32 m1;
  2789 |     |         bytes32 m2;
  2790 |     |         bytes32 m3;
  2791 |     |         bytes32 m4;
  2792 |     |         bytes32 m5;
  2793 |     |         bytes32 m6;
  2794 |     |         bytes32 m7;
  2795 |     |         /// @solidity memory-safe-assembly
  2796 |     |         assembly {
  2797 |     |             function writeString(pos, w) {
  2798 |     |                 let length := 0
  2799 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2800 |     |                 mstore(pos, length)
  2801 |     |                 let shift := sub(256, shl(3, length))
  2802 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2803 |     |             }
  2804 |     |             m0 := mload(0x00)
  2805 |     |             m1 := mload(0x20)
  2806 |     |             m2 := mload(0x40)
  2807 |     |             m3 := mload(0x60)
  2808 |     |             m4 := mload(0x80)
  2809 |     |             m5 := mload(0xa0)
  2810 |     |             m6 := mload(0xc0)
  2811 |     |             m7 := mload(0xe0)
  2812 |     |             // Selector of `log(string,string,address)`.
  2813 |     |             mstore(0x00, 0x95ed0195)
  2814 |     |             mstore(0x20, 0x60)
  2815 |     |             mstore(0x40, 0xa0)
  2816 |     |             mstore(0x60, p2)
  2817 |     |             writeString(0x80, p0)
  2818 |     |             writeString(0xc0, p1)
  2819 |     |         }
  2820 |     |         _sendLogPayload(0x1c, 0xe4);
  2821 |     |         /// @solidity memory-safe-assembly
  2822 |     |         assembly {
  2823 |     |             mstore(0x00, m0)
  2824 |     |             mstore(0x20, m1)
  2825 |     |             mstore(0x40, m2)
  2826 |     |             mstore(0x60, m3)
  2827 |     |             mstore(0x80, m4)
  2828 |     |             mstore(0xa0, m5)
  2829 |     |             mstore(0xc0, m6)
  2830 |     |             mstore(0xe0, m7)
  2831 |     |         }
  2832 |     |     }
  2833 |     | 
  2834 |     |     function log(bytes32 p0, bytes32 p1, bool p2) internal pure {
  2835 |     |         bytes32 m0;
  2836 |     |         bytes32 m1;
  2837 |     |         bytes32 m2;
  2838 |     |         bytes32 m3;
  2839 |     |         bytes32 m4;
  2840 |     |         bytes32 m5;
  2841 |     |         bytes32 m6;
  2842 |     |         bytes32 m7;
  2843 |     |         /// @solidity memory-safe-assembly
  2844 |     |         assembly {
  2845 |     |             function writeString(pos, w) {
  2846 |     |                 let length := 0
  2847 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2848 |     |                 mstore(pos, length)
  2849 |     |                 let shift := sub(256, shl(3, length))
  2850 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2851 |     |             }
  2852 |     |             m0 := mload(0x00)
  2853 |     |             m1 := mload(0x20)
  2854 |     |             m2 := mload(0x40)
  2855 |     |             m3 := mload(0x60)
  2856 |     |             m4 := mload(0x80)
  2857 |     |             m5 := mload(0xa0)
  2858 |     |             m6 := mload(0xc0)
  2859 |     |             m7 := mload(0xe0)
  2860 |     |             // Selector of `log(string,string,bool)`.
  2861 |     |             mstore(0x00, 0xb0e0f9b5)
  2862 |     |             mstore(0x20, 0x60)
  2863 |     |             mstore(0x40, 0xa0)
  2864 |     |             mstore(0x60, p2)
  2865 |     |             writeString(0x80, p0)
  2866 |     |             writeString(0xc0, p1)
  2867 |     |         }
  2868 |     |         _sendLogPayload(0x1c, 0xe4);
  2869 |     |         /// @solidity memory-safe-assembly
  2870 |     |         assembly {
  2871 |     |             mstore(0x00, m0)
  2872 |     |             mstore(0x20, m1)
  2873 |     |             mstore(0x40, m2)
  2874 |     |             mstore(0x60, m3)
  2875 |     |             mstore(0x80, m4)
  2876 |     |             mstore(0xa0, m5)
  2877 |     |             mstore(0xc0, m6)
  2878 |     |             mstore(0xe0, m7)
  2879 |     |         }
  2880 |     |     }
  2881 |     | 
  2882 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {
  2883 |     |         bytes32 m0;
  2884 |     |         bytes32 m1;
  2885 |     |         bytes32 m2;
  2886 |     |         bytes32 m3;
  2887 |     |         bytes32 m4;
  2888 |     |         bytes32 m5;
  2889 |     |         bytes32 m6;
  2890 |     |         bytes32 m7;
  2891 |     |         /// @solidity memory-safe-assembly
  2892 |     |         assembly {
  2893 |     |             function writeString(pos, w) {
  2894 |     |                 let length := 0
  2895 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2896 |     |                 mstore(pos, length)
  2897 |     |                 let shift := sub(256, shl(3, length))
  2898 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2899 |     |             }
  2900 |     |             m0 := mload(0x00)
  2901 |     |             m1 := mload(0x20)
  2902 |     |             m2 := mload(0x40)
  2903 |     |             m3 := mload(0x60)
  2904 |     |             m4 := mload(0x80)
  2905 |     |             m5 := mload(0xa0)
  2906 |     |             m6 := mload(0xc0)
  2907 |     |             m7 := mload(0xe0)
  2908 |     |             // Selector of `log(string,string,uint256)`.
  2909 |     |             mstore(0x00, 0x5821efa1)
  2910 |     |             mstore(0x20, 0x60)
  2911 |     |             mstore(0x40, 0xa0)
  2912 |     |             mstore(0x60, p2)
  2913 |     |             writeString(0x80, p0)
  2914 |     |             writeString(0xc0, p1)
  2915 |     |         }
  2916 |     |         _sendLogPayload(0x1c, 0xe4);
  2917 |     |         /// @solidity memory-safe-assembly
  2918 |     |         assembly {
  2919 |     |             mstore(0x00, m0)
  2920 |     |             mstore(0x20, m1)
  2921 |     |             mstore(0x40, m2)
  2922 |     |             mstore(0x60, m3)
  2923 |     |             mstore(0x80, m4)
  2924 |     |             mstore(0xa0, m5)
  2925 |     |             mstore(0xc0, m6)
  2926 |     |             mstore(0xe0, m7)
  2927 |     |         }
  2928 |     |     }
  2929 |     | 
  2930 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {
  2931 |     |         bytes32 m0;
  2932 |     |         bytes32 m1;
  2933 |     |         bytes32 m2;
  2934 |     |         bytes32 m3;
  2935 |     |         bytes32 m4;
  2936 |     |         bytes32 m5;
  2937 |     |         bytes32 m6;
  2938 |     |         bytes32 m7;
  2939 |     |         bytes32 m8;
  2940 |     |         bytes32 m9;
  2941 |     |         /// @solidity memory-safe-assembly
  2942 |     |         assembly {
  2943 |     |             function writeString(pos, w) {
  2944 |     |                 let length := 0
  2945 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2946 |     |                 mstore(pos, length)
  2947 |     |                 let shift := sub(256, shl(3, length))
  2948 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2949 |     |             }
  2950 |     |             m0 := mload(0x00)
  2951 |     |             m1 := mload(0x20)
  2952 |     |             m2 := mload(0x40)
  2953 |     |             m3 := mload(0x60)
  2954 |     |             m4 := mload(0x80)
  2955 |     |             m5 := mload(0xa0)
  2956 |     |             m6 := mload(0xc0)
  2957 |     |             m7 := mload(0xe0)
  2958 |     |             m8 := mload(0x100)
  2959 |     |             m9 := mload(0x120)
  2960 |     |             // Selector of `log(string,string,string)`.
  2961 |     |             mstore(0x00, 0x2ced7cef)
  2962 |     |             mstore(0x20, 0x60)
  2963 |     |             mstore(0x40, 0xa0)
  2964 |     |             mstore(0x60, 0xe0)
  2965 |     |             writeString(0x80, p0)
  2966 |     |             writeString(0xc0, p1)
  2967 |     |             writeString(0x100, p2)
  2968 |     |         }
  2969 |     |         _sendLogPayload(0x1c, 0x124);
  2970 |     |         /// @solidity memory-safe-assembly
  2971 |     |         assembly {
  2972 |     |             mstore(0x00, m0)
  2973 |     |             mstore(0x20, m1)
  2974 |     |             mstore(0x40, m2)
  2975 |     |             mstore(0x60, m3)
  2976 |     |             mstore(0x80, m4)
  2977 |     |             mstore(0xa0, m5)
  2978 |     |             mstore(0xc0, m6)
  2979 |     |             mstore(0xe0, m7)
  2980 |     |             mstore(0x100, m8)
  2981 |     |             mstore(0x120, m9)
  2982 |     |         }
  2983 |     |     }
  2984 |     | 
  2985 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
  2986 |     |         bytes32 m0;
  2987 |     |         bytes32 m1;
  2988 |     |         bytes32 m2;
  2989 |     |         bytes32 m3;
  2990 |     |         bytes32 m4;
  2991 |     |         /// @solidity memory-safe-assembly
  2992 |     |         assembly {
  2993 |     |             m0 := mload(0x00)
  2994 |     |             m1 := mload(0x20)
  2995 |     |             m2 := mload(0x40)
  2996 |     |             m3 := mload(0x60)
  2997 |     |             m4 := mload(0x80)
  2998 |     |             // Selector of `log(address,address,address,address)`.
  2999 |     |             mstore(0x00, 0x665bf134)
  3000 |     |             mstore(0x20, p0)
  3001 |     |             mstore(0x40, p1)
  3002 |     |             mstore(0x60, p2)
  3003 |     |             mstore(0x80, p3)
  3004 |     |         }
  3005 |     |         _sendLogPayload(0x1c, 0x84);
  3006 |     |         /// @solidity memory-safe-assembly
  3007 |     |         assembly {
  3008 |     |             mstore(0x00, m0)
  3009 |     |             mstore(0x20, m1)
  3010 |     |             mstore(0x40, m2)
  3011 |     |             mstore(0x60, m3)
  3012 |     |             mstore(0x80, m4)
  3013 |     |         }
  3014 |     |     }
  3015 |     | 
  3016 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
  3017 |     |         bytes32 m0;
  3018 |     |         bytes32 m1;
  3019 |     |         bytes32 m2;
  3020 |     |         bytes32 m3;
  3021 |     |         bytes32 m4;
  3022 |     |         /// @solidity memory-safe-assembly
  3023 |     |         assembly {
  3024 |     |             m0 := mload(0x00)
  3025 |     |             m1 := mload(0x20)
  3026 |     |             m2 := mload(0x40)
  3027 |     |             m3 := mload(0x60)
  3028 |     |             m4 := mload(0x80)
  3029 |     |             // Selector of `log(address,address,address,bool)`.
  3030 |     |             mstore(0x00, 0x0e378994)
  3031 |     |             mstore(0x20, p0)
  3032 |     |             mstore(0x40, p1)
  3033 |     |             mstore(0x60, p2)
  3034 |     |             mstore(0x80, p3)
  3035 |     |         }
  3036 |     |         _sendLogPayload(0x1c, 0x84);
  3037 |     |         /// @solidity memory-safe-assembly
  3038 |     |         assembly {
  3039 |     |             mstore(0x00, m0)
  3040 |     |             mstore(0x20, m1)
  3041 |     |             mstore(0x40, m2)
  3042 |     |             mstore(0x60, m3)
  3043 |     |             mstore(0x80, m4)
  3044 |     |         }
  3045 |     |     }
  3046 |     | 
  3047 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
  3048 |     |         bytes32 m0;
  3049 |     |         bytes32 m1;
  3050 |     |         bytes32 m2;
  3051 |     |         bytes32 m3;
  3052 |     |         bytes32 m4;
  3053 |     |         /// @solidity memory-safe-assembly
  3054 |     |         assembly {
  3055 |     |             m0 := mload(0x00)
  3056 |     |             m1 := mload(0x20)
  3057 |     |             m2 := mload(0x40)
  3058 |     |             m3 := mload(0x60)
  3059 |     |             m4 := mload(0x80)
  3060 |     |             // Selector of `log(address,address,address,uint256)`.
  3061 |     |             mstore(0x00, 0x94250d77)
  3062 |     |             mstore(0x20, p0)
  3063 |     |             mstore(0x40, p1)
  3064 |     |             mstore(0x60, p2)
  3065 |     |             mstore(0x80, p3)
  3066 |     |         }
  3067 |     |         _sendLogPayload(0x1c, 0x84);
  3068 |     |         /// @solidity memory-safe-assembly
  3069 |     |         assembly {
  3070 |     |             mstore(0x00, m0)
  3071 |     |             mstore(0x20, m1)
  3072 |     |             mstore(0x40, m2)
  3073 |     |             mstore(0x60, m3)
  3074 |     |             mstore(0x80, m4)
  3075 |     |         }
  3076 |     |     }
  3077 |     | 
  3078 |     |     function log(address p0, address p1, address p2, bytes32 p3) internal pure {
  3079 |     |         bytes32 m0;
  3080 |     |         bytes32 m1;
  3081 |     |         bytes32 m2;
  3082 |     |         bytes32 m3;
  3083 |     |         bytes32 m4;
  3084 |     |         bytes32 m5;
  3085 |     |         bytes32 m6;
  3086 |     |         /// @solidity memory-safe-assembly
  3087 |     |         assembly {
  3088 |     |             function writeString(pos, w) {
  3089 |     |                 let length := 0
  3090 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3091 |     |                 mstore(pos, length)
  3092 |     |                 let shift := sub(256, shl(3, length))
  3093 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3094 |     |             }
  3095 |     |             m0 := mload(0x00)
  3096 |     |             m1 := mload(0x20)
  3097 |     |             m2 := mload(0x40)
  3098 |     |             m3 := mload(0x60)
  3099 |     |             m4 := mload(0x80)
  3100 |     |             m5 := mload(0xa0)
  3101 |     |             m6 := mload(0xc0)
  3102 |     |             // Selector of `log(address,address,address,string)`.
  3103 |     |             mstore(0x00, 0xf808da20)
  3104 |     |             mstore(0x20, p0)
  3105 |     |             mstore(0x40, p1)
  3106 |     |             mstore(0x60, p2)
  3107 |     |             mstore(0x80, 0x80)
  3108 |     |             writeString(0xa0, p3)
  3109 |     |         }
  3110 |     |         _sendLogPayload(0x1c, 0xc4);
  3111 |     |         /// @solidity memory-safe-assembly
  3112 |     |         assembly {
  3113 |     |             mstore(0x00, m0)
  3114 |     |             mstore(0x20, m1)
  3115 |     |             mstore(0x40, m2)
  3116 |     |             mstore(0x60, m3)
  3117 |     |             mstore(0x80, m4)
  3118 |     |             mstore(0xa0, m5)
  3119 |     |             mstore(0xc0, m6)
  3120 |     |         }
  3121 |     |     }
  3122 |     | 
  3123 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
  3124 |     |         bytes32 m0;
  3125 |     |         bytes32 m1;
  3126 |     |         bytes32 m2;
  3127 |     |         bytes32 m3;
  3128 |     |         bytes32 m4;
  3129 |     |         /// @solidity memory-safe-assembly
  3130 |     |         assembly {
  3131 |     |             m0 := mload(0x00)
  3132 |     |             m1 := mload(0x20)
  3133 |     |             m2 := mload(0x40)
  3134 |     |             m3 := mload(0x60)
  3135 |     |             m4 := mload(0x80)
  3136 |     |             // Selector of `log(address,address,bool,address)`.
  3137 |     |             mstore(0x00, 0x9f1bc36e)
  3138 |     |             mstore(0x20, p0)
  3139 |     |             mstore(0x40, p1)
  3140 |     |             mstore(0x60, p2)
  3141 |     |             mstore(0x80, p3)
  3142 |     |         }
  3143 |     |         _sendLogPayload(0x1c, 0x84);
  3144 |     |         /// @solidity memory-safe-assembly
  3145 |     |         assembly {
  3146 |     |             mstore(0x00, m0)
  3147 |     |             mstore(0x20, m1)
  3148 |     |             mstore(0x40, m2)
  3149 |     |             mstore(0x60, m3)
  3150 |     |             mstore(0x80, m4)
  3151 |     |         }
  3152 |     |     }
  3153 |     | 
  3154 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
  3155 |     |         bytes32 m0;
  3156 |     |         bytes32 m1;
  3157 |     |         bytes32 m2;
  3158 |     |         bytes32 m3;
  3159 |     |         bytes32 m4;
  3160 |     |         /// @solidity memory-safe-assembly
  3161 |     |         assembly {
  3162 |     |             m0 := mload(0x00)
  3163 |     |             m1 := mload(0x20)
  3164 |     |             m2 := mload(0x40)
  3165 |     |             m3 := mload(0x60)
  3166 |     |             m4 := mload(0x80)
  3167 |     |             // Selector of `log(address,address,bool,bool)`.
  3168 |     |             mstore(0x00, 0x2cd4134a)
  3169 |     |             mstore(0x20, p0)
  3170 |     |             mstore(0x40, p1)
  3171 |     |             mstore(0x60, p2)
  3172 |     |             mstore(0x80, p3)
  3173 |     |         }
  3174 |     |         _sendLogPayload(0x1c, 0x84);
  3175 |     |         /// @solidity memory-safe-assembly
  3176 |     |         assembly {
  3177 |     |             mstore(0x00, m0)
  3178 |     |             mstore(0x20, m1)
  3179 |     |             mstore(0x40, m2)
  3180 |     |             mstore(0x60, m3)
  3181 |     |             mstore(0x80, m4)
  3182 |     |         }
  3183 |     |     }
  3184 |     | 
  3185 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
  3186 |     |         bytes32 m0;
  3187 |     |         bytes32 m1;
  3188 |     |         bytes32 m2;
  3189 |     |         bytes32 m3;
  3190 |     |         bytes32 m4;
  3191 |     |         /// @solidity memory-safe-assembly
  3192 |     |         assembly {
  3193 |     |             m0 := mload(0x00)
  3194 |     |             m1 := mload(0x20)
  3195 |     |             m2 := mload(0x40)
  3196 |     |             m3 := mload(0x60)
  3197 |     |             m4 := mload(0x80)
  3198 |     |             // Selector of `log(address,address,bool,uint256)`.
  3199 |     |             mstore(0x00, 0x3971e78c)
  3200 |     |             mstore(0x20, p0)
  3201 |     |             mstore(0x40, p1)
  3202 |     |             mstore(0x60, p2)
  3203 |     |             mstore(0x80, p3)
  3204 |     |         }
  3205 |     |         _sendLogPayload(0x1c, 0x84);
  3206 |     |         /// @solidity memory-safe-assembly
  3207 |     |         assembly {
  3208 |     |             mstore(0x00, m0)
  3209 |     |             mstore(0x20, m1)
  3210 |     |             mstore(0x40, m2)
  3211 |     |             mstore(0x60, m3)
  3212 |     |             mstore(0x80, m4)
  3213 |     |         }
  3214 |     |     }
  3215 |     | 
  3216 |     |     function log(address p0, address p1, bool p2, bytes32 p3) internal pure {
  3217 |     |         bytes32 m0;
  3218 |     |         bytes32 m1;
  3219 |     |         bytes32 m2;
  3220 |     |         bytes32 m3;
  3221 |     |         bytes32 m4;
  3222 |     |         bytes32 m5;
  3223 |     |         bytes32 m6;
  3224 |     |         /// @solidity memory-safe-assembly
  3225 |     |         assembly {
  3226 |     |             function writeString(pos, w) {
  3227 |     |                 let length := 0
  3228 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3229 |     |                 mstore(pos, length)
  3230 |     |                 let shift := sub(256, shl(3, length))
  3231 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3232 |     |             }
  3233 |     |             m0 := mload(0x00)
  3234 |     |             m1 := mload(0x20)
  3235 |     |             m2 := mload(0x40)
  3236 |     |             m3 := mload(0x60)
  3237 |     |             m4 := mload(0x80)
  3238 |     |             m5 := mload(0xa0)
  3239 |     |             m6 := mload(0xc0)
  3240 |     |             // Selector of `log(address,address,bool,string)`.
  3241 |     |             mstore(0x00, 0xaa6540c8)
  3242 |     |             mstore(0x20, p0)
  3243 |     |             mstore(0x40, p1)
  3244 |     |             mstore(0x60, p2)
  3245 |     |             mstore(0x80, 0x80)
  3246 |     |             writeString(0xa0, p3)
  3247 |     |         }
  3248 |     |         _sendLogPayload(0x1c, 0xc4);
  3249 |     |         /// @solidity memory-safe-assembly
  3250 |     |         assembly {
  3251 |     |             mstore(0x00, m0)
  3252 |     |             mstore(0x20, m1)
  3253 |     |             mstore(0x40, m2)
  3254 |     |             mstore(0x60, m3)
  3255 |     |             mstore(0x80, m4)
  3256 |     |             mstore(0xa0, m5)
  3257 |     |             mstore(0xc0, m6)
  3258 |     |         }
  3259 |     |     }
  3260 |     | 
  3261 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
  3262 |     |         bytes32 m0;
  3263 |     |         bytes32 m1;
  3264 |     |         bytes32 m2;
  3265 |     |         bytes32 m3;
  3266 |     |         bytes32 m4;
  3267 |     |         /// @solidity memory-safe-assembly
  3268 |     |         assembly {
  3269 |     |             m0 := mload(0x00)
  3270 |     |             m1 := mload(0x20)
  3271 |     |             m2 := mload(0x40)
  3272 |     |             m3 := mload(0x60)
  3273 |     |             m4 := mload(0x80)
  3274 |     |             // Selector of `log(address,address,uint256,address)`.
  3275 |     |             mstore(0x00, 0x8da6def5)
  3276 |     |             mstore(0x20, p0)
  3277 |     |             mstore(0x40, p1)
  3278 |     |             mstore(0x60, p2)
  3279 |     |             mstore(0x80, p3)
  3280 |     |         }
  3281 |     |         _sendLogPayload(0x1c, 0x84);
  3282 |     |         /// @solidity memory-safe-assembly
  3283 |     |         assembly {
  3284 |     |             mstore(0x00, m0)
  3285 |     |             mstore(0x20, m1)
  3286 |     |             mstore(0x40, m2)
  3287 |     |             mstore(0x60, m3)
  3288 |     |             mstore(0x80, m4)
  3289 |     |         }
  3290 |     |     }
  3291 |     | 
  3292 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
  3293 |     |         bytes32 m0;
  3294 |     |         bytes32 m1;
  3295 |     |         bytes32 m2;
  3296 |     |         bytes32 m3;
  3297 |     |         bytes32 m4;
  3298 |     |         /// @solidity memory-safe-assembly
  3299 |     |         assembly {
  3300 |     |             m0 := mload(0x00)
  3301 |     |             m1 := mload(0x20)
  3302 |     |             m2 := mload(0x40)
  3303 |     |             m3 := mload(0x60)
  3304 |     |             m4 := mload(0x80)
  3305 |     |             // Selector of `log(address,address,uint256,bool)`.
  3306 |     |             mstore(0x00, 0x9b4254e2)
  3307 |     |             mstore(0x20, p0)
  3308 |     |             mstore(0x40, p1)
  3309 |     |             mstore(0x60, p2)
  3310 |     |             mstore(0x80, p3)
  3311 |     |         }
  3312 |     |         _sendLogPayload(0x1c, 0x84);
  3313 |     |         /// @solidity memory-safe-assembly
  3314 |     |         assembly {
  3315 |     |             mstore(0x00, m0)
  3316 |     |             mstore(0x20, m1)
  3317 |     |             mstore(0x40, m2)
  3318 |     |             mstore(0x60, m3)
  3319 |     |             mstore(0x80, m4)
  3320 |     |         }
  3321 |     |     }
  3322 |     | 
  3323 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
  3324 |     |         bytes32 m0;
  3325 |     |         bytes32 m1;
  3326 |     |         bytes32 m2;
  3327 |     |         bytes32 m3;
  3328 |     |         bytes32 m4;
  3329 |     |         /// @solidity memory-safe-assembly
  3330 |     |         assembly {
  3331 |     |             m0 := mload(0x00)
  3332 |     |             m1 := mload(0x20)
  3333 |     |             m2 := mload(0x40)
  3334 |     |             m3 := mload(0x60)
  3335 |     |             m4 := mload(0x80)
  3336 |     |             // Selector of `log(address,address,uint256,uint256)`.
  3337 |     |             mstore(0x00, 0xbe553481)
  3338 |     |             mstore(0x20, p0)
  3339 |     |             mstore(0x40, p1)
  3340 |     |             mstore(0x60, p2)
  3341 |     |             mstore(0x80, p3)
  3342 |     |         }
  3343 |     |         _sendLogPayload(0x1c, 0x84);
  3344 |     |         /// @solidity memory-safe-assembly
  3345 |     |         assembly {
  3346 |     |             mstore(0x00, m0)
  3347 |     |             mstore(0x20, m1)
  3348 |     |             mstore(0x40, m2)
  3349 |     |             mstore(0x60, m3)
  3350 |     |             mstore(0x80, m4)
  3351 |     |         }
  3352 |     |     }
  3353 |     | 
  3354 |     |     function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {
  3355 |     |         bytes32 m0;
  3356 |     |         bytes32 m1;
  3357 |     |         bytes32 m2;
  3358 |     |         bytes32 m3;
  3359 |     |         bytes32 m4;
  3360 |     |         bytes32 m5;
  3361 |     |         bytes32 m6;
  3362 |     |         /// @solidity memory-safe-assembly
  3363 |     |         assembly {
  3364 |     |             function writeString(pos, w) {
  3365 |     |                 let length := 0
  3366 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3367 |     |                 mstore(pos, length)
  3368 |     |                 let shift := sub(256, shl(3, length))
  3369 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3370 |     |             }
  3371 |     |             m0 := mload(0x00)
  3372 |     |             m1 := mload(0x20)
  3373 |     |             m2 := mload(0x40)
  3374 |     |             m3 := mload(0x60)
  3375 |     |             m4 := mload(0x80)
  3376 |     |             m5 := mload(0xa0)
  3377 |     |             m6 := mload(0xc0)
  3378 |     |             // Selector of `log(address,address,uint256,string)`.
  3379 |     |             mstore(0x00, 0xfdb4f990)
  3380 |     |             mstore(0x20, p0)
  3381 |     |             mstore(0x40, p1)
  3382 |     |             mstore(0x60, p2)
  3383 |     |             mstore(0x80, 0x80)
  3384 |     |             writeString(0xa0, p3)
  3385 |     |         }
  3386 |     |         _sendLogPayload(0x1c, 0xc4);
  3387 |     |         /// @solidity memory-safe-assembly
  3388 |     |         assembly {
  3389 |     |             mstore(0x00, m0)
  3390 |     |             mstore(0x20, m1)
  3391 |     |             mstore(0x40, m2)
  3392 |     |             mstore(0x60, m3)
  3393 |     |             mstore(0x80, m4)
  3394 |     |             mstore(0xa0, m5)
  3395 |     |             mstore(0xc0, m6)
  3396 |     |         }
  3397 |     |     }
  3398 |     | 
  3399 |     |     function log(address p0, address p1, bytes32 p2, address p3) internal pure {
  3400 |     |         bytes32 m0;
  3401 |     |         bytes32 m1;
  3402 |     |         bytes32 m2;
  3403 |     |         bytes32 m3;
  3404 |     |         bytes32 m4;
  3405 |     |         bytes32 m5;
  3406 |     |         bytes32 m6;
  3407 |     |         /// @solidity memory-safe-assembly
  3408 |     |         assembly {
  3409 |     |             function writeString(pos, w) {
  3410 |     |                 let length := 0
  3411 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3412 |     |                 mstore(pos, length)
  3413 |     |                 let shift := sub(256, shl(3, length))
  3414 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3415 |     |             }
  3416 |     |             m0 := mload(0x00)
  3417 |     |             m1 := mload(0x20)
  3418 |     |             m2 := mload(0x40)
  3419 |     |             m3 := mload(0x60)
  3420 |     |             m4 := mload(0x80)
  3421 |     |             m5 := mload(0xa0)
  3422 |     |             m6 := mload(0xc0)
  3423 |     |             // Selector of `log(address,address,string,address)`.
  3424 |     |             mstore(0x00, 0x8f736d16)
  3425 |     |             mstore(0x20, p0)
  3426 |     |             mstore(0x40, p1)
  3427 |     |             mstore(0x60, 0x80)
  3428 |     |             mstore(0x80, p3)
  3429 |     |             writeString(0xa0, p2)
  3430 |     |         }
  3431 |     |         _sendLogPayload(0x1c, 0xc4);
  3432 |     |         /// @solidity memory-safe-assembly
  3433 |     |         assembly {
  3434 |     |             mstore(0x00, m0)
  3435 |     |             mstore(0x20, m1)
  3436 |     |             mstore(0x40, m2)
  3437 |     |             mstore(0x60, m3)
  3438 |     |             mstore(0x80, m4)
  3439 |     |             mstore(0xa0, m5)
  3440 |     |             mstore(0xc0, m6)
  3441 |     |         }
  3442 |     |     }
  3443 |     | 
  3444 |     |     function log(address p0, address p1, bytes32 p2, bool p3) internal pure {
  3445 |     |         bytes32 m0;
  3446 |     |         bytes32 m1;
  3447 |     |         bytes32 m2;
  3448 |     |         bytes32 m3;
  3449 |     |         bytes32 m4;
  3450 |     |         bytes32 m5;
  3451 |     |         bytes32 m6;
  3452 |     |         /// @solidity memory-safe-assembly
  3453 |     |         assembly {
  3454 |     |             function writeString(pos, w) {
  3455 |     |                 let length := 0
  3456 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3457 |     |                 mstore(pos, length)
  3458 |     |                 let shift := sub(256, shl(3, length))
  3459 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3460 |     |             }
  3461 |     |             m0 := mload(0x00)
  3462 |     |             m1 := mload(0x20)
  3463 |     |             m2 := mload(0x40)
  3464 |     |             m3 := mload(0x60)
  3465 |     |             m4 := mload(0x80)
  3466 |     |             m5 := mload(0xa0)
  3467 |     |             m6 := mload(0xc0)
  3468 |     |             // Selector of `log(address,address,string,bool)`.
  3469 |     |             mstore(0x00, 0x6f1a594e)
  3470 |     |             mstore(0x20, p0)
  3471 |     |             mstore(0x40, p1)
  3472 |     |             mstore(0x60, 0x80)
  3473 |     |             mstore(0x80, p3)
  3474 |     |             writeString(0xa0, p2)
  3475 |     |         }
  3476 |     |         _sendLogPayload(0x1c, 0xc4);
  3477 |     |         /// @solidity memory-safe-assembly
  3478 |     |         assembly {
  3479 |     |             mstore(0x00, m0)
  3480 |     |             mstore(0x20, m1)
  3481 |     |             mstore(0x40, m2)
  3482 |     |             mstore(0x60, m3)
  3483 |     |             mstore(0x80, m4)
  3484 |     |             mstore(0xa0, m5)
  3485 |     |             mstore(0xc0, m6)
  3486 |     |         }
  3487 |     |     }
  3488 |     | 
  3489 |     |     function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {
  3490 |     |         bytes32 m0;
  3491 |     |         bytes32 m1;
  3492 |     |         bytes32 m2;
  3493 |     |         bytes32 m3;
  3494 |     |         bytes32 m4;
  3495 |     |         bytes32 m5;
  3496 |     |         bytes32 m6;
  3497 |     |         /// @solidity memory-safe-assembly
  3498 |     |         assembly {
  3499 |     |             function writeString(pos, w) {
  3500 |     |                 let length := 0
  3501 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3502 |     |                 mstore(pos, length)
  3503 |     |                 let shift := sub(256, shl(3, length))
  3504 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3505 |     |             }
  3506 |     |             m0 := mload(0x00)
  3507 |     |             m1 := mload(0x20)
  3508 |     |             m2 := mload(0x40)
  3509 |     |             m3 := mload(0x60)
  3510 |     |             m4 := mload(0x80)
  3511 |     |             m5 := mload(0xa0)
  3512 |     |             m6 := mload(0xc0)
  3513 |     |             // Selector of `log(address,address,string,uint256)`.
  3514 |     |             mstore(0x00, 0xef1cefe7)
  3515 |     |             mstore(0x20, p0)
  3516 |     |             mstore(0x40, p1)
  3517 |     |             mstore(0x60, 0x80)
  3518 |     |             mstore(0x80, p3)
  3519 |     |             writeString(0xa0, p2)
  3520 |     |         }
  3521 |     |         _sendLogPayload(0x1c, 0xc4);
  3522 |     |         /// @solidity memory-safe-assembly
  3523 |     |         assembly {
  3524 |     |             mstore(0x00, m0)
  3525 |     |             mstore(0x20, m1)
  3526 |     |             mstore(0x40, m2)
  3527 |     |             mstore(0x60, m3)
  3528 |     |             mstore(0x80, m4)
  3529 |     |             mstore(0xa0, m5)
  3530 |     |             mstore(0xc0, m6)
  3531 |     |         }
  3532 |     |     }
  3533 |     | 
  3534 |     |     function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  3535 |     |         bytes32 m0;
  3536 |     |         bytes32 m1;
  3537 |     |         bytes32 m2;
  3538 |     |         bytes32 m3;
  3539 |     |         bytes32 m4;
  3540 |     |         bytes32 m5;
  3541 |     |         bytes32 m6;
  3542 |     |         bytes32 m7;
  3543 |     |         bytes32 m8;
  3544 |     |         /// @solidity memory-safe-assembly
  3545 |     |         assembly {
  3546 |     |             function writeString(pos, w) {
  3547 |     |                 let length := 0
  3548 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3549 |     |                 mstore(pos, length)
  3550 |     |                 let shift := sub(256, shl(3, length))
  3551 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3552 |     |             }
  3553 |     |             m0 := mload(0x00)
  3554 |     |             m1 := mload(0x20)
  3555 |     |             m2 := mload(0x40)
  3556 |     |             m3 := mload(0x60)
  3557 |     |             m4 := mload(0x80)
  3558 |     |             m5 := mload(0xa0)
  3559 |     |             m6 := mload(0xc0)
  3560 |     |             m7 := mload(0xe0)
  3561 |     |             m8 := mload(0x100)
  3562 |     |             // Selector of `log(address,address,string,string)`.
  3563 |     |             mstore(0x00, 0x21bdaf25)
  3564 |     |             mstore(0x20, p0)
  3565 |     |             mstore(0x40, p1)
  3566 |     |             mstore(0x60, 0x80)
  3567 |     |             mstore(0x80, 0xc0)
  3568 |     |             writeString(0xa0, p2)
  3569 |     |             writeString(0xe0, p3)
  3570 |     |         }
  3571 |     |         _sendLogPayload(0x1c, 0x104);
  3572 |     |         /// @solidity memory-safe-assembly
  3573 |     |         assembly {
  3574 |     |             mstore(0x00, m0)
  3575 |     |             mstore(0x20, m1)
  3576 |     |             mstore(0x40, m2)
  3577 |     |             mstore(0x60, m3)
  3578 |     |             mstore(0x80, m4)
  3579 |     |             mstore(0xa0, m5)
  3580 |     |             mstore(0xc0, m6)
  3581 |     |             mstore(0xe0, m7)
  3582 |     |             mstore(0x100, m8)
  3583 |     |         }
  3584 |     |     }
  3585 |     | 
  3586 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
  3587 |     |         bytes32 m0;
  3588 |     |         bytes32 m1;
  3589 |     |         bytes32 m2;
  3590 |     |         bytes32 m3;
  3591 |     |         bytes32 m4;
  3592 |     |         /// @solidity memory-safe-assembly
  3593 |     |         assembly {
  3594 |     |             m0 := mload(0x00)
  3595 |     |             m1 := mload(0x20)
  3596 |     |             m2 := mload(0x40)
  3597 |     |             m3 := mload(0x60)
  3598 |     |             m4 := mload(0x80)
  3599 |     |             // Selector of `log(address,bool,address,address)`.
  3600 |     |             mstore(0x00, 0x660375dd)
  3601 |     |             mstore(0x20, p0)
  3602 |     |             mstore(0x40, p1)
  3603 |     |             mstore(0x60, p2)
  3604 |     |             mstore(0x80, p3)
  3605 |     |         }
  3606 |     |         _sendLogPayload(0x1c, 0x84);
  3607 |     |         /// @solidity memory-safe-assembly
  3608 |     |         assembly {
  3609 |     |             mstore(0x00, m0)
  3610 |     |             mstore(0x20, m1)
  3611 |     |             mstore(0x40, m2)
  3612 |     |             mstore(0x60, m3)
  3613 |     |             mstore(0x80, m4)
  3614 |     |         }
  3615 |     |     }
  3616 |     | 
  3617 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
  3618 |     |         bytes32 m0;
  3619 |     |         bytes32 m1;
  3620 |     |         bytes32 m2;
  3621 |     |         bytes32 m3;
  3622 |     |         bytes32 m4;
  3623 |     |         /// @solidity memory-safe-assembly
  3624 |     |         assembly {
  3625 |     |             m0 := mload(0x00)
  3626 |     |             m1 := mload(0x20)
  3627 |     |             m2 := mload(0x40)
  3628 |     |             m3 := mload(0x60)
  3629 |     |             m4 := mload(0x80)
  3630 |     |             // Selector of `log(address,bool,address,bool)`.
  3631 |     |             mstore(0x00, 0xa6f50b0f)
  3632 |     |             mstore(0x20, p0)
  3633 |     |             mstore(0x40, p1)
  3634 |     |             mstore(0x60, p2)
  3635 |     |             mstore(0x80, p3)
  3636 |     |         }
  3637 |     |         _sendLogPayload(0x1c, 0x84);
  3638 |     |         /// @solidity memory-safe-assembly
  3639 |     |         assembly {
  3640 |     |             mstore(0x00, m0)
  3641 |     |             mstore(0x20, m1)
  3642 |     |             mstore(0x40, m2)
  3643 |     |             mstore(0x60, m3)
  3644 |     |             mstore(0x80, m4)
  3645 |     |         }
  3646 |     |     }
  3647 |     | 
  3648 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
  3649 |     |         bytes32 m0;
  3650 |     |         bytes32 m1;
  3651 |     |         bytes32 m2;
  3652 |     |         bytes32 m3;
  3653 |     |         bytes32 m4;
  3654 |     |         /// @solidity memory-safe-assembly
  3655 |     |         assembly {
  3656 |     |             m0 := mload(0x00)
  3657 |     |             m1 := mload(0x20)
  3658 |     |             m2 := mload(0x40)
  3659 |     |             m3 := mload(0x60)
  3660 |     |             m4 := mload(0x80)
  3661 |     |             // Selector of `log(address,bool,address,uint256)`.
  3662 |     |             mstore(0x00, 0xa75c59de)
  3663 |     |             mstore(0x20, p0)
  3664 |     |             mstore(0x40, p1)
  3665 |     |             mstore(0x60, p2)
  3666 |     |             mstore(0x80, p3)
  3667 |     |         }
  3668 |     |         _sendLogPayload(0x1c, 0x84);
  3669 |     |         /// @solidity memory-safe-assembly
  3670 |     |         assembly {
  3671 |     |             mstore(0x00, m0)
  3672 |     |             mstore(0x20, m1)
  3673 |     |             mstore(0x40, m2)
  3674 |     |             mstore(0x60, m3)
  3675 |     |             mstore(0x80, m4)
  3676 |     |         }
  3677 |     |     }
  3678 |     | 
  3679 |     |     function log(address p0, bool p1, address p2, bytes32 p3) internal pure {
  3680 |     |         bytes32 m0;
  3681 |     |         bytes32 m1;
  3682 |     |         bytes32 m2;
  3683 |     |         bytes32 m3;
  3684 |     |         bytes32 m4;
  3685 |     |         bytes32 m5;
  3686 |     |         bytes32 m6;
  3687 |     |         /// @solidity memory-safe-assembly
  3688 |     |         assembly {
  3689 |     |             function writeString(pos, w) {
  3690 |     |                 let length := 0
  3691 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3692 |     |                 mstore(pos, length)
  3693 |     |                 let shift := sub(256, shl(3, length))
  3694 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3695 |     |             }
  3696 |     |             m0 := mload(0x00)
  3697 |     |             m1 := mload(0x20)
  3698 |     |             m2 := mload(0x40)
  3699 |     |             m3 := mload(0x60)
  3700 |     |             m4 := mload(0x80)
  3701 |     |             m5 := mload(0xa0)
  3702 |     |             m6 := mload(0xc0)
  3703 |     |             // Selector of `log(address,bool,address,string)`.
  3704 |     |             mstore(0x00, 0x2dd778e6)
  3705 |     |             mstore(0x20, p0)
  3706 |     |             mstore(0x40, p1)
  3707 |     |             mstore(0x60, p2)
  3708 |     |             mstore(0x80, 0x80)
  3709 |     |             writeString(0xa0, p3)
  3710 |     |         }
  3711 |     |         _sendLogPayload(0x1c, 0xc4);
  3712 |     |         /// @solidity memory-safe-assembly
  3713 |     |         assembly {
  3714 |     |             mstore(0x00, m0)
  3715 |     |             mstore(0x20, m1)
  3716 |     |             mstore(0x40, m2)
  3717 |     |             mstore(0x60, m3)
  3718 |     |             mstore(0x80, m4)
  3719 |     |             mstore(0xa0, m5)
  3720 |     |             mstore(0xc0, m6)
  3721 |     |         }
  3722 |     |     }
  3723 |     | 
  3724 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
  3725 |     |         bytes32 m0;
  3726 |     |         bytes32 m1;
  3727 |     |         bytes32 m2;
  3728 |     |         bytes32 m3;
  3729 |     |         bytes32 m4;
  3730 |     |         /// @solidity memory-safe-assembly
  3731 |     |         assembly {
  3732 |     |             m0 := mload(0x00)
  3733 |     |             m1 := mload(0x20)
  3734 |     |             m2 := mload(0x40)
  3735 |     |             m3 := mload(0x60)
  3736 |     |             m4 := mload(0x80)
  3737 |     |             // Selector of `log(address,bool,bool,address)`.
  3738 |     |             mstore(0x00, 0xcf394485)
  3739 |     |             mstore(0x20, p0)
  3740 |     |             mstore(0x40, p1)
  3741 |     |             mstore(0x60, p2)
  3742 |     |             mstore(0x80, p3)
  3743 |     |         }
  3744 |     |         _sendLogPayload(0x1c, 0x84);
  3745 |     |         /// @solidity memory-safe-assembly
  3746 |     |         assembly {
  3747 |     |             mstore(0x00, m0)
  3748 |     |             mstore(0x20, m1)
  3749 |     |             mstore(0x40, m2)
  3750 |     |             mstore(0x60, m3)
  3751 |     |             mstore(0x80, m4)
  3752 |     |         }
  3753 |     |     }
  3754 |     | 
  3755 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
  3756 |     |         bytes32 m0;
  3757 |     |         bytes32 m1;
  3758 |     |         bytes32 m2;
  3759 |     |         bytes32 m3;
  3760 |     |         bytes32 m4;
  3761 |     |         /// @solidity memory-safe-assembly
  3762 |     |         assembly {
  3763 |     |             m0 := mload(0x00)
  3764 |     |             m1 := mload(0x20)
  3765 |     |             m2 := mload(0x40)
  3766 |     |             m3 := mload(0x60)
  3767 |     |             m4 := mload(0x80)
  3768 |     |             // Selector of `log(address,bool,bool,bool)`.
  3769 |     |             mstore(0x00, 0xcac43479)
  3770 |     |             mstore(0x20, p0)
  3771 |     |             mstore(0x40, p1)
  3772 |     |             mstore(0x60, p2)
  3773 |     |             mstore(0x80, p3)
  3774 |     |         }
  3775 |     |         _sendLogPayload(0x1c, 0x84);
  3776 |     |         /// @solidity memory-safe-assembly
  3777 |     |         assembly {
  3778 |     |             mstore(0x00, m0)
  3779 |     |             mstore(0x20, m1)
  3780 |     |             mstore(0x40, m2)
  3781 |     |             mstore(0x60, m3)
  3782 |     |             mstore(0x80, m4)
  3783 |     |         }
  3784 |     |     }
  3785 |     | 
  3786 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
  3787 |     |         bytes32 m0;
  3788 |     |         bytes32 m1;
  3789 |     |         bytes32 m2;
  3790 |     |         bytes32 m3;
  3791 |     |         bytes32 m4;
  3792 |     |         /// @solidity memory-safe-assembly
  3793 |     |         assembly {
  3794 |     |             m0 := mload(0x00)
  3795 |     |             m1 := mload(0x20)
  3796 |     |             m2 := mload(0x40)
  3797 |     |             m3 := mload(0x60)
  3798 |     |             m4 := mload(0x80)
  3799 |     |             // Selector of `log(address,bool,bool,uint256)`.
  3800 |     |             mstore(0x00, 0x8c4e5de6)
  3801 |     |             mstore(0x20, p0)
  3802 |     |             mstore(0x40, p1)
  3803 |     |             mstore(0x60, p2)
  3804 |     |             mstore(0x80, p3)
  3805 |     |         }
  3806 |     |         _sendLogPayload(0x1c, 0x84);
  3807 |     |         /// @solidity memory-safe-assembly
  3808 |     |         assembly {
  3809 |     |             mstore(0x00, m0)
  3810 |     |             mstore(0x20, m1)
  3811 |     |             mstore(0x40, m2)
  3812 |     |             mstore(0x60, m3)
  3813 |     |             mstore(0x80, m4)
  3814 |     |         }
  3815 |     |     }
  3816 |     | 
  3817 |     |     function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {
  3818 |     |         bytes32 m0;
  3819 |     |         bytes32 m1;
  3820 |     |         bytes32 m2;
  3821 |     |         bytes32 m3;
  3822 |     |         bytes32 m4;
  3823 |     |         bytes32 m5;
  3824 |     |         bytes32 m6;
  3825 |     |         /// @solidity memory-safe-assembly
  3826 |     |         assembly {
  3827 |     |             function writeString(pos, w) {
  3828 |     |                 let length := 0
  3829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3830 |     |                 mstore(pos, length)
  3831 |     |                 let shift := sub(256, shl(3, length))
  3832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3833 |     |             }
  3834 |     |             m0 := mload(0x00)
  3835 |     |             m1 := mload(0x20)
  3836 |     |             m2 := mload(0x40)
  3837 |     |             m3 := mload(0x60)
  3838 |     |             m4 := mload(0x80)
  3839 |     |             m5 := mload(0xa0)
  3840 |     |             m6 := mload(0xc0)
  3841 |     |             // Selector of `log(address,bool,bool,string)`.
  3842 |     |             mstore(0x00, 0xdfc4a2e8)
  3843 |     |             mstore(0x20, p0)
  3844 |     |             mstore(0x40, p1)
  3845 |     |             mstore(0x60, p2)
  3846 |     |             mstore(0x80, 0x80)
  3847 |     |             writeString(0xa0, p3)
  3848 |     |         }
  3849 |     |         _sendLogPayload(0x1c, 0xc4);
  3850 |     |         /// @solidity memory-safe-assembly
  3851 |     |         assembly {
  3852 |     |             mstore(0x00, m0)
  3853 |     |             mstore(0x20, m1)
  3854 |     |             mstore(0x40, m2)
  3855 |     |             mstore(0x60, m3)
  3856 |     |             mstore(0x80, m4)
  3857 |     |             mstore(0xa0, m5)
  3858 |     |             mstore(0xc0, m6)
  3859 |     |         }
  3860 |     |     }
  3861 |     | 
  3862 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
  3863 |     |         bytes32 m0;
  3864 |     |         bytes32 m1;
  3865 |     |         bytes32 m2;
  3866 |     |         bytes32 m3;
  3867 |     |         bytes32 m4;
  3868 |     |         /// @solidity memory-safe-assembly
  3869 |     |         assembly {
  3870 |     |             m0 := mload(0x00)
  3871 |     |             m1 := mload(0x20)
  3872 |     |             m2 := mload(0x40)
  3873 |     |             m3 := mload(0x60)
  3874 |     |             m4 := mload(0x80)
  3875 |     |             // Selector of `log(address,bool,uint256,address)`.
  3876 |     |             mstore(0x00, 0xccf790a1)
  3877 |     |             mstore(0x20, p0)
  3878 |     |             mstore(0x40, p1)
  3879 |     |             mstore(0x60, p2)
  3880 |     |             mstore(0x80, p3)
  3881 |     |         }
  3882 |     |         _sendLogPayload(0x1c, 0x84);
  3883 |     |         /// @solidity memory-safe-assembly
  3884 |     |         assembly {
  3885 |     |             mstore(0x00, m0)
  3886 |     |             mstore(0x20, m1)
  3887 |     |             mstore(0x40, m2)
  3888 |     |             mstore(0x60, m3)
  3889 |     |             mstore(0x80, m4)
  3890 |     |         }
  3891 |     |     }
  3892 |     | 
  3893 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
  3894 |     |         bytes32 m0;
  3895 |     |         bytes32 m1;
  3896 |     |         bytes32 m2;
  3897 |     |         bytes32 m3;
  3898 |     |         bytes32 m4;
  3899 |     |         /// @solidity memory-safe-assembly
  3900 |     |         assembly {
  3901 |     |             m0 := mload(0x00)
  3902 |     |             m1 := mload(0x20)
  3903 |     |             m2 := mload(0x40)
  3904 |     |             m3 := mload(0x60)
  3905 |     |             m4 := mload(0x80)
  3906 |     |             // Selector of `log(address,bool,uint256,bool)`.
  3907 |     |             mstore(0x00, 0xc4643e20)
  3908 |     |             mstore(0x20, p0)
  3909 |     |             mstore(0x40, p1)
  3910 |     |             mstore(0x60, p2)
  3911 |     |             mstore(0x80, p3)
  3912 |     |         }
  3913 |     |         _sendLogPayload(0x1c, 0x84);
  3914 |     |         /// @solidity memory-safe-assembly
  3915 |     |         assembly {
  3916 |     |             mstore(0x00, m0)
  3917 |     |             mstore(0x20, m1)
  3918 |     |             mstore(0x40, m2)
  3919 |     |             mstore(0x60, m3)
  3920 |     |             mstore(0x80, m4)
  3921 |     |         }
  3922 |     |     }
  3923 |     | 
  3924 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
  3925 |     |         bytes32 m0;
  3926 |     |         bytes32 m1;
  3927 |     |         bytes32 m2;
  3928 |     |         bytes32 m3;
  3929 |     |         bytes32 m4;
  3930 |     |         /// @solidity memory-safe-assembly
  3931 |     |         assembly {
  3932 |     |             m0 := mload(0x00)
  3933 |     |             m1 := mload(0x20)
  3934 |     |             m2 := mload(0x40)
  3935 |     |             m3 := mload(0x60)
  3936 |     |             m4 := mload(0x80)
  3937 |     |             // Selector of `log(address,bool,uint256,uint256)`.
  3938 |     |             mstore(0x00, 0x386ff5f4)
  3939 |     |             mstore(0x20, p0)
  3940 |     |             mstore(0x40, p1)
  3941 |     |             mstore(0x60, p2)
  3942 |     |             mstore(0x80, p3)
  3943 |     |         }
  3944 |     |         _sendLogPayload(0x1c, 0x84);
  3945 |     |         /// @solidity memory-safe-assembly
  3946 |     |         assembly {
  3947 |     |             mstore(0x00, m0)
  3948 |     |             mstore(0x20, m1)
  3949 |     |             mstore(0x40, m2)
  3950 |     |             mstore(0x60, m3)
  3951 |     |             mstore(0x80, m4)
  3952 |     |         }
  3953 |     |     }
  3954 |     | 
  3955 |     |     function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  3956 |     |         bytes32 m0;
  3957 |     |         bytes32 m1;
  3958 |     |         bytes32 m2;
  3959 |     |         bytes32 m3;
  3960 |     |         bytes32 m4;
  3961 |     |         bytes32 m5;
  3962 |     |         bytes32 m6;
  3963 |     |         /// @solidity memory-safe-assembly
  3964 |     |         assembly {
  3965 |     |             function writeString(pos, w) {
  3966 |     |                 let length := 0
  3967 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3968 |     |                 mstore(pos, length)
  3969 |     |                 let shift := sub(256, shl(3, length))
  3970 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3971 |     |             }
  3972 |     |             m0 := mload(0x00)
  3973 |     |             m1 := mload(0x20)
  3974 |     |             m2 := mload(0x40)
  3975 |     |             m3 := mload(0x60)
  3976 |     |             m4 := mload(0x80)
  3977 |     |             m5 := mload(0xa0)
  3978 |     |             m6 := mload(0xc0)
  3979 |     |             // Selector of `log(address,bool,uint256,string)`.
  3980 |     |             mstore(0x00, 0x0aa6cfad)
  3981 |     |             mstore(0x20, p0)
  3982 |     |             mstore(0x40, p1)
  3983 |     |             mstore(0x60, p2)
  3984 |     |             mstore(0x80, 0x80)
  3985 |     |             writeString(0xa0, p3)
  3986 |     |         }
  3987 |     |         _sendLogPayload(0x1c, 0xc4);
  3988 |     |         /// @solidity memory-safe-assembly
  3989 |     |         assembly {
  3990 |     |             mstore(0x00, m0)
  3991 |     |             mstore(0x20, m1)
  3992 |     |             mstore(0x40, m2)
  3993 |     |             mstore(0x60, m3)
  3994 |     |             mstore(0x80, m4)
  3995 |     |             mstore(0xa0, m5)
  3996 |     |             mstore(0xc0, m6)
  3997 |     |         }
  3998 |     |     }
  3999 |     | 
  4000 |     |     function log(address p0, bool p1, bytes32 p2, address p3) internal pure {
  4001 |     |         bytes32 m0;
  4002 |     |         bytes32 m1;
  4003 |     |         bytes32 m2;
  4004 |     |         bytes32 m3;
  4005 |     |         bytes32 m4;
  4006 |     |         bytes32 m5;
  4007 |     |         bytes32 m6;
  4008 |     |         /// @solidity memory-safe-assembly
  4009 |     |         assembly {
  4010 |     |             function writeString(pos, w) {
  4011 |     |                 let length := 0
  4012 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4013 |     |                 mstore(pos, length)
  4014 |     |                 let shift := sub(256, shl(3, length))
  4015 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4016 |     |             }
  4017 |     |             m0 := mload(0x00)
  4018 |     |             m1 := mload(0x20)
  4019 |     |             m2 := mload(0x40)
  4020 |     |             m3 := mload(0x60)
  4021 |     |             m4 := mload(0x80)
  4022 |     |             m5 := mload(0xa0)
  4023 |     |             m6 := mload(0xc0)
  4024 |     |             // Selector of `log(address,bool,string,address)`.
  4025 |     |             mstore(0x00, 0x19fd4956)
  4026 |     |             mstore(0x20, p0)
  4027 |     |             mstore(0x40, p1)
  4028 |     |             mstore(0x60, 0x80)
  4029 |     |             mstore(0x80, p3)
  4030 |     |             writeString(0xa0, p2)
  4031 |     |         }
  4032 |     |         _sendLogPayload(0x1c, 0xc4);
  4033 |     |         /// @solidity memory-safe-assembly
  4034 |     |         assembly {
  4035 |     |             mstore(0x00, m0)
  4036 |     |             mstore(0x20, m1)
  4037 |     |             mstore(0x40, m2)
  4038 |     |             mstore(0x60, m3)
  4039 |     |             mstore(0x80, m4)
  4040 |     |             mstore(0xa0, m5)
  4041 |     |             mstore(0xc0, m6)
  4042 |     |         }
  4043 |     |     }
  4044 |     | 
  4045 |     |     function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {
  4046 |     |         bytes32 m0;
  4047 |     |         bytes32 m1;
  4048 |     |         bytes32 m2;
  4049 |     |         bytes32 m3;
  4050 |     |         bytes32 m4;
  4051 |     |         bytes32 m5;
  4052 |     |         bytes32 m6;
  4053 |     |         /// @solidity memory-safe-assembly
  4054 |     |         assembly {
  4055 |     |             function writeString(pos, w) {
  4056 |     |                 let length := 0
  4057 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4058 |     |                 mstore(pos, length)
  4059 |     |                 let shift := sub(256, shl(3, length))
  4060 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4061 |     |             }
  4062 |     |             m0 := mload(0x00)
  4063 |     |             m1 := mload(0x20)
  4064 |     |             m2 := mload(0x40)
  4065 |     |             m3 := mload(0x60)
  4066 |     |             m4 := mload(0x80)
  4067 |     |             m5 := mload(0xa0)
  4068 |     |             m6 := mload(0xc0)
  4069 |     |             // Selector of `log(address,bool,string,bool)`.
  4070 |     |             mstore(0x00, 0x50ad461d)
  4071 |     |             mstore(0x20, p0)
  4072 |     |             mstore(0x40, p1)
  4073 |     |             mstore(0x60, 0x80)
  4074 |     |             mstore(0x80, p3)
  4075 |     |             writeString(0xa0, p2)
  4076 |     |         }
  4077 |     |         _sendLogPayload(0x1c, 0xc4);
  4078 |     |         /// @solidity memory-safe-assembly
  4079 |     |         assembly {
  4080 |     |             mstore(0x00, m0)
  4081 |     |             mstore(0x20, m1)
  4082 |     |             mstore(0x40, m2)
  4083 |     |             mstore(0x60, m3)
  4084 |     |             mstore(0x80, m4)
  4085 |     |             mstore(0xa0, m5)
  4086 |     |             mstore(0xc0, m6)
  4087 |     |         }
  4088 |     |     }
  4089 |     | 
  4090 |     |     function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  4091 |     |         bytes32 m0;
  4092 |     |         bytes32 m1;
  4093 |     |         bytes32 m2;
  4094 |     |         bytes32 m3;
  4095 |     |         bytes32 m4;
  4096 |     |         bytes32 m5;
  4097 |     |         bytes32 m6;
  4098 |     |         /// @solidity memory-safe-assembly
  4099 |     |         assembly {
  4100 |     |             function writeString(pos, w) {
  4101 |     |                 let length := 0
  4102 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4103 |     |                 mstore(pos, length)
  4104 |     |                 let shift := sub(256, shl(3, length))
  4105 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4106 |     |             }
  4107 |     |             m0 := mload(0x00)
  4108 |     |             m1 := mload(0x20)
  4109 |     |             m2 := mload(0x40)
  4110 |     |             m3 := mload(0x60)
  4111 |     |             m4 := mload(0x80)
  4112 |     |             m5 := mload(0xa0)
  4113 |     |             m6 := mload(0xc0)
  4114 |     |             // Selector of `log(address,bool,string,uint256)`.
  4115 |     |             mstore(0x00, 0x80e6a20b)
  4116 |     |             mstore(0x20, p0)
  4117 |     |             mstore(0x40, p1)
  4118 |     |             mstore(0x60, 0x80)
  4119 |     |             mstore(0x80, p3)
  4120 |     |             writeString(0xa0, p2)
  4121 |     |         }
  4122 |     |         _sendLogPayload(0x1c, 0xc4);
  4123 |     |         /// @solidity memory-safe-assembly
  4124 |     |         assembly {
  4125 |     |             mstore(0x00, m0)
  4126 |     |             mstore(0x20, m1)
  4127 |     |             mstore(0x40, m2)
  4128 |     |             mstore(0x60, m3)
  4129 |     |             mstore(0x80, m4)
  4130 |     |             mstore(0xa0, m5)
  4131 |     |             mstore(0xc0, m6)
  4132 |     |         }
  4133 |     |     }
  4134 |     | 
  4135 |     |     function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  4136 |     |         bytes32 m0;
  4137 |     |         bytes32 m1;
  4138 |     |         bytes32 m2;
  4139 |     |         bytes32 m3;
  4140 |     |         bytes32 m4;
  4141 |     |         bytes32 m5;
  4142 |     |         bytes32 m6;
  4143 |     |         bytes32 m7;
  4144 |     |         bytes32 m8;
  4145 |     |         /// @solidity memory-safe-assembly
  4146 |     |         assembly {
  4147 |     |             function writeString(pos, w) {
  4148 |     |                 let length := 0
  4149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4150 |     |                 mstore(pos, length)
  4151 |     |                 let shift := sub(256, shl(3, length))
  4152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4153 |     |             }
  4154 |     |             m0 := mload(0x00)
  4155 |     |             m1 := mload(0x20)
  4156 |     |             m2 := mload(0x40)
  4157 |     |             m3 := mload(0x60)
  4158 |     |             m4 := mload(0x80)
  4159 |     |             m5 := mload(0xa0)
  4160 |     |             m6 := mload(0xc0)
  4161 |     |             m7 := mload(0xe0)
  4162 |     |             m8 := mload(0x100)
  4163 |     |             // Selector of `log(address,bool,string,string)`.
  4164 |     |             mstore(0x00, 0x475c5c33)
  4165 |     |             mstore(0x20, p0)
  4166 |     |             mstore(0x40, p1)
  4167 |     |             mstore(0x60, 0x80)
  4168 |     |             mstore(0x80, 0xc0)
  4169 |     |             writeString(0xa0, p2)
  4170 |     |             writeString(0xe0, p3)
  4171 |     |         }
  4172 |     |         _sendLogPayload(0x1c, 0x104);
  4173 |     |         /// @solidity memory-safe-assembly
  4174 |     |         assembly {
  4175 |     |             mstore(0x00, m0)
  4176 |     |             mstore(0x20, m1)
  4177 |     |             mstore(0x40, m2)
  4178 |     |             mstore(0x60, m3)
  4179 |     |             mstore(0x80, m4)
  4180 |     |             mstore(0xa0, m5)
  4181 |     |             mstore(0xc0, m6)
  4182 |     |             mstore(0xe0, m7)
  4183 |     |             mstore(0x100, m8)
  4184 |     |         }
  4185 |     |     }
  4186 |     | 
  4187 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
  4188 |     |         bytes32 m0;
  4189 |     |         bytes32 m1;
  4190 |     |         bytes32 m2;
  4191 |     |         bytes32 m3;
  4192 |     |         bytes32 m4;
  4193 |     |         /// @solidity memory-safe-assembly
  4194 |     |         assembly {
  4195 |     |             m0 := mload(0x00)
  4196 |     |             m1 := mload(0x20)
  4197 |     |             m2 := mload(0x40)
  4198 |     |             m3 := mload(0x60)
  4199 |     |             m4 := mload(0x80)
  4200 |     |             // Selector of `log(address,uint256,address,address)`.
  4201 |     |             mstore(0x00, 0x478d1c62)
  4202 |     |             mstore(0x20, p0)
  4203 |     |             mstore(0x40, p1)
  4204 |     |             mstore(0x60, p2)
  4205 |     |             mstore(0x80, p3)
  4206 |     |         }
  4207 |     |         _sendLogPayload(0x1c, 0x84);
  4208 |     |         /// @solidity memory-safe-assembly
  4209 |     |         assembly {
  4210 |     |             mstore(0x00, m0)
  4211 |     |             mstore(0x20, m1)
  4212 |     |             mstore(0x40, m2)
  4213 |     |             mstore(0x60, m3)
  4214 |     |             mstore(0x80, m4)
  4215 |     |         }
  4216 |     |     }
  4217 |     | 
  4218 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
  4219 |     |         bytes32 m0;
  4220 |     |         bytes32 m1;
  4221 |     |         bytes32 m2;
  4222 |     |         bytes32 m3;
  4223 |     |         bytes32 m4;
  4224 |     |         /// @solidity memory-safe-assembly
  4225 |     |         assembly {
  4226 |     |             m0 := mload(0x00)
  4227 |     |             m1 := mload(0x20)
  4228 |     |             m2 := mload(0x40)
  4229 |     |             m3 := mload(0x60)
  4230 |     |             m4 := mload(0x80)
  4231 |     |             // Selector of `log(address,uint256,address,bool)`.
  4232 |     |             mstore(0x00, 0xa1bcc9b3)
  4233 |     |             mstore(0x20, p0)
  4234 |     |             mstore(0x40, p1)
  4235 |     |             mstore(0x60, p2)
  4236 |     |             mstore(0x80, p3)
  4237 |     |         }
  4238 |     |         _sendLogPayload(0x1c, 0x84);
  4239 |     |         /// @solidity memory-safe-assembly
  4240 |     |         assembly {
  4241 |     |             mstore(0x00, m0)
  4242 |     |             mstore(0x20, m1)
  4243 |     |             mstore(0x40, m2)
  4244 |     |             mstore(0x60, m3)
  4245 |     |             mstore(0x80, m4)
  4246 |     |         }
  4247 |     |     }
  4248 |     | 
  4249 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
  4250 |     |         bytes32 m0;
  4251 |     |         bytes32 m1;
  4252 |     |         bytes32 m2;
  4253 |     |         bytes32 m3;
  4254 |     |         bytes32 m4;
  4255 |     |         /// @solidity memory-safe-assembly
  4256 |     |         assembly {
  4257 |     |             m0 := mload(0x00)
  4258 |     |             m1 := mload(0x20)
  4259 |     |             m2 := mload(0x40)
  4260 |     |             m3 := mload(0x60)
  4261 |     |             m4 := mload(0x80)
  4262 |     |             // Selector of `log(address,uint256,address,uint256)`.
  4263 |     |             mstore(0x00, 0x100f650e)
  4264 |     |             mstore(0x20, p0)
  4265 |     |             mstore(0x40, p1)
  4266 |     |             mstore(0x60, p2)
  4267 |     |             mstore(0x80, p3)
  4268 |     |         }
  4269 |     |         _sendLogPayload(0x1c, 0x84);
  4270 |     |         /// @solidity memory-safe-assembly
  4271 |     |         assembly {
  4272 |     |             mstore(0x00, m0)
  4273 |     |             mstore(0x20, m1)
  4274 |     |             mstore(0x40, m2)
  4275 |     |             mstore(0x60, m3)
  4276 |     |             mstore(0x80, m4)
  4277 |     |         }
  4278 |     |     }
  4279 |     | 
  4280 |     |     function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {
  4281 |     |         bytes32 m0;
  4282 |     |         bytes32 m1;
  4283 |     |         bytes32 m2;
  4284 |     |         bytes32 m3;
  4285 |     |         bytes32 m4;
  4286 |     |         bytes32 m5;
  4287 |     |         bytes32 m6;
  4288 |     |         /// @solidity memory-safe-assembly
  4289 |     |         assembly {
  4290 |     |             function writeString(pos, w) {
  4291 |     |                 let length := 0
  4292 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4293 |     |                 mstore(pos, length)
  4294 |     |                 let shift := sub(256, shl(3, length))
  4295 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4296 |     |             }
  4297 |     |             m0 := mload(0x00)
  4298 |     |             m1 := mload(0x20)
  4299 |     |             m2 := mload(0x40)
  4300 |     |             m3 := mload(0x60)
  4301 |     |             m4 := mload(0x80)
  4302 |     |             m5 := mload(0xa0)
  4303 |     |             m6 := mload(0xc0)
  4304 |     |             // Selector of `log(address,uint256,address,string)`.
  4305 |     |             mstore(0x00, 0x1da986ea)
  4306 |     |             mstore(0x20, p0)
  4307 |     |             mstore(0x40, p1)
  4308 |     |             mstore(0x60, p2)
  4309 |     |             mstore(0x80, 0x80)
  4310 |     |             writeString(0xa0, p3)
  4311 |     |         }
  4312 |     |         _sendLogPayload(0x1c, 0xc4);
  4313 |     |         /// @solidity memory-safe-assembly
  4314 |     |         assembly {
  4315 |     |             mstore(0x00, m0)
  4316 |     |             mstore(0x20, m1)
  4317 |     |             mstore(0x40, m2)
  4318 |     |             mstore(0x60, m3)
  4319 |     |             mstore(0x80, m4)
  4320 |     |             mstore(0xa0, m5)
  4321 |     |             mstore(0xc0, m6)
  4322 |     |         }
  4323 |     |     }
  4324 |     | 
  4325 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
  4326 |     |         bytes32 m0;
  4327 |     |         bytes32 m1;
  4328 |     |         bytes32 m2;
  4329 |     |         bytes32 m3;
  4330 |     |         bytes32 m4;
  4331 |     |         /// @solidity memory-safe-assembly
  4332 |     |         assembly {
  4333 |     |             m0 := mload(0x00)
  4334 |     |             m1 := mload(0x20)
  4335 |     |             m2 := mload(0x40)
  4336 |     |             m3 := mload(0x60)
  4337 |     |             m4 := mload(0x80)
  4338 |     |             // Selector of `log(address,uint256,bool,address)`.
  4339 |     |             mstore(0x00, 0xa31bfdcc)
  4340 |     |             mstore(0x20, p0)
  4341 |     |             mstore(0x40, p1)
  4342 |     |             mstore(0x60, p2)
  4343 |     |             mstore(0x80, p3)
  4344 |     |         }
  4345 |     |         _sendLogPayload(0x1c, 0x84);
  4346 |     |         /// @solidity memory-safe-assembly
  4347 |     |         assembly {
  4348 |     |             mstore(0x00, m0)
  4349 |     |             mstore(0x20, m1)
  4350 |     |             mstore(0x40, m2)
  4351 |     |             mstore(0x60, m3)
  4352 |     |             mstore(0x80, m4)
  4353 |     |         }
  4354 |     |     }
  4355 |     | 
  4356 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
  4357 |     |         bytes32 m0;
  4358 |     |         bytes32 m1;
  4359 |     |         bytes32 m2;
  4360 |     |         bytes32 m3;
  4361 |     |         bytes32 m4;
  4362 |     |         /// @solidity memory-safe-assembly
  4363 |     |         assembly {
  4364 |     |             m0 := mload(0x00)
  4365 |     |             m1 := mload(0x20)
  4366 |     |             m2 := mload(0x40)
  4367 |     |             m3 := mload(0x60)
  4368 |     |             m4 := mload(0x80)
  4369 |     |             // Selector of `log(address,uint256,bool,bool)`.
  4370 |     |             mstore(0x00, 0x3bf5e537)
  4371 |     |             mstore(0x20, p0)
  4372 |     |             mstore(0x40, p1)
  4373 |     |             mstore(0x60, p2)
  4374 |     |             mstore(0x80, p3)
  4375 |     |         }
  4376 |     |         _sendLogPayload(0x1c, 0x84);
  4377 |     |         /// @solidity memory-safe-assembly
  4378 |     |         assembly {
  4379 |     |             mstore(0x00, m0)
  4380 |     |             mstore(0x20, m1)
  4381 |     |             mstore(0x40, m2)
  4382 |     |             mstore(0x60, m3)
  4383 |     |             mstore(0x80, m4)
  4384 |     |         }
  4385 |     |     }
  4386 |     | 
  4387 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
  4388 |     |         bytes32 m0;
  4389 |     |         bytes32 m1;
  4390 |     |         bytes32 m2;
  4391 |     |         bytes32 m3;
  4392 |     |         bytes32 m4;
  4393 |     |         /// @solidity memory-safe-assembly
  4394 |     |         assembly {
  4395 |     |             m0 := mload(0x00)
  4396 |     |             m1 := mload(0x20)
  4397 |     |             m2 := mload(0x40)
  4398 |     |             m3 := mload(0x60)
  4399 |     |             m4 := mload(0x80)
  4400 |     |             // Selector of `log(address,uint256,bool,uint256)`.
  4401 |     |             mstore(0x00, 0x22f6b999)
  4402 |     |             mstore(0x20, p0)
  4403 |     |             mstore(0x40, p1)
  4404 |     |             mstore(0x60, p2)
  4405 |     |             mstore(0x80, p3)
  4406 |     |         }
  4407 |     |         _sendLogPayload(0x1c, 0x84);
  4408 |     |         /// @solidity memory-safe-assembly
  4409 |     |         assembly {
  4410 |     |             mstore(0x00, m0)
  4411 |     |             mstore(0x20, m1)
  4412 |     |             mstore(0x40, m2)
  4413 |     |             mstore(0x60, m3)
  4414 |     |             mstore(0x80, m4)
  4415 |     |         }
  4416 |     |     }
  4417 |     | 
  4418 |     |     function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  4419 |     |         bytes32 m0;
  4420 |     |         bytes32 m1;
  4421 |     |         bytes32 m2;
  4422 |     |         bytes32 m3;
  4423 |     |         bytes32 m4;
  4424 |     |         bytes32 m5;
  4425 |     |         bytes32 m6;
  4426 |     |         /// @solidity memory-safe-assembly
  4427 |     |         assembly {
  4428 |     |             function writeString(pos, w) {
  4429 |     |                 let length := 0
  4430 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4431 |     |                 mstore(pos, length)
  4432 |     |                 let shift := sub(256, shl(3, length))
  4433 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4434 |     |             }
  4435 |     |             m0 := mload(0x00)
  4436 |     |             m1 := mload(0x20)
  4437 |     |             m2 := mload(0x40)
  4438 |     |             m3 := mload(0x60)
  4439 |     |             m4 := mload(0x80)
  4440 |     |             m5 := mload(0xa0)
  4441 |     |             m6 := mload(0xc0)
  4442 |     |             // Selector of `log(address,uint256,bool,string)`.
  4443 |     |             mstore(0x00, 0xc5ad85f9)
  4444 |     |             mstore(0x20, p0)
  4445 |     |             mstore(0x40, p1)
  4446 |     |             mstore(0x60, p2)
  4447 |     |             mstore(0x80, 0x80)
  4448 |     |             writeString(0xa0, p3)
  4449 |     |         }
  4450 |     |         _sendLogPayload(0x1c, 0xc4);
  4451 |     |         /// @solidity memory-safe-assembly
  4452 |     |         assembly {
  4453 |     |             mstore(0x00, m0)
  4454 |     |             mstore(0x20, m1)
  4455 |     |             mstore(0x40, m2)
  4456 |     |             mstore(0x60, m3)
  4457 |     |             mstore(0x80, m4)
  4458 |     |             mstore(0xa0, m5)
  4459 |     |             mstore(0xc0, m6)
  4460 |     |         }
  4461 |     |     }
  4462 |     | 
  4463 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
  4464 |     |         bytes32 m0;
  4465 |     |         bytes32 m1;
  4466 |     |         bytes32 m2;
  4467 |     |         bytes32 m3;
  4468 |     |         bytes32 m4;
  4469 |     |         /// @solidity memory-safe-assembly
  4470 |     |         assembly {
  4471 |     |             m0 := mload(0x00)
  4472 |     |             m1 := mload(0x20)
  4473 |     |             m2 := mload(0x40)
  4474 |     |             m3 := mload(0x60)
  4475 |     |             m4 := mload(0x80)
  4476 |     |             // Selector of `log(address,uint256,uint256,address)`.
  4477 |     |             mstore(0x00, 0x20e3984d)
  4478 |     |             mstore(0x20, p0)
  4479 |     |             mstore(0x40, p1)
  4480 |     |             mstore(0x60, p2)
  4481 |     |             mstore(0x80, p3)
  4482 |     |         }
  4483 |     |         _sendLogPayload(0x1c, 0x84);
  4484 |     |         /// @solidity memory-safe-assembly
  4485 |     |         assembly {
  4486 |     |             mstore(0x00, m0)
  4487 |     |             mstore(0x20, m1)
  4488 |     |             mstore(0x40, m2)
  4489 |     |             mstore(0x60, m3)
  4490 |     |             mstore(0x80, m4)
  4491 |     |         }
  4492 |     |     }
  4493 |     | 
  4494 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
  4495 |     |         bytes32 m0;
  4496 |     |         bytes32 m1;
  4497 |     |         bytes32 m2;
  4498 |     |         bytes32 m3;
  4499 |     |         bytes32 m4;
  4500 |     |         /// @solidity memory-safe-assembly
  4501 |     |         assembly {
  4502 |     |             m0 := mload(0x00)
  4503 |     |             m1 := mload(0x20)
  4504 |     |             m2 := mload(0x40)
  4505 |     |             m3 := mload(0x60)
  4506 |     |             m4 := mload(0x80)
  4507 |     |             // Selector of `log(address,uint256,uint256,bool)`.
  4508 |     |             mstore(0x00, 0x66f1bc67)
  4509 |     |             mstore(0x20, p0)
  4510 |     |             mstore(0x40, p1)
  4511 |     |             mstore(0x60, p2)
  4512 |     |             mstore(0x80, p3)
  4513 |     |         }
  4514 |     |         _sendLogPayload(0x1c, 0x84);
  4515 |     |         /// @solidity memory-safe-assembly
  4516 |     |         assembly {
  4517 |     |             mstore(0x00, m0)
  4518 |     |             mstore(0x20, m1)
  4519 |     |             mstore(0x40, m2)
  4520 |     |             mstore(0x60, m3)
  4521 |     |             mstore(0x80, m4)
  4522 |     |         }
  4523 |     |     }
  4524 |     | 
  4525 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  4526 |     |         bytes32 m0;
  4527 |     |         bytes32 m1;
  4528 |     |         bytes32 m2;
  4529 |     |         bytes32 m3;
  4530 |     |         bytes32 m4;
  4531 |     |         /// @solidity memory-safe-assembly
  4532 |     |         assembly {
  4533 |     |             m0 := mload(0x00)
  4534 |     |             m1 := mload(0x20)
  4535 |     |             m2 := mload(0x40)
  4536 |     |             m3 := mload(0x60)
  4537 |     |             m4 := mload(0x80)
  4538 |     |             // Selector of `log(address,uint256,uint256,uint256)`.
  4539 |     |             mstore(0x00, 0x34f0e636)
  4540 |     |             mstore(0x20, p0)
  4541 |     |             mstore(0x40, p1)
  4542 |     |             mstore(0x60, p2)
  4543 |     |             mstore(0x80, p3)
  4544 |     |         }
  4545 |     |         _sendLogPayload(0x1c, 0x84);
  4546 |     |         /// @solidity memory-safe-assembly
  4547 |     |         assembly {
  4548 |     |             mstore(0x00, m0)
  4549 |     |             mstore(0x20, m1)
  4550 |     |             mstore(0x40, m2)
  4551 |     |             mstore(0x60, m3)
  4552 |     |             mstore(0x80, m4)
  4553 |     |         }
  4554 |     |     }
  4555 |     | 
  4556 |     |     function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  4557 |     |         bytes32 m0;
  4558 |     |         bytes32 m1;
  4559 |     |         bytes32 m2;
  4560 |     |         bytes32 m3;
  4561 |     |         bytes32 m4;
  4562 |     |         bytes32 m5;
  4563 |     |         bytes32 m6;
  4564 |     |         /// @solidity memory-safe-assembly
  4565 |     |         assembly {
  4566 |     |             function writeString(pos, w) {
  4567 |     |                 let length := 0
  4568 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4569 |     |                 mstore(pos, length)
  4570 |     |                 let shift := sub(256, shl(3, length))
  4571 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4572 |     |             }
  4573 |     |             m0 := mload(0x00)
  4574 |     |             m1 := mload(0x20)
  4575 |     |             m2 := mload(0x40)
  4576 |     |             m3 := mload(0x60)
  4577 |     |             m4 := mload(0x80)
  4578 |     |             m5 := mload(0xa0)
  4579 |     |             m6 := mload(0xc0)
  4580 |     |             // Selector of `log(address,uint256,uint256,string)`.
  4581 |     |             mstore(0x00, 0x4a28c017)
  4582 |     |             mstore(0x20, p0)
  4583 |     |             mstore(0x40, p1)
  4584 |     |             mstore(0x60, p2)
  4585 |     |             mstore(0x80, 0x80)
  4586 |     |             writeString(0xa0, p3)
  4587 |     |         }
  4588 |     |         _sendLogPayload(0x1c, 0xc4);
  4589 |     |         /// @solidity memory-safe-assembly
  4590 |     |         assembly {
  4591 |     |             mstore(0x00, m0)
  4592 |     |             mstore(0x20, m1)
  4593 |     |             mstore(0x40, m2)
  4594 |     |             mstore(0x60, m3)
  4595 |     |             mstore(0x80, m4)
  4596 |     |             mstore(0xa0, m5)
  4597 |     |             mstore(0xc0, m6)
  4598 |     |         }
  4599 |     |     }
  4600 |     | 
  4601 |     |     function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {
  4602 |     |         bytes32 m0;
  4603 |     |         bytes32 m1;
  4604 |     |         bytes32 m2;
  4605 |     |         bytes32 m3;
  4606 |     |         bytes32 m4;
  4607 |     |         bytes32 m5;
  4608 |     |         bytes32 m6;
  4609 |     |         /// @solidity memory-safe-assembly
  4610 |     |         assembly {
  4611 |     |             function writeString(pos, w) {
  4612 |     |                 let length := 0
  4613 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4614 |     |                 mstore(pos, length)
  4615 |     |                 let shift := sub(256, shl(3, length))
  4616 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4617 |     |             }
  4618 |     |             m0 := mload(0x00)
  4619 |     |             m1 := mload(0x20)
  4620 |     |             m2 := mload(0x40)
  4621 |     |             m3 := mload(0x60)
  4622 |     |             m4 := mload(0x80)
  4623 |     |             m5 := mload(0xa0)
  4624 |     |             m6 := mload(0xc0)
  4625 |     |             // Selector of `log(address,uint256,string,address)`.
  4626 |     |             mstore(0x00, 0x5c430d47)
  4627 |     |             mstore(0x20, p0)
  4628 |     |             mstore(0x40, p1)
  4629 |     |             mstore(0x60, 0x80)
  4630 |     |             mstore(0x80, p3)
  4631 |     |             writeString(0xa0, p2)
  4632 |     |         }
  4633 |     |         _sendLogPayload(0x1c, 0xc4);
  4634 |     |         /// @solidity memory-safe-assembly
  4635 |     |         assembly {
  4636 |     |             mstore(0x00, m0)
  4637 |     |             mstore(0x20, m1)
  4638 |     |             mstore(0x40, m2)
  4639 |     |             mstore(0x60, m3)
  4640 |     |             mstore(0x80, m4)
  4641 |     |             mstore(0xa0, m5)
  4642 |     |             mstore(0xc0, m6)
  4643 |     |         }
  4644 |     |     }
  4645 |     | 
  4646 |     |     function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  4647 |     |         bytes32 m0;
  4648 |     |         bytes32 m1;
  4649 |     |         bytes32 m2;
  4650 |     |         bytes32 m3;
  4651 |     |         bytes32 m4;
  4652 |     |         bytes32 m5;
  4653 |     |         bytes32 m6;
  4654 |     |         /// @solidity memory-safe-assembly
  4655 |     |         assembly {
  4656 |     |             function writeString(pos, w) {
  4657 |     |                 let length := 0
  4658 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4659 |     |                 mstore(pos, length)
  4660 |     |                 let shift := sub(256, shl(3, length))
  4661 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4662 |     |             }
  4663 |     |             m0 := mload(0x00)
  4664 |     |             m1 := mload(0x20)
  4665 |     |             m2 := mload(0x40)
  4666 |     |             m3 := mload(0x60)
  4667 |     |             m4 := mload(0x80)
  4668 |     |             m5 := mload(0xa0)
  4669 |     |             m6 := mload(0xc0)
  4670 |     |             // Selector of `log(address,uint256,string,bool)`.
  4671 |     |             mstore(0x00, 0xcf18105c)
  4672 |     |             mstore(0x20, p0)
  4673 |     |             mstore(0x40, p1)
  4674 |     |             mstore(0x60, 0x80)
  4675 |     |             mstore(0x80, p3)
  4676 |     |             writeString(0xa0, p2)
  4677 |     |         }
  4678 |     |         _sendLogPayload(0x1c, 0xc4);
  4679 |     |         /// @solidity memory-safe-assembly
  4680 |     |         assembly {
  4681 |     |             mstore(0x00, m0)
  4682 |     |             mstore(0x20, m1)
  4683 |     |             mstore(0x40, m2)
  4684 |     |             mstore(0x60, m3)
  4685 |     |             mstore(0x80, m4)
  4686 |     |             mstore(0xa0, m5)
  4687 |     |             mstore(0xc0, m6)
  4688 |     |         }
  4689 |     |     }
  4690 |     | 
  4691 |     |     function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  4692 |     |         bytes32 m0;
  4693 |     |         bytes32 m1;
  4694 |     |         bytes32 m2;
  4695 |     |         bytes32 m3;
  4696 |     |         bytes32 m4;
  4697 |     |         bytes32 m5;
  4698 |     |         bytes32 m6;
  4699 |     |         /// @solidity memory-safe-assembly
  4700 |     |         assembly {
  4701 |     |             function writeString(pos, w) {
  4702 |     |                 let length := 0
  4703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4704 |     |                 mstore(pos, length)
  4705 |     |                 let shift := sub(256, shl(3, length))
  4706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4707 |     |             }
  4708 |     |             m0 := mload(0x00)
  4709 |     |             m1 := mload(0x20)
  4710 |     |             m2 := mload(0x40)
  4711 |     |             m3 := mload(0x60)
  4712 |     |             m4 := mload(0x80)
  4713 |     |             m5 := mload(0xa0)
  4714 |     |             m6 := mload(0xc0)
  4715 |     |             // Selector of `log(address,uint256,string,uint256)`.
  4716 |     |             mstore(0x00, 0xbf01f891)
  4717 |     |             mstore(0x20, p0)
  4718 |     |             mstore(0x40, p1)
  4719 |     |             mstore(0x60, 0x80)
  4720 |     |             mstore(0x80, p3)
  4721 |     |             writeString(0xa0, p2)
  4722 |     |         }
  4723 |     |         _sendLogPayload(0x1c, 0xc4);
  4724 |     |         /// @solidity memory-safe-assembly
  4725 |     |         assembly {
  4726 |     |             mstore(0x00, m0)
  4727 |     |             mstore(0x20, m1)
  4728 |     |             mstore(0x40, m2)
  4729 |     |             mstore(0x60, m3)
  4730 |     |             mstore(0x80, m4)
  4731 |     |             mstore(0xa0, m5)
  4732 |     |             mstore(0xc0, m6)
  4733 |     |         }
  4734 |     |     }
  4735 |     | 
  4736 |     |     function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  4737 |     |         bytes32 m0;
  4738 |     |         bytes32 m1;
  4739 |     |         bytes32 m2;
  4740 |     |         bytes32 m3;
  4741 |     |         bytes32 m4;
  4742 |     |         bytes32 m5;
  4743 |     |         bytes32 m6;
  4744 |     |         bytes32 m7;
  4745 |     |         bytes32 m8;
  4746 |     |         /// @solidity memory-safe-assembly
  4747 |     |         assembly {
  4748 |     |             function writeString(pos, w) {
  4749 |     |                 let length := 0
  4750 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4751 |     |                 mstore(pos, length)
  4752 |     |                 let shift := sub(256, shl(3, length))
  4753 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4754 |     |             }
  4755 |     |             m0 := mload(0x00)
  4756 |     |             m1 := mload(0x20)
  4757 |     |             m2 := mload(0x40)
  4758 |     |             m3 := mload(0x60)
  4759 |     |             m4 := mload(0x80)
  4760 |     |             m5 := mload(0xa0)
  4761 |     |             m6 := mload(0xc0)
  4762 |     |             m7 := mload(0xe0)
  4763 |     |             m8 := mload(0x100)
  4764 |     |             // Selector of `log(address,uint256,string,string)`.
  4765 |     |             mstore(0x00, 0x88a8c406)
  4766 |     |             mstore(0x20, p0)
  4767 |     |             mstore(0x40, p1)
  4768 |     |             mstore(0x60, 0x80)
  4769 |     |             mstore(0x80, 0xc0)
  4770 |     |             writeString(0xa0, p2)
  4771 |     |             writeString(0xe0, p3)
  4772 |     |         }
  4773 |     |         _sendLogPayload(0x1c, 0x104);
  4774 |     |         /// @solidity memory-safe-assembly
  4775 |     |         assembly {
  4776 |     |             mstore(0x00, m0)
  4777 |     |             mstore(0x20, m1)
  4778 |     |             mstore(0x40, m2)
  4779 |     |             mstore(0x60, m3)
  4780 |     |             mstore(0x80, m4)
  4781 |     |             mstore(0xa0, m5)
  4782 |     |             mstore(0xc0, m6)
  4783 |     |             mstore(0xe0, m7)
  4784 |     |             mstore(0x100, m8)
  4785 |     |         }
  4786 |     |     }
  4787 |     | 
  4788 |     |     function log(address p0, bytes32 p1, address p2, address p3) internal pure {
  4789 |     |         bytes32 m0;
  4790 |     |         bytes32 m1;
  4791 |     |         bytes32 m2;
  4792 |     |         bytes32 m3;
  4793 |     |         bytes32 m4;
  4794 |     |         bytes32 m5;
  4795 |     |         bytes32 m6;
  4796 |     |         /// @solidity memory-safe-assembly
  4797 |     |         assembly {
  4798 |     |             function writeString(pos, w) {
  4799 |     |                 let length := 0
  4800 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4801 |     |                 mstore(pos, length)
  4802 |     |                 let shift := sub(256, shl(3, length))
  4803 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4804 |     |             }
  4805 |     |             m0 := mload(0x00)
  4806 |     |             m1 := mload(0x20)
  4807 |     |             m2 := mload(0x40)
  4808 |     |             m3 := mload(0x60)
  4809 |     |             m4 := mload(0x80)
  4810 |     |             m5 := mload(0xa0)
  4811 |     |             m6 := mload(0xc0)
  4812 |     |             // Selector of `log(address,string,address,address)`.
  4813 |     |             mstore(0x00, 0x0d36fa20)
  4814 |     |             mstore(0x20, p0)
  4815 |     |             mstore(0x40, 0x80)
  4816 |     |             mstore(0x60, p2)
  4817 |     |             mstore(0x80, p3)
  4818 |     |             writeString(0xa0, p1)
  4819 |     |         }
  4820 |     |         _sendLogPayload(0x1c, 0xc4);
  4821 |     |         /// @solidity memory-safe-assembly
  4822 |     |         assembly {
  4823 |     |             mstore(0x00, m0)
  4824 |     |             mstore(0x20, m1)
  4825 |     |             mstore(0x40, m2)
  4826 |     |             mstore(0x60, m3)
  4827 |     |             mstore(0x80, m4)
  4828 |     |             mstore(0xa0, m5)
  4829 |     |             mstore(0xc0, m6)
  4830 |     |         }
  4831 |     |     }
  4832 |     | 
  4833 |     |     function log(address p0, bytes32 p1, address p2, bool p3) internal pure {
  4834 |     |         bytes32 m0;
  4835 |     |         bytes32 m1;
  4836 |     |         bytes32 m2;
  4837 |     |         bytes32 m3;
  4838 |     |         bytes32 m4;
  4839 |     |         bytes32 m5;
  4840 |     |         bytes32 m6;
  4841 |     |         /// @solidity memory-safe-assembly
  4842 |     |         assembly {
  4843 |     |             function writeString(pos, w) {
  4844 |     |                 let length := 0
  4845 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4846 |     |                 mstore(pos, length)
  4847 |     |                 let shift := sub(256, shl(3, length))
  4848 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4849 |     |             }
  4850 |     |             m0 := mload(0x00)
  4851 |     |             m1 := mload(0x20)
  4852 |     |             m2 := mload(0x40)
  4853 |     |             m3 := mload(0x60)
  4854 |     |             m4 := mload(0x80)
  4855 |     |             m5 := mload(0xa0)
  4856 |     |             m6 := mload(0xc0)
  4857 |     |             // Selector of `log(address,string,address,bool)`.
  4858 |     |             mstore(0x00, 0x0df12b76)
  4859 |     |             mstore(0x20, p0)
  4860 |     |             mstore(0x40, 0x80)
  4861 |     |             mstore(0x60, p2)
  4862 |     |             mstore(0x80, p3)
  4863 |     |             writeString(0xa0, p1)
  4864 |     |         }
  4865 |     |         _sendLogPayload(0x1c, 0xc4);
  4866 |     |         /// @solidity memory-safe-assembly
  4867 |     |         assembly {
  4868 |     |             mstore(0x00, m0)
  4869 |     |             mstore(0x20, m1)
  4870 |     |             mstore(0x40, m2)
  4871 |     |             mstore(0x60, m3)
  4872 |     |             mstore(0x80, m4)
  4873 |     |             mstore(0xa0, m5)
  4874 |     |             mstore(0xc0, m6)
  4875 |     |         }
  4876 |     |     }
  4877 |     | 
  4878 |     |     function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {
  4879 |     |         bytes32 m0;
  4880 |     |         bytes32 m1;
  4881 |     |         bytes32 m2;
  4882 |     |         bytes32 m3;
  4883 |     |         bytes32 m4;
  4884 |     |         bytes32 m5;
  4885 |     |         bytes32 m6;
  4886 |     |         /// @solidity memory-safe-assembly
  4887 |     |         assembly {
  4888 |     |             function writeString(pos, w) {
  4889 |     |                 let length := 0
  4890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4891 |     |                 mstore(pos, length)
  4892 |     |                 let shift := sub(256, shl(3, length))
  4893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4894 |     |             }
  4895 |     |             m0 := mload(0x00)
  4896 |     |             m1 := mload(0x20)
  4897 |     |             m2 := mload(0x40)
  4898 |     |             m3 := mload(0x60)
  4899 |     |             m4 := mload(0x80)
  4900 |     |             m5 := mload(0xa0)
  4901 |     |             m6 := mload(0xc0)
  4902 |     |             // Selector of `log(address,string,address,uint256)`.
  4903 |     |             mstore(0x00, 0x457fe3cf)
  4904 |     |             mstore(0x20, p0)
  4905 |     |             mstore(0x40, 0x80)
  4906 |     |             mstore(0x60, p2)
  4907 |     |             mstore(0x80, p3)
  4908 |     |             writeString(0xa0, p1)
  4909 |     |         }
  4910 |     |         _sendLogPayload(0x1c, 0xc4);
  4911 |     |         /// @solidity memory-safe-assembly
  4912 |     |         assembly {
  4913 |     |             mstore(0x00, m0)
  4914 |     |             mstore(0x20, m1)
  4915 |     |             mstore(0x40, m2)
  4916 |     |             mstore(0x60, m3)
  4917 |     |             mstore(0x80, m4)
  4918 |     |             mstore(0xa0, m5)
  4919 |     |             mstore(0xc0, m6)
  4920 |     |         }
  4921 |     |     }
  4922 |     | 
  4923 |     |     function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  4924 |     |         bytes32 m0;
  4925 |     |         bytes32 m1;
  4926 |     |         bytes32 m2;
  4927 |     |         bytes32 m3;
  4928 |     |         bytes32 m4;
  4929 |     |         bytes32 m5;
  4930 |     |         bytes32 m6;
  4931 |     |         bytes32 m7;
  4932 |     |         bytes32 m8;
  4933 |     |         /// @solidity memory-safe-assembly
  4934 |     |         assembly {
  4935 |     |             function writeString(pos, w) {
  4936 |     |                 let length := 0
  4937 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4938 |     |                 mstore(pos, length)
  4939 |     |                 let shift := sub(256, shl(3, length))
  4940 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4941 |     |             }
  4942 |     |             m0 := mload(0x00)
  4943 |     |             m1 := mload(0x20)
  4944 |     |             m2 := mload(0x40)
  4945 |     |             m3 := mload(0x60)
  4946 |     |             m4 := mload(0x80)
  4947 |     |             m5 := mload(0xa0)
  4948 |     |             m6 := mload(0xc0)
  4949 |     |             m7 := mload(0xe0)
  4950 |     |             m8 := mload(0x100)
  4951 |     |             // Selector of `log(address,string,address,string)`.
  4952 |     |             mstore(0x00, 0xf7e36245)
  4953 |     |             mstore(0x20, p0)
  4954 |     |             mstore(0x40, 0x80)
  4955 |     |             mstore(0x60, p2)
  4956 |     |             mstore(0x80, 0xc0)
  4957 |     |             writeString(0xa0, p1)
  4958 |     |             writeString(0xe0, p3)
  4959 |     |         }
  4960 |     |         _sendLogPayload(0x1c, 0x104);
  4961 |     |         /// @solidity memory-safe-assembly
  4962 |     |         assembly {
  4963 |     |             mstore(0x00, m0)
  4964 |     |             mstore(0x20, m1)
  4965 |     |             mstore(0x40, m2)
  4966 |     |             mstore(0x60, m3)
  4967 |     |             mstore(0x80, m4)
  4968 |     |             mstore(0xa0, m5)
  4969 |     |             mstore(0xc0, m6)
  4970 |     |             mstore(0xe0, m7)
  4971 |     |             mstore(0x100, m8)
  4972 |     |         }
  4973 |     |     }
  4974 |     | 
  4975 |     |     function log(address p0, bytes32 p1, bool p2, address p3) internal pure {
  4976 |     |         bytes32 m0;
  4977 |     |         bytes32 m1;
  4978 |     |         bytes32 m2;
  4979 |     |         bytes32 m3;
  4980 |     |         bytes32 m4;
  4981 |     |         bytes32 m5;
  4982 |     |         bytes32 m6;
  4983 |     |         /// @solidity memory-safe-assembly
  4984 |     |         assembly {
  4985 |     |             function writeString(pos, w) {
  4986 |     |                 let length := 0
  4987 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4988 |     |                 mstore(pos, length)
  4989 |     |                 let shift := sub(256, shl(3, length))
  4990 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4991 |     |             }
  4992 |     |             m0 := mload(0x00)
  4993 |     |             m1 := mload(0x20)
  4994 |     |             m2 := mload(0x40)
  4995 |     |             m3 := mload(0x60)
  4996 |     |             m4 := mload(0x80)
  4997 |     |             m5 := mload(0xa0)
  4998 |     |             m6 := mload(0xc0)
  4999 |     |             // Selector of `log(address,string,bool,address)`.
  5000 |     |             mstore(0x00, 0x205871c2)
  5001 |     |             mstore(0x20, p0)
  5002 |     |             mstore(0x40, 0x80)
  5003 |     |             mstore(0x60, p2)
  5004 |     |             mstore(0x80, p3)
  5005 |     |             writeString(0xa0, p1)
  5006 |     |         }
  5007 |     |         _sendLogPayload(0x1c, 0xc4);
  5008 |     |         /// @solidity memory-safe-assembly
  5009 |     |         assembly {
  5010 |     |             mstore(0x00, m0)
  5011 |     |             mstore(0x20, m1)
  5012 |     |             mstore(0x40, m2)
  5013 |     |             mstore(0x60, m3)
  5014 |     |             mstore(0x80, m4)
  5015 |     |             mstore(0xa0, m5)
  5016 |     |             mstore(0xc0, m6)
  5017 |     |         }
  5018 |     |     }
  5019 |     | 
  5020 |     |     function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {
  5021 |     |         bytes32 m0;
  5022 |     |         bytes32 m1;
  5023 |     |         bytes32 m2;
  5024 |     |         bytes32 m3;
  5025 |     |         bytes32 m4;
  5026 |     |         bytes32 m5;
  5027 |     |         bytes32 m6;
  5028 |     |         /// @solidity memory-safe-assembly
  5029 |     |         assembly {
  5030 |     |             function writeString(pos, w) {
  5031 |     |                 let length := 0
  5032 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5033 |     |                 mstore(pos, length)
  5034 |     |                 let shift := sub(256, shl(3, length))
  5035 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5036 |     |             }
  5037 |     |             m0 := mload(0x00)
  5038 |     |             m1 := mload(0x20)
  5039 |     |             m2 := mload(0x40)
  5040 |     |             m3 := mload(0x60)
  5041 |     |             m4 := mload(0x80)
  5042 |     |             m5 := mload(0xa0)
  5043 |     |             m6 := mload(0xc0)
  5044 |     |             // Selector of `log(address,string,bool,bool)`.
  5045 |     |             mstore(0x00, 0x5f1d5c9f)
  5046 |     |             mstore(0x20, p0)
  5047 |     |             mstore(0x40, 0x80)
  5048 |     |             mstore(0x60, p2)
  5049 |     |             mstore(0x80, p3)
  5050 |     |             writeString(0xa0, p1)
  5051 |     |         }
  5052 |     |         _sendLogPayload(0x1c, 0xc4);
  5053 |     |         /// @solidity memory-safe-assembly
  5054 |     |         assembly {
  5055 |     |             mstore(0x00, m0)
  5056 |     |             mstore(0x20, m1)
  5057 |     |             mstore(0x40, m2)
  5058 |     |             mstore(0x60, m3)
  5059 |     |             mstore(0x80, m4)
  5060 |     |             mstore(0xa0, m5)
  5061 |     |             mstore(0xc0, m6)
  5062 |     |         }
  5063 |     |     }
  5064 |     | 
  5065 |     |     function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  5066 |     |         bytes32 m0;
  5067 |     |         bytes32 m1;
  5068 |     |         bytes32 m2;
  5069 |     |         bytes32 m3;
  5070 |     |         bytes32 m4;
  5071 |     |         bytes32 m5;
  5072 |     |         bytes32 m6;
  5073 |     |         /// @solidity memory-safe-assembly
  5074 |     |         assembly {
  5075 |     |             function writeString(pos, w) {
  5076 |     |                 let length := 0
  5077 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5078 |     |                 mstore(pos, length)
  5079 |     |                 let shift := sub(256, shl(3, length))
  5080 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5081 |     |             }
  5082 |     |             m0 := mload(0x00)
  5083 |     |             m1 := mload(0x20)
  5084 |     |             m2 := mload(0x40)
  5085 |     |             m3 := mload(0x60)
  5086 |     |             m4 := mload(0x80)
  5087 |     |             m5 := mload(0xa0)
  5088 |     |             m6 := mload(0xc0)
  5089 |     |             // Selector of `log(address,string,bool,uint256)`.
  5090 |     |             mstore(0x00, 0x515e38b6)
  5091 |     |             mstore(0x20, p0)
  5092 |     |             mstore(0x40, 0x80)
  5093 |     |             mstore(0x60, p2)
  5094 |     |             mstore(0x80, p3)
  5095 |     |             writeString(0xa0, p1)
  5096 |     |         }
  5097 |     |         _sendLogPayload(0x1c, 0xc4);
  5098 |     |         /// @solidity memory-safe-assembly
  5099 |     |         assembly {
  5100 |     |             mstore(0x00, m0)
  5101 |     |             mstore(0x20, m1)
  5102 |     |             mstore(0x40, m2)
  5103 |     |             mstore(0x60, m3)
  5104 |     |             mstore(0x80, m4)
  5105 |     |             mstore(0xa0, m5)
  5106 |     |             mstore(0xc0, m6)
  5107 |     |         }
  5108 |     |     }
  5109 |     | 
  5110 |     |     function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  5111 |     |         bytes32 m0;
  5112 |     |         bytes32 m1;
  5113 |     |         bytes32 m2;
  5114 |     |         bytes32 m3;
  5115 |     |         bytes32 m4;
  5116 |     |         bytes32 m5;
  5117 |     |         bytes32 m6;
  5118 |     |         bytes32 m7;
  5119 |     |         bytes32 m8;
  5120 |     |         /// @solidity memory-safe-assembly
  5121 |     |         assembly {
  5122 |     |             function writeString(pos, w) {
  5123 |     |                 let length := 0
  5124 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5125 |     |                 mstore(pos, length)
  5126 |     |                 let shift := sub(256, shl(3, length))
  5127 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5128 |     |             }
  5129 |     |             m0 := mload(0x00)
  5130 |     |             m1 := mload(0x20)
  5131 |     |             m2 := mload(0x40)
  5132 |     |             m3 := mload(0x60)
  5133 |     |             m4 := mload(0x80)
  5134 |     |             m5 := mload(0xa0)
  5135 |     |             m6 := mload(0xc0)
  5136 |     |             m7 := mload(0xe0)
  5137 |     |             m8 := mload(0x100)
  5138 |     |             // Selector of `log(address,string,bool,string)`.
  5139 |     |             mstore(0x00, 0xbc0b61fe)
  5140 |     |             mstore(0x20, p0)
  5141 |     |             mstore(0x40, 0x80)
  5142 |     |             mstore(0x60, p2)
  5143 |     |             mstore(0x80, 0xc0)
  5144 |     |             writeString(0xa0, p1)
  5145 |     |             writeString(0xe0, p3)
  5146 |     |         }
  5147 |     |         _sendLogPayload(0x1c, 0x104);
  5148 |     |         /// @solidity memory-safe-assembly
  5149 |     |         assembly {
  5150 |     |             mstore(0x00, m0)
  5151 |     |             mstore(0x20, m1)
  5152 |     |             mstore(0x40, m2)
  5153 |     |             mstore(0x60, m3)
  5154 |     |             mstore(0x80, m4)
  5155 |     |             mstore(0xa0, m5)
  5156 |     |             mstore(0xc0, m6)
  5157 |     |             mstore(0xe0, m7)
  5158 |     |             mstore(0x100, m8)
  5159 |     |         }
  5160 |     |     }
  5161 |     | 
  5162 |     |     function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {
  5163 |     |         bytes32 m0;
  5164 |     |         bytes32 m1;
  5165 |     |         bytes32 m2;
  5166 |     |         bytes32 m3;
  5167 |     |         bytes32 m4;
  5168 |     |         bytes32 m5;
  5169 |     |         bytes32 m6;
  5170 |     |         /// @solidity memory-safe-assembly
  5171 |     |         assembly {
  5172 |     |             function writeString(pos, w) {
  5173 |     |                 let length := 0
  5174 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5175 |     |                 mstore(pos, length)
  5176 |     |                 let shift := sub(256, shl(3, length))
  5177 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5178 |     |             }
  5179 |     |             m0 := mload(0x00)
  5180 |     |             m1 := mload(0x20)
  5181 |     |             m2 := mload(0x40)
  5182 |     |             m3 := mload(0x60)
  5183 |     |             m4 := mload(0x80)
  5184 |     |             m5 := mload(0xa0)
  5185 |     |             m6 := mload(0xc0)
  5186 |     |             // Selector of `log(address,string,uint256,address)`.
  5187 |     |             mstore(0x00, 0x63183678)
  5188 |     |             mstore(0x20, p0)
  5189 |     |             mstore(0x40, 0x80)
  5190 |     |             mstore(0x60, p2)
  5191 |     |             mstore(0x80, p3)
  5192 |     |             writeString(0xa0, p1)
  5193 |     |         }
  5194 |     |         _sendLogPayload(0x1c, 0xc4);
  5195 |     |         /// @solidity memory-safe-assembly
  5196 |     |         assembly {
  5197 |     |             mstore(0x00, m0)
  5198 |     |             mstore(0x20, m1)
  5199 |     |             mstore(0x40, m2)
  5200 |     |             mstore(0x60, m3)
  5201 |     |             mstore(0x80, m4)
  5202 |     |             mstore(0xa0, m5)
  5203 |     |             mstore(0xc0, m6)
  5204 |     |         }
  5205 |     |     }
  5206 |     | 
  5207 |     |     function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  5208 |     |         bytes32 m0;
  5209 |     |         bytes32 m1;
  5210 |     |         bytes32 m2;
  5211 |     |         bytes32 m3;
  5212 |     |         bytes32 m4;
  5213 |     |         bytes32 m5;
  5214 |     |         bytes32 m6;
  5215 |     |         /// @solidity memory-safe-assembly
  5216 |     |         assembly {
  5217 |     |             function writeString(pos, w) {
  5218 |     |                 let length := 0
  5219 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5220 |     |                 mstore(pos, length)
  5221 |     |                 let shift := sub(256, shl(3, length))
  5222 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5223 |     |             }
  5224 |     |             m0 := mload(0x00)
  5225 |     |             m1 := mload(0x20)
  5226 |     |             m2 := mload(0x40)
  5227 |     |             m3 := mload(0x60)
  5228 |     |             m4 := mload(0x80)
  5229 |     |             m5 := mload(0xa0)
  5230 |     |             m6 := mload(0xc0)
  5231 |     |             // Selector of `log(address,string,uint256,bool)`.
  5232 |     |             mstore(0x00, 0x0ef7e050)
  5233 |     |             mstore(0x20, p0)
  5234 |     |             mstore(0x40, 0x80)
  5235 |     |             mstore(0x60, p2)
  5236 |     |             mstore(0x80, p3)
  5237 |     |             writeString(0xa0, p1)
  5238 |     |         }
  5239 |     |         _sendLogPayload(0x1c, 0xc4);
  5240 |     |         /// @solidity memory-safe-assembly
  5241 |     |         assembly {
  5242 |     |             mstore(0x00, m0)
  5243 |     |             mstore(0x20, m1)
  5244 |     |             mstore(0x40, m2)
  5245 |     |             mstore(0x60, m3)
  5246 |     |             mstore(0x80, m4)
  5247 |     |             mstore(0xa0, m5)
  5248 |     |             mstore(0xc0, m6)
  5249 |     |         }
  5250 |     |     }
  5251 |     | 
  5252 |     |     function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  5253 |     |         bytes32 m0;
  5254 |     |         bytes32 m1;
  5255 |     |         bytes32 m2;
  5256 |     |         bytes32 m3;
  5257 |     |         bytes32 m4;
  5258 |     |         bytes32 m5;
  5259 |     |         bytes32 m6;
  5260 |     |         /// @solidity memory-safe-assembly
  5261 |     |         assembly {
  5262 |     |             function writeString(pos, w) {
  5263 |     |                 let length := 0
  5264 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5265 |     |                 mstore(pos, length)
  5266 |     |                 let shift := sub(256, shl(3, length))
  5267 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5268 |     |             }
  5269 |     |             m0 := mload(0x00)
  5270 |     |             m1 := mload(0x20)
  5271 |     |             m2 := mload(0x40)
  5272 |     |             m3 := mload(0x60)
  5273 |     |             m4 := mload(0x80)
  5274 |     |             m5 := mload(0xa0)
  5275 |     |             m6 := mload(0xc0)
  5276 |     |             // Selector of `log(address,string,uint256,uint256)`.
  5277 |     |             mstore(0x00, 0x1dc8e1b8)
  5278 |     |             mstore(0x20, p0)
  5279 |     |             mstore(0x40, 0x80)
  5280 |     |             mstore(0x60, p2)
  5281 |     |             mstore(0x80, p3)
  5282 |     |             writeString(0xa0, p1)
  5283 |     |         }
  5284 |     |         _sendLogPayload(0x1c, 0xc4);
  5285 |     |         /// @solidity memory-safe-assembly
  5286 |     |         assembly {
  5287 |     |             mstore(0x00, m0)
  5288 |     |             mstore(0x20, m1)
  5289 |     |             mstore(0x40, m2)
  5290 |     |             mstore(0x60, m3)
  5291 |     |             mstore(0x80, m4)
  5292 |     |             mstore(0xa0, m5)
  5293 |     |             mstore(0xc0, m6)
  5294 |     |         }
  5295 |     |     }
  5296 |     | 
  5297 |     |     function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  5298 |     |         bytes32 m0;
  5299 |     |         bytes32 m1;
  5300 |     |         bytes32 m2;
  5301 |     |         bytes32 m3;
  5302 |     |         bytes32 m4;
  5303 |     |         bytes32 m5;
  5304 |     |         bytes32 m6;
  5305 |     |         bytes32 m7;
  5306 |     |         bytes32 m8;
  5307 |     |         /// @solidity memory-safe-assembly
  5308 |     |         assembly {
  5309 |     |             function writeString(pos, w) {
  5310 |     |                 let length := 0
  5311 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5312 |     |                 mstore(pos, length)
  5313 |     |                 let shift := sub(256, shl(3, length))
  5314 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5315 |     |             }
  5316 |     |             m0 := mload(0x00)
  5317 |     |             m1 := mload(0x20)
  5318 |     |             m2 := mload(0x40)
  5319 |     |             m3 := mload(0x60)
  5320 |     |             m4 := mload(0x80)
  5321 |     |             m5 := mload(0xa0)
  5322 |     |             m6 := mload(0xc0)
  5323 |     |             m7 := mload(0xe0)
  5324 |     |             m8 := mload(0x100)
  5325 |     |             // Selector of `log(address,string,uint256,string)`.
  5326 |     |             mstore(0x00, 0x448830a8)
  5327 |     |             mstore(0x20, p0)
  5328 |     |             mstore(0x40, 0x80)
  5329 |     |             mstore(0x60, p2)
  5330 |     |             mstore(0x80, 0xc0)
  5331 |     |             writeString(0xa0, p1)
  5332 |     |             writeString(0xe0, p3)
  5333 |     |         }
  5334 |     |         _sendLogPayload(0x1c, 0x104);
  5335 |     |         /// @solidity memory-safe-assembly
  5336 |     |         assembly {
  5337 |     |             mstore(0x00, m0)
  5338 |     |             mstore(0x20, m1)
  5339 |     |             mstore(0x40, m2)
  5340 |     |             mstore(0x60, m3)
  5341 |     |             mstore(0x80, m4)
  5342 |     |             mstore(0xa0, m5)
  5343 |     |             mstore(0xc0, m6)
  5344 |     |             mstore(0xe0, m7)
  5345 |     |             mstore(0x100, m8)
  5346 |     |         }
  5347 |     |     }
  5348 |     | 
  5349 |     |     function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  5350 |     |         bytes32 m0;
  5351 |     |         bytes32 m1;
  5352 |     |         bytes32 m2;
  5353 |     |         bytes32 m3;
  5354 |     |         bytes32 m4;
  5355 |     |         bytes32 m5;
  5356 |     |         bytes32 m6;
  5357 |     |         bytes32 m7;
  5358 |     |         bytes32 m8;
  5359 |     |         /// @solidity memory-safe-assembly
  5360 |     |         assembly {
  5361 |     |             function writeString(pos, w) {
  5362 |     |                 let length := 0
  5363 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5364 |     |                 mstore(pos, length)
  5365 |     |                 let shift := sub(256, shl(3, length))
  5366 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5367 |     |             }
  5368 |     |             m0 := mload(0x00)
  5369 |     |             m1 := mload(0x20)
  5370 |     |             m2 := mload(0x40)
  5371 |     |             m3 := mload(0x60)
  5372 |     |             m4 := mload(0x80)
  5373 |     |             m5 := mload(0xa0)
  5374 |     |             m6 := mload(0xc0)
  5375 |     |             m7 := mload(0xe0)
  5376 |     |             m8 := mload(0x100)
  5377 |     |             // Selector of `log(address,string,string,address)`.
  5378 |     |             mstore(0x00, 0xa04e2f87)
  5379 |     |             mstore(0x20, p0)
  5380 |     |             mstore(0x40, 0x80)
  5381 |     |             mstore(0x60, 0xc0)
  5382 |     |             mstore(0x80, p3)
  5383 |     |             writeString(0xa0, p1)
  5384 |     |             writeString(0xe0, p2)
  5385 |     |         }
  5386 |     |         _sendLogPayload(0x1c, 0x104);
  5387 |     |         /// @solidity memory-safe-assembly
  5388 |     |         assembly {
  5389 |     |             mstore(0x00, m0)
  5390 |     |             mstore(0x20, m1)
  5391 |     |             mstore(0x40, m2)
  5392 |     |             mstore(0x60, m3)
  5393 |     |             mstore(0x80, m4)
  5394 |     |             mstore(0xa0, m5)
  5395 |     |             mstore(0xc0, m6)
  5396 |     |             mstore(0xe0, m7)
  5397 |     |             mstore(0x100, m8)
  5398 |     |         }
  5399 |     |     }
  5400 |     | 
  5401 |     |     function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  5402 |     |         bytes32 m0;
  5403 |     |         bytes32 m1;
  5404 |     |         bytes32 m2;
  5405 |     |         bytes32 m3;
  5406 |     |         bytes32 m4;
  5407 |     |         bytes32 m5;
  5408 |     |         bytes32 m6;
  5409 |     |         bytes32 m7;
  5410 |     |         bytes32 m8;
  5411 |     |         /// @solidity memory-safe-assembly
  5412 |     |         assembly {
  5413 |     |             function writeString(pos, w) {
  5414 |     |                 let length := 0
  5415 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5416 |     |                 mstore(pos, length)
  5417 |     |                 let shift := sub(256, shl(3, length))
  5418 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5419 |     |             }
  5420 |     |             m0 := mload(0x00)
  5421 |     |             m1 := mload(0x20)
  5422 |     |             m2 := mload(0x40)
  5423 |     |             m3 := mload(0x60)
  5424 |     |             m4 := mload(0x80)
  5425 |     |             m5 := mload(0xa0)
  5426 |     |             m6 := mload(0xc0)
  5427 |     |             m7 := mload(0xe0)
  5428 |     |             m8 := mload(0x100)
  5429 |     |             // Selector of `log(address,string,string,bool)`.
  5430 |     |             mstore(0x00, 0x35a5071f)
  5431 |     |             mstore(0x20, p0)
  5432 |     |             mstore(0x40, 0x80)
  5433 |     |             mstore(0x60, 0xc0)
  5434 |     |             mstore(0x80, p3)
  5435 |     |             writeString(0xa0, p1)
  5436 |     |             writeString(0xe0, p2)
  5437 |     |         }
  5438 |     |         _sendLogPayload(0x1c, 0x104);
  5439 |     |         /// @solidity memory-safe-assembly
  5440 |     |         assembly {
  5441 |     |             mstore(0x00, m0)
  5442 |     |             mstore(0x20, m1)
  5443 |     |             mstore(0x40, m2)
  5444 |     |             mstore(0x60, m3)
  5445 |     |             mstore(0x80, m4)
  5446 |     |             mstore(0xa0, m5)
  5447 |     |             mstore(0xc0, m6)
  5448 |     |             mstore(0xe0, m7)
  5449 |     |             mstore(0x100, m8)
  5450 |     |         }
  5451 |     |     }
  5452 |     | 
  5453 |     |     function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  5454 |     |         bytes32 m0;
  5455 |     |         bytes32 m1;
  5456 |     |         bytes32 m2;
  5457 |     |         bytes32 m3;
  5458 |     |         bytes32 m4;
  5459 |     |         bytes32 m5;
  5460 |     |         bytes32 m6;
  5461 |     |         bytes32 m7;
  5462 |     |         bytes32 m8;
  5463 |     |         /// @solidity memory-safe-assembly
  5464 |     |         assembly {
  5465 |     |             function writeString(pos, w) {
  5466 |     |                 let length := 0
  5467 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5468 |     |                 mstore(pos, length)
  5469 |     |                 let shift := sub(256, shl(3, length))
  5470 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5471 |     |             }
  5472 |     |             m0 := mload(0x00)
  5473 |     |             m1 := mload(0x20)
  5474 |     |             m2 := mload(0x40)
  5475 |     |             m3 := mload(0x60)
  5476 |     |             m4 := mload(0x80)
  5477 |     |             m5 := mload(0xa0)
  5478 |     |             m6 := mload(0xc0)
  5479 |     |             m7 := mload(0xe0)
  5480 |     |             m8 := mload(0x100)
  5481 |     |             // Selector of `log(address,string,string,uint256)`.
  5482 |     |             mstore(0x00, 0x159f8927)
  5483 |     |             mstore(0x20, p0)
  5484 |     |             mstore(0x40, 0x80)
  5485 |     |             mstore(0x60, 0xc0)
  5486 |     |             mstore(0x80, p3)
  5487 |     |             writeString(0xa0, p1)
  5488 |     |             writeString(0xe0, p2)
  5489 |     |         }
  5490 |     |         _sendLogPayload(0x1c, 0x104);
  5491 |     |         /// @solidity memory-safe-assembly
  5492 |     |         assembly {
  5493 |     |             mstore(0x00, m0)
  5494 |     |             mstore(0x20, m1)
  5495 |     |             mstore(0x40, m2)
  5496 |     |             mstore(0x60, m3)
  5497 |     |             mstore(0x80, m4)
  5498 |     |             mstore(0xa0, m5)
  5499 |     |             mstore(0xc0, m6)
  5500 |     |             mstore(0xe0, m7)
  5501 |     |             mstore(0x100, m8)
  5502 |     |         }
  5503 |     |     }
  5504 |     | 
  5505 |     |     function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  5506 |     |         bytes32 m0;
  5507 |     |         bytes32 m1;
  5508 |     |         bytes32 m2;
  5509 |     |         bytes32 m3;
  5510 |     |         bytes32 m4;
  5511 |     |         bytes32 m5;
  5512 |     |         bytes32 m6;
  5513 |     |         bytes32 m7;
  5514 |     |         bytes32 m8;
  5515 |     |         bytes32 m9;
  5516 |     |         bytes32 m10;
  5517 |     |         /// @solidity memory-safe-assembly
  5518 |     |         assembly {
  5519 |     |             function writeString(pos, w) {
  5520 |     |                 let length := 0
  5521 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5522 |     |                 mstore(pos, length)
  5523 |     |                 let shift := sub(256, shl(3, length))
  5524 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5525 |     |             }
  5526 |     |             m0 := mload(0x00)
  5527 |     |             m1 := mload(0x20)
  5528 |     |             m2 := mload(0x40)
  5529 |     |             m3 := mload(0x60)
  5530 |     |             m4 := mload(0x80)
  5531 |     |             m5 := mload(0xa0)
  5532 |     |             m6 := mload(0xc0)
  5533 |     |             m7 := mload(0xe0)
  5534 |     |             m8 := mload(0x100)
  5535 |     |             m9 := mload(0x120)
  5536 |     |             m10 := mload(0x140)
  5537 |     |             // Selector of `log(address,string,string,string)`.
  5538 |     |             mstore(0x00, 0x5d02c50b)
  5539 |     |             mstore(0x20, p0)
  5540 |     |             mstore(0x40, 0x80)
  5541 |     |             mstore(0x60, 0xc0)
  5542 |     |             mstore(0x80, 0x100)
  5543 |     |             writeString(0xa0, p1)
  5544 |     |             writeString(0xe0, p2)
  5545 |     |             writeString(0x120, p3)
  5546 |     |         }
  5547 |     |         _sendLogPayload(0x1c, 0x144);
  5548 |     |         /// @solidity memory-safe-assembly
  5549 |     |         assembly {
  5550 |     |             mstore(0x00, m0)
  5551 |     |             mstore(0x20, m1)
  5552 |     |             mstore(0x40, m2)
  5553 |     |             mstore(0x60, m3)
  5554 |     |             mstore(0x80, m4)
  5555 |     |             mstore(0xa0, m5)
  5556 |     |             mstore(0xc0, m6)
  5557 |     |             mstore(0xe0, m7)
  5558 |     |             mstore(0x100, m8)
  5559 |     |             mstore(0x120, m9)
  5560 |     |             mstore(0x140, m10)
  5561 |     |         }
  5562 |     |     }
  5563 |     | 
  5564 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
  5565 |     |         bytes32 m0;
  5566 |     |         bytes32 m1;
  5567 |     |         bytes32 m2;
  5568 |     |         bytes32 m3;
  5569 |     |         bytes32 m4;
  5570 |     |         /// @solidity memory-safe-assembly
  5571 |     |         assembly {
  5572 |     |             m0 := mload(0x00)
  5573 |     |             m1 := mload(0x20)
  5574 |     |             m2 := mload(0x40)
  5575 |     |             m3 := mload(0x60)
  5576 |     |             m4 := mload(0x80)
  5577 |     |             // Selector of `log(bool,address,address,address)`.
  5578 |     |             mstore(0x00, 0x1d14d001)
  5579 |     |             mstore(0x20, p0)
  5580 |     |             mstore(0x40, p1)
  5581 |     |             mstore(0x60, p2)
  5582 |     |             mstore(0x80, p3)
  5583 |     |         }
  5584 |     |         _sendLogPayload(0x1c, 0x84);
  5585 |     |         /// @solidity memory-safe-assembly
  5586 |     |         assembly {
  5587 |     |             mstore(0x00, m0)
  5588 |     |             mstore(0x20, m1)
  5589 |     |             mstore(0x40, m2)
  5590 |     |             mstore(0x60, m3)
  5591 |     |             mstore(0x80, m4)
  5592 |     |         }
  5593 |     |     }
  5594 |     | 
  5595 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
  5596 |     |         bytes32 m0;
  5597 |     |         bytes32 m1;
  5598 |     |         bytes32 m2;
  5599 |     |         bytes32 m3;
  5600 |     |         bytes32 m4;
  5601 |     |         /// @solidity memory-safe-assembly
  5602 |     |         assembly {
  5603 |     |             m0 := mload(0x00)
  5604 |     |             m1 := mload(0x20)
  5605 |     |             m2 := mload(0x40)
  5606 |     |             m3 := mload(0x60)
  5607 |     |             m4 := mload(0x80)
  5608 |     |             // Selector of `log(bool,address,address,bool)`.
  5609 |     |             mstore(0x00, 0x46600be0)
  5610 |     |             mstore(0x20, p0)
  5611 |     |             mstore(0x40, p1)
  5612 |     |             mstore(0x60, p2)
  5613 |     |             mstore(0x80, p3)
  5614 |     |         }
  5615 |     |         _sendLogPayload(0x1c, 0x84);
  5616 |     |         /// @solidity memory-safe-assembly
  5617 |     |         assembly {
  5618 |     |             mstore(0x00, m0)
  5619 |     |             mstore(0x20, m1)
  5620 |     |             mstore(0x40, m2)
  5621 |     |             mstore(0x60, m3)
  5622 |     |             mstore(0x80, m4)
  5623 |     |         }
  5624 |     |     }
  5625 |     | 
  5626 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
  5627 |     |         bytes32 m0;
  5628 |     |         bytes32 m1;
  5629 |     |         bytes32 m2;
  5630 |     |         bytes32 m3;
  5631 |     |         bytes32 m4;
  5632 |     |         /// @solidity memory-safe-assembly
  5633 |     |         assembly {
  5634 |     |             m0 := mload(0x00)
  5635 |     |             m1 := mload(0x20)
  5636 |     |             m2 := mload(0x40)
  5637 |     |             m3 := mload(0x60)
  5638 |     |             m4 := mload(0x80)
  5639 |     |             // Selector of `log(bool,address,address,uint256)`.
  5640 |     |             mstore(0x00, 0x0c66d1be)
  5641 |     |             mstore(0x20, p0)
  5642 |     |             mstore(0x40, p1)
  5643 |     |             mstore(0x60, p2)
  5644 |     |             mstore(0x80, p3)
  5645 |     |         }
  5646 |     |         _sendLogPayload(0x1c, 0x84);
  5647 |     |         /// @solidity memory-safe-assembly
  5648 |     |         assembly {
  5649 |     |             mstore(0x00, m0)
  5650 |     |             mstore(0x20, m1)
  5651 |     |             mstore(0x40, m2)
  5652 |     |             mstore(0x60, m3)
  5653 |     |             mstore(0x80, m4)
  5654 |     |         }
  5655 |     |     }
  5656 |     | 
  5657 |     |     function log(bool p0, address p1, address p2, bytes32 p3) internal pure {
  5658 |     |         bytes32 m0;
  5659 |     |         bytes32 m1;
  5660 |     |         bytes32 m2;
  5661 |     |         bytes32 m3;
  5662 |     |         bytes32 m4;
  5663 |     |         bytes32 m5;
  5664 |     |         bytes32 m6;
  5665 |     |         /// @solidity memory-safe-assembly
  5666 |     |         assembly {
  5667 |     |             function writeString(pos, w) {
  5668 |     |                 let length := 0
  5669 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5670 |     |                 mstore(pos, length)
  5671 |     |                 let shift := sub(256, shl(3, length))
  5672 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5673 |     |             }
  5674 |     |             m0 := mload(0x00)
  5675 |     |             m1 := mload(0x20)
  5676 |     |             m2 := mload(0x40)
  5677 |     |             m3 := mload(0x60)
  5678 |     |             m4 := mload(0x80)
  5679 |     |             m5 := mload(0xa0)
  5680 |     |             m6 := mload(0xc0)
  5681 |     |             // Selector of `log(bool,address,address,string)`.
  5682 |     |             mstore(0x00, 0xd812a167)
  5683 |     |             mstore(0x20, p0)
  5684 |     |             mstore(0x40, p1)
  5685 |     |             mstore(0x60, p2)
  5686 |     |             mstore(0x80, 0x80)
  5687 |     |             writeString(0xa0, p3)
  5688 |     |         }
  5689 |     |         _sendLogPayload(0x1c, 0xc4);
  5690 |     |         /// @solidity memory-safe-assembly
  5691 |     |         assembly {
  5692 |     |             mstore(0x00, m0)
  5693 |     |             mstore(0x20, m1)
  5694 |     |             mstore(0x40, m2)
  5695 |     |             mstore(0x60, m3)
  5696 |     |             mstore(0x80, m4)
  5697 |     |             mstore(0xa0, m5)
  5698 |     |             mstore(0xc0, m6)
  5699 |     |         }
  5700 |     |     }
  5701 |     | 
  5702 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
  5703 |     |         bytes32 m0;
  5704 |     |         bytes32 m1;
  5705 |     |         bytes32 m2;
  5706 |     |         bytes32 m3;
  5707 |     |         bytes32 m4;
  5708 |     |         /// @solidity memory-safe-assembly
  5709 |     |         assembly {
  5710 |     |             m0 := mload(0x00)
  5711 |     |             m1 := mload(0x20)
  5712 |     |             m2 := mload(0x40)
  5713 |     |             m3 := mload(0x60)
  5714 |     |             m4 := mload(0x80)
  5715 |     |             // Selector of `log(bool,address,bool,address)`.
  5716 |     |             mstore(0x00, 0x1c41a336)
  5717 |     |             mstore(0x20, p0)
  5718 |     |             mstore(0x40, p1)
  5719 |     |             mstore(0x60, p2)
  5720 |     |             mstore(0x80, p3)
  5721 |     |         }
  5722 |     |         _sendLogPayload(0x1c, 0x84);
  5723 |     |         /// @solidity memory-safe-assembly
  5724 |     |         assembly {
  5725 |     |             mstore(0x00, m0)
  5726 |     |             mstore(0x20, m1)
  5727 |     |             mstore(0x40, m2)
  5728 |     |             mstore(0x60, m3)
  5729 |     |             mstore(0x80, m4)
  5730 |     |         }
  5731 |     |     }
  5732 |     | 
  5733 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
  5734 |     |         bytes32 m0;
  5735 |     |         bytes32 m1;
  5736 |     |         bytes32 m2;
  5737 |     |         bytes32 m3;
  5738 |     |         bytes32 m4;
  5739 |     |         /// @solidity memory-safe-assembly
  5740 |     |         assembly {
  5741 |     |             m0 := mload(0x00)
  5742 |     |             m1 := mload(0x20)
  5743 |     |             m2 := mload(0x40)
  5744 |     |             m3 := mload(0x60)
  5745 |     |             m4 := mload(0x80)
  5746 |     |             // Selector of `log(bool,address,bool,bool)`.
  5747 |     |             mstore(0x00, 0x6a9c478b)
  5748 |     |             mstore(0x20, p0)
  5749 |     |             mstore(0x40, p1)
  5750 |     |             mstore(0x60, p2)
  5751 |     |             mstore(0x80, p3)
  5752 |     |         }
  5753 |     |         _sendLogPayload(0x1c, 0x84);
  5754 |     |         /// @solidity memory-safe-assembly
  5755 |     |         assembly {
  5756 |     |             mstore(0x00, m0)
  5757 |     |             mstore(0x20, m1)
  5758 |     |             mstore(0x40, m2)
  5759 |     |             mstore(0x60, m3)
  5760 |     |             mstore(0x80, m4)
  5761 |     |         }
  5762 |     |     }
  5763 |     | 
  5764 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
  5765 |     |         bytes32 m0;
  5766 |     |         bytes32 m1;
  5767 |     |         bytes32 m2;
  5768 |     |         bytes32 m3;
  5769 |     |         bytes32 m4;
  5770 |     |         /// @solidity memory-safe-assembly
  5771 |     |         assembly {
  5772 |     |             m0 := mload(0x00)
  5773 |     |             m1 := mload(0x20)
  5774 |     |             m2 := mload(0x40)
  5775 |     |             m3 := mload(0x60)
  5776 |     |             m4 := mload(0x80)
  5777 |     |             // Selector of `log(bool,address,bool,uint256)`.
  5778 |     |             mstore(0x00, 0x07831502)
  5779 |     |             mstore(0x20, p0)
  5780 |     |             mstore(0x40, p1)
  5781 |     |             mstore(0x60, p2)
  5782 |     |             mstore(0x80, p3)
  5783 |     |         }
  5784 |     |         _sendLogPayload(0x1c, 0x84);
  5785 |     |         /// @solidity memory-safe-assembly
  5786 |     |         assembly {
  5787 |     |             mstore(0x00, m0)
  5788 |     |             mstore(0x20, m1)
  5789 |     |             mstore(0x40, m2)
  5790 |     |             mstore(0x60, m3)
  5791 |     |             mstore(0x80, m4)
  5792 |     |         }
  5793 |     |     }
  5794 |     | 
  5795 |     |     function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {
  5796 |     |         bytes32 m0;
  5797 |     |         bytes32 m1;
  5798 |     |         bytes32 m2;
  5799 |     |         bytes32 m3;
  5800 |     |         bytes32 m4;
  5801 |     |         bytes32 m5;
  5802 |     |         bytes32 m6;
  5803 |     |         /// @solidity memory-safe-assembly
  5804 |     |         assembly {
  5805 |     |             function writeString(pos, w) {
  5806 |     |                 let length := 0
  5807 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5808 |     |                 mstore(pos, length)
  5809 |     |                 let shift := sub(256, shl(3, length))
  5810 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5811 |     |             }
  5812 |     |             m0 := mload(0x00)
  5813 |     |             m1 := mload(0x20)
  5814 |     |             m2 := mload(0x40)
  5815 |     |             m3 := mload(0x60)
  5816 |     |             m4 := mload(0x80)
  5817 |     |             m5 := mload(0xa0)
  5818 |     |             m6 := mload(0xc0)
  5819 |     |             // Selector of `log(bool,address,bool,string)`.
  5820 |     |             mstore(0x00, 0x4a66cb34)
  5821 |     |             mstore(0x20, p0)
  5822 |     |             mstore(0x40, p1)
  5823 |     |             mstore(0x60, p2)
  5824 |     |             mstore(0x80, 0x80)
  5825 |     |             writeString(0xa0, p3)
  5826 |     |         }
  5827 |     |         _sendLogPayload(0x1c, 0xc4);
  5828 |     |         /// @solidity memory-safe-assembly
  5829 |     |         assembly {
  5830 |     |             mstore(0x00, m0)
  5831 |     |             mstore(0x20, m1)
  5832 |     |             mstore(0x40, m2)
  5833 |     |             mstore(0x60, m3)
  5834 |     |             mstore(0x80, m4)
  5835 |     |             mstore(0xa0, m5)
  5836 |     |             mstore(0xc0, m6)
  5837 |     |         }
  5838 |     |     }
  5839 |     | 
  5840 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
  5841 |     |         bytes32 m0;
  5842 |     |         bytes32 m1;
  5843 |     |         bytes32 m2;
  5844 |     |         bytes32 m3;
  5845 |     |         bytes32 m4;
  5846 |     |         /// @solidity memory-safe-assembly
  5847 |     |         assembly {
  5848 |     |             m0 := mload(0x00)
  5849 |     |             m1 := mload(0x20)
  5850 |     |             m2 := mload(0x40)
  5851 |     |             m3 := mload(0x60)
  5852 |     |             m4 := mload(0x80)
  5853 |     |             // Selector of `log(bool,address,uint256,address)`.
  5854 |     |             mstore(0x00, 0x136b05dd)
  5855 |     |             mstore(0x20, p0)
  5856 |     |             mstore(0x40, p1)
  5857 |     |             mstore(0x60, p2)
  5858 |     |             mstore(0x80, p3)
  5859 |     |         }
  5860 |     |         _sendLogPayload(0x1c, 0x84);
  5861 |     |         /// @solidity memory-safe-assembly
  5862 |     |         assembly {
  5863 |     |             mstore(0x00, m0)
  5864 |     |             mstore(0x20, m1)
  5865 |     |             mstore(0x40, m2)
  5866 |     |             mstore(0x60, m3)
  5867 |     |             mstore(0x80, m4)
  5868 |     |         }
  5869 |     |     }
  5870 |     | 
  5871 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
  5872 |     |         bytes32 m0;
  5873 |     |         bytes32 m1;
  5874 |     |         bytes32 m2;
  5875 |     |         bytes32 m3;
  5876 |     |         bytes32 m4;
  5877 |     |         /// @solidity memory-safe-assembly
  5878 |     |         assembly {
  5879 |     |             m0 := mload(0x00)
  5880 |     |             m1 := mload(0x20)
  5881 |     |             m2 := mload(0x40)
  5882 |     |             m3 := mload(0x60)
  5883 |     |             m4 := mload(0x80)
  5884 |     |             // Selector of `log(bool,address,uint256,bool)`.
  5885 |     |             mstore(0x00, 0xd6019f1c)
  5886 |     |             mstore(0x20, p0)
  5887 |     |             mstore(0x40, p1)
  5888 |     |             mstore(0x60, p2)
  5889 |     |             mstore(0x80, p3)
  5890 |     |         }
  5891 |     |         _sendLogPayload(0x1c, 0x84);
  5892 |     |         /// @solidity memory-safe-assembly
  5893 |     |         assembly {
  5894 |     |             mstore(0x00, m0)
  5895 |     |             mstore(0x20, m1)
  5896 |     |             mstore(0x40, m2)
  5897 |     |             mstore(0x60, m3)
  5898 |     |             mstore(0x80, m4)
  5899 |     |         }
  5900 |     |     }
  5901 |     | 
  5902 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
  5903 |     |         bytes32 m0;
  5904 |     |         bytes32 m1;
  5905 |     |         bytes32 m2;
  5906 |     |         bytes32 m3;
  5907 |     |         bytes32 m4;
  5908 |     |         /// @solidity memory-safe-assembly
  5909 |     |         assembly {
  5910 |     |             m0 := mload(0x00)
  5911 |     |             m1 := mload(0x20)
  5912 |     |             m2 := mload(0x40)
  5913 |     |             m3 := mload(0x60)
  5914 |     |             m4 := mload(0x80)
  5915 |     |             // Selector of `log(bool,address,uint256,uint256)`.
  5916 |     |             mstore(0x00, 0x7bf181a1)
  5917 |     |             mstore(0x20, p0)
  5918 |     |             mstore(0x40, p1)
  5919 |     |             mstore(0x60, p2)
  5920 |     |             mstore(0x80, p3)
  5921 |     |         }
  5922 |     |         _sendLogPayload(0x1c, 0x84);
  5923 |     |         /// @solidity memory-safe-assembly
  5924 |     |         assembly {
  5925 |     |             mstore(0x00, m0)
  5926 |     |             mstore(0x20, m1)
  5927 |     |             mstore(0x40, m2)
  5928 |     |             mstore(0x60, m3)
  5929 |     |             mstore(0x80, m4)
  5930 |     |         }
  5931 |     |     }
  5932 |     | 
  5933 |     |     function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {
  5934 |     |         bytes32 m0;
  5935 |     |         bytes32 m1;
  5936 |     |         bytes32 m2;
  5937 |     |         bytes32 m3;
  5938 |     |         bytes32 m4;
  5939 |     |         bytes32 m5;
  5940 |     |         bytes32 m6;
  5941 |     |         /// @solidity memory-safe-assembly
  5942 |     |         assembly {
  5943 |     |             function writeString(pos, w) {
  5944 |     |                 let length := 0
  5945 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5946 |     |                 mstore(pos, length)
  5947 |     |                 let shift := sub(256, shl(3, length))
  5948 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5949 |     |             }
  5950 |     |             m0 := mload(0x00)
  5951 |     |             m1 := mload(0x20)
  5952 |     |             m2 := mload(0x40)
  5953 |     |             m3 := mload(0x60)
  5954 |     |             m4 := mload(0x80)
  5955 |     |             m5 := mload(0xa0)
  5956 |     |             m6 := mload(0xc0)
  5957 |     |             // Selector of `log(bool,address,uint256,string)`.
  5958 |     |             mstore(0x00, 0x51f09ff8)
  5959 |     |             mstore(0x20, p0)
  5960 |     |             mstore(0x40, p1)
  5961 |     |             mstore(0x60, p2)
  5962 |     |             mstore(0x80, 0x80)
  5963 |     |             writeString(0xa0, p3)
  5964 |     |         }
  5965 |     |         _sendLogPayload(0x1c, 0xc4);
  5966 |     |         /// @solidity memory-safe-assembly
  5967 |     |         assembly {
  5968 |     |             mstore(0x00, m0)
  5969 |     |             mstore(0x20, m1)
  5970 |     |             mstore(0x40, m2)
  5971 |     |             mstore(0x60, m3)
  5972 |     |             mstore(0x80, m4)
  5973 |     |             mstore(0xa0, m5)
  5974 |     |             mstore(0xc0, m6)
  5975 |     |         }
  5976 |     |     }
  5977 |     | 
  5978 |     |     function log(bool p0, address p1, bytes32 p2, address p3) internal pure {
  5979 |     |         bytes32 m0;
  5980 |     |         bytes32 m1;
  5981 |     |         bytes32 m2;
  5982 |     |         bytes32 m3;
  5983 |     |         bytes32 m4;
  5984 |     |         bytes32 m5;
  5985 |     |         bytes32 m6;
  5986 |     |         /// @solidity memory-safe-assembly
  5987 |     |         assembly {
  5988 |     |             function writeString(pos, w) {
  5989 |     |                 let length := 0
  5990 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5991 |     |                 mstore(pos, length)
  5992 |     |                 let shift := sub(256, shl(3, length))
  5993 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5994 |     |             }
  5995 |     |             m0 := mload(0x00)
  5996 |     |             m1 := mload(0x20)
  5997 |     |             m2 := mload(0x40)
  5998 |     |             m3 := mload(0x60)
  5999 |     |             m4 := mload(0x80)
  6000 |     |             m5 := mload(0xa0)
  6001 |     |             m6 := mload(0xc0)
  6002 |     |             // Selector of `log(bool,address,string,address)`.
  6003 |     |             mstore(0x00, 0x6f7c603e)
  6004 |     |             mstore(0x20, p0)
  6005 |     |             mstore(0x40, p1)
  6006 |     |             mstore(0x60, 0x80)
  6007 |     |             mstore(0x80, p3)
  6008 |     |             writeString(0xa0, p2)
  6009 |     |         }
  6010 |     |         _sendLogPayload(0x1c, 0xc4);
  6011 |     |         /// @solidity memory-safe-assembly
  6012 |     |         assembly {
  6013 |     |             mstore(0x00, m0)
  6014 |     |             mstore(0x20, m1)
  6015 |     |             mstore(0x40, m2)
  6016 |     |             mstore(0x60, m3)
  6017 |     |             mstore(0x80, m4)
  6018 |     |             mstore(0xa0, m5)
  6019 |     |             mstore(0xc0, m6)
  6020 |     |         }
  6021 |     |     }
  6022 |     | 
  6023 |     |     function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {
  6024 |     |         bytes32 m0;
  6025 |     |         bytes32 m1;
  6026 |     |         bytes32 m2;
  6027 |     |         bytes32 m3;
  6028 |     |         bytes32 m4;
  6029 |     |         bytes32 m5;
  6030 |     |         bytes32 m6;
  6031 |     |         /// @solidity memory-safe-assembly
  6032 |     |         assembly {
  6033 |     |             function writeString(pos, w) {
  6034 |     |                 let length := 0
  6035 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6036 |     |                 mstore(pos, length)
  6037 |     |                 let shift := sub(256, shl(3, length))
  6038 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6039 |     |             }
  6040 |     |             m0 := mload(0x00)
  6041 |     |             m1 := mload(0x20)
  6042 |     |             m2 := mload(0x40)
  6043 |     |             m3 := mload(0x60)
  6044 |     |             m4 := mload(0x80)
  6045 |     |             m5 := mload(0xa0)
  6046 |     |             m6 := mload(0xc0)
  6047 |     |             // Selector of `log(bool,address,string,bool)`.
  6048 |     |             mstore(0x00, 0xe2bfd60b)
  6049 |     |             mstore(0x20, p0)
  6050 |     |             mstore(0x40, p1)
  6051 |     |             mstore(0x60, 0x80)
  6052 |     |             mstore(0x80, p3)
  6053 |     |             writeString(0xa0, p2)
  6054 |     |         }
  6055 |     |         _sendLogPayload(0x1c, 0xc4);
  6056 |     |         /// @solidity memory-safe-assembly
  6057 |     |         assembly {
  6058 |     |             mstore(0x00, m0)
  6059 |     |             mstore(0x20, m1)
  6060 |     |             mstore(0x40, m2)
  6061 |     |             mstore(0x60, m3)
  6062 |     |             mstore(0x80, m4)
  6063 |     |             mstore(0xa0, m5)
  6064 |     |             mstore(0xc0, m6)
  6065 |     |         }
  6066 |     |     }
  6067 |     | 
  6068 |     |     function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {
  6069 |     |         bytes32 m0;
  6070 |     |         bytes32 m1;
  6071 |     |         bytes32 m2;
  6072 |     |         bytes32 m3;
  6073 |     |         bytes32 m4;
  6074 |     |         bytes32 m5;
  6075 |     |         bytes32 m6;
  6076 |     |         /// @solidity memory-safe-assembly
  6077 |     |         assembly {
  6078 |     |             function writeString(pos, w) {
  6079 |     |                 let length := 0
  6080 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6081 |     |                 mstore(pos, length)
  6082 |     |                 let shift := sub(256, shl(3, length))
  6083 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6084 |     |             }
  6085 |     |             m0 := mload(0x00)
  6086 |     |             m1 := mload(0x20)
  6087 |     |             m2 := mload(0x40)
  6088 |     |             m3 := mload(0x60)
  6089 |     |             m4 := mload(0x80)
  6090 |     |             m5 := mload(0xa0)
  6091 |     |             m6 := mload(0xc0)
  6092 |     |             // Selector of `log(bool,address,string,uint256)`.
  6093 |     |             mstore(0x00, 0xc21f64c7)
  6094 |     |             mstore(0x20, p0)
  6095 |     |             mstore(0x40, p1)
  6096 |     |             mstore(0x60, 0x80)
  6097 |     |             mstore(0x80, p3)
  6098 |     |             writeString(0xa0, p2)
  6099 |     |         }
  6100 |     |         _sendLogPayload(0x1c, 0xc4);
  6101 |     |         /// @solidity memory-safe-assembly
  6102 |     |         assembly {
  6103 |     |             mstore(0x00, m0)
  6104 |     |             mstore(0x20, m1)
  6105 |     |             mstore(0x40, m2)
  6106 |     |             mstore(0x60, m3)
  6107 |     |             mstore(0x80, m4)
  6108 |     |             mstore(0xa0, m5)
  6109 |     |             mstore(0xc0, m6)
  6110 |     |         }
  6111 |     |     }
  6112 |     | 
  6113 |     |     function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  6114 |     |         bytes32 m0;
  6115 |     |         bytes32 m1;
  6116 |     |         bytes32 m2;
  6117 |     |         bytes32 m3;
  6118 |     |         bytes32 m4;
  6119 |     |         bytes32 m5;
  6120 |     |         bytes32 m6;
  6121 |     |         bytes32 m7;
  6122 |     |         bytes32 m8;
  6123 |     |         /// @solidity memory-safe-assembly
  6124 |     |         assembly {
  6125 |     |             function writeString(pos, w) {
  6126 |     |                 let length := 0
  6127 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6128 |     |                 mstore(pos, length)
  6129 |     |                 let shift := sub(256, shl(3, length))
  6130 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6131 |     |             }
  6132 |     |             m0 := mload(0x00)
  6133 |     |             m1 := mload(0x20)
  6134 |     |             m2 := mload(0x40)
  6135 |     |             m3 := mload(0x60)
  6136 |     |             m4 := mload(0x80)
  6137 |     |             m5 := mload(0xa0)
  6138 |     |             m6 := mload(0xc0)
  6139 |     |             m7 := mload(0xe0)
  6140 |     |             m8 := mload(0x100)
  6141 |     |             // Selector of `log(bool,address,string,string)`.
  6142 |     |             mstore(0x00, 0xa73c1db6)
  6143 |     |             mstore(0x20, p0)
  6144 |     |             mstore(0x40, p1)
  6145 |     |             mstore(0x60, 0x80)
  6146 |     |             mstore(0x80, 0xc0)
  6147 |     |             writeString(0xa0, p2)
  6148 |     |             writeString(0xe0, p3)
  6149 |     |         }
  6150 |     |         _sendLogPayload(0x1c, 0x104);
  6151 |     |         /// @solidity memory-safe-assembly
  6152 |     |         assembly {
  6153 |     |             mstore(0x00, m0)
  6154 |     |             mstore(0x20, m1)
  6155 |     |             mstore(0x40, m2)
  6156 |     |             mstore(0x60, m3)
  6157 |     |             mstore(0x80, m4)
  6158 |     |             mstore(0xa0, m5)
  6159 |     |             mstore(0xc0, m6)
  6160 |     |             mstore(0xe0, m7)
  6161 |     |             mstore(0x100, m8)
  6162 |     |         }
  6163 |     |     }
  6164 |     | 
  6165 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
  6166 |     |         bytes32 m0;
  6167 |     |         bytes32 m1;
  6168 |     |         bytes32 m2;
  6169 |     |         bytes32 m3;
  6170 |     |         bytes32 m4;
  6171 |     |         /// @solidity memory-safe-assembly
  6172 |     |         assembly {
  6173 |     |             m0 := mload(0x00)
  6174 |     |             m1 := mload(0x20)
  6175 |     |             m2 := mload(0x40)
  6176 |     |             m3 := mload(0x60)
  6177 |     |             m4 := mload(0x80)
  6178 |     |             // Selector of `log(bool,bool,address,address)`.
  6179 |     |             mstore(0x00, 0xf4880ea4)
  6180 |     |             mstore(0x20, p0)
  6181 |     |             mstore(0x40, p1)
  6182 |     |             mstore(0x60, p2)
  6183 |     |             mstore(0x80, p3)
  6184 |     |         }
  6185 |     |         _sendLogPayload(0x1c, 0x84);
  6186 |     |         /// @solidity memory-safe-assembly
  6187 |     |         assembly {
  6188 |     |             mstore(0x00, m0)
  6189 |     |             mstore(0x20, m1)
  6190 |     |             mstore(0x40, m2)
  6191 |     |             mstore(0x60, m3)
  6192 |     |             mstore(0x80, m4)
  6193 |     |         }
  6194 |     |     }
  6195 |     | 
  6196 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
  6197 |     |         bytes32 m0;
  6198 |     |         bytes32 m1;
  6199 |     |         bytes32 m2;
  6200 |     |         bytes32 m3;
  6201 |     |         bytes32 m4;
  6202 |     |         /// @solidity memory-safe-assembly
  6203 |     |         assembly {
  6204 |     |             m0 := mload(0x00)
  6205 |     |             m1 := mload(0x20)
  6206 |     |             m2 := mload(0x40)
  6207 |     |             m3 := mload(0x60)
  6208 |     |             m4 := mload(0x80)
  6209 |     |             // Selector of `log(bool,bool,address,bool)`.
  6210 |     |             mstore(0x00, 0xc0a302d8)
  6211 |     |             mstore(0x20, p0)
  6212 |     |             mstore(0x40, p1)
  6213 |     |             mstore(0x60, p2)
  6214 |     |             mstore(0x80, p3)
  6215 |     |         }
  6216 |     |         _sendLogPayload(0x1c, 0x84);
  6217 |     |         /// @solidity memory-safe-assembly
  6218 |     |         assembly {
  6219 |     |             mstore(0x00, m0)
  6220 |     |             mstore(0x20, m1)
  6221 |     |             mstore(0x40, m2)
  6222 |     |             mstore(0x60, m3)
  6223 |     |             mstore(0x80, m4)
  6224 |     |         }
  6225 |     |     }
  6226 |     | 
  6227 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
  6228 |     |         bytes32 m0;
  6229 |     |         bytes32 m1;
  6230 |     |         bytes32 m2;
  6231 |     |         bytes32 m3;
  6232 |     |         bytes32 m4;
  6233 |     |         /// @solidity memory-safe-assembly
  6234 |     |         assembly {
  6235 |     |             m0 := mload(0x00)
  6236 |     |             m1 := mload(0x20)
  6237 |     |             m2 := mload(0x40)
  6238 |     |             m3 := mload(0x60)
  6239 |     |             m4 := mload(0x80)
  6240 |     |             // Selector of `log(bool,bool,address,uint256)`.
  6241 |     |             mstore(0x00, 0x4c123d57)
  6242 |     |             mstore(0x20, p0)
  6243 |     |             mstore(0x40, p1)
  6244 |     |             mstore(0x60, p2)
  6245 |     |             mstore(0x80, p3)
  6246 |     |         }
  6247 |     |         _sendLogPayload(0x1c, 0x84);
  6248 |     |         /// @solidity memory-safe-assembly
  6249 |     |         assembly {
  6250 |     |             mstore(0x00, m0)
  6251 |     |             mstore(0x20, m1)
  6252 |     |             mstore(0x40, m2)
  6253 |     |             mstore(0x60, m3)
  6254 |     |             mstore(0x80, m4)
  6255 |     |         }
  6256 |     |     }
  6257 |     | 
  6258 |     |     function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {
  6259 |     |         bytes32 m0;
  6260 |     |         bytes32 m1;
  6261 |     |         bytes32 m2;
  6262 |     |         bytes32 m3;
  6263 |     |         bytes32 m4;
  6264 |     |         bytes32 m5;
  6265 |     |         bytes32 m6;
  6266 |     |         /// @solidity memory-safe-assembly
  6267 |     |         assembly {
  6268 |     |             function writeString(pos, w) {
  6269 |     |                 let length := 0
  6270 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6271 |     |                 mstore(pos, length)
  6272 |     |                 let shift := sub(256, shl(3, length))
  6273 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6274 |     |             }
  6275 |     |             m0 := mload(0x00)
  6276 |     |             m1 := mload(0x20)
  6277 |     |             m2 := mload(0x40)
  6278 |     |             m3 := mload(0x60)
  6279 |     |             m4 := mload(0x80)
  6280 |     |             m5 := mload(0xa0)
  6281 |     |             m6 := mload(0xc0)
  6282 |     |             // Selector of `log(bool,bool,address,string)`.
  6283 |     |             mstore(0x00, 0xa0a47963)
  6284 |     |             mstore(0x20, p0)
  6285 |     |             mstore(0x40, p1)
  6286 |     |             mstore(0x60, p2)
  6287 |     |             mstore(0x80, 0x80)
  6288 |     |             writeString(0xa0, p3)
  6289 |     |         }
  6290 |     |         _sendLogPayload(0x1c, 0xc4);
  6291 |     |         /// @solidity memory-safe-assembly
  6292 |     |         assembly {
  6293 |     |             mstore(0x00, m0)
  6294 |     |             mstore(0x20, m1)
  6295 |     |             mstore(0x40, m2)
  6296 |     |             mstore(0x60, m3)
  6297 |     |             mstore(0x80, m4)
  6298 |     |             mstore(0xa0, m5)
  6299 |     |             mstore(0xc0, m6)
  6300 |     |         }
  6301 |     |     }
  6302 |     | 
  6303 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
  6304 |     |         bytes32 m0;
  6305 |     |         bytes32 m1;
  6306 |     |         bytes32 m2;
  6307 |     |         bytes32 m3;
  6308 |     |         bytes32 m4;
  6309 |     |         /// @solidity memory-safe-assembly
  6310 |     |         assembly {
  6311 |     |             m0 := mload(0x00)
  6312 |     |             m1 := mload(0x20)
  6313 |     |             m2 := mload(0x40)
  6314 |     |             m3 := mload(0x60)
  6315 |     |             m4 := mload(0x80)
  6316 |     |             // Selector of `log(bool,bool,bool,address)`.
  6317 |     |             mstore(0x00, 0x8c329b1a)
  6318 |     |             mstore(0x20, p0)
  6319 |     |             mstore(0x40, p1)
  6320 |     |             mstore(0x60, p2)
  6321 |     |             mstore(0x80, p3)
  6322 |     |         }
  6323 |     |         _sendLogPayload(0x1c, 0x84);
  6324 |     |         /// @solidity memory-safe-assembly
  6325 |     |         assembly {
  6326 |     |             mstore(0x00, m0)
  6327 |     |             mstore(0x20, m1)
  6328 |     |             mstore(0x40, m2)
  6329 |     |             mstore(0x60, m3)
  6330 |     |             mstore(0x80, m4)
  6331 |     |         }
  6332 |     |     }
  6333 |     | 
  6334 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
  6335 |     |         bytes32 m0;
  6336 |     |         bytes32 m1;
  6337 |     |         bytes32 m2;
  6338 |     |         bytes32 m3;
  6339 |     |         bytes32 m4;
  6340 |     |         /// @solidity memory-safe-assembly
  6341 |     |         assembly {
  6342 |     |             m0 := mload(0x00)
  6343 |     |             m1 := mload(0x20)
  6344 |     |             m2 := mload(0x40)
  6345 |     |             m3 := mload(0x60)
  6346 |     |             m4 := mload(0x80)
  6347 |     |             // Selector of `log(bool,bool,bool,bool)`.
  6348 |     |             mstore(0x00, 0x3b2a5ce0)
  6349 |     |             mstore(0x20, p0)
  6350 |     |             mstore(0x40, p1)
  6351 |     |             mstore(0x60, p2)
  6352 |     |             mstore(0x80, p3)
  6353 |     |         }
  6354 |     |         _sendLogPayload(0x1c, 0x84);
  6355 |     |         /// @solidity memory-safe-assembly
  6356 |     |         assembly {
  6357 |     |             mstore(0x00, m0)
  6358 |     |             mstore(0x20, m1)
  6359 |     |             mstore(0x40, m2)
  6360 |     |             mstore(0x60, m3)
  6361 |     |             mstore(0x80, m4)
  6362 |     |         }
  6363 |     |     }
  6364 |     | 
  6365 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
  6366 |     |         bytes32 m0;
  6367 |     |         bytes32 m1;
  6368 |     |         bytes32 m2;
  6369 |     |         bytes32 m3;
  6370 |     |         bytes32 m4;
  6371 |     |         /// @solidity memory-safe-assembly
  6372 |     |         assembly {
  6373 |     |             m0 := mload(0x00)
  6374 |     |             m1 := mload(0x20)
  6375 |     |             m2 := mload(0x40)
  6376 |     |             m3 := mload(0x60)
  6377 |     |             m4 := mload(0x80)
  6378 |     |             // Selector of `log(bool,bool,bool,uint256)`.
  6379 |     |             mstore(0x00, 0x6d7045c1)
  6380 |     |             mstore(0x20, p0)
  6381 |     |             mstore(0x40, p1)
  6382 |     |             mstore(0x60, p2)
  6383 |     |             mstore(0x80, p3)
  6384 |     |         }
  6385 |     |         _sendLogPayload(0x1c, 0x84);
  6386 |     |         /// @solidity memory-safe-assembly
  6387 |     |         assembly {
  6388 |     |             mstore(0x00, m0)
  6389 |     |             mstore(0x20, m1)
  6390 |     |             mstore(0x40, m2)
  6391 |     |             mstore(0x60, m3)
  6392 |     |             mstore(0x80, m4)
  6393 |     |         }
  6394 |     |     }
  6395 |     | 
  6396 |     |     function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {
  6397 |     |         bytes32 m0;
  6398 |     |         bytes32 m1;
  6399 |     |         bytes32 m2;
  6400 |     |         bytes32 m3;
  6401 |     |         bytes32 m4;
  6402 |     |         bytes32 m5;
  6403 |     |         bytes32 m6;
  6404 |     |         /// @solidity memory-safe-assembly
  6405 |     |         assembly {
  6406 |     |             function writeString(pos, w) {
  6407 |     |                 let length := 0
  6408 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6409 |     |                 mstore(pos, length)
  6410 |     |                 let shift := sub(256, shl(3, length))
  6411 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6412 |     |             }
  6413 |     |             m0 := mload(0x00)
  6414 |     |             m1 := mload(0x20)
  6415 |     |             m2 := mload(0x40)
  6416 |     |             m3 := mload(0x60)
  6417 |     |             m4 := mload(0x80)
  6418 |     |             m5 := mload(0xa0)
  6419 |     |             m6 := mload(0xc0)
  6420 |     |             // Selector of `log(bool,bool,bool,string)`.
  6421 |     |             mstore(0x00, 0x2ae408d4)
  6422 |     |             mstore(0x20, p0)
  6423 |     |             mstore(0x40, p1)
  6424 |     |             mstore(0x60, p2)
  6425 |     |             mstore(0x80, 0x80)
  6426 |     |             writeString(0xa0, p3)
  6427 |     |         }
  6428 |     |         _sendLogPayload(0x1c, 0xc4);
  6429 |     |         /// @solidity memory-safe-assembly
  6430 |     |         assembly {
  6431 |     |             mstore(0x00, m0)
  6432 |     |             mstore(0x20, m1)
  6433 |     |             mstore(0x40, m2)
  6434 |     |             mstore(0x60, m3)
  6435 |     |             mstore(0x80, m4)
  6436 |     |             mstore(0xa0, m5)
  6437 |     |             mstore(0xc0, m6)
  6438 |     |         }
  6439 |     |     }
  6440 |     | 
  6441 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
  6442 |     |         bytes32 m0;
  6443 |     |         bytes32 m1;
  6444 |     |         bytes32 m2;
  6445 |     |         bytes32 m3;
  6446 |     |         bytes32 m4;
  6447 |     |         /// @solidity memory-safe-assembly
  6448 |     |         assembly {
  6449 |     |             m0 := mload(0x00)
  6450 |     |             m1 := mload(0x20)
  6451 |     |             m2 := mload(0x40)
  6452 |     |             m3 := mload(0x60)
  6453 |     |             m4 := mload(0x80)
  6454 |     |             // Selector of `log(bool,bool,uint256,address)`.
  6455 |     |             mstore(0x00, 0x54a7a9a0)
  6456 |     |             mstore(0x20, p0)
  6457 |     |             mstore(0x40, p1)
  6458 |     |             mstore(0x60, p2)
  6459 |     |             mstore(0x80, p3)
  6460 |     |         }
  6461 |     |         _sendLogPayload(0x1c, 0x84);
  6462 |     |         /// @solidity memory-safe-assembly
  6463 |     |         assembly {
  6464 |     |             mstore(0x00, m0)
  6465 |     |             mstore(0x20, m1)
  6466 |     |             mstore(0x40, m2)
  6467 |     |             mstore(0x60, m3)
  6468 |     |             mstore(0x80, m4)
  6469 |     |         }
  6470 |     |     }
  6471 |     | 
  6472 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
  6473 |     |         bytes32 m0;
  6474 |     |         bytes32 m1;
  6475 |     |         bytes32 m2;
  6476 |     |         bytes32 m3;
  6477 |     |         bytes32 m4;
  6478 |     |         /// @solidity memory-safe-assembly
  6479 |     |         assembly {
  6480 |     |             m0 := mload(0x00)
  6481 |     |             m1 := mload(0x20)
  6482 |     |             m2 := mload(0x40)
  6483 |     |             m3 := mload(0x60)
  6484 |     |             m4 := mload(0x80)
  6485 |     |             // Selector of `log(bool,bool,uint256,bool)`.
  6486 |     |             mstore(0x00, 0x619e4d0e)
  6487 |     |             mstore(0x20, p0)
  6488 |     |             mstore(0x40, p1)
  6489 |     |             mstore(0x60, p2)
  6490 |     |             mstore(0x80, p3)
  6491 |     |         }
  6492 |     |         _sendLogPayload(0x1c, 0x84);
  6493 |     |         /// @solidity memory-safe-assembly
  6494 |     |         assembly {
  6495 |     |             mstore(0x00, m0)
  6496 |     |             mstore(0x20, m1)
  6497 |     |             mstore(0x40, m2)
  6498 |     |             mstore(0x60, m3)
  6499 |     |             mstore(0x80, m4)
  6500 |     |         }
  6501 |     |     }
  6502 |     | 
  6503 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
  6504 |     |         bytes32 m0;
  6505 |     |         bytes32 m1;
  6506 |     |         bytes32 m2;
  6507 |     |         bytes32 m3;
  6508 |     |         bytes32 m4;
  6509 |     |         /// @solidity memory-safe-assembly
  6510 |     |         assembly {
  6511 |     |             m0 := mload(0x00)
  6512 |     |             m1 := mload(0x20)
  6513 |     |             m2 := mload(0x40)
  6514 |     |             m3 := mload(0x60)
  6515 |     |             m4 := mload(0x80)
  6516 |     |             // Selector of `log(bool,bool,uint256,uint256)`.
  6517 |     |             mstore(0x00, 0x0bb00eab)
  6518 |     |             mstore(0x20, p0)
  6519 |     |             mstore(0x40, p1)
  6520 |     |             mstore(0x60, p2)
  6521 |     |             mstore(0x80, p3)
  6522 |     |         }
  6523 |     |         _sendLogPayload(0x1c, 0x84);
  6524 |     |         /// @solidity memory-safe-assembly
  6525 |     |         assembly {
  6526 |     |             mstore(0x00, m0)
  6527 |     |             mstore(0x20, m1)
  6528 |     |             mstore(0x40, m2)
  6529 |     |             mstore(0x60, m3)
  6530 |     |             mstore(0x80, m4)
  6531 |     |         }
  6532 |     |     }
  6533 |     | 
  6534 |     |     function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  6535 |     |         bytes32 m0;
  6536 |     |         bytes32 m1;
  6537 |     |         bytes32 m2;
  6538 |     |         bytes32 m3;
  6539 |     |         bytes32 m4;
  6540 |     |         bytes32 m5;
  6541 |     |         bytes32 m6;
  6542 |     |         /// @solidity memory-safe-assembly
  6543 |     |         assembly {
  6544 |     |             function writeString(pos, w) {
  6545 |     |                 let length := 0
  6546 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6547 |     |                 mstore(pos, length)
  6548 |     |                 let shift := sub(256, shl(3, length))
  6549 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6550 |     |             }
  6551 |     |             m0 := mload(0x00)
  6552 |     |             m1 := mload(0x20)
  6553 |     |             m2 := mload(0x40)
  6554 |     |             m3 := mload(0x60)
  6555 |     |             m4 := mload(0x80)
  6556 |     |             m5 := mload(0xa0)
  6557 |     |             m6 := mload(0xc0)
  6558 |     |             // Selector of `log(bool,bool,uint256,string)`.
  6559 |     |             mstore(0x00, 0x7dd4d0e0)
  6560 |     |             mstore(0x20, p0)
  6561 |     |             mstore(0x40, p1)
  6562 |     |             mstore(0x60, p2)
  6563 |     |             mstore(0x80, 0x80)
  6564 |     |             writeString(0xa0, p3)
  6565 |     |         }
  6566 |     |         _sendLogPayload(0x1c, 0xc4);
  6567 |     |         /// @solidity memory-safe-assembly
  6568 |     |         assembly {
  6569 |     |             mstore(0x00, m0)
  6570 |     |             mstore(0x20, m1)
  6571 |     |             mstore(0x40, m2)
  6572 |     |             mstore(0x60, m3)
  6573 |     |             mstore(0x80, m4)
  6574 |     |             mstore(0xa0, m5)
  6575 |     |             mstore(0xc0, m6)
  6576 |     |         }
  6577 |     |     }
  6578 |     | 
  6579 |     |     function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {
  6580 |     |         bytes32 m0;
  6581 |     |         bytes32 m1;
  6582 |     |         bytes32 m2;
  6583 |     |         bytes32 m3;
  6584 |     |         bytes32 m4;
  6585 |     |         bytes32 m5;
  6586 |     |         bytes32 m6;
  6587 |     |         /// @solidity memory-safe-assembly
  6588 |     |         assembly {
  6589 |     |             function writeString(pos, w) {
  6590 |     |                 let length := 0
  6591 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6592 |     |                 mstore(pos, length)
  6593 |     |                 let shift := sub(256, shl(3, length))
  6594 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6595 |     |             }
  6596 |     |             m0 := mload(0x00)
  6597 |     |             m1 := mload(0x20)
  6598 |     |             m2 := mload(0x40)
  6599 |     |             m3 := mload(0x60)
  6600 |     |             m4 := mload(0x80)
  6601 |     |             m5 := mload(0xa0)
  6602 |     |             m6 := mload(0xc0)
  6603 |     |             // Selector of `log(bool,bool,string,address)`.
  6604 |     |             mstore(0x00, 0xf9ad2b89)
  6605 |     |             mstore(0x20, p0)
  6606 |     |             mstore(0x40, p1)
  6607 |     |             mstore(0x60, 0x80)
  6608 |     |             mstore(0x80, p3)
  6609 |     |             writeString(0xa0, p2)
  6610 |     |         }
  6611 |     |         _sendLogPayload(0x1c, 0xc4);
  6612 |     |         /// @solidity memory-safe-assembly
  6613 |     |         assembly {
  6614 |     |             mstore(0x00, m0)
  6615 |     |             mstore(0x20, m1)
  6616 |     |             mstore(0x40, m2)
  6617 |     |             mstore(0x60, m3)
  6618 |     |             mstore(0x80, m4)
  6619 |     |             mstore(0xa0, m5)
  6620 |     |             mstore(0xc0, m6)
  6621 |     |         }
  6622 |     |     }
  6623 |     | 
  6624 |     |     function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {
  6625 |     |         bytes32 m0;
  6626 |     |         bytes32 m1;
  6627 |     |         bytes32 m2;
  6628 |     |         bytes32 m3;
  6629 |     |         bytes32 m4;
  6630 |     |         bytes32 m5;
  6631 |     |         bytes32 m6;
  6632 |     |         /// @solidity memory-safe-assembly
  6633 |     |         assembly {
  6634 |     |             function writeString(pos, w) {
  6635 |     |                 let length := 0
  6636 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6637 |     |                 mstore(pos, length)
  6638 |     |                 let shift := sub(256, shl(3, length))
  6639 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6640 |     |             }
  6641 |     |             m0 := mload(0x00)
  6642 |     |             m1 := mload(0x20)
  6643 |     |             m2 := mload(0x40)
  6644 |     |             m3 := mload(0x60)
  6645 |     |             m4 := mload(0x80)
  6646 |     |             m5 := mload(0xa0)
  6647 |     |             m6 := mload(0xc0)
  6648 |     |             // Selector of `log(bool,bool,string,bool)`.
  6649 |     |             mstore(0x00, 0xb857163a)
  6650 |     |             mstore(0x20, p0)
  6651 |     |             mstore(0x40, p1)
  6652 |     |             mstore(0x60, 0x80)
  6653 |     |             mstore(0x80, p3)
  6654 |     |             writeString(0xa0, p2)
  6655 |     |         }
  6656 |     |         _sendLogPayload(0x1c, 0xc4);
  6657 |     |         /// @solidity memory-safe-assembly
  6658 |     |         assembly {
  6659 |     |             mstore(0x00, m0)
  6660 |     |             mstore(0x20, m1)
  6661 |     |             mstore(0x40, m2)
  6662 |     |             mstore(0x60, m3)
  6663 |     |             mstore(0x80, m4)
  6664 |     |             mstore(0xa0, m5)
  6665 |     |             mstore(0xc0, m6)
  6666 |     |         }
  6667 |     |     }
  6668 |     | 
  6669 |     |     function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  6670 |     |         bytes32 m0;
  6671 |     |         bytes32 m1;
  6672 |     |         bytes32 m2;
  6673 |     |         bytes32 m3;
  6674 |     |         bytes32 m4;
  6675 |     |         bytes32 m5;
  6676 |     |         bytes32 m6;
  6677 |     |         /// @solidity memory-safe-assembly
  6678 |     |         assembly {
  6679 |     |             function writeString(pos, w) {
  6680 |     |                 let length := 0
  6681 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6682 |     |                 mstore(pos, length)
  6683 |     |                 let shift := sub(256, shl(3, length))
  6684 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6685 |     |             }
  6686 |     |             m0 := mload(0x00)
  6687 |     |             m1 := mload(0x20)
  6688 |     |             m2 := mload(0x40)
  6689 |     |             m3 := mload(0x60)
  6690 |     |             m4 := mload(0x80)
  6691 |     |             m5 := mload(0xa0)
  6692 |     |             m6 := mload(0xc0)
  6693 |     |             // Selector of `log(bool,bool,string,uint256)`.
  6694 |     |             mstore(0x00, 0xe3a9ca2f)
  6695 |     |             mstore(0x20, p0)
  6696 |     |             mstore(0x40, p1)
  6697 |     |             mstore(0x60, 0x80)
  6698 |     |             mstore(0x80, p3)
  6699 |     |             writeString(0xa0, p2)
  6700 |     |         }
  6701 |     |         _sendLogPayload(0x1c, 0xc4);
  6702 |     |         /// @solidity memory-safe-assembly
  6703 |     |         assembly {
  6704 |     |             mstore(0x00, m0)
  6705 |     |             mstore(0x20, m1)
  6706 |     |             mstore(0x40, m2)
  6707 |     |             mstore(0x60, m3)
  6708 |     |             mstore(0x80, m4)
  6709 |     |             mstore(0xa0, m5)
  6710 |     |             mstore(0xc0, m6)
  6711 |     |         }
  6712 |     |     }
  6713 |     | 
  6714 |     |     function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  6715 |     |         bytes32 m0;
  6716 |     |         bytes32 m1;
  6717 |     |         bytes32 m2;
  6718 |     |         bytes32 m3;
  6719 |     |         bytes32 m4;
  6720 |     |         bytes32 m5;
  6721 |     |         bytes32 m6;
  6722 |     |         bytes32 m7;
  6723 |     |         bytes32 m8;
  6724 |     |         /// @solidity memory-safe-assembly
  6725 |     |         assembly {
  6726 |     |             function writeString(pos, w) {
  6727 |     |                 let length := 0
  6728 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6729 |     |                 mstore(pos, length)
  6730 |     |                 let shift := sub(256, shl(3, length))
  6731 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6732 |     |             }
  6733 |     |             m0 := mload(0x00)
  6734 |     |             m1 := mload(0x20)
  6735 |     |             m2 := mload(0x40)
  6736 |     |             m3 := mload(0x60)
  6737 |     |             m4 := mload(0x80)
  6738 |     |             m5 := mload(0xa0)
  6739 |     |             m6 := mload(0xc0)
  6740 |     |             m7 := mload(0xe0)
  6741 |     |             m8 := mload(0x100)
  6742 |     |             // Selector of `log(bool,bool,string,string)`.
  6743 |     |             mstore(0x00, 0x6d1e8751)
  6744 |     |             mstore(0x20, p0)
  6745 |     |             mstore(0x40, p1)
  6746 |     |             mstore(0x60, 0x80)
  6747 |     |             mstore(0x80, 0xc0)
  6748 |     |             writeString(0xa0, p2)
  6749 |     |             writeString(0xe0, p3)
  6750 |     |         }
  6751 |     |         _sendLogPayload(0x1c, 0x104);
  6752 |     |         /// @solidity memory-safe-assembly
  6753 |     |         assembly {
  6754 |     |             mstore(0x00, m0)
  6755 |     |             mstore(0x20, m1)
  6756 |     |             mstore(0x40, m2)
  6757 |     |             mstore(0x60, m3)
  6758 |     |             mstore(0x80, m4)
  6759 |     |             mstore(0xa0, m5)
  6760 |     |             mstore(0xc0, m6)
  6761 |     |             mstore(0xe0, m7)
  6762 |     |             mstore(0x100, m8)
  6763 |     |         }
  6764 |     |     }
  6765 |     | 
  6766 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
  6767 |     |         bytes32 m0;
  6768 |     |         bytes32 m1;
  6769 |     |         bytes32 m2;
  6770 |     |         bytes32 m3;
  6771 |     |         bytes32 m4;
  6772 |     |         /// @solidity memory-safe-assembly
  6773 |     |         assembly {
  6774 |     |             m0 := mload(0x00)
  6775 |     |             m1 := mload(0x20)
  6776 |     |             m2 := mload(0x40)
  6777 |     |             m3 := mload(0x60)
  6778 |     |             m4 := mload(0x80)
  6779 |     |             // Selector of `log(bool,uint256,address,address)`.
  6780 |     |             mstore(0x00, 0x26f560a8)
  6781 |     |             mstore(0x20, p0)
  6782 |     |             mstore(0x40, p1)
  6783 |     |             mstore(0x60, p2)
  6784 |     |             mstore(0x80, p3)
  6785 |     |         }
  6786 |     |         _sendLogPayload(0x1c, 0x84);
  6787 |     |         /// @solidity memory-safe-assembly
  6788 |     |         assembly {
  6789 |     |             mstore(0x00, m0)
  6790 |     |             mstore(0x20, m1)
  6791 |     |             mstore(0x40, m2)
  6792 |     |             mstore(0x60, m3)
  6793 |     |             mstore(0x80, m4)
  6794 |     |         }
  6795 |     |     }
  6796 |     | 
  6797 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
  6798 |     |         bytes32 m0;
  6799 |     |         bytes32 m1;
  6800 |     |         bytes32 m2;
  6801 |     |         bytes32 m3;
  6802 |     |         bytes32 m4;
  6803 |     |         /// @solidity memory-safe-assembly
  6804 |     |         assembly {
  6805 |     |             m0 := mload(0x00)
  6806 |     |             m1 := mload(0x20)
  6807 |     |             m2 := mload(0x40)
  6808 |     |             m3 := mload(0x60)
  6809 |     |             m4 := mload(0x80)
  6810 |     |             // Selector of `log(bool,uint256,address,bool)`.
  6811 |     |             mstore(0x00, 0xb4c314ff)
  6812 |     |             mstore(0x20, p0)
  6813 |     |             mstore(0x40, p1)
  6814 |     |             mstore(0x60, p2)
  6815 |     |             mstore(0x80, p3)
  6816 |     |         }
  6817 |     |         _sendLogPayload(0x1c, 0x84);
  6818 |     |         /// @solidity memory-safe-assembly
  6819 |     |         assembly {
  6820 |     |             mstore(0x00, m0)
  6821 |     |             mstore(0x20, m1)
  6822 |     |             mstore(0x40, m2)
  6823 |     |             mstore(0x60, m3)
  6824 |     |             mstore(0x80, m4)
  6825 |     |         }
  6826 |     |     }
  6827 |     | 
  6828 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
  6829 |     |         bytes32 m0;
  6830 |     |         bytes32 m1;
  6831 |     |         bytes32 m2;
  6832 |     |         bytes32 m3;
  6833 |     |         bytes32 m4;
  6834 |     |         /// @solidity memory-safe-assembly
  6835 |     |         assembly {
  6836 |     |             m0 := mload(0x00)
  6837 |     |             m1 := mload(0x20)
  6838 |     |             m2 := mload(0x40)
  6839 |     |             m3 := mload(0x60)
  6840 |     |             m4 := mload(0x80)
  6841 |     |             // Selector of `log(bool,uint256,address,uint256)`.
  6842 |     |             mstore(0x00, 0x1537dc87)
  6843 |     |             mstore(0x20, p0)
  6844 |     |             mstore(0x40, p1)
  6845 |     |             mstore(0x60, p2)
  6846 |     |             mstore(0x80, p3)
  6847 |     |         }
  6848 |     |         _sendLogPayload(0x1c, 0x84);
  6849 |     |         /// @solidity memory-safe-assembly
  6850 |     |         assembly {
  6851 |     |             mstore(0x00, m0)
  6852 |     |             mstore(0x20, m1)
  6853 |     |             mstore(0x40, m2)
  6854 |     |             mstore(0x60, m3)
  6855 |     |             mstore(0x80, m4)
  6856 |     |         }
  6857 |     |     }
  6858 |     | 
  6859 |     |     function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {
  6860 |     |         bytes32 m0;
  6861 |     |         bytes32 m1;
  6862 |     |         bytes32 m2;
  6863 |     |         bytes32 m3;
  6864 |     |         bytes32 m4;
  6865 |     |         bytes32 m5;
  6866 |     |         bytes32 m6;
  6867 |     |         /// @solidity memory-safe-assembly
  6868 |     |         assembly {
  6869 |     |             function writeString(pos, w) {
  6870 |     |                 let length := 0
  6871 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6872 |     |                 mstore(pos, length)
  6873 |     |                 let shift := sub(256, shl(3, length))
  6874 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6875 |     |             }
  6876 |     |             m0 := mload(0x00)
  6877 |     |             m1 := mload(0x20)
  6878 |     |             m2 := mload(0x40)
  6879 |     |             m3 := mload(0x60)
  6880 |     |             m4 := mload(0x80)
  6881 |     |             m5 := mload(0xa0)
  6882 |     |             m6 := mload(0xc0)
  6883 |     |             // Selector of `log(bool,uint256,address,string)`.
  6884 |     |             mstore(0x00, 0x1bb3b09a)
  6885 |     |             mstore(0x20, p0)
  6886 |     |             mstore(0x40, p1)
  6887 |     |             mstore(0x60, p2)
  6888 |     |             mstore(0x80, 0x80)
  6889 |     |             writeString(0xa0, p3)
  6890 |     |         }
  6891 |     |         _sendLogPayload(0x1c, 0xc4);
  6892 |     |         /// @solidity memory-safe-assembly
  6893 |     |         assembly {
  6894 |     |             mstore(0x00, m0)
  6895 |     |             mstore(0x20, m1)
  6896 |     |             mstore(0x40, m2)
  6897 |     |             mstore(0x60, m3)
  6898 |     |             mstore(0x80, m4)
  6899 |     |             mstore(0xa0, m5)
  6900 |     |             mstore(0xc0, m6)
  6901 |     |         }
  6902 |     |     }
  6903 |     | 
  6904 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
  6905 |     |         bytes32 m0;
  6906 |     |         bytes32 m1;
  6907 |     |         bytes32 m2;
  6908 |     |         bytes32 m3;
  6909 |     |         bytes32 m4;
  6910 |     |         /// @solidity memory-safe-assembly
  6911 |     |         assembly {
  6912 |     |             m0 := mload(0x00)
  6913 |     |             m1 := mload(0x20)
  6914 |     |             m2 := mload(0x40)
  6915 |     |             m3 := mload(0x60)
  6916 |     |             m4 := mload(0x80)
  6917 |     |             // Selector of `log(bool,uint256,bool,address)`.
  6918 |     |             mstore(0x00, 0x9acd3616)
  6919 |     |             mstore(0x20, p0)
  6920 |     |             mstore(0x40, p1)
  6921 |     |             mstore(0x60, p2)
  6922 |     |             mstore(0x80, p3)
  6923 |     |         }
  6924 |     |         _sendLogPayload(0x1c, 0x84);
  6925 |     |         /// @solidity memory-safe-assembly
  6926 |     |         assembly {
  6927 |     |             mstore(0x00, m0)
  6928 |     |             mstore(0x20, m1)
  6929 |     |             mstore(0x40, m2)
  6930 |     |             mstore(0x60, m3)
  6931 |     |             mstore(0x80, m4)
  6932 |     |         }
  6933 |     |     }
  6934 |     | 
  6935 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
  6936 |     |         bytes32 m0;
  6937 |     |         bytes32 m1;
  6938 |     |         bytes32 m2;
  6939 |     |         bytes32 m3;
  6940 |     |         bytes32 m4;
  6941 |     |         /// @solidity memory-safe-assembly
  6942 |     |         assembly {
  6943 |     |             m0 := mload(0x00)
  6944 |     |             m1 := mload(0x20)
  6945 |     |             m2 := mload(0x40)
  6946 |     |             m3 := mload(0x60)
  6947 |     |             m4 := mload(0x80)
  6948 |     |             // Selector of `log(bool,uint256,bool,bool)`.
  6949 |     |             mstore(0x00, 0xceb5f4d7)
  6950 |     |             mstore(0x20, p0)
  6951 |     |             mstore(0x40, p1)
  6952 |     |             mstore(0x60, p2)
  6953 |     |             mstore(0x80, p3)
  6954 |     |         }
  6955 |     |         _sendLogPayload(0x1c, 0x84);
  6956 |     |         /// @solidity memory-safe-assembly
  6957 |     |         assembly {
  6958 |     |             mstore(0x00, m0)
  6959 |     |             mstore(0x20, m1)
  6960 |     |             mstore(0x40, m2)
  6961 |     |             mstore(0x60, m3)
  6962 |     |             mstore(0x80, m4)
  6963 |     |         }
  6964 |     |     }
  6965 |     | 
  6966 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
  6967 |     |         bytes32 m0;
  6968 |     |         bytes32 m1;
  6969 |     |         bytes32 m2;
  6970 |     |         bytes32 m3;
  6971 |     |         bytes32 m4;
  6972 |     |         /// @solidity memory-safe-assembly
  6973 |     |         assembly {
  6974 |     |             m0 := mload(0x00)
  6975 |     |             m1 := mload(0x20)
  6976 |     |             m2 := mload(0x40)
  6977 |     |             m3 := mload(0x60)
  6978 |     |             m4 := mload(0x80)
  6979 |     |             // Selector of `log(bool,uint256,bool,uint256)`.
  6980 |     |             mstore(0x00, 0x7f9bbca2)
  6981 |     |             mstore(0x20, p0)
  6982 |     |             mstore(0x40, p1)
  6983 |     |             mstore(0x60, p2)
  6984 |     |             mstore(0x80, p3)
  6985 |     |         }
  6986 |     |         _sendLogPayload(0x1c, 0x84);
  6987 |     |         /// @solidity memory-safe-assembly
  6988 |     |         assembly {
  6989 |     |             mstore(0x00, m0)
  6990 |     |             mstore(0x20, m1)
  6991 |     |             mstore(0x40, m2)
  6992 |     |             mstore(0x60, m3)
  6993 |     |             mstore(0x80, m4)
  6994 |     |         }
  6995 |     |     }
  6996 |     | 
  6997 |     |     function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  6998 |     |         bytes32 m0;
  6999 |     |         bytes32 m1;
  7000 |     |         bytes32 m2;
  7001 |     |         bytes32 m3;
  7002 |     |         bytes32 m4;
  7003 |     |         bytes32 m5;
  7004 |     |         bytes32 m6;
  7005 |     |         /// @solidity memory-safe-assembly
  7006 |     |         assembly {
  7007 |     |             function writeString(pos, w) {
  7008 |     |                 let length := 0
  7009 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7010 |     |                 mstore(pos, length)
  7011 |     |                 let shift := sub(256, shl(3, length))
  7012 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7013 |     |             }
  7014 |     |             m0 := mload(0x00)
  7015 |     |             m1 := mload(0x20)
  7016 |     |             m2 := mload(0x40)
  7017 |     |             m3 := mload(0x60)
  7018 |     |             m4 := mload(0x80)
  7019 |     |             m5 := mload(0xa0)
  7020 |     |             m6 := mload(0xc0)
  7021 |     |             // Selector of `log(bool,uint256,bool,string)`.
  7022 |     |             mstore(0x00, 0x9143dbb1)
  7023 |     |             mstore(0x20, p0)
  7024 |     |             mstore(0x40, p1)
  7025 |     |             mstore(0x60, p2)
  7026 |     |             mstore(0x80, 0x80)
  7027 |     |             writeString(0xa0, p3)
  7028 |     |         }
  7029 |     |         _sendLogPayload(0x1c, 0xc4);
  7030 |     |         /// @solidity memory-safe-assembly
  7031 |     |         assembly {
  7032 |     |             mstore(0x00, m0)
  7033 |     |             mstore(0x20, m1)
  7034 |     |             mstore(0x40, m2)
  7035 |     |             mstore(0x60, m3)
  7036 |     |             mstore(0x80, m4)
  7037 |     |             mstore(0xa0, m5)
  7038 |     |             mstore(0xc0, m6)
  7039 |     |         }
  7040 |     |     }
  7041 |     | 
  7042 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
  7043 |     |         bytes32 m0;
  7044 |     |         bytes32 m1;
  7045 |     |         bytes32 m2;
  7046 |     |         bytes32 m3;
  7047 |     |         bytes32 m4;
  7048 |     |         /// @solidity memory-safe-assembly
  7049 |     |         assembly {
  7050 |     |             m0 := mload(0x00)
  7051 |     |             m1 := mload(0x20)
  7052 |     |             m2 := mload(0x40)
  7053 |     |             m3 := mload(0x60)
  7054 |     |             m4 := mload(0x80)
  7055 |     |             // Selector of `log(bool,uint256,uint256,address)`.
  7056 |     |             mstore(0x00, 0x00dd87b9)
  7057 |     |             mstore(0x20, p0)
  7058 |     |             mstore(0x40, p1)
  7059 |     |             mstore(0x60, p2)
  7060 |     |             mstore(0x80, p3)
  7061 |     |         }
  7062 |     |         _sendLogPayload(0x1c, 0x84);
  7063 |     |         /// @solidity memory-safe-assembly
  7064 |     |         assembly {
  7065 |     |             mstore(0x00, m0)
  7066 |     |             mstore(0x20, m1)
  7067 |     |             mstore(0x40, m2)
  7068 |     |             mstore(0x60, m3)
  7069 |     |             mstore(0x80, m4)
  7070 |     |         }
  7071 |     |     }
  7072 |     | 
  7073 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
  7074 |     |         bytes32 m0;
  7075 |     |         bytes32 m1;
  7076 |     |         bytes32 m2;
  7077 |     |         bytes32 m3;
  7078 |     |         bytes32 m4;
  7079 |     |         /// @solidity memory-safe-assembly
  7080 |     |         assembly {
  7081 |     |             m0 := mload(0x00)
  7082 |     |             m1 := mload(0x20)
  7083 |     |             m2 := mload(0x40)
  7084 |     |             m3 := mload(0x60)
  7085 |     |             m4 := mload(0x80)
  7086 |     |             // Selector of `log(bool,uint256,uint256,bool)`.
  7087 |     |             mstore(0x00, 0xbe984353)
  7088 |     |             mstore(0x20, p0)
  7089 |     |             mstore(0x40, p1)
  7090 |     |             mstore(0x60, p2)
  7091 |     |             mstore(0x80, p3)
  7092 |     |         }
  7093 |     |         _sendLogPayload(0x1c, 0x84);
  7094 |     |         /// @solidity memory-safe-assembly
  7095 |     |         assembly {
  7096 |     |             mstore(0x00, m0)
  7097 |     |             mstore(0x20, m1)
  7098 |     |             mstore(0x40, m2)
  7099 |     |             mstore(0x60, m3)
  7100 |     |             mstore(0x80, m4)
  7101 |     |         }
  7102 |     |     }
  7103 |     | 
  7104 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  7105 |     |         bytes32 m0;
  7106 |     |         bytes32 m1;
  7107 |     |         bytes32 m2;
  7108 |     |         bytes32 m3;
  7109 |     |         bytes32 m4;
  7110 |     |         /// @solidity memory-safe-assembly
  7111 |     |         assembly {
  7112 |     |             m0 := mload(0x00)
  7113 |     |             m1 := mload(0x20)
  7114 |     |             m2 := mload(0x40)
  7115 |     |             m3 := mload(0x60)
  7116 |     |             m4 := mload(0x80)
  7117 |     |             // Selector of `log(bool,uint256,uint256,uint256)`.
  7118 |     |             mstore(0x00, 0x374bb4b2)
  7119 |     |             mstore(0x20, p0)
  7120 |     |             mstore(0x40, p1)
  7121 |     |             mstore(0x60, p2)
  7122 |     |             mstore(0x80, p3)
  7123 |     |         }
  7124 |     |         _sendLogPayload(0x1c, 0x84);
  7125 |     |         /// @solidity memory-safe-assembly
  7126 |     |         assembly {
  7127 |     |             mstore(0x00, m0)
  7128 |     |             mstore(0x20, m1)
  7129 |     |             mstore(0x40, m2)
  7130 |     |             mstore(0x60, m3)
  7131 |     |             mstore(0x80, m4)
  7132 |     |         }
  7133 |     |     }
  7134 |     | 
  7135 |     |     function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  7136 |     |         bytes32 m0;
  7137 |     |         bytes32 m1;
  7138 |     |         bytes32 m2;
  7139 |     |         bytes32 m3;
  7140 |     |         bytes32 m4;
  7141 |     |         bytes32 m5;
  7142 |     |         bytes32 m6;
  7143 |     |         /// @solidity memory-safe-assembly
  7144 |     |         assembly {
  7145 |     |             function writeString(pos, w) {
  7146 |     |                 let length := 0
  7147 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7148 |     |                 mstore(pos, length)
  7149 |     |                 let shift := sub(256, shl(3, length))
  7150 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7151 |     |             }
  7152 |     |             m0 := mload(0x00)
  7153 |     |             m1 := mload(0x20)
  7154 |     |             m2 := mload(0x40)
  7155 |     |             m3 := mload(0x60)
  7156 |     |             m4 := mload(0x80)
  7157 |     |             m5 := mload(0xa0)
  7158 |     |             m6 := mload(0xc0)
  7159 |     |             // Selector of `log(bool,uint256,uint256,string)`.
  7160 |     |             mstore(0x00, 0x8e69fb5d)
  7161 |     |             mstore(0x20, p0)
  7162 |     |             mstore(0x40, p1)
  7163 |     |             mstore(0x60, p2)
  7164 |     |             mstore(0x80, 0x80)
  7165 |     |             writeString(0xa0, p3)
  7166 |     |         }
  7167 |     |         _sendLogPayload(0x1c, 0xc4);
  7168 |     |         /// @solidity memory-safe-assembly
  7169 |     |         assembly {
  7170 |     |             mstore(0x00, m0)
  7171 |     |             mstore(0x20, m1)
  7172 |     |             mstore(0x40, m2)
  7173 |     |             mstore(0x60, m3)
  7174 |     |             mstore(0x80, m4)
  7175 |     |             mstore(0xa0, m5)
  7176 |     |             mstore(0xc0, m6)
  7177 |     |         }
  7178 |     |     }
  7179 |     | 
  7180 |     |     function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {
  7181 |     |         bytes32 m0;
  7182 |     |         bytes32 m1;
  7183 |     |         bytes32 m2;
  7184 |     |         bytes32 m3;
  7185 |     |         bytes32 m4;
  7186 |     |         bytes32 m5;
  7187 |     |         bytes32 m6;
  7188 |     |         /// @solidity memory-safe-assembly
  7189 |     |         assembly {
  7190 |     |             function writeString(pos, w) {
  7191 |     |                 let length := 0
  7192 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7193 |     |                 mstore(pos, length)
  7194 |     |                 let shift := sub(256, shl(3, length))
  7195 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7196 |     |             }
  7197 |     |             m0 := mload(0x00)
  7198 |     |             m1 := mload(0x20)
  7199 |     |             m2 := mload(0x40)
  7200 |     |             m3 := mload(0x60)
  7201 |     |             m4 := mload(0x80)
  7202 |     |             m5 := mload(0xa0)
  7203 |     |             m6 := mload(0xc0)
  7204 |     |             // Selector of `log(bool,uint256,string,address)`.
  7205 |     |             mstore(0x00, 0xfedd1fff)
  7206 |     |             mstore(0x20, p0)
  7207 |     |             mstore(0x40, p1)
  7208 |     |             mstore(0x60, 0x80)
  7209 |     |             mstore(0x80, p3)
  7210 |     |             writeString(0xa0, p2)
  7211 |     |         }
  7212 |     |         _sendLogPayload(0x1c, 0xc4);
  7213 |     |         /// @solidity memory-safe-assembly
  7214 |     |         assembly {
  7215 |     |             mstore(0x00, m0)
  7216 |     |             mstore(0x20, m1)
  7217 |     |             mstore(0x40, m2)
  7218 |     |             mstore(0x60, m3)
  7219 |     |             mstore(0x80, m4)
  7220 |     |             mstore(0xa0, m5)
  7221 |     |             mstore(0xc0, m6)
  7222 |     |         }
  7223 |     |     }
  7224 |     | 
  7225 |     |     function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  7226 |     |         bytes32 m0;
  7227 |     |         bytes32 m1;
  7228 |     |         bytes32 m2;
  7229 |     |         bytes32 m3;
  7230 |     |         bytes32 m4;
  7231 |     |         bytes32 m5;
  7232 |     |         bytes32 m6;
  7233 |     |         /// @solidity memory-safe-assembly
  7234 |     |         assembly {
  7235 |     |             function writeString(pos, w) {
  7236 |     |                 let length := 0
  7237 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7238 |     |                 mstore(pos, length)
  7239 |     |                 let shift := sub(256, shl(3, length))
  7240 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7241 |     |             }
  7242 |     |             m0 := mload(0x00)
  7243 |     |             m1 := mload(0x20)
  7244 |     |             m2 := mload(0x40)
  7245 |     |             m3 := mload(0x60)
  7246 |     |             m4 := mload(0x80)
  7247 |     |             m5 := mload(0xa0)
  7248 |     |             m6 := mload(0xc0)
  7249 |     |             // Selector of `log(bool,uint256,string,bool)`.
  7250 |     |             mstore(0x00, 0xe5e70b2b)
  7251 |     |             mstore(0x20, p0)
  7252 |     |             mstore(0x40, p1)
  7253 |     |             mstore(0x60, 0x80)
  7254 |     |             mstore(0x80, p3)
  7255 |     |             writeString(0xa0, p2)
  7256 |     |         }
  7257 |     |         _sendLogPayload(0x1c, 0xc4);
  7258 |     |         /// @solidity memory-safe-assembly
  7259 |     |         assembly {
  7260 |     |             mstore(0x00, m0)
  7261 |     |             mstore(0x20, m1)
  7262 |     |             mstore(0x40, m2)
  7263 |     |             mstore(0x60, m3)
  7264 |     |             mstore(0x80, m4)
  7265 |     |             mstore(0xa0, m5)
  7266 |     |             mstore(0xc0, m6)
  7267 |     |         }
  7268 |     |     }
  7269 |     | 
  7270 |     |     function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  7271 |     |         bytes32 m0;
  7272 |     |         bytes32 m1;
  7273 |     |         bytes32 m2;
  7274 |     |         bytes32 m3;
  7275 |     |         bytes32 m4;
  7276 |     |         bytes32 m5;
  7277 |     |         bytes32 m6;
  7278 |     |         /// @solidity memory-safe-assembly
  7279 |     |         assembly {
  7280 |     |             function writeString(pos, w) {
  7281 |     |                 let length := 0
  7282 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7283 |     |                 mstore(pos, length)
  7284 |     |                 let shift := sub(256, shl(3, length))
  7285 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7286 |     |             }
  7287 |     |             m0 := mload(0x00)
  7288 |     |             m1 := mload(0x20)
  7289 |     |             m2 := mload(0x40)
  7290 |     |             m3 := mload(0x60)
  7291 |     |             m4 := mload(0x80)
  7292 |     |             m5 := mload(0xa0)
  7293 |     |             m6 := mload(0xc0)
  7294 |     |             // Selector of `log(bool,uint256,string,uint256)`.
  7295 |     |             mstore(0x00, 0x6a1199e2)
  7296 |     |             mstore(0x20, p0)
  7297 |     |             mstore(0x40, p1)
  7298 |     |             mstore(0x60, 0x80)
  7299 |     |             mstore(0x80, p3)
  7300 |     |             writeString(0xa0, p2)
  7301 |     |         }
  7302 |     |         _sendLogPayload(0x1c, 0xc4);
  7303 |     |         /// @solidity memory-safe-assembly
  7304 |     |         assembly {
  7305 |     |             mstore(0x00, m0)
  7306 |     |             mstore(0x20, m1)
  7307 |     |             mstore(0x40, m2)
  7308 |     |             mstore(0x60, m3)
  7309 |     |             mstore(0x80, m4)
  7310 |     |             mstore(0xa0, m5)
  7311 |     |             mstore(0xc0, m6)
  7312 |     |         }
  7313 |     |     }
  7314 |     | 
  7315 |     |     function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  7316 |     |         bytes32 m0;
  7317 |     |         bytes32 m1;
  7318 |     |         bytes32 m2;
  7319 |     |         bytes32 m3;
  7320 |     |         bytes32 m4;
  7321 |     |         bytes32 m5;
  7322 |     |         bytes32 m6;
  7323 |     |         bytes32 m7;
  7324 |     |         bytes32 m8;
  7325 |     |         /// @solidity memory-safe-assembly
  7326 |     |         assembly {
  7327 |     |             function writeString(pos, w) {
  7328 |     |                 let length := 0
  7329 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7330 |     |                 mstore(pos, length)
  7331 |     |                 let shift := sub(256, shl(3, length))
  7332 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7333 |     |             }
  7334 |     |             m0 := mload(0x00)
  7335 |     |             m1 := mload(0x20)
  7336 |     |             m2 := mload(0x40)
  7337 |     |             m3 := mload(0x60)
  7338 |     |             m4 := mload(0x80)
  7339 |     |             m5 := mload(0xa0)
  7340 |     |             m6 := mload(0xc0)
  7341 |     |             m7 := mload(0xe0)
  7342 |     |             m8 := mload(0x100)
  7343 |     |             // Selector of `log(bool,uint256,string,string)`.
  7344 |     |             mstore(0x00, 0xf5bc2249)
  7345 |     |             mstore(0x20, p0)
  7346 |     |             mstore(0x40, p1)
  7347 |     |             mstore(0x60, 0x80)
  7348 |     |             mstore(0x80, 0xc0)
  7349 |     |             writeString(0xa0, p2)
  7350 |     |             writeString(0xe0, p3)
  7351 |     |         }
  7352 |     |         _sendLogPayload(0x1c, 0x104);
  7353 |     |         /// @solidity memory-safe-assembly
  7354 |     |         assembly {
  7355 |     |             mstore(0x00, m0)
  7356 |     |             mstore(0x20, m1)
  7357 |     |             mstore(0x40, m2)
  7358 |     |             mstore(0x60, m3)
  7359 |     |             mstore(0x80, m4)
  7360 |     |             mstore(0xa0, m5)
  7361 |     |             mstore(0xc0, m6)
  7362 |     |             mstore(0xe0, m7)
  7363 |     |             mstore(0x100, m8)
  7364 |     |         }
  7365 |     |     }
  7366 |     | 
  7367 |     |     function log(bool p0, bytes32 p1, address p2, address p3) internal pure {
  7368 |     |         bytes32 m0;
  7369 |     |         bytes32 m1;
  7370 |     |         bytes32 m2;
  7371 |     |         bytes32 m3;
  7372 |     |         bytes32 m4;
  7373 |     |         bytes32 m5;
  7374 |     |         bytes32 m6;
  7375 |     |         /// @solidity memory-safe-assembly
  7376 |     |         assembly {
  7377 |     |             function writeString(pos, w) {
  7378 |     |                 let length := 0
  7379 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7380 |     |                 mstore(pos, length)
  7381 |     |                 let shift := sub(256, shl(3, length))
  7382 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7383 |     |             }
  7384 |     |             m0 := mload(0x00)
  7385 |     |             m1 := mload(0x20)
  7386 |     |             m2 := mload(0x40)
  7387 |     |             m3 := mload(0x60)
  7388 |     |             m4 := mload(0x80)
  7389 |     |             m5 := mload(0xa0)
  7390 |     |             m6 := mload(0xc0)
  7391 |     |             // Selector of `log(bool,string,address,address)`.
  7392 |     |             mstore(0x00, 0x2b2b18dc)
  7393 |     |             mstore(0x20, p0)
  7394 |     |             mstore(0x40, 0x80)
  7395 |     |             mstore(0x60, p2)
  7396 |     |             mstore(0x80, p3)
  7397 |     |             writeString(0xa0, p1)
  7398 |     |         }
  7399 |     |         _sendLogPayload(0x1c, 0xc4);
  7400 |     |         /// @solidity memory-safe-assembly
  7401 |     |         assembly {
  7402 |     |             mstore(0x00, m0)
  7403 |     |             mstore(0x20, m1)
  7404 |     |             mstore(0x40, m2)
  7405 |     |             mstore(0x60, m3)
  7406 |     |             mstore(0x80, m4)
  7407 |     |             mstore(0xa0, m5)
  7408 |     |             mstore(0xc0, m6)
  7409 |     |         }
  7410 |     |     }
  7411 |     | 
  7412 |     |     function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {
  7413 |     |         bytes32 m0;
  7414 |     |         bytes32 m1;
  7415 |     |         bytes32 m2;
  7416 |     |         bytes32 m3;
  7417 |     |         bytes32 m4;
  7418 |     |         bytes32 m5;
  7419 |     |         bytes32 m6;
  7420 |     |         /// @solidity memory-safe-assembly
  7421 |     |         assembly {
  7422 |     |             function writeString(pos, w) {
  7423 |     |                 let length := 0
  7424 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7425 |     |                 mstore(pos, length)
  7426 |     |                 let shift := sub(256, shl(3, length))
  7427 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7428 |     |             }
  7429 |     |             m0 := mload(0x00)
  7430 |     |             m1 := mload(0x20)
  7431 |     |             m2 := mload(0x40)
  7432 |     |             m3 := mload(0x60)
  7433 |     |             m4 := mload(0x80)
  7434 |     |             m5 := mload(0xa0)
  7435 |     |             m6 := mload(0xc0)
  7436 |     |             // Selector of `log(bool,string,address,bool)`.
  7437 |     |             mstore(0x00, 0x6dd434ca)
  7438 |     |             mstore(0x20, p0)
  7439 |     |             mstore(0x40, 0x80)
  7440 |     |             mstore(0x60, p2)
  7441 |     |             mstore(0x80, p3)
  7442 |     |             writeString(0xa0, p1)
  7443 |     |         }
  7444 |     |         _sendLogPayload(0x1c, 0xc4);
  7445 |     |         /// @solidity memory-safe-assembly
  7446 |     |         assembly {
  7447 |     |             mstore(0x00, m0)
  7448 |     |             mstore(0x20, m1)
  7449 |     |             mstore(0x40, m2)
  7450 |     |             mstore(0x60, m3)
  7451 |     |             mstore(0x80, m4)
  7452 |     |             mstore(0xa0, m5)
  7453 |     |             mstore(0xc0, m6)
  7454 |     |         }
  7455 |     |     }
  7456 |     | 
  7457 |     |     function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {
  7458 |     |         bytes32 m0;
  7459 |     |         bytes32 m1;
  7460 |     |         bytes32 m2;
  7461 |     |         bytes32 m3;
  7462 |     |         bytes32 m4;
  7463 |     |         bytes32 m5;
  7464 |     |         bytes32 m6;
  7465 |     |         /// @solidity memory-safe-assembly
  7466 |     |         assembly {
  7467 |     |             function writeString(pos, w) {
  7468 |     |                 let length := 0
  7469 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7470 |     |                 mstore(pos, length)
  7471 |     |                 let shift := sub(256, shl(3, length))
  7472 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7473 |     |             }
  7474 |     |             m0 := mload(0x00)
  7475 |     |             m1 := mload(0x20)
  7476 |     |             m2 := mload(0x40)
  7477 |     |             m3 := mload(0x60)
  7478 |     |             m4 := mload(0x80)
  7479 |     |             m5 := mload(0xa0)
  7480 |     |             m6 := mload(0xc0)
  7481 |     |             // Selector of `log(bool,string,address,uint256)`.
  7482 |     |             mstore(0x00, 0xa5cada94)
  7483 |     |             mstore(0x20, p0)
  7484 |     |             mstore(0x40, 0x80)
  7485 |     |             mstore(0x60, p2)
  7486 |     |             mstore(0x80, p3)
  7487 |     |             writeString(0xa0, p1)
  7488 |     |         }
  7489 |     |         _sendLogPayload(0x1c, 0xc4);
  7490 |     |         /// @solidity memory-safe-assembly
  7491 |     |         assembly {
  7492 |     |             mstore(0x00, m0)
  7493 |     |             mstore(0x20, m1)
  7494 |     |             mstore(0x40, m2)
  7495 |     |             mstore(0x60, m3)
  7496 |     |             mstore(0x80, m4)
  7497 |     |             mstore(0xa0, m5)
  7498 |     |             mstore(0xc0, m6)
  7499 |     |         }
  7500 |     |     }
  7501 |     | 
  7502 |     |     function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  7503 |     |         bytes32 m0;
  7504 |     |         bytes32 m1;
  7505 |     |         bytes32 m2;
  7506 |     |         bytes32 m3;
  7507 |     |         bytes32 m4;
  7508 |     |         bytes32 m5;
  7509 |     |         bytes32 m6;
  7510 |     |         bytes32 m7;
  7511 |     |         bytes32 m8;
  7512 |     |         /// @solidity memory-safe-assembly
  7513 |     |         assembly {
  7514 |     |             function writeString(pos, w) {
  7515 |     |                 let length := 0
  7516 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7517 |     |                 mstore(pos, length)
  7518 |     |                 let shift := sub(256, shl(3, length))
  7519 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7520 |     |             }
  7521 |     |             m0 := mload(0x00)
  7522 |     |             m1 := mload(0x20)
  7523 |     |             m2 := mload(0x40)
  7524 |     |             m3 := mload(0x60)
  7525 |     |             m4 := mload(0x80)
  7526 |     |             m5 := mload(0xa0)
  7527 |     |             m6 := mload(0xc0)
  7528 |     |             m7 := mload(0xe0)
  7529 |     |             m8 := mload(0x100)
  7530 |     |             // Selector of `log(bool,string,address,string)`.
  7531 |     |             mstore(0x00, 0x12d6c788)
  7532 |     |             mstore(0x20, p0)
  7533 |     |             mstore(0x40, 0x80)
  7534 |     |             mstore(0x60, p2)
  7535 |     |             mstore(0x80, 0xc0)
  7536 |     |             writeString(0xa0, p1)
  7537 |     |             writeString(0xe0, p3)
  7538 |     |         }
  7539 |     |         _sendLogPayload(0x1c, 0x104);
  7540 |     |         /// @solidity memory-safe-assembly
  7541 |     |         assembly {
  7542 |     |             mstore(0x00, m0)
  7543 |     |             mstore(0x20, m1)
  7544 |     |             mstore(0x40, m2)
  7545 |     |             mstore(0x60, m3)
  7546 |     |             mstore(0x80, m4)
  7547 |     |             mstore(0xa0, m5)
  7548 |     |             mstore(0xc0, m6)
  7549 |     |             mstore(0xe0, m7)
  7550 |     |             mstore(0x100, m8)
  7551 |     |         }
  7552 |     |     }
  7553 |     | 
  7554 |     |     function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {
  7555 |     |         bytes32 m0;
  7556 |     |         bytes32 m1;
  7557 |     |         bytes32 m2;
  7558 |     |         bytes32 m3;
  7559 |     |         bytes32 m4;
  7560 |     |         bytes32 m5;
  7561 |     |         bytes32 m6;
  7562 |     |         /// @solidity memory-safe-assembly
  7563 |     |         assembly {
  7564 |     |             function writeString(pos, w) {
  7565 |     |                 let length := 0
  7566 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7567 |     |                 mstore(pos, length)
  7568 |     |                 let shift := sub(256, shl(3, length))
  7569 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7570 |     |             }
  7571 |     |             m0 := mload(0x00)
  7572 |     |             m1 := mload(0x20)
  7573 |     |             m2 := mload(0x40)
  7574 |     |             m3 := mload(0x60)
  7575 |     |             m4 := mload(0x80)
  7576 |     |             m5 := mload(0xa0)
  7577 |     |             m6 := mload(0xc0)
  7578 |     |             // Selector of `log(bool,string,bool,address)`.
  7579 |     |             mstore(0x00, 0x538e06ab)
  7580 |     |             mstore(0x20, p0)
  7581 |     |             mstore(0x40, 0x80)
  7582 |     |             mstore(0x60, p2)
  7583 |     |             mstore(0x80, p3)
  7584 |     |             writeString(0xa0, p1)
  7585 |     |         }
  7586 |     |         _sendLogPayload(0x1c, 0xc4);
  7587 |     |         /// @solidity memory-safe-assembly
  7588 |     |         assembly {
  7589 |     |             mstore(0x00, m0)
  7590 |     |             mstore(0x20, m1)
  7591 |     |             mstore(0x40, m2)
  7592 |     |             mstore(0x60, m3)
  7593 |     |             mstore(0x80, m4)
  7594 |     |             mstore(0xa0, m5)
  7595 |     |             mstore(0xc0, m6)
  7596 |     |         }
  7597 |     |     }
  7598 |     | 
  7599 |     |     function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {
  7600 |     |         bytes32 m0;
  7601 |     |         bytes32 m1;
  7602 |     |         bytes32 m2;
  7603 |     |         bytes32 m3;
  7604 |     |         bytes32 m4;
  7605 |     |         bytes32 m5;
  7606 |     |         bytes32 m6;
  7607 |     |         /// @solidity memory-safe-assembly
  7608 |     |         assembly {
  7609 |     |             function writeString(pos, w) {
  7610 |     |                 let length := 0
  7611 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7612 |     |                 mstore(pos, length)
  7613 |     |                 let shift := sub(256, shl(3, length))
  7614 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7615 |     |             }
  7616 |     |             m0 := mload(0x00)
  7617 |     |             m1 := mload(0x20)
  7618 |     |             m2 := mload(0x40)
  7619 |     |             m3 := mload(0x60)
  7620 |     |             m4 := mload(0x80)
  7621 |     |             m5 := mload(0xa0)
  7622 |     |             m6 := mload(0xc0)
  7623 |     |             // Selector of `log(bool,string,bool,bool)`.
  7624 |     |             mstore(0x00, 0xdc5e935b)
  7625 |     |             mstore(0x20, p0)
  7626 |     |             mstore(0x40, 0x80)
  7627 |     |             mstore(0x60, p2)
  7628 |     |             mstore(0x80, p3)
  7629 |     |             writeString(0xa0, p1)
  7630 |     |         }
  7631 |     |         _sendLogPayload(0x1c, 0xc4);
  7632 |     |         /// @solidity memory-safe-assembly
  7633 |     |         assembly {
  7634 |     |             mstore(0x00, m0)
  7635 |     |             mstore(0x20, m1)
  7636 |     |             mstore(0x40, m2)
  7637 |     |             mstore(0x60, m3)
  7638 |     |             mstore(0x80, m4)
  7639 |     |             mstore(0xa0, m5)
  7640 |     |             mstore(0xc0, m6)
  7641 |     |         }
  7642 |     |     }
  7643 |     | 
  7644 |     |     function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  7645 |     |         bytes32 m0;
  7646 |     |         bytes32 m1;
  7647 |     |         bytes32 m2;
  7648 |     |         bytes32 m3;
  7649 |     |         bytes32 m4;
  7650 |     |         bytes32 m5;
  7651 |     |         bytes32 m6;
  7652 |     |         /// @solidity memory-safe-assembly
  7653 |     |         assembly {
  7654 |     |             function writeString(pos, w) {
  7655 |     |                 let length := 0
  7656 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7657 |     |                 mstore(pos, length)
  7658 |     |                 let shift := sub(256, shl(3, length))
  7659 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7660 |     |             }
  7661 |     |             m0 := mload(0x00)
  7662 |     |             m1 := mload(0x20)
  7663 |     |             m2 := mload(0x40)
  7664 |     |             m3 := mload(0x60)
  7665 |     |             m4 := mload(0x80)
  7666 |     |             m5 := mload(0xa0)
  7667 |     |             m6 := mload(0xc0)
  7668 |     |             // Selector of `log(bool,string,bool,uint256)`.
  7669 |     |             mstore(0x00, 0x1606a393)
  7670 |     |             mstore(0x20, p0)
  7671 |     |             mstore(0x40, 0x80)
  7672 |     |             mstore(0x60, p2)
  7673 |     |             mstore(0x80, p3)
  7674 |     |             writeString(0xa0, p1)
  7675 |     |         }
  7676 |     |         _sendLogPayload(0x1c, 0xc4);
  7677 |     |         /// @solidity memory-safe-assembly
  7678 |     |         assembly {
  7679 |     |             mstore(0x00, m0)
  7680 |     |             mstore(0x20, m1)
  7681 |     |             mstore(0x40, m2)
  7682 |     |             mstore(0x60, m3)
  7683 |     |             mstore(0x80, m4)
  7684 |     |             mstore(0xa0, m5)
  7685 |     |             mstore(0xc0, m6)
  7686 |     |         }
  7687 |     |     }
  7688 |     | 
  7689 |     |     function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  7690 |     |         bytes32 m0;
  7691 |     |         bytes32 m1;
  7692 |     |         bytes32 m2;
  7693 |     |         bytes32 m3;
  7694 |     |         bytes32 m4;
  7695 |     |         bytes32 m5;
  7696 |     |         bytes32 m6;
  7697 |     |         bytes32 m7;
  7698 |     |         bytes32 m8;
  7699 |     |         /// @solidity memory-safe-assembly
  7700 |     |         assembly {
  7701 |     |             function writeString(pos, w) {
  7702 |     |                 let length := 0
  7703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7704 |     |                 mstore(pos, length)
  7705 |     |                 let shift := sub(256, shl(3, length))
  7706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7707 |     |             }
  7708 |     |             m0 := mload(0x00)
  7709 |     |             m1 := mload(0x20)
  7710 |     |             m2 := mload(0x40)
  7711 |     |             m3 := mload(0x60)
  7712 |     |             m4 := mload(0x80)
  7713 |     |             m5 := mload(0xa0)
  7714 |     |             m6 := mload(0xc0)
  7715 |     |             m7 := mload(0xe0)
  7716 |     |             m8 := mload(0x100)
  7717 |     |             // Selector of `log(bool,string,bool,string)`.
  7718 |     |             mstore(0x00, 0x483d0416)
  7719 |     |             mstore(0x20, p0)
  7720 |     |             mstore(0x40, 0x80)
  7721 |     |             mstore(0x60, p2)
  7722 |     |             mstore(0x80, 0xc0)
  7723 |     |             writeString(0xa0, p1)
  7724 |     |             writeString(0xe0, p3)
  7725 |     |         }
  7726 |     |         _sendLogPayload(0x1c, 0x104);
  7727 |     |         /// @solidity memory-safe-assembly
  7728 |     |         assembly {
  7729 |     |             mstore(0x00, m0)
  7730 |     |             mstore(0x20, m1)
  7731 |     |             mstore(0x40, m2)
  7732 |     |             mstore(0x60, m3)
  7733 |     |             mstore(0x80, m4)
  7734 |     |             mstore(0xa0, m5)
  7735 |     |             mstore(0xc0, m6)
  7736 |     |             mstore(0xe0, m7)
  7737 |     |             mstore(0x100, m8)
  7738 |     |         }
  7739 |     |     }
  7740 |     | 
  7741 |     |     function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {
  7742 |     |         bytes32 m0;
  7743 |     |         bytes32 m1;
  7744 |     |         bytes32 m2;
  7745 |     |         bytes32 m3;
  7746 |     |         bytes32 m4;
  7747 |     |         bytes32 m5;
  7748 |     |         bytes32 m6;
  7749 |     |         /// @solidity memory-safe-assembly
  7750 |     |         assembly {
  7751 |     |             function writeString(pos, w) {
  7752 |     |                 let length := 0
  7753 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7754 |     |                 mstore(pos, length)
  7755 |     |                 let shift := sub(256, shl(3, length))
  7756 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7757 |     |             }
  7758 |     |             m0 := mload(0x00)
  7759 |     |             m1 := mload(0x20)
  7760 |     |             m2 := mload(0x40)
  7761 |     |             m3 := mload(0x60)
  7762 |     |             m4 := mload(0x80)
  7763 |     |             m5 := mload(0xa0)
  7764 |     |             m6 := mload(0xc0)
  7765 |     |             // Selector of `log(bool,string,uint256,address)`.
  7766 |     |             mstore(0x00, 0x1596a1ce)
  7767 |     |             mstore(0x20, p0)
  7768 |     |             mstore(0x40, 0x80)
  7769 |     |             mstore(0x60, p2)
  7770 |     |             mstore(0x80, p3)
  7771 |     |             writeString(0xa0, p1)
  7772 |     |         }
  7773 |     |         _sendLogPayload(0x1c, 0xc4);
  7774 |     |         /// @solidity memory-safe-assembly
  7775 |     |         assembly {
  7776 |     |             mstore(0x00, m0)
  7777 |     |             mstore(0x20, m1)
  7778 |     |             mstore(0x40, m2)
  7779 |     |             mstore(0x60, m3)
  7780 |     |             mstore(0x80, m4)
  7781 |     |             mstore(0xa0, m5)
  7782 |     |             mstore(0xc0, m6)
  7783 |     |         }
  7784 |     |     }
  7785 |     | 
  7786 |     |     function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  7787 |     |         bytes32 m0;
  7788 |     |         bytes32 m1;
  7789 |     |         bytes32 m2;
  7790 |     |         bytes32 m3;
  7791 |     |         bytes32 m4;
  7792 |     |         bytes32 m5;
  7793 |     |         bytes32 m6;
  7794 |     |         /// @solidity memory-safe-assembly
  7795 |     |         assembly {
  7796 |     |             function writeString(pos, w) {
  7797 |     |                 let length := 0
  7798 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7799 |     |                 mstore(pos, length)
  7800 |     |                 let shift := sub(256, shl(3, length))
  7801 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7802 |     |             }
  7803 |     |             m0 := mload(0x00)
  7804 |     |             m1 := mload(0x20)
  7805 |     |             m2 := mload(0x40)
  7806 |     |             m3 := mload(0x60)
  7807 |     |             m4 := mload(0x80)
  7808 |     |             m5 := mload(0xa0)
  7809 |     |             m6 := mload(0xc0)
  7810 |     |             // Selector of `log(bool,string,uint256,bool)`.
  7811 |     |             mstore(0x00, 0x6b0e5d53)
  7812 |     |             mstore(0x20, p0)
  7813 |     |             mstore(0x40, 0x80)
  7814 |     |             mstore(0x60, p2)
  7815 |     |             mstore(0x80, p3)
  7816 |     |             writeString(0xa0, p1)
  7817 |     |         }
  7818 |     |         _sendLogPayload(0x1c, 0xc4);
  7819 |     |         /// @solidity memory-safe-assembly
  7820 |     |         assembly {
  7821 |     |             mstore(0x00, m0)
  7822 |     |             mstore(0x20, m1)
  7823 |     |             mstore(0x40, m2)
  7824 |     |             mstore(0x60, m3)
  7825 |     |             mstore(0x80, m4)
  7826 |     |             mstore(0xa0, m5)
  7827 |     |             mstore(0xc0, m6)
  7828 |     |         }
  7829 |     |     }
  7830 |     | 
  7831 |     |     function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  7832 |     |         bytes32 m0;
  7833 |     |         bytes32 m1;
  7834 |     |         bytes32 m2;
  7835 |     |         bytes32 m3;
  7836 |     |         bytes32 m4;
  7837 |     |         bytes32 m5;
  7838 |     |         bytes32 m6;
  7839 |     |         /// @solidity memory-safe-assembly
  7840 |     |         assembly {
  7841 |     |             function writeString(pos, w) {
  7842 |     |                 let length := 0
  7843 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7844 |     |                 mstore(pos, length)
  7845 |     |                 let shift := sub(256, shl(3, length))
  7846 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7847 |     |             }
  7848 |     |             m0 := mload(0x00)
  7849 |     |             m1 := mload(0x20)
  7850 |     |             m2 := mload(0x40)
  7851 |     |             m3 := mload(0x60)
  7852 |     |             m4 := mload(0x80)
  7853 |     |             m5 := mload(0xa0)
  7854 |     |             m6 := mload(0xc0)
  7855 |     |             // Selector of `log(bool,string,uint256,uint256)`.
  7856 |     |             mstore(0x00, 0x28863fcb)
  7857 |     |             mstore(0x20, p0)
  7858 |     |             mstore(0x40, 0x80)
  7859 |     |             mstore(0x60, p2)
  7860 |     |             mstore(0x80, p3)
  7861 |     |             writeString(0xa0, p1)
  7862 |     |         }
  7863 |     |         _sendLogPayload(0x1c, 0xc4);
  7864 |     |         /// @solidity memory-safe-assembly
  7865 |     |         assembly {
  7866 |     |             mstore(0x00, m0)
  7867 |     |             mstore(0x20, m1)
  7868 |     |             mstore(0x40, m2)
  7869 |     |             mstore(0x60, m3)
  7870 |     |             mstore(0x80, m4)
  7871 |     |             mstore(0xa0, m5)
  7872 |     |             mstore(0xc0, m6)
  7873 |     |         }
  7874 |     |     }
  7875 |     | 
  7876 |     |     function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  7877 |     |         bytes32 m0;
  7878 |     |         bytes32 m1;
  7879 |     |         bytes32 m2;
  7880 |     |         bytes32 m3;
  7881 |     |         bytes32 m4;
  7882 |     |         bytes32 m5;
  7883 |     |         bytes32 m6;
  7884 |     |         bytes32 m7;
  7885 |     |         bytes32 m8;
  7886 |     |         /// @solidity memory-safe-assembly
  7887 |     |         assembly {
  7888 |     |             function writeString(pos, w) {
  7889 |     |                 let length := 0
  7890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7891 |     |                 mstore(pos, length)
  7892 |     |                 let shift := sub(256, shl(3, length))
  7893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7894 |     |             }
  7895 |     |             m0 := mload(0x00)
  7896 |     |             m1 := mload(0x20)
  7897 |     |             m2 := mload(0x40)
  7898 |     |             m3 := mload(0x60)
  7899 |     |             m4 := mload(0x80)
  7900 |     |             m5 := mload(0xa0)
  7901 |     |             m6 := mload(0xc0)
  7902 |     |             m7 := mload(0xe0)
  7903 |     |             m8 := mload(0x100)
  7904 |     |             // Selector of `log(bool,string,uint256,string)`.
  7905 |     |             mstore(0x00, 0x1ad96de6)
  7906 |     |             mstore(0x20, p0)
  7907 |     |             mstore(0x40, 0x80)
  7908 |     |             mstore(0x60, p2)
  7909 |     |             mstore(0x80, 0xc0)
  7910 |     |             writeString(0xa0, p1)
  7911 |     |             writeString(0xe0, p3)
  7912 |     |         }
  7913 |     |         _sendLogPayload(0x1c, 0x104);
  7914 |     |         /// @solidity memory-safe-assembly
  7915 |     |         assembly {
  7916 |     |             mstore(0x00, m0)
  7917 |     |             mstore(0x20, m1)
  7918 |     |             mstore(0x40, m2)
  7919 |     |             mstore(0x60, m3)
  7920 |     |             mstore(0x80, m4)
  7921 |     |             mstore(0xa0, m5)
  7922 |     |             mstore(0xc0, m6)
  7923 |     |             mstore(0xe0, m7)
  7924 |     |             mstore(0x100, m8)
  7925 |     |         }
  7926 |     |     }
  7927 |     | 
  7928 |     |     function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  7929 |     |         bytes32 m0;
  7930 |     |         bytes32 m1;
  7931 |     |         bytes32 m2;
  7932 |     |         bytes32 m3;
  7933 |     |         bytes32 m4;
  7934 |     |         bytes32 m5;
  7935 |     |         bytes32 m6;
  7936 |     |         bytes32 m7;
  7937 |     |         bytes32 m8;
  7938 |     |         /// @solidity memory-safe-assembly
  7939 |     |         assembly {
  7940 |     |             function writeString(pos, w) {
  7941 |     |                 let length := 0
  7942 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7943 |     |                 mstore(pos, length)
  7944 |     |                 let shift := sub(256, shl(3, length))
  7945 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7946 |     |             }
  7947 |     |             m0 := mload(0x00)
  7948 |     |             m1 := mload(0x20)
  7949 |     |             m2 := mload(0x40)
  7950 |     |             m3 := mload(0x60)
  7951 |     |             m4 := mload(0x80)
  7952 |     |             m5 := mload(0xa0)
  7953 |     |             m6 := mload(0xc0)
  7954 |     |             m7 := mload(0xe0)
  7955 |     |             m8 := mload(0x100)
  7956 |     |             // Selector of `log(bool,string,string,address)`.
  7957 |     |             mstore(0x00, 0x97d394d8)
  7958 |     |             mstore(0x20, p0)
  7959 |     |             mstore(0x40, 0x80)
  7960 |     |             mstore(0x60, 0xc0)
  7961 |     |             mstore(0x80, p3)
  7962 |     |             writeString(0xa0, p1)
  7963 |     |             writeString(0xe0, p2)
  7964 |     |         }
  7965 |     |         _sendLogPayload(0x1c, 0x104);
  7966 |     |         /// @solidity memory-safe-assembly
  7967 |     |         assembly {
  7968 |     |             mstore(0x00, m0)
  7969 |     |             mstore(0x20, m1)
  7970 |     |             mstore(0x40, m2)
  7971 |     |             mstore(0x60, m3)
  7972 |     |             mstore(0x80, m4)
  7973 |     |             mstore(0xa0, m5)
  7974 |     |             mstore(0xc0, m6)
  7975 |     |             mstore(0xe0, m7)
  7976 |     |             mstore(0x100, m8)
  7977 |     |         }
  7978 |     |     }
  7979 |     | 
  7980 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  7981 |     |         bytes32 m0;
  7982 |     |         bytes32 m1;
  7983 |     |         bytes32 m2;
  7984 |     |         bytes32 m3;
  7985 |     |         bytes32 m4;
  7986 |     |         bytes32 m5;
  7987 |     |         bytes32 m6;
  7988 |     |         bytes32 m7;
  7989 |     |         bytes32 m8;
  7990 |     |         /// @solidity memory-safe-assembly
  7991 |     |         assembly {
  7992 |     |             function writeString(pos, w) {
  7993 |     |                 let length := 0
  7994 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7995 |     |                 mstore(pos, length)
  7996 |     |                 let shift := sub(256, shl(3, length))
  7997 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7998 |     |             }
  7999 |     |             m0 := mload(0x00)
  8000 |     |             m1 := mload(0x20)
  8001 |     |             m2 := mload(0x40)
  8002 |     |             m3 := mload(0x60)
  8003 |     |             m4 := mload(0x80)
  8004 |     |             m5 := mload(0xa0)
  8005 |     |             m6 := mload(0xc0)
  8006 |     |             m7 := mload(0xe0)
  8007 |     |             m8 := mload(0x100)
  8008 |     |             // Selector of `log(bool,string,string,bool)`.
  8009 |     |             mstore(0x00, 0x1e4b87e5)
  8010 |     |             mstore(0x20, p0)
  8011 |     |             mstore(0x40, 0x80)
  8012 |     |             mstore(0x60, 0xc0)
  8013 |     |             mstore(0x80, p3)
  8014 |     |             writeString(0xa0, p1)
  8015 |     |             writeString(0xe0, p2)
  8016 |     |         }
  8017 |     |         _sendLogPayload(0x1c, 0x104);
  8018 |     |         /// @solidity memory-safe-assembly
  8019 |     |         assembly {
  8020 |     |             mstore(0x00, m0)
  8021 |     |             mstore(0x20, m1)
  8022 |     |             mstore(0x40, m2)
  8023 |     |             mstore(0x60, m3)
  8024 |     |             mstore(0x80, m4)
  8025 |     |             mstore(0xa0, m5)
  8026 |     |             mstore(0xc0, m6)
  8027 |     |             mstore(0xe0, m7)
  8028 |     |             mstore(0x100, m8)
  8029 |     |         }
  8030 |     |     }
  8031 |     | 
  8032 |     |     function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  8033 |     |         bytes32 m0;
  8034 |     |         bytes32 m1;
  8035 |     |         bytes32 m2;
  8036 |     |         bytes32 m3;
  8037 |     |         bytes32 m4;
  8038 |     |         bytes32 m5;
  8039 |     |         bytes32 m6;
  8040 |     |         bytes32 m7;
  8041 |     |         bytes32 m8;
  8042 |     |         /// @solidity memory-safe-assembly
  8043 |     |         assembly {
  8044 |     |             function writeString(pos, w) {
  8045 |     |                 let length := 0
  8046 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8047 |     |                 mstore(pos, length)
  8048 |     |                 let shift := sub(256, shl(3, length))
  8049 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8050 |     |             }
  8051 |     |             m0 := mload(0x00)
  8052 |     |             m1 := mload(0x20)
  8053 |     |             m2 := mload(0x40)
  8054 |     |             m3 := mload(0x60)
  8055 |     |             m4 := mload(0x80)
  8056 |     |             m5 := mload(0xa0)
  8057 |     |             m6 := mload(0xc0)
  8058 |     |             m7 := mload(0xe0)
  8059 |     |             m8 := mload(0x100)
  8060 |     |             // Selector of `log(bool,string,string,uint256)`.
  8061 |     |             mstore(0x00, 0x7be0c3eb)
  8062 |     |             mstore(0x20, p0)
  8063 |     |             mstore(0x40, 0x80)
  8064 |     |             mstore(0x60, 0xc0)
  8065 |     |             mstore(0x80, p3)
  8066 |     |             writeString(0xa0, p1)
  8067 |     |             writeString(0xe0, p2)
  8068 |     |         }
  8069 |     |         _sendLogPayload(0x1c, 0x104);
  8070 |     |         /// @solidity memory-safe-assembly
  8071 |     |         assembly {
  8072 |     |             mstore(0x00, m0)
  8073 |     |             mstore(0x20, m1)
  8074 |     |             mstore(0x40, m2)
  8075 |     |             mstore(0x60, m3)
  8076 |     |             mstore(0x80, m4)
  8077 |     |             mstore(0xa0, m5)
  8078 |     |             mstore(0xc0, m6)
  8079 |     |             mstore(0xe0, m7)
  8080 |     |             mstore(0x100, m8)
  8081 |     |         }
  8082 |     |     }
  8083 |     | 
  8084 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  8085 |     |         bytes32 m0;
  8086 |     |         bytes32 m1;
  8087 |     |         bytes32 m2;
  8088 |     |         bytes32 m3;
  8089 |     |         bytes32 m4;
  8090 |     |         bytes32 m5;
  8091 |     |         bytes32 m6;
  8092 |     |         bytes32 m7;
  8093 |     |         bytes32 m8;
  8094 |     |         bytes32 m9;
  8095 |     |         bytes32 m10;
  8096 |     |         /// @solidity memory-safe-assembly
  8097 |     |         assembly {
  8098 |     |             function writeString(pos, w) {
  8099 |     |                 let length := 0
  8100 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8101 |     |                 mstore(pos, length)
  8102 |     |                 let shift := sub(256, shl(3, length))
  8103 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8104 |     |             }
  8105 |     |             m0 := mload(0x00)
  8106 |     |             m1 := mload(0x20)
  8107 |     |             m2 := mload(0x40)
  8108 |     |             m3 := mload(0x60)
  8109 |     |             m4 := mload(0x80)
  8110 |     |             m5 := mload(0xa0)
  8111 |     |             m6 := mload(0xc0)
  8112 |     |             m7 := mload(0xe0)
  8113 |     |             m8 := mload(0x100)
  8114 |     |             m9 := mload(0x120)
  8115 |     |             m10 := mload(0x140)
  8116 |     |             // Selector of `log(bool,string,string,string)`.
  8117 |     |             mstore(0x00, 0x1762e32a)
  8118 |     |             mstore(0x20, p0)
  8119 |     |             mstore(0x40, 0x80)
  8120 |     |             mstore(0x60, 0xc0)
  8121 |     |             mstore(0x80, 0x100)
  8122 |     |             writeString(0xa0, p1)
  8123 |     |             writeString(0xe0, p2)
  8124 |     |             writeString(0x120, p3)
  8125 |     |         }
  8126 |     |         _sendLogPayload(0x1c, 0x144);
  8127 |     |         /// @solidity memory-safe-assembly
  8128 |     |         assembly {
  8129 |     |             mstore(0x00, m0)
  8130 |     |             mstore(0x20, m1)
  8131 |     |             mstore(0x40, m2)
  8132 |     |             mstore(0x60, m3)
  8133 |     |             mstore(0x80, m4)
  8134 |     |             mstore(0xa0, m5)
  8135 |     |             mstore(0xc0, m6)
  8136 |     |             mstore(0xe0, m7)
  8137 |     |             mstore(0x100, m8)
  8138 |     |             mstore(0x120, m9)
  8139 |     |             mstore(0x140, m10)
  8140 |     |         }
  8141 |     |     }
  8142 |     | 
  8143 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  8144 |     |         bytes32 m0;
  8145 |     |         bytes32 m1;
  8146 |     |         bytes32 m2;
  8147 |     |         bytes32 m3;
  8148 |     |         bytes32 m4;
  8149 |     |         /// @solidity memory-safe-assembly
  8150 |     |         assembly {
  8151 |     |             m0 := mload(0x00)
  8152 |     |             m1 := mload(0x20)
  8153 |     |             m2 := mload(0x40)
  8154 |     |             m3 := mload(0x60)
  8155 |     |             m4 := mload(0x80)
  8156 |     |             // Selector of `log(uint256,address,address,address)`.
  8157 |     |             mstore(0x00, 0x2488b414)
  8158 |     |             mstore(0x20, p0)
  8159 |     |             mstore(0x40, p1)
  8160 |     |             mstore(0x60, p2)
  8161 |     |             mstore(0x80, p3)
  8162 |     |         }
  8163 |     |         _sendLogPayload(0x1c, 0x84);
  8164 |     |         /// @solidity memory-safe-assembly
  8165 |     |         assembly {
  8166 |     |             mstore(0x00, m0)
  8167 |     |             mstore(0x20, m1)
  8168 |     |             mstore(0x40, m2)
  8169 |     |             mstore(0x60, m3)
  8170 |     |             mstore(0x80, m4)
  8171 |     |         }
  8172 |     |     }
  8173 |     | 
  8174 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  8175 |     |         bytes32 m0;
  8176 |     |         bytes32 m1;
  8177 |     |         bytes32 m2;
  8178 |     |         bytes32 m3;
  8179 |     |         bytes32 m4;
  8180 |     |         /// @solidity memory-safe-assembly
  8181 |     |         assembly {
  8182 |     |             m0 := mload(0x00)
  8183 |     |             m1 := mload(0x20)
  8184 |     |             m2 := mload(0x40)
  8185 |     |             m3 := mload(0x60)
  8186 |     |             m4 := mload(0x80)
  8187 |     |             // Selector of `log(uint256,address,address,bool)`.
  8188 |     |             mstore(0x00, 0x091ffaf5)
  8189 |     |             mstore(0x20, p0)
  8190 |     |             mstore(0x40, p1)
  8191 |     |             mstore(0x60, p2)
  8192 |     |             mstore(0x80, p3)
  8193 |     |         }
  8194 |     |         _sendLogPayload(0x1c, 0x84);
  8195 |     |         /// @solidity memory-safe-assembly
  8196 |     |         assembly {
  8197 |     |             mstore(0x00, m0)
  8198 |     |             mstore(0x20, m1)
  8199 |     |             mstore(0x40, m2)
  8200 |     |             mstore(0x60, m3)
  8201 |     |             mstore(0x80, m4)
  8202 |     |         }
  8203 |     |     }
  8204 |     | 
  8205 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  8206 |     |         bytes32 m0;
  8207 |     |         bytes32 m1;
  8208 |     |         bytes32 m2;
  8209 |     |         bytes32 m3;
  8210 |     |         bytes32 m4;
  8211 |     |         /// @solidity memory-safe-assembly
  8212 |     |         assembly {
  8213 |     |             m0 := mload(0x00)
  8214 |     |             m1 := mload(0x20)
  8215 |     |             m2 := mload(0x40)
  8216 |     |             m3 := mload(0x60)
  8217 |     |             m4 := mload(0x80)
  8218 |     |             // Selector of `log(uint256,address,address,uint256)`.
  8219 |     |             mstore(0x00, 0x736efbb6)
  8220 |     |             mstore(0x20, p0)
  8221 |     |             mstore(0x40, p1)
  8222 |     |             mstore(0x60, p2)
  8223 |     |             mstore(0x80, p3)
  8224 |     |         }
  8225 |     |         _sendLogPayload(0x1c, 0x84);
  8226 |     |         /// @solidity memory-safe-assembly
  8227 |     |         assembly {
  8228 |     |             mstore(0x00, m0)
  8229 |     |             mstore(0x20, m1)
  8230 |     |             mstore(0x40, m2)
  8231 |     |             mstore(0x60, m3)
  8232 |     |             mstore(0x80, m4)
  8233 |     |         }
  8234 |     |     }
  8235 |     | 
  8236 |     |     function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {
  8237 |     |         bytes32 m0;
  8238 |     |         bytes32 m1;
  8239 |     |         bytes32 m2;
  8240 |     |         bytes32 m3;
  8241 |     |         bytes32 m4;
  8242 |     |         bytes32 m5;
  8243 |     |         bytes32 m6;
  8244 |     |         /// @solidity memory-safe-assembly
  8245 |     |         assembly {
  8246 |     |             function writeString(pos, w) {
  8247 |     |                 let length := 0
  8248 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8249 |     |                 mstore(pos, length)
  8250 |     |                 let shift := sub(256, shl(3, length))
  8251 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8252 |     |             }
  8253 |     |             m0 := mload(0x00)
  8254 |     |             m1 := mload(0x20)
  8255 |     |             m2 := mload(0x40)
  8256 |     |             m3 := mload(0x60)
  8257 |     |             m4 := mload(0x80)
  8258 |     |             m5 := mload(0xa0)
  8259 |     |             m6 := mload(0xc0)
  8260 |     |             // Selector of `log(uint256,address,address,string)`.
  8261 |     |             mstore(0x00, 0x031c6f73)
  8262 |     |             mstore(0x20, p0)
  8263 |     |             mstore(0x40, p1)
  8264 |     |             mstore(0x60, p2)
  8265 |     |             mstore(0x80, 0x80)
  8266 |     |             writeString(0xa0, p3)
  8267 |     |         }
  8268 |     |         _sendLogPayload(0x1c, 0xc4);
  8269 |     |         /// @solidity memory-safe-assembly
  8270 |     |         assembly {
  8271 |     |             mstore(0x00, m0)
  8272 |     |             mstore(0x20, m1)
  8273 |     |             mstore(0x40, m2)
  8274 |     |             mstore(0x60, m3)
  8275 |     |             mstore(0x80, m4)
  8276 |     |             mstore(0xa0, m5)
  8277 |     |             mstore(0xc0, m6)
  8278 |     |         }
  8279 |     |     }
  8280 |     | 
  8281 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  8282 |     |         bytes32 m0;
  8283 |     |         bytes32 m1;
  8284 |     |         bytes32 m2;
  8285 |     |         bytes32 m3;
  8286 |     |         bytes32 m4;
  8287 |     |         /// @solidity memory-safe-assembly
  8288 |     |         assembly {
  8289 |     |             m0 := mload(0x00)
  8290 |     |             m1 := mload(0x20)
  8291 |     |             m2 := mload(0x40)
  8292 |     |             m3 := mload(0x60)
  8293 |     |             m4 := mload(0x80)
  8294 |     |             // Selector of `log(uint256,address,bool,address)`.
  8295 |     |             mstore(0x00, 0xef72c513)
  8296 |     |             mstore(0x20, p0)
  8297 |     |             mstore(0x40, p1)
  8298 |     |             mstore(0x60, p2)
  8299 |     |             mstore(0x80, p3)
  8300 |     |         }
  8301 |     |         _sendLogPayload(0x1c, 0x84);
  8302 |     |         /// @solidity memory-safe-assembly
  8303 |     |         assembly {
  8304 |     |             mstore(0x00, m0)
  8305 |     |             mstore(0x20, m1)
  8306 |     |             mstore(0x40, m2)
  8307 |     |             mstore(0x60, m3)
  8308 |     |             mstore(0x80, m4)
  8309 |     |         }
  8310 |     |     }
  8311 |     | 
  8312 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  8313 |     |         bytes32 m0;
  8314 |     |         bytes32 m1;
  8315 |     |         bytes32 m2;
  8316 |     |         bytes32 m3;
  8317 |     |         bytes32 m4;
  8318 |     |         /// @solidity memory-safe-assembly
  8319 |     |         assembly {
  8320 |     |             m0 := mload(0x00)
  8321 |     |             m1 := mload(0x20)
  8322 |     |             m2 := mload(0x40)
  8323 |     |             m3 := mload(0x60)
  8324 |     |             m4 := mload(0x80)
  8325 |     |             // Selector of `log(uint256,address,bool,bool)`.
  8326 |     |             mstore(0x00, 0xe351140f)
  8327 |     |             mstore(0x20, p0)
  8328 |     |             mstore(0x40, p1)
  8329 |     |             mstore(0x60, p2)
  8330 |     |             mstore(0x80, p3)
  8331 |     |         }
  8332 |     |         _sendLogPayload(0x1c, 0x84);
  8333 |     |         /// @solidity memory-safe-assembly
  8334 |     |         assembly {
  8335 |     |             mstore(0x00, m0)
  8336 |     |             mstore(0x20, m1)
  8337 |     |             mstore(0x40, m2)
  8338 |     |             mstore(0x60, m3)
  8339 |     |             mstore(0x80, m4)
  8340 |     |         }
  8341 |     |     }
  8342 |     | 
  8343 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  8344 |     |         bytes32 m0;
  8345 |     |         bytes32 m1;
  8346 |     |         bytes32 m2;
  8347 |     |         bytes32 m3;
  8348 |     |         bytes32 m4;
  8349 |     |         /// @solidity memory-safe-assembly
  8350 |     |         assembly {
  8351 |     |             m0 := mload(0x00)
  8352 |     |             m1 := mload(0x20)
  8353 |     |             m2 := mload(0x40)
  8354 |     |             m3 := mload(0x60)
  8355 |     |             m4 := mload(0x80)
  8356 |     |             // Selector of `log(uint256,address,bool,uint256)`.
  8357 |     |             mstore(0x00, 0x5abd992a)
  8358 |     |             mstore(0x20, p0)
  8359 |     |             mstore(0x40, p1)
  8360 |     |             mstore(0x60, p2)
  8361 |     |             mstore(0x80, p3)
  8362 |     |         }
  8363 |     |         _sendLogPayload(0x1c, 0x84);
  8364 |     |         /// @solidity memory-safe-assembly
  8365 |     |         assembly {
  8366 |     |             mstore(0x00, m0)
  8367 |     |             mstore(0x20, m1)
  8368 |     |             mstore(0x40, m2)
  8369 |     |             mstore(0x60, m3)
  8370 |     |             mstore(0x80, m4)
  8371 |     |         }
  8372 |     |     }
  8373 |     | 
  8374 |     |     function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {
  8375 |     |         bytes32 m0;
  8376 |     |         bytes32 m1;
  8377 |     |         bytes32 m2;
  8378 |     |         bytes32 m3;
  8379 |     |         bytes32 m4;
  8380 |     |         bytes32 m5;
  8381 |     |         bytes32 m6;
  8382 |     |         /// @solidity memory-safe-assembly
  8383 |     |         assembly {
  8384 |     |             function writeString(pos, w) {
  8385 |     |                 let length := 0
  8386 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8387 |     |                 mstore(pos, length)
  8388 |     |                 let shift := sub(256, shl(3, length))
  8389 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8390 |     |             }
  8391 |     |             m0 := mload(0x00)
  8392 |     |             m1 := mload(0x20)
  8393 |     |             m2 := mload(0x40)
  8394 |     |             m3 := mload(0x60)
  8395 |     |             m4 := mload(0x80)
  8396 |     |             m5 := mload(0xa0)
  8397 |     |             m6 := mload(0xc0)
  8398 |     |             // Selector of `log(uint256,address,bool,string)`.
  8399 |     |             mstore(0x00, 0x90fb06aa)
  8400 |     |             mstore(0x20, p0)
  8401 |     |             mstore(0x40, p1)
  8402 |     |             mstore(0x60, p2)
  8403 |     |             mstore(0x80, 0x80)
  8404 |     |             writeString(0xa0, p3)
  8405 |     |         }
  8406 |     |         _sendLogPayload(0x1c, 0xc4);
  8407 |     |         /// @solidity memory-safe-assembly
  8408 |     |         assembly {
  8409 |     |             mstore(0x00, m0)
  8410 |     |             mstore(0x20, m1)
  8411 |     |             mstore(0x40, m2)
  8412 |     |             mstore(0x60, m3)
  8413 |     |             mstore(0x80, m4)
  8414 |     |             mstore(0xa0, m5)
  8415 |     |             mstore(0xc0, m6)
  8416 |     |         }
  8417 |     |     }
  8418 |     | 
  8419 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  8420 |     |         bytes32 m0;
  8421 |     |         bytes32 m1;
  8422 |     |         bytes32 m2;
  8423 |     |         bytes32 m3;
  8424 |     |         bytes32 m4;
  8425 |     |         /// @solidity memory-safe-assembly
  8426 |     |         assembly {
  8427 |     |             m0 := mload(0x00)
  8428 |     |             m1 := mload(0x20)
  8429 |     |             m2 := mload(0x40)
  8430 |     |             m3 := mload(0x60)
  8431 |     |             m4 := mload(0x80)
  8432 |     |             // Selector of `log(uint256,address,uint256,address)`.
  8433 |     |             mstore(0x00, 0x15c127b5)
  8434 |     |             mstore(0x20, p0)
  8435 |     |             mstore(0x40, p1)
  8436 |     |             mstore(0x60, p2)
  8437 |     |             mstore(0x80, p3)
  8438 |     |         }
  8439 |     |         _sendLogPayload(0x1c, 0x84);
  8440 |     |         /// @solidity memory-safe-assembly
  8441 |     |         assembly {
  8442 |     |             mstore(0x00, m0)
  8443 |     |             mstore(0x20, m1)
  8444 |     |             mstore(0x40, m2)
  8445 |     |             mstore(0x60, m3)
  8446 |     |             mstore(0x80, m4)
  8447 |     |         }
  8448 |     |     }
  8449 |     | 
  8450 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  8451 |     |         bytes32 m0;
  8452 |     |         bytes32 m1;
  8453 |     |         bytes32 m2;
  8454 |     |         bytes32 m3;
  8455 |     |         bytes32 m4;
  8456 |     |         /// @solidity memory-safe-assembly
  8457 |     |         assembly {
  8458 |     |             m0 := mload(0x00)
  8459 |     |             m1 := mload(0x20)
  8460 |     |             m2 := mload(0x40)
  8461 |     |             m3 := mload(0x60)
  8462 |     |             m4 := mload(0x80)
  8463 |     |             // Selector of `log(uint256,address,uint256,bool)`.
  8464 |     |             mstore(0x00, 0x5f743a7c)
  8465 |     |             mstore(0x20, p0)
  8466 |     |             mstore(0x40, p1)
  8467 |     |             mstore(0x60, p2)
  8468 |     |             mstore(0x80, p3)
  8469 |     |         }
  8470 |     |         _sendLogPayload(0x1c, 0x84);
  8471 |     |         /// @solidity memory-safe-assembly
  8472 |     |         assembly {
  8473 |     |             mstore(0x00, m0)
  8474 |     |             mstore(0x20, m1)
  8475 |     |             mstore(0x40, m2)
  8476 |     |             mstore(0x60, m3)
  8477 |     |             mstore(0x80, m4)
  8478 |     |         }
  8479 |     |     }
  8480 |     | 
  8481 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  8482 |     |         bytes32 m0;
  8483 |     |         bytes32 m1;
  8484 |     |         bytes32 m2;
  8485 |     |         bytes32 m3;
  8486 |     |         bytes32 m4;
  8487 |     |         /// @solidity memory-safe-assembly
  8488 |     |         assembly {
  8489 |     |             m0 := mload(0x00)
  8490 |     |             m1 := mload(0x20)
  8491 |     |             m2 := mload(0x40)
  8492 |     |             m3 := mload(0x60)
  8493 |     |             m4 := mload(0x80)
  8494 |     |             // Selector of `log(uint256,address,uint256,uint256)`.
  8495 |     |             mstore(0x00, 0x0c9cd9c1)
  8496 |     |             mstore(0x20, p0)
  8497 |     |             mstore(0x40, p1)
  8498 |     |             mstore(0x60, p2)
  8499 |     |             mstore(0x80, p3)
  8500 |     |         }
  8501 |     |         _sendLogPayload(0x1c, 0x84);
  8502 |     |         /// @solidity memory-safe-assembly
  8503 |     |         assembly {
  8504 |     |             mstore(0x00, m0)
  8505 |     |             mstore(0x20, m1)
  8506 |     |             mstore(0x40, m2)
  8507 |     |             mstore(0x60, m3)
  8508 |     |             mstore(0x80, m4)
  8509 |     |         }
  8510 |     |     }
  8511 |     | 
  8512 |     |     function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {
  8513 |     |         bytes32 m0;
  8514 |     |         bytes32 m1;
  8515 |     |         bytes32 m2;
  8516 |     |         bytes32 m3;
  8517 |     |         bytes32 m4;
  8518 |     |         bytes32 m5;
  8519 |     |         bytes32 m6;
  8520 |     |         /// @solidity memory-safe-assembly
  8521 |     |         assembly {
  8522 |     |             function writeString(pos, w) {
  8523 |     |                 let length := 0
  8524 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8525 |     |                 mstore(pos, length)
  8526 |     |                 let shift := sub(256, shl(3, length))
  8527 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8528 |     |             }
  8529 |     |             m0 := mload(0x00)
  8530 |     |             m1 := mload(0x20)
  8531 |     |             m2 := mload(0x40)
  8532 |     |             m3 := mload(0x60)
  8533 |     |             m4 := mload(0x80)
  8534 |     |             m5 := mload(0xa0)
  8535 |     |             m6 := mload(0xc0)
  8536 |     |             // Selector of `log(uint256,address,uint256,string)`.
  8537 |     |             mstore(0x00, 0xddb06521)
  8538 |     |             mstore(0x20, p0)
  8539 |     |             mstore(0x40, p1)
  8540 |     |             mstore(0x60, p2)
  8541 |     |             mstore(0x80, 0x80)
  8542 |     |             writeString(0xa0, p3)
  8543 |     |         }
  8544 |     |         _sendLogPayload(0x1c, 0xc4);
  8545 |     |         /// @solidity memory-safe-assembly
  8546 |     |         assembly {
  8547 |     |             mstore(0x00, m0)
  8548 |     |             mstore(0x20, m1)
  8549 |     |             mstore(0x40, m2)
  8550 |     |             mstore(0x60, m3)
  8551 |     |             mstore(0x80, m4)
  8552 |     |             mstore(0xa0, m5)
  8553 |     |             mstore(0xc0, m6)
  8554 |     |         }
  8555 |     |     }
  8556 |     | 
  8557 |     |     function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {
  8558 |     |         bytes32 m0;
  8559 |     |         bytes32 m1;
  8560 |     |         bytes32 m2;
  8561 |     |         bytes32 m3;
  8562 |     |         bytes32 m4;
  8563 |     |         bytes32 m5;
  8564 |     |         bytes32 m6;
  8565 |     |         /// @solidity memory-safe-assembly
  8566 |     |         assembly {
  8567 |     |             function writeString(pos, w) {
  8568 |     |                 let length := 0
  8569 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8570 |     |                 mstore(pos, length)
  8571 |     |                 let shift := sub(256, shl(3, length))
  8572 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8573 |     |             }
  8574 |     |             m0 := mload(0x00)
  8575 |     |             m1 := mload(0x20)
  8576 |     |             m2 := mload(0x40)
  8577 |     |             m3 := mload(0x60)
  8578 |     |             m4 := mload(0x80)
  8579 |     |             m5 := mload(0xa0)
  8580 |     |             m6 := mload(0xc0)
  8581 |     |             // Selector of `log(uint256,address,string,address)`.
  8582 |     |             mstore(0x00, 0x9cba8fff)
  8583 |     |             mstore(0x20, p0)
  8584 |     |             mstore(0x40, p1)
  8585 |     |             mstore(0x60, 0x80)
  8586 |     |             mstore(0x80, p3)
  8587 |     |             writeString(0xa0, p2)
  8588 |     |         }
  8589 |     |         _sendLogPayload(0x1c, 0xc4);
  8590 |     |         /// @solidity memory-safe-assembly
  8591 |     |         assembly {
  8592 |     |             mstore(0x00, m0)
  8593 |     |             mstore(0x20, m1)
  8594 |     |             mstore(0x40, m2)
  8595 |     |             mstore(0x60, m3)
  8596 |     |             mstore(0x80, m4)
  8597 |     |             mstore(0xa0, m5)
  8598 |     |             mstore(0xc0, m6)
  8599 |     |         }
  8600 |     |     }
  8601 |     | 
  8602 |     |     function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {
  8603 |     |         bytes32 m0;
  8604 |     |         bytes32 m1;
  8605 |     |         bytes32 m2;
  8606 |     |         bytes32 m3;
  8607 |     |         bytes32 m4;
  8608 |     |         bytes32 m5;
  8609 |     |         bytes32 m6;
  8610 |     |         /// @solidity memory-safe-assembly
  8611 |     |         assembly {
  8612 |     |             function writeString(pos, w) {
  8613 |     |                 let length := 0
  8614 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8615 |     |                 mstore(pos, length)
  8616 |     |                 let shift := sub(256, shl(3, length))
  8617 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8618 |     |             }
  8619 |     |             m0 := mload(0x00)
  8620 |     |             m1 := mload(0x20)
  8621 |     |             m2 := mload(0x40)
  8622 |     |             m3 := mload(0x60)
  8623 |     |             m4 := mload(0x80)
  8624 |     |             m5 := mload(0xa0)
  8625 |     |             m6 := mload(0xc0)
  8626 |     |             // Selector of `log(uint256,address,string,bool)`.
  8627 |     |             mstore(0x00, 0xcc32ab07)
  8628 |     |             mstore(0x20, p0)
  8629 |     |             mstore(0x40, p1)
  8630 |     |             mstore(0x60, 0x80)
  8631 |     |             mstore(0x80, p3)
  8632 |     |             writeString(0xa0, p2)
  8633 |     |         }
  8634 |     |         _sendLogPayload(0x1c, 0xc4);
  8635 |     |         /// @solidity memory-safe-assembly
  8636 |     |         assembly {
  8637 |     |             mstore(0x00, m0)
  8638 |     |             mstore(0x20, m1)
  8639 |     |             mstore(0x40, m2)
  8640 |     |             mstore(0x60, m3)
  8641 |     |             mstore(0x80, m4)
  8642 |     |             mstore(0xa0, m5)
  8643 |     |             mstore(0xc0, m6)
  8644 |     |         }
  8645 |     |     }
  8646 |     | 
  8647 |     |     function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {
  8648 |     |         bytes32 m0;
  8649 |     |         bytes32 m1;
  8650 |     |         bytes32 m2;
  8651 |     |         bytes32 m3;
  8652 |     |         bytes32 m4;
  8653 |     |         bytes32 m5;
  8654 |     |         bytes32 m6;
  8655 |     |         /// @solidity memory-safe-assembly
  8656 |     |         assembly {
  8657 |     |             function writeString(pos, w) {
  8658 |     |                 let length := 0
  8659 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8660 |     |                 mstore(pos, length)
  8661 |     |                 let shift := sub(256, shl(3, length))
  8662 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8663 |     |             }
  8664 |     |             m0 := mload(0x00)
  8665 |     |             m1 := mload(0x20)
  8666 |     |             m2 := mload(0x40)
  8667 |     |             m3 := mload(0x60)
  8668 |     |             m4 := mload(0x80)
  8669 |     |             m5 := mload(0xa0)
  8670 |     |             m6 := mload(0xc0)
  8671 |     |             // Selector of `log(uint256,address,string,uint256)`.
  8672 |     |             mstore(0x00, 0x46826b5d)
  8673 |     |             mstore(0x20, p0)
  8674 |     |             mstore(0x40, p1)
  8675 |     |             mstore(0x60, 0x80)
  8676 |     |             mstore(0x80, p3)
  8677 |     |             writeString(0xa0, p2)
  8678 |     |         }
  8679 |     |         _sendLogPayload(0x1c, 0xc4);
  8680 |     |         /// @solidity memory-safe-assembly
  8681 |     |         assembly {
  8682 |     |             mstore(0x00, m0)
  8683 |     |             mstore(0x20, m1)
  8684 |     |             mstore(0x40, m2)
  8685 |     |             mstore(0x60, m3)
  8686 |     |             mstore(0x80, m4)
  8687 |     |             mstore(0xa0, m5)
  8688 |     |             mstore(0xc0, m6)
  8689 |     |         }
  8690 |     |     }
  8691 |     | 
  8692 |     |     function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  8693 |     |         bytes32 m0;
  8694 |     |         bytes32 m1;
  8695 |     |         bytes32 m2;
  8696 |     |         bytes32 m3;
  8697 |     |         bytes32 m4;
  8698 |     |         bytes32 m5;
  8699 |     |         bytes32 m6;
  8700 |     |         bytes32 m7;
  8701 |     |         bytes32 m8;
  8702 |     |         /// @solidity memory-safe-assembly
  8703 |     |         assembly {
  8704 |     |             function writeString(pos, w) {
  8705 |     |                 let length := 0
  8706 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8707 |     |                 mstore(pos, length)
  8708 |     |                 let shift := sub(256, shl(3, length))
  8709 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8710 |     |             }
  8711 |     |             m0 := mload(0x00)
  8712 |     |             m1 := mload(0x20)
  8713 |     |             m2 := mload(0x40)
  8714 |     |             m3 := mload(0x60)
  8715 |     |             m4 := mload(0x80)
  8716 |     |             m5 := mload(0xa0)
  8717 |     |             m6 := mload(0xc0)
  8718 |     |             m7 := mload(0xe0)
  8719 |     |             m8 := mload(0x100)
  8720 |     |             // Selector of `log(uint256,address,string,string)`.
  8721 |     |             mstore(0x00, 0x3e128ca3)
  8722 |     |             mstore(0x20, p0)
  8723 |     |             mstore(0x40, p1)
  8724 |     |             mstore(0x60, 0x80)
  8725 |     |             mstore(0x80, 0xc0)
  8726 |     |             writeString(0xa0, p2)
  8727 |     |             writeString(0xe0, p3)
  8728 |     |         }
  8729 |     |         _sendLogPayload(0x1c, 0x104);
  8730 |     |         /// @solidity memory-safe-assembly
  8731 |     |         assembly {
  8732 |     |             mstore(0x00, m0)
  8733 |     |             mstore(0x20, m1)
  8734 |     |             mstore(0x40, m2)
  8735 |     |             mstore(0x60, m3)
  8736 |     |             mstore(0x80, m4)
  8737 |     |             mstore(0xa0, m5)
  8738 |     |             mstore(0xc0, m6)
  8739 |     |             mstore(0xe0, m7)
  8740 |     |             mstore(0x100, m8)
  8741 |     |         }
  8742 |     |     }
  8743 |     | 
  8744 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  8745 |     |         bytes32 m0;
  8746 |     |         bytes32 m1;
  8747 |     |         bytes32 m2;
  8748 |     |         bytes32 m3;
  8749 |     |         bytes32 m4;
  8750 |     |         /// @solidity memory-safe-assembly
  8751 |     |         assembly {
  8752 |     |             m0 := mload(0x00)
  8753 |     |             m1 := mload(0x20)
  8754 |     |             m2 := mload(0x40)
  8755 |     |             m3 := mload(0x60)
  8756 |     |             m4 := mload(0x80)
  8757 |     |             // Selector of `log(uint256,bool,address,address)`.
  8758 |     |             mstore(0x00, 0xa1ef4cbb)
  8759 |     |             mstore(0x20, p0)
  8760 |     |             mstore(0x40, p1)
  8761 |     |             mstore(0x60, p2)
  8762 |     |             mstore(0x80, p3)
  8763 |     |         }
  8764 |     |         _sendLogPayload(0x1c, 0x84);
  8765 |     |         /// @solidity memory-safe-assembly
  8766 |     |         assembly {
  8767 |     |             mstore(0x00, m0)
  8768 |     |             mstore(0x20, m1)
  8769 |     |             mstore(0x40, m2)
  8770 |     |             mstore(0x60, m3)
  8771 |     |             mstore(0x80, m4)
  8772 |     |         }
  8773 |     |     }
  8774 |     | 
  8775 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  8776 |     |         bytes32 m0;
  8777 |     |         bytes32 m1;
  8778 |     |         bytes32 m2;
  8779 |     |         bytes32 m3;
  8780 |     |         bytes32 m4;
  8781 |     |         /// @solidity memory-safe-assembly
  8782 |     |         assembly {
  8783 |     |             m0 := mload(0x00)
  8784 |     |             m1 := mload(0x20)
  8785 |     |             m2 := mload(0x40)
  8786 |     |             m3 := mload(0x60)
  8787 |     |             m4 := mload(0x80)
  8788 |     |             // Selector of `log(uint256,bool,address,bool)`.
  8789 |     |             mstore(0x00, 0x454d54a5)
  8790 |     |             mstore(0x20, p0)
  8791 |     |             mstore(0x40, p1)
  8792 |     |             mstore(0x60, p2)
  8793 |     |             mstore(0x80, p3)
  8794 |     |         }
  8795 |     |         _sendLogPayload(0x1c, 0x84);
  8796 |     |         /// @solidity memory-safe-assembly
  8797 |     |         assembly {
  8798 |     |             mstore(0x00, m0)
  8799 |     |             mstore(0x20, m1)
  8800 |     |             mstore(0x40, m2)
  8801 |     |             mstore(0x60, m3)
  8802 |     |             mstore(0x80, m4)
  8803 |     |         }
  8804 |     |     }
  8805 |     | 
  8806 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  8807 |     |         bytes32 m0;
  8808 |     |         bytes32 m1;
  8809 |     |         bytes32 m2;
  8810 |     |         bytes32 m3;
  8811 |     |         bytes32 m4;
  8812 |     |         /// @solidity memory-safe-assembly
  8813 |     |         assembly {
  8814 |     |             m0 := mload(0x00)
  8815 |     |             m1 := mload(0x20)
  8816 |     |             m2 := mload(0x40)
  8817 |     |             m3 := mload(0x60)
  8818 |     |             m4 := mload(0x80)
  8819 |     |             // Selector of `log(uint256,bool,address,uint256)`.
  8820 |     |             mstore(0x00, 0x078287f5)
  8821 |     |             mstore(0x20, p0)
  8822 |     |             mstore(0x40, p1)
  8823 |     |             mstore(0x60, p2)
  8824 |     |             mstore(0x80, p3)
  8825 |     |         }
  8826 |     |         _sendLogPayload(0x1c, 0x84);
  8827 |     |         /// @solidity memory-safe-assembly
  8828 |     |         assembly {
  8829 |     |             mstore(0x00, m0)
  8830 |     |             mstore(0x20, m1)
  8831 |     |             mstore(0x40, m2)
  8832 |     |             mstore(0x60, m3)
  8833 |     |             mstore(0x80, m4)
  8834 |     |         }
  8835 |     |     }
  8836 |     | 
  8837 |     |     function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {
  8838 |     |         bytes32 m0;
  8839 |     |         bytes32 m1;
  8840 |     |         bytes32 m2;
  8841 |     |         bytes32 m3;
  8842 |     |         bytes32 m4;
  8843 |     |         bytes32 m5;
  8844 |     |         bytes32 m6;
  8845 |     |         /// @solidity memory-safe-assembly
  8846 |     |         assembly {
  8847 |     |             function writeString(pos, w) {
  8848 |     |                 let length := 0
  8849 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8850 |     |                 mstore(pos, length)
  8851 |     |                 let shift := sub(256, shl(3, length))
  8852 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8853 |     |             }
  8854 |     |             m0 := mload(0x00)
  8855 |     |             m1 := mload(0x20)
  8856 |     |             m2 := mload(0x40)
  8857 |     |             m3 := mload(0x60)
  8858 |     |             m4 := mload(0x80)
  8859 |     |             m5 := mload(0xa0)
  8860 |     |             m6 := mload(0xc0)
  8861 |     |             // Selector of `log(uint256,bool,address,string)`.
  8862 |     |             mstore(0x00, 0xade052c7)
  8863 |     |             mstore(0x20, p0)
  8864 |     |             mstore(0x40, p1)
  8865 |     |             mstore(0x60, p2)
  8866 |     |             mstore(0x80, 0x80)
  8867 |     |             writeString(0xa0, p3)
  8868 |     |         }
  8869 |     |         _sendLogPayload(0x1c, 0xc4);
  8870 |     |         /// @solidity memory-safe-assembly
  8871 |     |         assembly {
  8872 |     |             mstore(0x00, m0)
  8873 |     |             mstore(0x20, m1)
  8874 |     |             mstore(0x40, m2)
  8875 |     |             mstore(0x60, m3)
  8876 |     |             mstore(0x80, m4)
  8877 |     |             mstore(0xa0, m5)
  8878 |     |             mstore(0xc0, m6)
  8879 |     |         }
  8880 |     |     }
  8881 |     | 
  8882 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  8883 |     |         bytes32 m0;
  8884 |     |         bytes32 m1;
  8885 |     |         bytes32 m2;
  8886 |     |         bytes32 m3;
  8887 |     |         bytes32 m4;
  8888 |     |         /// @solidity memory-safe-assembly
  8889 |     |         assembly {
  8890 |     |             m0 := mload(0x00)
  8891 |     |             m1 := mload(0x20)
  8892 |     |             m2 := mload(0x40)
  8893 |     |             m3 := mload(0x60)
  8894 |     |             m4 := mload(0x80)
  8895 |     |             // Selector of `log(uint256,bool,bool,address)`.
  8896 |     |             mstore(0x00, 0x69640b59)
  8897 |     |             mstore(0x20, p0)
  8898 |     |             mstore(0x40, p1)
  8899 |     |             mstore(0x60, p2)
  8900 |     |             mstore(0x80, p3)
  8901 |     |         }
  8902 |     |         _sendLogPayload(0x1c, 0x84);
  8903 |     |         /// @solidity memory-safe-assembly
  8904 |     |         assembly {
  8905 |     |             mstore(0x00, m0)
  8906 |     |             mstore(0x20, m1)
  8907 |     |             mstore(0x40, m2)
  8908 |     |             mstore(0x60, m3)
  8909 |     |             mstore(0x80, m4)
  8910 |     |         }
  8911 |     |     }
  8912 |     | 
  8913 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  8914 |     |         bytes32 m0;
  8915 |     |         bytes32 m1;
  8916 |     |         bytes32 m2;
  8917 |     |         bytes32 m3;
  8918 |     |         bytes32 m4;
  8919 |     |         /// @solidity memory-safe-assembly
  8920 |     |         assembly {
  8921 |     |             m0 := mload(0x00)
  8922 |     |             m1 := mload(0x20)
  8923 |     |             m2 := mload(0x40)
  8924 |     |             m3 := mload(0x60)
  8925 |     |             m4 := mload(0x80)
  8926 |     |             // Selector of `log(uint256,bool,bool,bool)`.
  8927 |     |             mstore(0x00, 0xb6f577a1)
  8928 |     |             mstore(0x20, p0)
  8929 |     |             mstore(0x40, p1)
  8930 |     |             mstore(0x60, p2)
  8931 |     |             mstore(0x80, p3)
  8932 |     |         }
  8933 |     |         _sendLogPayload(0x1c, 0x84);
  8934 |     |         /// @solidity memory-safe-assembly
  8935 |     |         assembly {
  8936 |     |             mstore(0x00, m0)
  8937 |     |             mstore(0x20, m1)
  8938 |     |             mstore(0x40, m2)
  8939 |     |             mstore(0x60, m3)
  8940 |     |             mstore(0x80, m4)
  8941 |     |         }
  8942 |     |     }
  8943 |     | 
  8944 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  8945 |     |         bytes32 m0;
  8946 |     |         bytes32 m1;
  8947 |     |         bytes32 m2;
  8948 |     |         bytes32 m3;
  8949 |     |         bytes32 m4;
  8950 |     |         /// @solidity memory-safe-assembly
  8951 |     |         assembly {
  8952 |     |             m0 := mload(0x00)
  8953 |     |             m1 := mload(0x20)
  8954 |     |             m2 := mload(0x40)
  8955 |     |             m3 := mload(0x60)
  8956 |     |             m4 := mload(0x80)
  8957 |     |             // Selector of `log(uint256,bool,bool,uint256)`.
  8958 |     |             mstore(0x00, 0x7464ce23)
  8959 |     |             mstore(0x20, p0)
  8960 |     |             mstore(0x40, p1)
  8961 |     |             mstore(0x60, p2)
  8962 |     |             mstore(0x80, p3)
  8963 |     |         }
  8964 |     |         _sendLogPayload(0x1c, 0x84);
  8965 |     |         /// @solidity memory-safe-assembly
  8966 |     |         assembly {
  8967 |     |             mstore(0x00, m0)
  8968 |     |             mstore(0x20, m1)
  8969 |     |             mstore(0x40, m2)
  8970 |     |             mstore(0x60, m3)
  8971 |     |             mstore(0x80, m4)
  8972 |     |         }
  8973 |     |     }
  8974 |     | 
  8975 |     |     function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {
  8976 |     |         bytes32 m0;
  8977 |     |         bytes32 m1;
  8978 |     |         bytes32 m2;
  8979 |     |         bytes32 m3;
  8980 |     |         bytes32 m4;
  8981 |     |         bytes32 m5;
  8982 |     |         bytes32 m6;
  8983 |     |         /// @solidity memory-safe-assembly
  8984 |     |         assembly {
  8985 |     |             function writeString(pos, w) {
  8986 |     |                 let length := 0
  8987 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8988 |     |                 mstore(pos, length)
  8989 |     |                 let shift := sub(256, shl(3, length))
  8990 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8991 |     |             }
  8992 |     |             m0 := mload(0x00)
  8993 |     |             m1 := mload(0x20)
  8994 |     |             m2 := mload(0x40)
  8995 |     |             m3 := mload(0x60)
  8996 |     |             m4 := mload(0x80)
  8997 |     |             m5 := mload(0xa0)
  8998 |     |             m6 := mload(0xc0)
  8999 |     |             // Selector of `log(uint256,bool,bool,string)`.
  9000 |     |             mstore(0x00, 0xdddb9561)
  9001 |     |             mstore(0x20, p0)
  9002 |     |             mstore(0x40, p1)
  9003 |     |             mstore(0x60, p2)
  9004 |     |             mstore(0x80, 0x80)
  9005 |     |             writeString(0xa0, p3)
  9006 |     |         }
  9007 |     |         _sendLogPayload(0x1c, 0xc4);
  9008 |     |         /// @solidity memory-safe-assembly
  9009 |     |         assembly {
  9010 |     |             mstore(0x00, m0)
  9011 |     |             mstore(0x20, m1)
  9012 |     |             mstore(0x40, m2)
  9013 |     |             mstore(0x60, m3)
  9014 |     |             mstore(0x80, m4)
  9015 |     |             mstore(0xa0, m5)
  9016 |     |             mstore(0xc0, m6)
  9017 |     |         }
  9018 |     |     }
  9019 |     | 
  9020 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  9021 |     |         bytes32 m0;
  9022 |     |         bytes32 m1;
  9023 |     |         bytes32 m2;
  9024 |     |         bytes32 m3;
  9025 |     |         bytes32 m4;
  9026 |     |         /// @solidity memory-safe-assembly
  9027 |     |         assembly {
  9028 |     |             m0 := mload(0x00)
  9029 |     |             m1 := mload(0x20)
  9030 |     |             m2 := mload(0x40)
  9031 |     |             m3 := mload(0x60)
  9032 |     |             m4 := mload(0x80)
  9033 |     |             // Selector of `log(uint256,bool,uint256,address)`.
  9034 |     |             mstore(0x00, 0x88cb6041)
  9035 |     |             mstore(0x20, p0)
  9036 |     |             mstore(0x40, p1)
  9037 |     |             mstore(0x60, p2)
  9038 |     |             mstore(0x80, p3)
  9039 |     |         }
  9040 |     |         _sendLogPayload(0x1c, 0x84);
  9041 |     |         /// @solidity memory-safe-assembly
  9042 |     |         assembly {
  9043 |     |             mstore(0x00, m0)
  9044 |     |             mstore(0x20, m1)
  9045 |     |             mstore(0x40, m2)
  9046 |     |             mstore(0x60, m3)
  9047 |     |             mstore(0x80, m4)
  9048 |     |         }
  9049 |     |     }
  9050 |     | 
  9051 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  9052 |     |         bytes32 m0;
  9053 |     |         bytes32 m1;
  9054 |     |         bytes32 m2;
  9055 |     |         bytes32 m3;
  9056 |     |         bytes32 m4;
  9057 |     |         /// @solidity memory-safe-assembly
  9058 |     |         assembly {
  9059 |     |             m0 := mload(0x00)
  9060 |     |             m1 := mload(0x20)
  9061 |     |             m2 := mload(0x40)
  9062 |     |             m3 := mload(0x60)
  9063 |     |             m4 := mload(0x80)
  9064 |     |             // Selector of `log(uint256,bool,uint256,bool)`.
  9065 |     |             mstore(0x00, 0x91a02e2a)
  9066 |     |             mstore(0x20, p0)
  9067 |     |             mstore(0x40, p1)
  9068 |     |             mstore(0x60, p2)
  9069 |     |             mstore(0x80, p3)
  9070 |     |         }
  9071 |     |         _sendLogPayload(0x1c, 0x84);
  9072 |     |         /// @solidity memory-safe-assembly
  9073 |     |         assembly {
  9074 |     |             mstore(0x00, m0)
  9075 |     |             mstore(0x20, m1)
  9076 |     |             mstore(0x40, m2)
  9077 |     |             mstore(0x60, m3)
  9078 |     |             mstore(0x80, m4)
  9079 |     |         }
  9080 |     |     }
  9081 |     | 
  9082 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  9083 |     |         bytes32 m0;
  9084 |     |         bytes32 m1;
  9085 |     |         bytes32 m2;
  9086 |     |         bytes32 m3;
  9087 |     |         bytes32 m4;
  9088 |     |         /// @solidity memory-safe-assembly
  9089 |     |         assembly {
  9090 |     |             m0 := mload(0x00)
  9091 |     |             m1 := mload(0x20)
  9092 |     |             m2 := mload(0x40)
  9093 |     |             m3 := mload(0x60)
  9094 |     |             m4 := mload(0x80)
  9095 |     |             // Selector of `log(uint256,bool,uint256,uint256)`.
  9096 |     |             mstore(0x00, 0xc6acc7a8)
  9097 |     |             mstore(0x20, p0)
  9098 |     |             mstore(0x40, p1)
  9099 |     |             mstore(0x60, p2)
  9100 |     |             mstore(0x80, p3)
  9101 |     |         }
  9102 |     |         _sendLogPayload(0x1c, 0x84);
  9103 |     |         /// @solidity memory-safe-assembly
  9104 |     |         assembly {
  9105 |     |             mstore(0x00, m0)
  9106 |     |             mstore(0x20, m1)
  9107 |     |             mstore(0x40, m2)
  9108 |     |             mstore(0x60, m3)
  9109 |     |             mstore(0x80, m4)
  9110 |     |         }
  9111 |     |     }
  9112 |     | 
  9113 |     |     function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  9114 |     |         bytes32 m0;
  9115 |     |         bytes32 m1;
  9116 |     |         bytes32 m2;
  9117 |     |         bytes32 m3;
  9118 |     |         bytes32 m4;
  9119 |     |         bytes32 m5;
  9120 |     |         bytes32 m6;
  9121 |     |         /// @solidity memory-safe-assembly
  9122 |     |         assembly {
  9123 |     |             function writeString(pos, w) {
  9124 |     |                 let length := 0
  9125 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9126 |     |                 mstore(pos, length)
  9127 |     |                 let shift := sub(256, shl(3, length))
  9128 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9129 |     |             }
  9130 |     |             m0 := mload(0x00)
  9131 |     |             m1 := mload(0x20)
  9132 |     |             m2 := mload(0x40)
  9133 |     |             m3 := mload(0x60)
  9134 |     |             m4 := mload(0x80)
  9135 |     |             m5 := mload(0xa0)
  9136 |     |             m6 := mload(0xc0)
  9137 |     |             // Selector of `log(uint256,bool,uint256,string)`.
  9138 |     |             mstore(0x00, 0xde03e774)
  9139 |     |             mstore(0x20, p0)
  9140 |     |             mstore(0x40, p1)
  9141 |     |             mstore(0x60, p2)
  9142 |     |             mstore(0x80, 0x80)
  9143 |     |             writeString(0xa0, p3)
  9144 |     |         }
  9145 |     |         _sendLogPayload(0x1c, 0xc4);
  9146 |     |         /// @solidity memory-safe-assembly
  9147 |     |         assembly {
  9148 |     |             mstore(0x00, m0)
  9149 |     |             mstore(0x20, m1)
  9150 |     |             mstore(0x40, m2)
  9151 |     |             mstore(0x60, m3)
  9152 |     |             mstore(0x80, m4)
  9153 |     |             mstore(0xa0, m5)
  9154 |     |             mstore(0xc0, m6)
  9155 |     |         }
  9156 |     |     }
  9157 |     | 
  9158 |     |     function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {
  9159 |     |         bytes32 m0;
  9160 |     |         bytes32 m1;
  9161 |     |         bytes32 m2;
  9162 |     |         bytes32 m3;
  9163 |     |         bytes32 m4;
  9164 |     |         bytes32 m5;
  9165 |     |         bytes32 m6;
  9166 |     |         /// @solidity memory-safe-assembly
  9167 |     |         assembly {
  9168 |     |             function writeString(pos, w) {
  9169 |     |                 let length := 0
  9170 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9171 |     |                 mstore(pos, length)
  9172 |     |                 let shift := sub(256, shl(3, length))
  9173 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9174 |     |             }
  9175 |     |             m0 := mload(0x00)
  9176 |     |             m1 := mload(0x20)
  9177 |     |             m2 := mload(0x40)
  9178 |     |             m3 := mload(0x60)
  9179 |     |             m4 := mload(0x80)
  9180 |     |             m5 := mload(0xa0)
  9181 |     |             m6 := mload(0xc0)
  9182 |     |             // Selector of `log(uint256,bool,string,address)`.
  9183 |     |             mstore(0x00, 0xef529018)
  9184 |     |             mstore(0x20, p0)
  9185 |     |             mstore(0x40, p1)
  9186 |     |             mstore(0x60, 0x80)
  9187 |     |             mstore(0x80, p3)
  9188 |     |             writeString(0xa0, p2)
  9189 |     |         }
  9190 |     |         _sendLogPayload(0x1c, 0xc4);
  9191 |     |         /// @solidity memory-safe-assembly
  9192 |     |         assembly {
  9193 |     |             mstore(0x00, m0)
  9194 |     |             mstore(0x20, m1)
  9195 |     |             mstore(0x40, m2)
  9196 |     |             mstore(0x60, m3)
  9197 |     |             mstore(0x80, m4)
  9198 |     |             mstore(0xa0, m5)
  9199 |     |             mstore(0xc0, m6)
  9200 |     |         }
  9201 |     |     }
  9202 |     | 
  9203 |     |     function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {
  9204 |     |         bytes32 m0;
  9205 |     |         bytes32 m1;
  9206 |     |         bytes32 m2;
  9207 |     |         bytes32 m3;
  9208 |     |         bytes32 m4;
  9209 |     |         bytes32 m5;
  9210 |     |         bytes32 m6;
  9211 |     |         /// @solidity memory-safe-assembly
  9212 |     |         assembly {
  9213 |     |             function writeString(pos, w) {
  9214 |     |                 let length := 0
  9215 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9216 |     |                 mstore(pos, length)
  9217 |     |                 let shift := sub(256, shl(3, length))
  9218 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9219 |     |             }
  9220 |     |             m0 := mload(0x00)
  9221 |     |             m1 := mload(0x20)
  9222 |     |             m2 := mload(0x40)
  9223 |     |             m3 := mload(0x60)
  9224 |     |             m4 := mload(0x80)
  9225 |     |             m5 := mload(0xa0)
  9226 |     |             m6 := mload(0xc0)
  9227 |     |             // Selector of `log(uint256,bool,string,bool)`.
  9228 |     |             mstore(0x00, 0xeb928d7f)
  9229 |     |             mstore(0x20, p0)
  9230 |     |             mstore(0x40, p1)
  9231 |     |             mstore(0x60, 0x80)
  9232 |     |             mstore(0x80, p3)
  9233 |     |             writeString(0xa0, p2)
  9234 |     |         }
  9235 |     |         _sendLogPayload(0x1c, 0xc4);
  9236 |     |         /// @solidity memory-safe-assembly
  9237 |     |         assembly {
  9238 |     |             mstore(0x00, m0)
  9239 |     |             mstore(0x20, m1)
  9240 |     |             mstore(0x40, m2)
  9241 |     |             mstore(0x60, m3)
  9242 |     |             mstore(0x80, m4)
  9243 |     |             mstore(0xa0, m5)
  9244 |     |             mstore(0xc0, m6)
  9245 |     |         }
  9246 |     |     }
  9247 |     | 
  9248 |     |     function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  9249 |     |         bytes32 m0;
  9250 |     |         bytes32 m1;
  9251 |     |         bytes32 m2;
  9252 |     |         bytes32 m3;
  9253 |     |         bytes32 m4;
  9254 |     |         bytes32 m5;
  9255 |     |         bytes32 m6;
  9256 |     |         /// @solidity memory-safe-assembly
  9257 |     |         assembly {
  9258 |     |             function writeString(pos, w) {
  9259 |     |                 let length := 0
  9260 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9261 |     |                 mstore(pos, length)
  9262 |     |                 let shift := sub(256, shl(3, length))
  9263 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9264 |     |             }
  9265 |     |             m0 := mload(0x00)
  9266 |     |             m1 := mload(0x20)
  9267 |     |             m2 := mload(0x40)
  9268 |     |             m3 := mload(0x60)
  9269 |     |             m4 := mload(0x80)
  9270 |     |             m5 := mload(0xa0)
  9271 |     |             m6 := mload(0xc0)
  9272 |     |             // Selector of `log(uint256,bool,string,uint256)`.
  9273 |     |             mstore(0x00, 0x2c1d0746)
  9274 |     |             mstore(0x20, p0)
  9275 |     |             mstore(0x40, p1)
  9276 |     |             mstore(0x60, 0x80)
  9277 |     |             mstore(0x80, p3)
  9278 |     |             writeString(0xa0, p2)
  9279 |     |         }
  9280 |     |         _sendLogPayload(0x1c, 0xc4);
  9281 |     |         /// @solidity memory-safe-assembly
  9282 |     |         assembly {
  9283 |     |             mstore(0x00, m0)
  9284 |     |             mstore(0x20, m1)
  9285 |     |             mstore(0x40, m2)
  9286 |     |             mstore(0x60, m3)
  9287 |     |             mstore(0x80, m4)
  9288 |     |             mstore(0xa0, m5)
  9289 |     |             mstore(0xc0, m6)
  9290 |     |         }
  9291 |     |     }
  9292 |     | 
  9293 |     |     function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  9294 |     |         bytes32 m0;
  9295 |     |         bytes32 m1;
  9296 |     |         bytes32 m2;
  9297 |     |         bytes32 m3;
  9298 |     |         bytes32 m4;
  9299 |     |         bytes32 m5;
  9300 |     |         bytes32 m6;
  9301 |     |         bytes32 m7;
  9302 |     |         bytes32 m8;
  9303 |     |         /// @solidity memory-safe-assembly
  9304 |     |         assembly {
  9305 |     |             function writeString(pos, w) {
  9306 |     |                 let length := 0
  9307 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9308 |     |                 mstore(pos, length)
  9309 |     |                 let shift := sub(256, shl(3, length))
  9310 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9311 |     |             }
  9312 |     |             m0 := mload(0x00)
  9313 |     |             m1 := mload(0x20)
  9314 |     |             m2 := mload(0x40)
  9315 |     |             m3 := mload(0x60)
  9316 |     |             m4 := mload(0x80)
  9317 |     |             m5 := mload(0xa0)
  9318 |     |             m6 := mload(0xc0)
  9319 |     |             m7 := mload(0xe0)
  9320 |     |             m8 := mload(0x100)
  9321 |     |             // Selector of `log(uint256,bool,string,string)`.
  9322 |     |             mstore(0x00, 0x68c8b8bd)
  9323 |     |             mstore(0x20, p0)
  9324 |     |             mstore(0x40, p1)
  9325 |     |             mstore(0x60, 0x80)
  9326 |     |             mstore(0x80, 0xc0)
  9327 |     |             writeString(0xa0, p2)
  9328 |     |             writeString(0xe0, p3)
  9329 |     |         }
  9330 |     |         _sendLogPayload(0x1c, 0x104);
  9331 |     |         /// @solidity memory-safe-assembly
  9332 |     |         assembly {
  9333 |     |             mstore(0x00, m0)
  9334 |     |             mstore(0x20, m1)
  9335 |     |             mstore(0x40, m2)
  9336 |     |             mstore(0x60, m3)
  9337 |     |             mstore(0x80, m4)
  9338 |     |             mstore(0xa0, m5)
  9339 |     |             mstore(0xc0, m6)
  9340 |     |             mstore(0xe0, m7)
  9341 |     |             mstore(0x100, m8)
  9342 |     |         }
  9343 |     |     }
  9344 |     | 
  9345 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  9346 |     |         bytes32 m0;
  9347 |     |         bytes32 m1;
  9348 |     |         bytes32 m2;
  9349 |     |         bytes32 m3;
  9350 |     |         bytes32 m4;
  9351 |     |         /// @solidity memory-safe-assembly
  9352 |     |         assembly {
  9353 |     |             m0 := mload(0x00)
  9354 |     |             m1 := mload(0x20)
  9355 |     |             m2 := mload(0x40)
  9356 |     |             m3 := mload(0x60)
  9357 |     |             m4 := mload(0x80)
  9358 |     |             // Selector of `log(uint256,uint256,address,address)`.
  9359 |     |             mstore(0x00, 0x56a5d1b1)
  9360 |     |             mstore(0x20, p0)
  9361 |     |             mstore(0x40, p1)
  9362 |     |             mstore(0x60, p2)
  9363 |     |             mstore(0x80, p3)
  9364 |     |         }
  9365 |     |         _sendLogPayload(0x1c, 0x84);
  9366 |     |         /// @solidity memory-safe-assembly
  9367 |     |         assembly {
  9368 |     |             mstore(0x00, m0)
  9369 |     |             mstore(0x20, m1)
  9370 |     |             mstore(0x40, m2)
  9371 |     |             mstore(0x60, m3)
  9372 |     |             mstore(0x80, m4)
  9373 |     |         }
  9374 |     |     }
  9375 |     | 
  9376 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  9377 |     |         bytes32 m0;
  9378 |     |         bytes32 m1;
  9379 |     |         bytes32 m2;
  9380 |     |         bytes32 m3;
  9381 |     |         bytes32 m4;
  9382 |     |         /// @solidity memory-safe-assembly
  9383 |     |         assembly {
  9384 |     |             m0 := mload(0x00)
  9385 |     |             m1 := mload(0x20)
  9386 |     |             m2 := mload(0x40)
  9387 |     |             m3 := mload(0x60)
  9388 |     |             m4 := mload(0x80)
  9389 |     |             // Selector of `log(uint256,uint256,address,bool)`.
  9390 |     |             mstore(0x00, 0x15cac476)
  9391 |     |             mstore(0x20, p0)
  9392 |     |             mstore(0x40, p1)
  9393 |     |             mstore(0x60, p2)
  9394 |     |             mstore(0x80, p3)
  9395 |     |         }
  9396 |     |         _sendLogPayload(0x1c, 0x84);
  9397 |     |         /// @solidity memory-safe-assembly
  9398 |     |         assembly {
  9399 |     |             mstore(0x00, m0)
  9400 |     |             mstore(0x20, m1)
  9401 |     |             mstore(0x40, m2)
  9402 |     |             mstore(0x60, m3)
  9403 |     |             mstore(0x80, m4)
  9404 |     |         }
  9405 |     |     }
  9406 |     | 
  9407 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  9408 |     |         bytes32 m0;
  9409 |     |         bytes32 m1;
  9410 |     |         bytes32 m2;
  9411 |     |         bytes32 m3;
  9412 |     |         bytes32 m4;
  9413 |     |         /// @solidity memory-safe-assembly
  9414 |     |         assembly {
  9415 |     |             m0 := mload(0x00)
  9416 |     |             m1 := mload(0x20)
  9417 |     |             m2 := mload(0x40)
  9418 |     |             m3 := mload(0x60)
  9419 |     |             m4 := mload(0x80)
  9420 |     |             // Selector of `log(uint256,uint256,address,uint256)`.
  9421 |     |             mstore(0x00, 0x88f6e4b2)
  9422 |     |             mstore(0x20, p0)
  9423 |     |             mstore(0x40, p1)
  9424 |     |             mstore(0x60, p2)
  9425 |     |             mstore(0x80, p3)
  9426 |     |         }
  9427 |     |         _sendLogPayload(0x1c, 0x84);
  9428 |     |         /// @solidity memory-safe-assembly
  9429 |     |         assembly {
  9430 |     |             mstore(0x00, m0)
  9431 |     |             mstore(0x20, m1)
  9432 |     |             mstore(0x40, m2)
  9433 |     |             mstore(0x60, m3)
  9434 |     |             mstore(0x80, m4)
  9435 |     |         }
  9436 |     |     }
  9437 |     | 
  9438 |     |     function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {
  9439 |     |         bytes32 m0;
  9440 |     |         bytes32 m1;
  9441 |     |         bytes32 m2;
  9442 |     |         bytes32 m3;
  9443 |     |         bytes32 m4;
  9444 |     |         bytes32 m5;
  9445 |     |         bytes32 m6;
  9446 |     |         /// @solidity memory-safe-assembly
  9447 |     |         assembly {
  9448 |     |             function writeString(pos, w) {
  9449 |     |                 let length := 0
  9450 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9451 |     |                 mstore(pos, length)
  9452 |     |                 let shift := sub(256, shl(3, length))
  9453 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9454 |     |             }
  9455 |     |             m0 := mload(0x00)
  9456 |     |             m1 := mload(0x20)
  9457 |     |             m2 := mload(0x40)
  9458 |     |             m3 := mload(0x60)
  9459 |     |             m4 := mload(0x80)
  9460 |     |             m5 := mload(0xa0)
  9461 |     |             m6 := mload(0xc0)
  9462 |     |             // Selector of `log(uint256,uint256,address,string)`.
  9463 |     |             mstore(0x00, 0x6cde40b8)
  9464 |     |             mstore(0x20, p0)
  9465 |     |             mstore(0x40, p1)
  9466 |     |             mstore(0x60, p2)
  9467 |     |             mstore(0x80, 0x80)
  9468 |     |             writeString(0xa0, p3)
  9469 |     |         }
  9470 |     |         _sendLogPayload(0x1c, 0xc4);
  9471 |     |         /// @solidity memory-safe-assembly
  9472 |     |         assembly {
  9473 |     |             mstore(0x00, m0)
  9474 |     |             mstore(0x20, m1)
  9475 |     |             mstore(0x40, m2)
  9476 |     |             mstore(0x60, m3)
  9477 |     |             mstore(0x80, m4)
  9478 |     |             mstore(0xa0, m5)
  9479 |     |             mstore(0xc0, m6)
  9480 |     |         }
  9481 |     |     }
  9482 |     | 
  9483 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  9484 |     |         bytes32 m0;
  9485 |     |         bytes32 m1;
  9486 |     |         bytes32 m2;
  9487 |     |         bytes32 m3;
  9488 |     |         bytes32 m4;
  9489 |     |         /// @solidity memory-safe-assembly
  9490 |     |         assembly {
  9491 |     |             m0 := mload(0x00)
  9492 |     |             m1 := mload(0x20)
  9493 |     |             m2 := mload(0x40)
  9494 |     |             m3 := mload(0x60)
  9495 |     |             m4 := mload(0x80)
  9496 |     |             // Selector of `log(uint256,uint256,bool,address)`.
  9497 |     |             mstore(0x00, 0x9a816a83)
  9498 |     |             mstore(0x20, p0)
  9499 |     |             mstore(0x40, p1)
  9500 |     |             mstore(0x60, p2)
  9501 |     |             mstore(0x80, p3)
  9502 |     |         }
  9503 |     |         _sendLogPayload(0x1c, 0x84);
  9504 |     |         /// @solidity memory-safe-assembly
  9505 |     |         assembly {
  9506 |     |             mstore(0x00, m0)
  9507 |     |             mstore(0x20, m1)
  9508 |     |             mstore(0x40, m2)
  9509 |     |             mstore(0x60, m3)
  9510 |     |             mstore(0x80, m4)
  9511 |     |         }
  9512 |     |     }
  9513 |     | 
  9514 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  9515 |     |         bytes32 m0;
  9516 |     |         bytes32 m1;
  9517 |     |         bytes32 m2;
  9518 |     |         bytes32 m3;
  9519 |     |         bytes32 m4;
  9520 |     |         /// @solidity memory-safe-assembly
  9521 |     |         assembly {
  9522 |     |             m0 := mload(0x00)
  9523 |     |             m1 := mload(0x20)
  9524 |     |             m2 := mload(0x40)
  9525 |     |             m3 := mload(0x60)
  9526 |     |             m4 := mload(0x80)
  9527 |     |             // Selector of `log(uint256,uint256,bool,bool)`.
  9528 |     |             mstore(0x00, 0xab085ae6)
  9529 |     |             mstore(0x20, p0)
  9530 |     |             mstore(0x40, p1)
  9531 |     |             mstore(0x60, p2)
  9532 |     |             mstore(0x80, p3)
  9533 |     |         }
  9534 |     |         _sendLogPayload(0x1c, 0x84);
  9535 |     |         /// @solidity memory-safe-assembly
  9536 |     |         assembly {
  9537 |     |             mstore(0x00, m0)
  9538 |     |             mstore(0x20, m1)
  9539 |     |             mstore(0x40, m2)
  9540 |     |             mstore(0x60, m3)
  9541 |     |             mstore(0x80, m4)
  9542 |     |         }
  9543 |     |     }
  9544 |     | 
  9545 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  9546 |     |         bytes32 m0;
  9547 |     |         bytes32 m1;
  9548 |     |         bytes32 m2;
  9549 |     |         bytes32 m3;
  9550 |     |         bytes32 m4;
  9551 |     |         /// @solidity memory-safe-assembly
  9552 |     |         assembly {
  9553 |     |             m0 := mload(0x00)
  9554 |     |             m1 := mload(0x20)
  9555 |     |             m2 := mload(0x40)
  9556 |     |             m3 := mload(0x60)
  9557 |     |             m4 := mload(0x80)
  9558 |     |             // Selector of `log(uint256,uint256,bool,uint256)`.
  9559 |     |             mstore(0x00, 0xeb7f6fd2)
  9560 |     |             mstore(0x20, p0)
  9561 |     |             mstore(0x40, p1)
  9562 |     |             mstore(0x60, p2)
  9563 |     |             mstore(0x80, p3)
  9564 |     |         }
  9565 |     |         _sendLogPayload(0x1c, 0x84);
  9566 |     |         /// @solidity memory-safe-assembly
  9567 |     |         assembly {
  9568 |     |             mstore(0x00, m0)
  9569 |     |             mstore(0x20, m1)
  9570 |     |             mstore(0x40, m2)
  9571 |     |             mstore(0x60, m3)
  9572 |     |             mstore(0x80, m4)
  9573 |     |         }
  9574 |     |     }
  9575 |     | 
  9576 |     |     function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  9577 |     |         bytes32 m0;
  9578 |     |         bytes32 m1;
  9579 |     |         bytes32 m2;
  9580 |     |         bytes32 m3;
  9581 |     |         bytes32 m4;
  9582 |     |         bytes32 m5;
  9583 |     |         bytes32 m6;
  9584 |     |         /// @solidity memory-safe-assembly
  9585 |     |         assembly {
  9586 |     |             function writeString(pos, w) {
  9587 |     |                 let length := 0
  9588 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9589 |     |                 mstore(pos, length)
  9590 |     |                 let shift := sub(256, shl(3, length))
  9591 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9592 |     |             }
  9593 |     |             m0 := mload(0x00)
  9594 |     |             m1 := mload(0x20)
  9595 |     |             m2 := mload(0x40)
  9596 |     |             m3 := mload(0x60)
  9597 |     |             m4 := mload(0x80)
  9598 |     |             m5 := mload(0xa0)
  9599 |     |             m6 := mload(0xc0)
  9600 |     |             // Selector of `log(uint256,uint256,bool,string)`.
  9601 |     |             mstore(0x00, 0xa5b4fc99)
  9602 |     |             mstore(0x20, p0)
  9603 |     |             mstore(0x40, p1)
  9604 |     |             mstore(0x60, p2)
  9605 |     |             mstore(0x80, 0x80)
  9606 |     |             writeString(0xa0, p3)
  9607 |     |         }
  9608 |     |         _sendLogPayload(0x1c, 0xc4);
  9609 |     |         /// @solidity memory-safe-assembly
  9610 |     |         assembly {
  9611 |     |             mstore(0x00, m0)
  9612 |     |             mstore(0x20, m1)
  9613 |     |             mstore(0x40, m2)
  9614 |     |             mstore(0x60, m3)
  9615 |     |             mstore(0x80, m4)
  9616 |     |             mstore(0xa0, m5)
  9617 |     |             mstore(0xc0, m6)
  9618 |     |         }
  9619 |     |     }
  9620 |     | 
  9621 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  9622 |     |         bytes32 m0;
  9623 |     |         bytes32 m1;
  9624 |     |         bytes32 m2;
  9625 |     |         bytes32 m3;
  9626 |     |         bytes32 m4;
  9627 |     |         /// @solidity memory-safe-assembly
  9628 |     |         assembly {
  9629 |     |             m0 := mload(0x00)
  9630 |     |             m1 := mload(0x20)
  9631 |     |             m2 := mload(0x40)
  9632 |     |             m3 := mload(0x60)
  9633 |     |             m4 := mload(0x80)
  9634 |     |             // Selector of `log(uint256,uint256,uint256,address)`.
  9635 |     |             mstore(0x00, 0xfa8185af)
  9636 |     |             mstore(0x20, p0)
  9637 |     |             mstore(0x40, p1)
  9638 |     |             mstore(0x60, p2)
  9639 |     |             mstore(0x80, p3)
  9640 |     |         }
  9641 |     |         _sendLogPayload(0x1c, 0x84);
  9642 |     |         /// @solidity memory-safe-assembly
  9643 |     |         assembly {
  9644 |     |             mstore(0x00, m0)
  9645 |     |             mstore(0x20, m1)
  9646 |     |             mstore(0x40, m2)
  9647 |     |             mstore(0x60, m3)
  9648 |     |             mstore(0x80, m4)
  9649 |     |         }
  9650 |     |     }
  9651 |     | 
  9652 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  9653 |     |         bytes32 m0;
  9654 |     |         bytes32 m1;
  9655 |     |         bytes32 m2;
  9656 |     |         bytes32 m3;
  9657 |     |         bytes32 m4;
  9658 |     |         /// @solidity memory-safe-assembly
  9659 |     |         assembly {
  9660 |     |             m0 := mload(0x00)
  9661 |     |             m1 := mload(0x20)
  9662 |     |             m2 := mload(0x40)
  9663 |     |             m3 := mload(0x60)
  9664 |     |             m4 := mload(0x80)
  9665 |     |             // Selector of `log(uint256,uint256,uint256,bool)`.
  9666 |     |             mstore(0x00, 0xc598d185)
  9667 |     |             mstore(0x20, p0)
  9668 |     |             mstore(0x40, p1)
  9669 |     |             mstore(0x60, p2)
  9670 |     |             mstore(0x80, p3)
  9671 |     |         }
  9672 |     |         _sendLogPayload(0x1c, 0x84);
  9673 |     |         /// @solidity memory-safe-assembly
  9674 |     |         assembly {
  9675 |     |             mstore(0x00, m0)
  9676 |     |             mstore(0x20, m1)
  9677 |     |             mstore(0x40, m2)
  9678 |     |             mstore(0x60, m3)
  9679 |     |             mstore(0x80, m4)
  9680 |     |         }
  9681 |     |     }
  9682 |     | 
  9683 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  9684 |     |         bytes32 m0;
  9685 |     |         bytes32 m1;
  9686 |     |         bytes32 m2;
  9687 |     |         bytes32 m3;
  9688 |     |         bytes32 m4;
  9689 |     |         /// @solidity memory-safe-assembly
  9690 |     |         assembly {
  9691 |     |             m0 := mload(0x00)
  9692 |     |             m1 := mload(0x20)
  9693 |     |             m2 := mload(0x40)
  9694 |     |             m3 := mload(0x60)
  9695 |     |             m4 := mload(0x80)
  9696 |     |             // Selector of `log(uint256,uint256,uint256,uint256)`.
  9697 |     |             mstore(0x00, 0x193fb800)
  9698 |     |             mstore(0x20, p0)
  9699 |     |             mstore(0x40, p1)
  9700 |     |             mstore(0x60, p2)
  9701 |     |             mstore(0x80, p3)
  9702 |     |         }
  9703 |     |         _sendLogPayload(0x1c, 0x84);
  9704 |     |         /// @solidity memory-safe-assembly
  9705 |     |         assembly {
  9706 |     |             mstore(0x00, m0)
  9707 |     |             mstore(0x20, m1)
  9708 |     |             mstore(0x40, m2)
  9709 |     |             mstore(0x60, m3)
  9710 |     |             mstore(0x80, m4)
  9711 |     |         }
  9712 |     |     }
  9713 |     | 
  9714 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  9715 |     |         bytes32 m0;
  9716 |     |         bytes32 m1;
  9717 |     |         bytes32 m2;
  9718 |     |         bytes32 m3;
  9719 |     |         bytes32 m4;
  9720 |     |         bytes32 m5;
  9721 |     |         bytes32 m6;
  9722 |     |         /// @solidity memory-safe-assembly
  9723 |     |         assembly {
  9724 |     |             function writeString(pos, w) {
  9725 |     |                 let length := 0
  9726 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9727 |     |                 mstore(pos, length)
  9728 |     |                 let shift := sub(256, shl(3, length))
  9729 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9730 |     |             }
  9731 |     |             m0 := mload(0x00)
  9732 |     |             m1 := mload(0x20)
  9733 |     |             m2 := mload(0x40)
  9734 |     |             m3 := mload(0x60)
  9735 |     |             m4 := mload(0x80)
  9736 |     |             m5 := mload(0xa0)
  9737 |     |             m6 := mload(0xc0)
  9738 |     |             // Selector of `log(uint256,uint256,uint256,string)`.
  9739 |     |             mstore(0x00, 0x59cfcbe3)
  9740 |     |             mstore(0x20, p0)
  9741 |     |             mstore(0x40, p1)
  9742 |     |             mstore(0x60, p2)
  9743 |     |             mstore(0x80, 0x80)
  9744 |     |             writeString(0xa0, p3)
  9745 |     |         }
  9746 |     |         _sendLogPayload(0x1c, 0xc4);
  9747 |     |         /// @solidity memory-safe-assembly
  9748 |     |         assembly {
  9749 |     |             mstore(0x00, m0)
  9750 |     |             mstore(0x20, m1)
  9751 |     |             mstore(0x40, m2)
  9752 |     |             mstore(0x60, m3)
  9753 |     |             mstore(0x80, m4)
  9754 |     |             mstore(0xa0, m5)
  9755 |     |             mstore(0xc0, m6)
  9756 |     |         }
  9757 |     |     }
  9758 |     | 
  9759 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {
  9760 |     |         bytes32 m0;
  9761 |     |         bytes32 m1;
  9762 |     |         bytes32 m2;
  9763 |     |         bytes32 m3;
  9764 |     |         bytes32 m4;
  9765 |     |         bytes32 m5;
  9766 |     |         bytes32 m6;
  9767 |     |         /// @solidity memory-safe-assembly
  9768 |     |         assembly {
  9769 |     |             function writeString(pos, w) {
  9770 |     |                 let length := 0
  9771 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9772 |     |                 mstore(pos, length)
  9773 |     |                 let shift := sub(256, shl(3, length))
  9774 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9775 |     |             }
  9776 |     |             m0 := mload(0x00)
  9777 |     |             m1 := mload(0x20)
  9778 |     |             m2 := mload(0x40)
  9779 |     |             m3 := mload(0x60)
  9780 |     |             m4 := mload(0x80)
  9781 |     |             m5 := mload(0xa0)
  9782 |     |             m6 := mload(0xc0)
  9783 |     |             // Selector of `log(uint256,uint256,string,address)`.
  9784 |     |             mstore(0x00, 0x42d21db7)
  9785 |     |             mstore(0x20, p0)
  9786 |     |             mstore(0x40, p1)
  9787 |     |             mstore(0x60, 0x80)
  9788 |     |             mstore(0x80, p3)
  9789 |     |             writeString(0xa0, p2)
  9790 |     |         }
  9791 |     |         _sendLogPayload(0x1c, 0xc4);
  9792 |     |         /// @solidity memory-safe-assembly
  9793 |     |         assembly {
  9794 |     |             mstore(0x00, m0)
  9795 |     |             mstore(0x20, m1)
  9796 |     |             mstore(0x40, m2)
  9797 |     |             mstore(0x60, m3)
  9798 |     |             mstore(0x80, m4)
  9799 |     |             mstore(0xa0, m5)
  9800 |     |             mstore(0xc0, m6)
  9801 |     |         }
  9802 |     |     }
  9803 |     | 
  9804 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  9805 |     |         bytes32 m0;
  9806 |     |         bytes32 m1;
  9807 |     |         bytes32 m2;
  9808 |     |         bytes32 m3;
  9809 |     |         bytes32 m4;
  9810 |     |         bytes32 m5;
  9811 |     |         bytes32 m6;
  9812 |     |         /// @solidity memory-safe-assembly
  9813 |     |         assembly {
  9814 |     |             function writeString(pos, w) {
  9815 |     |                 let length := 0
  9816 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9817 |     |                 mstore(pos, length)
  9818 |     |                 let shift := sub(256, shl(3, length))
  9819 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9820 |     |             }
  9821 |     |             m0 := mload(0x00)
  9822 |     |             m1 := mload(0x20)
  9823 |     |             m2 := mload(0x40)
  9824 |     |             m3 := mload(0x60)
  9825 |     |             m4 := mload(0x80)
  9826 |     |             m5 := mload(0xa0)
  9827 |     |             m6 := mload(0xc0)
  9828 |     |             // Selector of `log(uint256,uint256,string,bool)`.
  9829 |     |             mstore(0x00, 0x7af6ab25)
  9830 |     |             mstore(0x20, p0)
  9831 |     |             mstore(0x40, p1)
  9832 |     |             mstore(0x60, 0x80)
  9833 |     |             mstore(0x80, p3)
  9834 |     |             writeString(0xa0, p2)
  9835 |     |         }
  9836 |     |         _sendLogPayload(0x1c, 0xc4);
  9837 |     |         /// @solidity memory-safe-assembly
  9838 |     |         assembly {
  9839 |     |             mstore(0x00, m0)
  9840 |     |             mstore(0x20, m1)
  9841 |     |             mstore(0x40, m2)
  9842 |     |             mstore(0x60, m3)
  9843 |     |             mstore(0x80, m4)
  9844 |     |             mstore(0xa0, m5)
  9845 |     |             mstore(0xc0, m6)
  9846 |     |         }
  9847 |     |     }
  9848 |     | 
  9849 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  9850 |     |         bytes32 m0;
  9851 |     |         bytes32 m1;
  9852 |     |         bytes32 m2;
  9853 |     |         bytes32 m3;
  9854 |     |         bytes32 m4;
  9855 |     |         bytes32 m5;
  9856 |     |         bytes32 m6;
  9857 |     |         /// @solidity memory-safe-assembly
  9858 |     |         assembly {
  9859 |     |             function writeString(pos, w) {
  9860 |     |                 let length := 0
  9861 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9862 |     |                 mstore(pos, length)
  9863 |     |                 let shift := sub(256, shl(3, length))
  9864 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9865 |     |             }
  9866 |     |             m0 := mload(0x00)
  9867 |     |             m1 := mload(0x20)
  9868 |     |             m2 := mload(0x40)
  9869 |     |             m3 := mload(0x60)
  9870 |     |             m4 := mload(0x80)
  9871 |     |             m5 := mload(0xa0)
  9872 |     |             m6 := mload(0xc0)
  9873 |     |             // Selector of `log(uint256,uint256,string,uint256)`.
  9874 |     |             mstore(0x00, 0x5da297eb)
  9875 |     |             mstore(0x20, p0)
  9876 |     |             mstore(0x40, p1)
  9877 |     |             mstore(0x60, 0x80)
  9878 |     |             mstore(0x80, p3)
  9879 |     |             writeString(0xa0, p2)
  9880 |     |         }
  9881 |     |         _sendLogPayload(0x1c, 0xc4);
  9882 |     |         /// @solidity memory-safe-assembly
  9883 |     |         assembly {
  9884 |     |             mstore(0x00, m0)
  9885 |     |             mstore(0x20, m1)
  9886 |     |             mstore(0x40, m2)
  9887 |     |             mstore(0x60, m3)
  9888 |     |             mstore(0x80, m4)
  9889 |     |             mstore(0xa0, m5)
  9890 |     |             mstore(0xc0, m6)
  9891 |     |         }
  9892 |     |     }
  9893 |     | 
  9894 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  9895 |     |         bytes32 m0;
  9896 |     |         bytes32 m1;
  9897 |     |         bytes32 m2;
  9898 |     |         bytes32 m3;
  9899 |     |         bytes32 m4;
  9900 |     |         bytes32 m5;
  9901 |     |         bytes32 m6;
  9902 |     |         bytes32 m7;
  9903 |     |         bytes32 m8;
  9904 |     |         /// @solidity memory-safe-assembly
  9905 |     |         assembly {
  9906 |     |             function writeString(pos, w) {
  9907 |     |                 let length := 0
  9908 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9909 |     |                 mstore(pos, length)
  9910 |     |                 let shift := sub(256, shl(3, length))
  9911 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9912 |     |             }
  9913 |     |             m0 := mload(0x00)
  9914 |     |             m1 := mload(0x20)
  9915 |     |             m2 := mload(0x40)
  9916 |     |             m3 := mload(0x60)
  9917 |     |             m4 := mload(0x80)
  9918 |     |             m5 := mload(0xa0)
  9919 |     |             m6 := mload(0xc0)
  9920 |     |             m7 := mload(0xe0)
  9921 |     |             m8 := mload(0x100)
  9922 |     |             // Selector of `log(uint256,uint256,string,string)`.
  9923 |     |             mstore(0x00, 0x27d8afd2)
  9924 |     |             mstore(0x20, p0)
  9925 |     |             mstore(0x40, p1)
  9926 |     |             mstore(0x60, 0x80)
  9927 |     |             mstore(0x80, 0xc0)
  9928 |     |             writeString(0xa0, p2)
  9929 |     |             writeString(0xe0, p3)
  9930 |     |         }
  9931 |     |         _sendLogPayload(0x1c, 0x104);
  9932 |     |         /// @solidity memory-safe-assembly
  9933 |     |         assembly {
  9934 |     |             mstore(0x00, m0)
  9935 |     |             mstore(0x20, m1)
  9936 |     |             mstore(0x40, m2)
  9937 |     |             mstore(0x60, m3)
  9938 |     |             mstore(0x80, m4)
  9939 |     |             mstore(0xa0, m5)
  9940 |     |             mstore(0xc0, m6)
  9941 |     |             mstore(0xe0, m7)
  9942 |     |             mstore(0x100, m8)
  9943 |     |         }
  9944 |     |     }
  9945 |     | 
  9946 |     |     function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {
  9947 |     |         bytes32 m0;
  9948 |     |         bytes32 m1;
  9949 |     |         bytes32 m2;
  9950 |     |         bytes32 m3;
  9951 |     |         bytes32 m4;
  9952 |     |         bytes32 m5;
  9953 |     |         bytes32 m6;
  9954 |     |         /// @solidity memory-safe-assembly
  9955 |     |         assembly {
  9956 |     |             function writeString(pos, w) {
  9957 |     |                 let length := 0
  9958 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9959 |     |                 mstore(pos, length)
  9960 |     |                 let shift := sub(256, shl(3, length))
  9961 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9962 |     |             }
  9963 |     |             m0 := mload(0x00)
  9964 |     |             m1 := mload(0x20)
  9965 |     |             m2 := mload(0x40)
  9966 |     |             m3 := mload(0x60)
  9967 |     |             m4 := mload(0x80)
  9968 |     |             m5 := mload(0xa0)
  9969 |     |             m6 := mload(0xc0)
  9970 |     |             // Selector of `log(uint256,string,address,address)`.
  9971 |     |             mstore(0x00, 0x6168ed61)
  9972 |     |             mstore(0x20, p0)
  9973 |     |             mstore(0x40, 0x80)
  9974 |     |             mstore(0x60, p2)
  9975 |     |             mstore(0x80, p3)
  9976 |     |             writeString(0xa0, p1)
  9977 |     |         }
  9978 |     |         _sendLogPayload(0x1c, 0xc4);
  9979 |     |         /// @solidity memory-safe-assembly
  9980 |     |         assembly {
  9981 |     |             mstore(0x00, m0)
  9982 |     |             mstore(0x20, m1)
  9983 |     |             mstore(0x40, m2)
  9984 |     |             mstore(0x60, m3)
  9985 |     |             mstore(0x80, m4)
  9986 |     |             mstore(0xa0, m5)
  9987 |     |             mstore(0xc0, m6)
  9988 |     |         }
  9989 |     |     }
  9990 |     | 
  9991 |     |     function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {
  9992 |     |         bytes32 m0;
  9993 |     |         bytes32 m1;
  9994 |     |         bytes32 m2;
  9995 |     |         bytes32 m3;
  9996 |     |         bytes32 m4;
  9997 |     |         bytes32 m5;
  9998 |     |         bytes32 m6;
  9999 |     |         /// @solidity memory-safe-assembly
 10000 |     |         assembly {
 10001 |     |             function writeString(pos, w) {
 10002 |     |                 let length := 0
 10003 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10004 |     |                 mstore(pos, length)
 10005 |     |                 let shift := sub(256, shl(3, length))
 10006 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10007 |     |             }
 10008 |     |             m0 := mload(0x00)
 10009 |     |             m1 := mload(0x20)
 10010 |     |             m2 := mload(0x40)
 10011 |     |             m3 := mload(0x60)
 10012 |     |             m4 := mload(0x80)
 10013 |     |             m5 := mload(0xa0)
 10014 |     |             m6 := mload(0xc0)
 10015 |     |             // Selector of `log(uint256,string,address,bool)`.
 10016 |     |             mstore(0x00, 0x90c30a56)
 10017 |     |             mstore(0x20, p0)
 10018 |     |             mstore(0x40, 0x80)
 10019 |     |             mstore(0x60, p2)
 10020 |     |             mstore(0x80, p3)
 10021 |     |             writeString(0xa0, p1)
 10022 |     |         }
 10023 |     |         _sendLogPayload(0x1c, 0xc4);
 10024 |     |         /// @solidity memory-safe-assembly
 10025 |     |         assembly {
 10026 |     |             mstore(0x00, m0)
 10027 |     |             mstore(0x20, m1)
 10028 |     |             mstore(0x40, m2)
 10029 |     |             mstore(0x60, m3)
 10030 |     |             mstore(0x80, m4)
 10031 |     |             mstore(0xa0, m5)
 10032 |     |             mstore(0xc0, m6)
 10033 |     |         }
 10034 |     |     }
 10035 |     | 
 10036 |     |     function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 10037 |     |         bytes32 m0;
 10038 |     |         bytes32 m1;
 10039 |     |         bytes32 m2;
 10040 |     |         bytes32 m3;
 10041 |     |         bytes32 m4;
 10042 |     |         bytes32 m5;
 10043 |     |         bytes32 m6;
 10044 |     |         /// @solidity memory-safe-assembly
 10045 |     |         assembly {
 10046 |     |             function writeString(pos, w) {
 10047 |     |                 let length := 0
 10048 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10049 |     |                 mstore(pos, length)
 10050 |     |                 let shift := sub(256, shl(3, length))
 10051 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10052 |     |             }
 10053 |     |             m0 := mload(0x00)
 10054 |     |             m1 := mload(0x20)
 10055 |     |             m2 := mload(0x40)
 10056 |     |             m3 := mload(0x60)
 10057 |     |             m4 := mload(0x80)
 10058 |     |             m5 := mload(0xa0)
 10059 |     |             m6 := mload(0xc0)
 10060 |     |             // Selector of `log(uint256,string,address,uint256)`.
 10061 |     |             mstore(0x00, 0xe8d3018d)
 10062 |     |             mstore(0x20, p0)
 10063 |     |             mstore(0x40, 0x80)
 10064 |     |             mstore(0x60, p2)
 10065 |     |             mstore(0x80, p3)
 10066 |     |             writeString(0xa0, p1)
 10067 |     |         }
 10068 |     |         _sendLogPayload(0x1c, 0xc4);
 10069 |     |         /// @solidity memory-safe-assembly
 10070 |     |         assembly {
 10071 |     |             mstore(0x00, m0)
 10072 |     |             mstore(0x20, m1)
 10073 |     |             mstore(0x40, m2)
 10074 |     |             mstore(0x60, m3)
 10075 |     |             mstore(0x80, m4)
 10076 |     |             mstore(0xa0, m5)
 10077 |     |             mstore(0xc0, m6)
 10078 |     |         }
 10079 |     |     }
 10080 |     | 
 10081 |     |     function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 10082 |     |         bytes32 m0;
 10083 |     |         bytes32 m1;
 10084 |     |         bytes32 m2;
 10085 |     |         bytes32 m3;
 10086 |     |         bytes32 m4;
 10087 |     |         bytes32 m5;
 10088 |     |         bytes32 m6;
 10089 |     |         bytes32 m7;
 10090 |     |         bytes32 m8;
 10091 |     |         /// @solidity memory-safe-assembly
 10092 |     |         assembly {
 10093 |     |             function writeString(pos, w) {
 10094 |     |                 let length := 0
 10095 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10096 |     |                 mstore(pos, length)
 10097 |     |                 let shift := sub(256, shl(3, length))
 10098 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10099 |     |             }
 10100 |     |             m0 := mload(0x00)
 10101 |     |             m1 := mload(0x20)
 10102 |     |             m2 := mload(0x40)
 10103 |     |             m3 := mload(0x60)
 10104 |     |             m4 := mload(0x80)
 10105 |     |             m5 := mload(0xa0)
 10106 |     |             m6 := mload(0xc0)
 10107 |     |             m7 := mload(0xe0)
 10108 |     |             m8 := mload(0x100)
 10109 |     |             // Selector of `log(uint256,string,address,string)`.
 10110 |     |             mstore(0x00, 0x9c3adfa1)
 10111 |     |             mstore(0x20, p0)
 10112 |     |             mstore(0x40, 0x80)
 10113 |     |             mstore(0x60, p2)
 10114 |     |             mstore(0x80, 0xc0)
 10115 |     |             writeString(0xa0, p1)
 10116 |     |             writeString(0xe0, p3)
 10117 |     |         }
 10118 |     |         _sendLogPayload(0x1c, 0x104);
 10119 |     |         /// @solidity memory-safe-assembly
 10120 |     |         assembly {
 10121 |     |             mstore(0x00, m0)
 10122 |     |             mstore(0x20, m1)
 10123 |     |             mstore(0x40, m2)
 10124 |     |             mstore(0x60, m3)
 10125 |     |             mstore(0x80, m4)
 10126 |     |             mstore(0xa0, m5)
 10127 |     |             mstore(0xc0, m6)
 10128 |     |             mstore(0xe0, m7)
 10129 |     |             mstore(0x100, m8)
 10130 |     |         }
 10131 |     |     }
 10132 |     | 
 10133 |     |     function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {
 10134 |     |         bytes32 m0;
 10135 |     |         bytes32 m1;
 10136 |     |         bytes32 m2;
 10137 |     |         bytes32 m3;
 10138 |     |         bytes32 m4;
 10139 |     |         bytes32 m5;
 10140 |     |         bytes32 m6;
 10141 |     |         /// @solidity memory-safe-assembly
 10142 |     |         assembly {
 10143 |     |             function writeString(pos, w) {
 10144 |     |                 let length := 0
 10145 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10146 |     |                 mstore(pos, length)
 10147 |     |                 let shift := sub(256, shl(3, length))
 10148 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10149 |     |             }
 10150 |     |             m0 := mload(0x00)
 10151 |     |             m1 := mload(0x20)
 10152 |     |             m2 := mload(0x40)
 10153 |     |             m3 := mload(0x60)
 10154 |     |             m4 := mload(0x80)
 10155 |     |             m5 := mload(0xa0)
 10156 |     |             m6 := mload(0xc0)
 10157 |     |             // Selector of `log(uint256,string,bool,address)`.
 10158 |     |             mstore(0x00, 0xae2ec581)
 10159 |     |             mstore(0x20, p0)
 10160 |     |             mstore(0x40, 0x80)
 10161 |     |             mstore(0x60, p2)
 10162 |     |             mstore(0x80, p3)
 10163 |     |             writeString(0xa0, p1)
 10164 |     |         }
 10165 |     |         _sendLogPayload(0x1c, 0xc4);
 10166 |     |         /// @solidity memory-safe-assembly
 10167 |     |         assembly {
 10168 |     |             mstore(0x00, m0)
 10169 |     |             mstore(0x20, m1)
 10170 |     |             mstore(0x40, m2)
 10171 |     |             mstore(0x60, m3)
 10172 |     |             mstore(0x80, m4)
 10173 |     |             mstore(0xa0, m5)
 10174 |     |             mstore(0xc0, m6)
 10175 |     |         }
 10176 |     |     }
 10177 |     | 
 10178 |     |     function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {
 10179 |     |         bytes32 m0;
 10180 |     |         bytes32 m1;
 10181 |     |         bytes32 m2;
 10182 |     |         bytes32 m3;
 10183 |     |         bytes32 m4;
 10184 |     |         bytes32 m5;
 10185 |     |         bytes32 m6;
 10186 |     |         /// @solidity memory-safe-assembly
 10187 |     |         assembly {
 10188 |     |             function writeString(pos, w) {
 10189 |     |                 let length := 0
 10190 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10191 |     |                 mstore(pos, length)
 10192 |     |                 let shift := sub(256, shl(3, length))
 10193 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10194 |     |             }
 10195 |     |             m0 := mload(0x00)
 10196 |     |             m1 := mload(0x20)
 10197 |     |             m2 := mload(0x40)
 10198 |     |             m3 := mload(0x60)
 10199 |     |             m4 := mload(0x80)
 10200 |     |             m5 := mload(0xa0)
 10201 |     |             m6 := mload(0xc0)
 10202 |     |             // Selector of `log(uint256,string,bool,bool)`.
 10203 |     |             mstore(0x00, 0xba535d9c)
 10204 |     |             mstore(0x20, p0)
 10205 |     |             mstore(0x40, 0x80)
 10206 |     |             mstore(0x60, p2)
 10207 |     |             mstore(0x80, p3)
 10208 |     |             writeString(0xa0, p1)
 10209 |     |         }
 10210 |     |         _sendLogPayload(0x1c, 0xc4);
 10211 |     |         /// @solidity memory-safe-assembly
 10212 |     |         assembly {
 10213 |     |             mstore(0x00, m0)
 10214 |     |             mstore(0x20, m1)
 10215 |     |             mstore(0x40, m2)
 10216 |     |             mstore(0x60, m3)
 10217 |     |             mstore(0x80, m4)
 10218 |     |             mstore(0xa0, m5)
 10219 |     |             mstore(0xc0, m6)
 10220 |     |         }
 10221 |     |     }
 10222 |     | 
 10223 |     |     function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 10224 |     |         bytes32 m0;
 10225 |     |         bytes32 m1;
 10226 |     |         bytes32 m2;
 10227 |     |         bytes32 m3;
 10228 |     |         bytes32 m4;
 10229 |     |         bytes32 m5;
 10230 |     |         bytes32 m6;
 10231 |     |         /// @solidity memory-safe-assembly
 10232 |     |         assembly {
 10233 |     |             function writeString(pos, w) {
 10234 |     |                 let length := 0
 10235 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10236 |     |                 mstore(pos, length)
 10237 |     |                 let shift := sub(256, shl(3, length))
 10238 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10239 |     |             }
 10240 |     |             m0 := mload(0x00)
 10241 |     |             m1 := mload(0x20)
 10242 |     |             m2 := mload(0x40)
 10243 |     |             m3 := mload(0x60)
 10244 |     |             m4 := mload(0x80)
 10245 |     |             m5 := mload(0xa0)
 10246 |     |             m6 := mload(0xc0)
 10247 |     |             // Selector of `log(uint256,string,bool,uint256)`.
 10248 |     |             mstore(0x00, 0xcf009880)
 10249 |     |             mstore(0x20, p0)
 10250 |     |             mstore(0x40, 0x80)
 10251 |     |             mstore(0x60, p2)
 10252 |     |             mstore(0x80, p3)
 10253 |     |             writeString(0xa0, p1)
 10254 |     |         }
 10255 |     |         _sendLogPayload(0x1c, 0xc4);
 10256 |     |         /// @solidity memory-safe-assembly
 10257 |     |         assembly {
 10258 |     |             mstore(0x00, m0)
 10259 |     |             mstore(0x20, m1)
 10260 |     |             mstore(0x40, m2)
 10261 |     |             mstore(0x60, m3)
 10262 |     |             mstore(0x80, m4)
 10263 |     |             mstore(0xa0, m5)
 10264 |     |             mstore(0xc0, m6)
 10265 |     |         }
 10266 |     |     }
 10267 |     | 
 10268 |     |     function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 10269 |     |         bytes32 m0;
 10270 |     |         bytes32 m1;
 10271 |     |         bytes32 m2;
 10272 |     |         bytes32 m3;
 10273 |     |         bytes32 m4;
 10274 |     |         bytes32 m5;
 10275 |     |         bytes32 m6;
 10276 |     |         bytes32 m7;
 10277 |     |         bytes32 m8;
 10278 |     |         /// @solidity memory-safe-assembly
 10279 |     |         assembly {
 10280 |     |             function writeString(pos, w) {
 10281 |     |                 let length := 0
 10282 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10283 |     |                 mstore(pos, length)
 10284 |     |                 let shift := sub(256, shl(3, length))
 10285 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10286 |     |             }
 10287 |     |             m0 := mload(0x00)
 10288 |     |             m1 := mload(0x20)
 10289 |     |             m2 := mload(0x40)
 10290 |     |             m3 := mload(0x60)
 10291 |     |             m4 := mload(0x80)
 10292 |     |             m5 := mload(0xa0)
 10293 |     |             m6 := mload(0xc0)
 10294 |     |             m7 := mload(0xe0)
 10295 |     |             m8 := mload(0x100)
 10296 |     |             // Selector of `log(uint256,string,bool,string)`.
 10297 |     |             mstore(0x00, 0xd2d423cd)
 10298 |     |             mstore(0x20, p0)
 10299 |     |             mstore(0x40, 0x80)
 10300 |     |             mstore(0x60, p2)
 10301 |     |             mstore(0x80, 0xc0)
 10302 |     |             writeString(0xa0, p1)
 10303 |     |             writeString(0xe0, p3)
 10304 |     |         }
 10305 |     |         _sendLogPayload(0x1c, 0x104);
 10306 |     |         /// @solidity memory-safe-assembly
 10307 |     |         assembly {
 10308 |     |             mstore(0x00, m0)
 10309 |     |             mstore(0x20, m1)
 10310 |     |             mstore(0x40, m2)
 10311 |     |             mstore(0x60, m3)
 10312 |     |             mstore(0x80, m4)
 10313 |     |             mstore(0xa0, m5)
 10314 |     |             mstore(0xc0, m6)
 10315 |     |             mstore(0xe0, m7)
 10316 |     |             mstore(0x100, m8)
 10317 |     |         }
 10318 |     |     }
 10319 |     | 
 10320 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 10321 |     |         bytes32 m0;
 10322 |     |         bytes32 m1;
 10323 |     |         bytes32 m2;
 10324 |     |         bytes32 m3;
 10325 |     |         bytes32 m4;
 10326 |     |         bytes32 m5;
 10327 |     |         bytes32 m6;
 10328 |     |         /// @solidity memory-safe-assembly
 10329 |     |         assembly {
 10330 |     |             function writeString(pos, w) {
 10331 |     |                 let length := 0
 10332 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10333 |     |                 mstore(pos, length)
 10334 |     |                 let shift := sub(256, shl(3, length))
 10335 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10336 |     |             }
 10337 |     |             m0 := mload(0x00)
 10338 |     |             m1 := mload(0x20)
 10339 |     |             m2 := mload(0x40)
 10340 |     |             m3 := mload(0x60)
 10341 |     |             m4 := mload(0x80)
 10342 |     |             m5 := mload(0xa0)
 10343 |     |             m6 := mload(0xc0)
 10344 |     |             // Selector of `log(uint256,string,uint256,address)`.
 10345 |     |             mstore(0x00, 0x3b2279b4)
 10346 |     |             mstore(0x20, p0)
 10347 |     |             mstore(0x40, 0x80)
 10348 |     |             mstore(0x60, p2)
 10349 |     |             mstore(0x80, p3)
 10350 |     |             writeString(0xa0, p1)
 10351 |     |         }
 10352 |     |         _sendLogPayload(0x1c, 0xc4);
 10353 |     |         /// @solidity memory-safe-assembly
 10354 |     |         assembly {
 10355 |     |             mstore(0x00, m0)
 10356 |     |             mstore(0x20, m1)
 10357 |     |             mstore(0x40, m2)
 10358 |     |             mstore(0x60, m3)
 10359 |     |             mstore(0x80, m4)
 10360 |     |             mstore(0xa0, m5)
 10361 |     |             mstore(0xc0, m6)
 10362 |     |         }
 10363 |     |     }
 10364 |     | 
 10365 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 10366 |     |         bytes32 m0;
 10367 |     |         bytes32 m1;
 10368 |     |         bytes32 m2;
 10369 |     |         bytes32 m3;
 10370 |     |         bytes32 m4;
 10371 |     |         bytes32 m5;
 10372 |     |         bytes32 m6;
 10373 |     |         /// @solidity memory-safe-assembly
 10374 |     |         assembly {
 10375 |     |             function writeString(pos, w) {
 10376 |     |                 let length := 0
 10377 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10378 |     |                 mstore(pos, length)
 10379 |     |                 let shift := sub(256, shl(3, length))
 10380 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10381 |     |             }
 10382 |     |             m0 := mload(0x00)
 10383 |     |             m1 := mload(0x20)
 10384 |     |             m2 := mload(0x40)
 10385 |     |             m3 := mload(0x60)
 10386 |     |             m4 := mload(0x80)
 10387 |     |             m5 := mload(0xa0)
 10388 |     |             m6 := mload(0xc0)
 10389 |     |             // Selector of `log(uint256,string,uint256,bool)`.
 10390 |     |             mstore(0x00, 0x691a8f74)
 10391 |     |             mstore(0x20, p0)
 10392 |     |             mstore(0x40, 0x80)
 10393 |     |             mstore(0x60, p2)
 10394 |     |             mstore(0x80, p3)
 10395 |     |             writeString(0xa0, p1)
 10396 |     |         }
 10397 |     |         _sendLogPayload(0x1c, 0xc4);
 10398 |     |         /// @solidity memory-safe-assembly
 10399 |     |         assembly {
 10400 |     |             mstore(0x00, m0)
 10401 |     |             mstore(0x20, m1)
 10402 |     |             mstore(0x40, m2)
 10403 |     |             mstore(0x60, m3)
 10404 |     |             mstore(0x80, m4)
 10405 |     |             mstore(0xa0, m5)
 10406 |     |             mstore(0xc0, m6)
 10407 |     |         }
 10408 |     |     }
 10409 |     | 
 10410 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 10411 |     |         bytes32 m0;
 10412 |     |         bytes32 m1;
 10413 |     |         bytes32 m2;
 10414 |     |         bytes32 m3;
 10415 |     |         bytes32 m4;
 10416 |     |         bytes32 m5;
 10417 |     |         bytes32 m6;
 10418 |     |         /// @solidity memory-safe-assembly
 10419 |     |         assembly {
 10420 |     |             function writeString(pos, w) {
 10421 |     |                 let length := 0
 10422 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10423 |     |                 mstore(pos, length)
 10424 |     |                 let shift := sub(256, shl(3, length))
 10425 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10426 |     |             }
 10427 |     |             m0 := mload(0x00)
 10428 |     |             m1 := mload(0x20)
 10429 |     |             m2 := mload(0x40)
 10430 |     |             m3 := mload(0x60)
 10431 |     |             m4 := mload(0x80)
 10432 |     |             m5 := mload(0xa0)
 10433 |     |             m6 := mload(0xc0)
 10434 |     |             // Selector of `log(uint256,string,uint256,uint256)`.
 10435 |     |             mstore(0x00, 0x82c25b74)
 10436 |     |             mstore(0x20, p0)
 10437 |     |             mstore(0x40, 0x80)
 10438 |     |             mstore(0x60, p2)
 10439 |     |             mstore(0x80, p3)
 10440 |     |             writeString(0xa0, p1)
 10441 |     |         }
 10442 |     |         _sendLogPayload(0x1c, 0xc4);
 10443 |     |         /// @solidity memory-safe-assembly
 10444 |     |         assembly {
 10445 |     |             mstore(0x00, m0)
 10446 |     |             mstore(0x20, m1)
 10447 |     |             mstore(0x40, m2)
 10448 |     |             mstore(0x60, m3)
 10449 |     |             mstore(0x80, m4)
 10450 |     |             mstore(0xa0, m5)
 10451 |     |             mstore(0xc0, m6)
 10452 |     |         }
 10453 |     |     }
 10454 |     | 
 10455 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 10456 |     |         bytes32 m0;
 10457 |     |         bytes32 m1;
 10458 |     |         bytes32 m2;
 10459 |     |         bytes32 m3;
 10460 |     |         bytes32 m4;
 10461 |     |         bytes32 m5;
 10462 |     |         bytes32 m6;
 10463 |     |         bytes32 m7;
 10464 |     |         bytes32 m8;
 10465 |     |         /// @solidity memory-safe-assembly
 10466 |     |         assembly {
 10467 |     |             function writeString(pos, w) {
 10468 |     |                 let length := 0
 10469 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10470 |     |                 mstore(pos, length)
 10471 |     |                 let shift := sub(256, shl(3, length))
 10472 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10473 |     |             }
 10474 |     |             m0 := mload(0x00)
 10475 |     |             m1 := mload(0x20)
 10476 |     |             m2 := mload(0x40)
 10477 |     |             m3 := mload(0x60)
 10478 |     |             m4 := mload(0x80)
 10479 |     |             m5 := mload(0xa0)
 10480 |     |             m6 := mload(0xc0)
 10481 |     |             m7 := mload(0xe0)
 10482 |     |             m8 := mload(0x100)
 10483 |     |             // Selector of `log(uint256,string,uint256,string)`.
 10484 |     |             mstore(0x00, 0xb7b914ca)
 10485 |     |             mstore(0x20, p0)
 10486 |     |             mstore(0x40, 0x80)
 10487 |     |             mstore(0x60, p2)
 10488 |     |             mstore(0x80, 0xc0)
 10489 |     |             writeString(0xa0, p1)
 10490 |     |             writeString(0xe0, p3)
 10491 |     |         }
 10492 |     |         _sendLogPayload(0x1c, 0x104);
 10493 |     |         /// @solidity memory-safe-assembly
 10494 |     |         assembly {
 10495 |     |             mstore(0x00, m0)
 10496 |     |             mstore(0x20, m1)
 10497 |     |             mstore(0x40, m2)
 10498 |     |             mstore(0x60, m3)
 10499 |     |             mstore(0x80, m4)
 10500 |     |             mstore(0xa0, m5)
 10501 |     |             mstore(0xc0, m6)
 10502 |     |             mstore(0xe0, m7)
 10503 |     |             mstore(0x100, m8)
 10504 |     |         }
 10505 |     |     }
 10506 |     | 
 10507 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 10508 |     |         bytes32 m0;
 10509 |     |         bytes32 m1;
 10510 |     |         bytes32 m2;
 10511 |     |         bytes32 m3;
 10512 |     |         bytes32 m4;
 10513 |     |         bytes32 m5;
 10514 |     |         bytes32 m6;
 10515 |     |         bytes32 m7;
 10516 |     |         bytes32 m8;
 10517 |     |         /// @solidity memory-safe-assembly
 10518 |     |         assembly {
 10519 |     |             function writeString(pos, w) {
 10520 |     |                 let length := 0
 10521 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10522 |     |                 mstore(pos, length)
 10523 |     |                 let shift := sub(256, shl(3, length))
 10524 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10525 |     |             }
 10526 |     |             m0 := mload(0x00)
 10527 |     |             m1 := mload(0x20)
 10528 |     |             m2 := mload(0x40)
 10529 |     |             m3 := mload(0x60)
 10530 |     |             m4 := mload(0x80)
 10531 |     |             m5 := mload(0xa0)
 10532 |     |             m6 := mload(0xc0)
 10533 |     |             m7 := mload(0xe0)
 10534 |     |             m8 := mload(0x100)
 10535 |     |             // Selector of `log(uint256,string,string,address)`.
 10536 |     |             mstore(0x00, 0xd583c602)
 10537 |     |             mstore(0x20, p0)
 10538 |     |             mstore(0x40, 0x80)
 10539 |     |             mstore(0x60, 0xc0)
 10540 |     |             mstore(0x80, p3)
 10541 |     |             writeString(0xa0, p1)
 10542 |     |             writeString(0xe0, p2)
 10543 |     |         }
 10544 |     |         _sendLogPayload(0x1c, 0x104);
 10545 |     |         /// @solidity memory-safe-assembly
 10546 |     |         assembly {
 10547 |     |             mstore(0x00, m0)
 10548 |     |             mstore(0x20, m1)
 10549 |     |             mstore(0x40, m2)
 10550 |     |             mstore(0x60, m3)
 10551 |     |             mstore(0x80, m4)
 10552 |     |             mstore(0xa0, m5)
 10553 |     |             mstore(0xc0, m6)
 10554 |     |             mstore(0xe0, m7)
 10555 |     |             mstore(0x100, m8)
 10556 |     |         }
 10557 |     |     }
 10558 |     | 
 10559 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 10560 |     |         bytes32 m0;
 10561 |     |         bytes32 m1;
 10562 |     |         bytes32 m2;
 10563 |     |         bytes32 m3;
 10564 |     |         bytes32 m4;
 10565 |     |         bytes32 m5;
 10566 |     |         bytes32 m6;
 10567 |     |         bytes32 m7;
 10568 |     |         bytes32 m8;
 10569 |     |         /// @solidity memory-safe-assembly
 10570 |     |         assembly {
 10571 |     |             function writeString(pos, w) {
 10572 |     |                 let length := 0
 10573 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10574 |     |                 mstore(pos, length)
 10575 |     |                 let shift := sub(256, shl(3, length))
 10576 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10577 |     |             }
 10578 |     |             m0 := mload(0x00)
 10579 |     |             m1 := mload(0x20)
 10580 |     |             m2 := mload(0x40)
 10581 |     |             m3 := mload(0x60)
 10582 |     |             m4 := mload(0x80)
 10583 |     |             m5 := mload(0xa0)
 10584 |     |             m6 := mload(0xc0)
 10585 |     |             m7 := mload(0xe0)
 10586 |     |             m8 := mload(0x100)
 10587 |     |             // Selector of `log(uint256,string,string,bool)`.
 10588 |     |             mstore(0x00, 0xb3a6b6bd)
 10589 |     |             mstore(0x20, p0)
 10590 |     |             mstore(0x40, 0x80)
 10591 |     |             mstore(0x60, 0xc0)
 10592 |     |             mstore(0x80, p3)
 10593 |     |             writeString(0xa0, p1)
 10594 |     |             writeString(0xe0, p2)
 10595 |     |         }
 10596 |     |         _sendLogPayload(0x1c, 0x104);
 10597 |     |         /// @solidity memory-safe-assembly
 10598 |     |         assembly {
 10599 |     |             mstore(0x00, m0)
 10600 |     |             mstore(0x20, m1)
 10601 |     |             mstore(0x40, m2)
 10602 |     |             mstore(0x60, m3)
 10603 |     |             mstore(0x80, m4)
 10604 |     |             mstore(0xa0, m5)
 10605 |     |             mstore(0xc0, m6)
 10606 |     |             mstore(0xe0, m7)
 10607 |     |             mstore(0x100, m8)
 10608 |     |         }
 10609 |     |     }
 10610 |     | 
 10611 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 10612 |     |         bytes32 m0;
 10613 |     |         bytes32 m1;
 10614 |     |         bytes32 m2;
 10615 |     |         bytes32 m3;
 10616 |     |         bytes32 m4;
 10617 |     |         bytes32 m5;
 10618 |     |         bytes32 m6;
 10619 |     |         bytes32 m7;
 10620 |     |         bytes32 m8;
 10621 |     |         /// @solidity memory-safe-assembly
 10622 |     |         assembly {
 10623 |     |             function writeString(pos, w) {
 10624 |     |                 let length := 0
 10625 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10626 |     |                 mstore(pos, length)
 10627 |     |                 let shift := sub(256, shl(3, length))
 10628 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10629 |     |             }
 10630 |     |             m0 := mload(0x00)
 10631 |     |             m1 := mload(0x20)
 10632 |     |             m2 := mload(0x40)
 10633 |     |             m3 := mload(0x60)
 10634 |     |             m4 := mload(0x80)
 10635 |     |             m5 := mload(0xa0)
 10636 |     |             m6 := mload(0xc0)
 10637 |     |             m7 := mload(0xe0)
 10638 |     |             m8 := mload(0x100)
 10639 |     |             // Selector of `log(uint256,string,string,uint256)`.
 10640 |     |             mstore(0x00, 0xb028c9bd)
 10641 |     |             mstore(0x20, p0)
 10642 |     |             mstore(0x40, 0x80)
 10643 |     |             mstore(0x60, 0xc0)
 10644 |     |             mstore(0x80, p3)
 10645 |     |             writeString(0xa0, p1)
 10646 |     |             writeString(0xe0, p2)
 10647 |     |         }
 10648 |     |         _sendLogPayload(0x1c, 0x104);
 10649 |     |         /// @solidity memory-safe-assembly
 10650 |     |         assembly {
 10651 |     |             mstore(0x00, m0)
 10652 |     |             mstore(0x20, m1)
 10653 |     |             mstore(0x40, m2)
 10654 |     |             mstore(0x60, m3)
 10655 |     |             mstore(0x80, m4)
 10656 |     |             mstore(0xa0, m5)
 10657 |     |             mstore(0xc0, m6)
 10658 |     |             mstore(0xe0, m7)
 10659 |     |             mstore(0x100, m8)
 10660 |     |         }
 10661 |     |     }
 10662 |     | 
 10663 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 10664 |     |         bytes32 m0;
 10665 |     |         bytes32 m1;
 10666 |     |         bytes32 m2;
 10667 |     |         bytes32 m3;
 10668 |     |         bytes32 m4;
 10669 |     |         bytes32 m5;
 10670 |     |         bytes32 m6;
 10671 |     |         bytes32 m7;
 10672 |     |         bytes32 m8;
 10673 |     |         bytes32 m9;
 10674 |     |         bytes32 m10;
 10675 |     |         /// @solidity memory-safe-assembly
 10676 |     |         assembly {
 10677 |     |             function writeString(pos, w) {
 10678 |     |                 let length := 0
 10679 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10680 |     |                 mstore(pos, length)
 10681 |     |                 let shift := sub(256, shl(3, length))
 10682 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10683 |     |             }
 10684 |     |             m0 := mload(0x00)
 10685 |     |             m1 := mload(0x20)
 10686 |     |             m2 := mload(0x40)
 10687 |     |             m3 := mload(0x60)
 10688 |     |             m4 := mload(0x80)
 10689 |     |             m5 := mload(0xa0)
 10690 |     |             m6 := mload(0xc0)
 10691 |     |             m7 := mload(0xe0)
 10692 |     |             m8 := mload(0x100)
 10693 |     |             m9 := mload(0x120)
 10694 |     |             m10 := mload(0x140)
 10695 |     |             // Selector of `log(uint256,string,string,string)`.
 10696 |     |             mstore(0x00, 0x21ad0683)
 10697 |     |             mstore(0x20, p0)
 10698 |     |             mstore(0x40, 0x80)
 10699 |     |             mstore(0x60, 0xc0)
 10700 |     |             mstore(0x80, 0x100)
 10701 |     |             writeString(0xa0, p1)
 10702 |     |             writeString(0xe0, p2)
 10703 |     |             writeString(0x120, p3)
 10704 |     |         }
 10705 |     |         _sendLogPayload(0x1c, 0x144);
 10706 |     |         /// @solidity memory-safe-assembly
 10707 |     |         assembly {
 10708 |     |             mstore(0x00, m0)
 10709 |     |             mstore(0x20, m1)
 10710 |     |             mstore(0x40, m2)
 10711 |     |             mstore(0x60, m3)
 10712 |     |             mstore(0x80, m4)
 10713 |     |             mstore(0xa0, m5)
 10714 |     |             mstore(0xc0, m6)
 10715 |     |             mstore(0xe0, m7)
 10716 |     |             mstore(0x100, m8)
 10717 |     |             mstore(0x120, m9)
 10718 |     |             mstore(0x140, m10)
 10719 |     |         }
 10720 |     |     }
 10721 |     | 
 10722 |     |     function log(bytes32 p0, address p1, address p2, address p3) internal pure {
 10723 |     |         bytes32 m0;
 10724 |     |         bytes32 m1;
 10725 |     |         bytes32 m2;
 10726 |     |         bytes32 m3;
 10727 |     |         bytes32 m4;
 10728 |     |         bytes32 m5;
 10729 |     |         bytes32 m6;
 10730 |     |         /// @solidity memory-safe-assembly
 10731 |     |         assembly {
 10732 |     |             function writeString(pos, w) {
 10733 |     |                 let length := 0
 10734 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10735 |     |                 mstore(pos, length)
 10736 |     |                 let shift := sub(256, shl(3, length))
 10737 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10738 |     |             }
 10739 |     |             m0 := mload(0x00)
 10740 |     |             m1 := mload(0x20)
 10741 |     |             m2 := mload(0x40)
 10742 |     |             m3 := mload(0x60)
 10743 |     |             m4 := mload(0x80)
 10744 |     |             m5 := mload(0xa0)
 10745 |     |             m6 := mload(0xc0)
 10746 |     |             // Selector of `log(string,address,address,address)`.
 10747 |     |             mstore(0x00, 0xed8f28f6)
 10748 |     |             mstore(0x20, 0x80)
 10749 |     |             mstore(0x40, p1)
 10750 |     |             mstore(0x60, p2)
 10751 |     |             mstore(0x80, p3)
 10752 |     |             writeString(0xa0, p0)
 10753 |     |         }
 10754 |     |         _sendLogPayload(0x1c, 0xc4);
 10755 |     |         /// @solidity memory-safe-assembly
 10756 |     |         assembly {
 10757 |     |             mstore(0x00, m0)
 10758 |     |             mstore(0x20, m1)
 10759 |     |             mstore(0x40, m2)
 10760 |     |             mstore(0x60, m3)
 10761 |     |             mstore(0x80, m4)
 10762 |     |             mstore(0xa0, m5)
 10763 |     |             mstore(0xc0, m6)
 10764 |     |         }
 10765 |     |     }
 10766 |     | 
 10767 |     |     function log(bytes32 p0, address p1, address p2, bool p3) internal pure {
 10768 |     |         bytes32 m0;
 10769 |     |         bytes32 m1;
 10770 |     |         bytes32 m2;
 10771 |     |         bytes32 m3;
 10772 |     |         bytes32 m4;
 10773 |     |         bytes32 m5;
 10774 |     |         bytes32 m6;
 10775 |     |         /// @solidity memory-safe-assembly
 10776 |     |         assembly {
 10777 |     |             function writeString(pos, w) {
 10778 |     |                 let length := 0
 10779 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10780 |     |                 mstore(pos, length)
 10781 |     |                 let shift := sub(256, shl(3, length))
 10782 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10783 |     |             }
 10784 |     |             m0 := mload(0x00)
 10785 |     |             m1 := mload(0x20)
 10786 |     |             m2 := mload(0x40)
 10787 |     |             m3 := mload(0x60)
 10788 |     |             m4 := mload(0x80)
 10789 |     |             m5 := mload(0xa0)
 10790 |     |             m6 := mload(0xc0)
 10791 |     |             // Selector of `log(string,address,address,bool)`.
 10792 |     |             mstore(0x00, 0xb59dbd60)
 10793 |     |             mstore(0x20, 0x80)
 10794 |     |             mstore(0x40, p1)
 10795 |     |             mstore(0x60, p2)
 10796 |     |             mstore(0x80, p3)
 10797 |     |             writeString(0xa0, p0)
 10798 |     |         }
 10799 |     |         _sendLogPayload(0x1c, 0xc4);
 10800 |     |         /// @solidity memory-safe-assembly
 10801 |     |         assembly {
 10802 |     |             mstore(0x00, m0)
 10803 |     |             mstore(0x20, m1)
 10804 |     |             mstore(0x40, m2)
 10805 |     |             mstore(0x60, m3)
 10806 |     |             mstore(0x80, m4)
 10807 |     |             mstore(0xa0, m5)
 10808 |     |             mstore(0xc0, m6)
 10809 |     |         }
 10810 |     |     }
 10811 |     | 
 10812 |     |     function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {
 10813 |     |         bytes32 m0;
 10814 |     |         bytes32 m1;
 10815 |     |         bytes32 m2;
 10816 |     |         bytes32 m3;
 10817 |     |         bytes32 m4;
 10818 |     |         bytes32 m5;
 10819 |     |         bytes32 m6;
 10820 |     |         /// @solidity memory-safe-assembly
 10821 |     |         assembly {
 10822 |     |             function writeString(pos, w) {
 10823 |     |                 let length := 0
 10824 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10825 |     |                 mstore(pos, length)
 10826 |     |                 let shift := sub(256, shl(3, length))
 10827 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10828 |     |             }
 10829 |     |             m0 := mload(0x00)
 10830 |     |             m1 := mload(0x20)
 10831 |     |             m2 := mload(0x40)
 10832 |     |             m3 := mload(0x60)
 10833 |     |             m4 := mload(0x80)
 10834 |     |             m5 := mload(0xa0)
 10835 |     |             m6 := mload(0xc0)
 10836 |     |             // Selector of `log(string,address,address,uint256)`.
 10837 |     |             mstore(0x00, 0x8ef3f399)
 10838 |     |             mstore(0x20, 0x80)
 10839 |     |             mstore(0x40, p1)
 10840 |     |             mstore(0x60, p2)
 10841 |     |             mstore(0x80, p3)
 10842 |     |             writeString(0xa0, p0)
 10843 |     |         }
 10844 |     |         _sendLogPayload(0x1c, 0xc4);
 10845 |     |         /// @solidity memory-safe-assembly
 10846 |     |         assembly {
 10847 |     |             mstore(0x00, m0)
 10848 |     |             mstore(0x20, m1)
 10849 |     |             mstore(0x40, m2)
 10850 |     |             mstore(0x60, m3)
 10851 |     |             mstore(0x80, m4)
 10852 |     |             mstore(0xa0, m5)
 10853 |     |             mstore(0xc0, m6)
 10854 |     |         }
 10855 |     |     }
 10856 |     | 
 10857 |     |     function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {
 10858 |     |         bytes32 m0;
 10859 |     |         bytes32 m1;
 10860 |     |         bytes32 m2;
 10861 |     |         bytes32 m3;
 10862 |     |         bytes32 m4;
 10863 |     |         bytes32 m5;
 10864 |     |         bytes32 m6;
 10865 |     |         bytes32 m7;
 10866 |     |         bytes32 m8;
 10867 |     |         /// @solidity memory-safe-assembly
 10868 |     |         assembly {
 10869 |     |             function writeString(pos, w) {
 10870 |     |                 let length := 0
 10871 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10872 |     |                 mstore(pos, length)
 10873 |     |                 let shift := sub(256, shl(3, length))
 10874 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10875 |     |             }
 10876 |     |             m0 := mload(0x00)
 10877 |     |             m1 := mload(0x20)
 10878 |     |             m2 := mload(0x40)
 10879 |     |             m3 := mload(0x60)
 10880 |     |             m4 := mload(0x80)
 10881 |     |             m5 := mload(0xa0)
 10882 |     |             m6 := mload(0xc0)
 10883 |     |             m7 := mload(0xe0)
 10884 |     |             m8 := mload(0x100)
 10885 |     |             // Selector of `log(string,address,address,string)`.
 10886 |     |             mstore(0x00, 0x800a1c67)
 10887 |     |             mstore(0x20, 0x80)
 10888 |     |             mstore(0x40, p1)
 10889 |     |             mstore(0x60, p2)
 10890 |     |             mstore(0x80, 0xc0)
 10891 |     |             writeString(0xa0, p0)
 10892 |     |             writeString(0xe0, p3)
 10893 |     |         }
 10894 |     |         _sendLogPayload(0x1c, 0x104);
 10895 |     |         /// @solidity memory-safe-assembly
 10896 |     |         assembly {
 10897 |     |             mstore(0x00, m0)
 10898 |     |             mstore(0x20, m1)
 10899 |     |             mstore(0x40, m2)
 10900 |     |             mstore(0x60, m3)
 10901 |     |             mstore(0x80, m4)
 10902 |     |             mstore(0xa0, m5)
 10903 |     |             mstore(0xc0, m6)
 10904 |     |             mstore(0xe0, m7)
 10905 |     |             mstore(0x100, m8)
 10906 |     |         }
 10907 |     |     }
 10908 |     | 
 10909 |     |     function log(bytes32 p0, address p1, bool p2, address p3) internal pure {
 10910 |     |         bytes32 m0;
 10911 |     |         bytes32 m1;
 10912 |     |         bytes32 m2;
 10913 |     |         bytes32 m3;
 10914 |     |         bytes32 m4;
 10915 |     |         bytes32 m5;
 10916 |     |         bytes32 m6;
 10917 |     |         /// @solidity memory-safe-assembly
 10918 |     |         assembly {
 10919 |     |             function writeString(pos, w) {
 10920 |     |                 let length := 0
 10921 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10922 |     |                 mstore(pos, length)
 10923 |     |                 let shift := sub(256, shl(3, length))
 10924 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10925 |     |             }
 10926 |     |             m0 := mload(0x00)
 10927 |     |             m1 := mload(0x20)
 10928 |     |             m2 := mload(0x40)
 10929 |     |             m3 := mload(0x60)
 10930 |     |             m4 := mload(0x80)
 10931 |     |             m5 := mload(0xa0)
 10932 |     |             m6 := mload(0xc0)
 10933 |     |             // Selector of `log(string,address,bool,address)`.
 10934 |     |             mstore(0x00, 0x223603bd)
 10935 |     |             mstore(0x20, 0x80)
 10936 |     |             mstore(0x40, p1)
 10937 |     |             mstore(0x60, p2)
 10938 |     |             mstore(0x80, p3)
 10939 |     |             writeString(0xa0, p0)
 10940 |     |         }
 10941 |     |         _sendLogPayload(0x1c, 0xc4);
 10942 |     |         /// @solidity memory-safe-assembly
 10943 |     |         assembly {
 10944 |     |             mstore(0x00, m0)
 10945 |     |             mstore(0x20, m1)
 10946 |     |             mstore(0x40, m2)
 10947 |     |             mstore(0x60, m3)
 10948 |     |             mstore(0x80, m4)
 10949 |     |             mstore(0xa0, m5)
 10950 |     |             mstore(0xc0, m6)
 10951 |     |         }
 10952 |     |     }
 10953 |     | 
 10954 |     |     function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {
 10955 |     |         bytes32 m0;
 10956 |     |         bytes32 m1;
 10957 |     |         bytes32 m2;
 10958 |     |         bytes32 m3;
 10959 |     |         bytes32 m4;
 10960 |     |         bytes32 m5;
 10961 |     |         bytes32 m6;
 10962 |     |         /// @solidity memory-safe-assembly
 10963 |     |         assembly {
 10964 |     |             function writeString(pos, w) {
 10965 |     |                 let length := 0
 10966 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10967 |     |                 mstore(pos, length)
 10968 |     |                 let shift := sub(256, shl(3, length))
 10969 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10970 |     |             }
 10971 |     |             m0 := mload(0x00)
 10972 |     |             m1 := mload(0x20)
 10973 |     |             m2 := mload(0x40)
 10974 |     |             m3 := mload(0x60)
 10975 |     |             m4 := mload(0x80)
 10976 |     |             m5 := mload(0xa0)
 10977 |     |             m6 := mload(0xc0)
 10978 |     |             // Selector of `log(string,address,bool,bool)`.
 10979 |     |             mstore(0x00, 0x79884c2b)
 10980 |     |             mstore(0x20, 0x80)
 10981 |     |             mstore(0x40, p1)
 10982 |     |             mstore(0x60, p2)
 10983 |     |             mstore(0x80, p3)
 10984 |     |             writeString(0xa0, p0)
 10985 |     |         }
 10986 |     |         _sendLogPayload(0x1c, 0xc4);
 10987 |     |         /// @solidity memory-safe-assembly
 10988 |     |         assembly {
 10989 |     |             mstore(0x00, m0)
 10990 |     |             mstore(0x20, m1)
 10991 |     |             mstore(0x40, m2)
 10992 |     |             mstore(0x60, m3)
 10993 |     |             mstore(0x80, m4)
 10994 |     |             mstore(0xa0, m5)
 10995 |     |             mstore(0xc0, m6)
 10996 |     |         }
 10997 |     |     }
 10998 |     | 
 10999 |     |     function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {
 11000 |     |         bytes32 m0;
 11001 |     |         bytes32 m1;
 11002 |     |         bytes32 m2;
 11003 |     |         bytes32 m3;
 11004 |     |         bytes32 m4;
 11005 |     |         bytes32 m5;
 11006 |     |         bytes32 m6;
 11007 |     |         /// @solidity memory-safe-assembly
 11008 |     |         assembly {
 11009 |     |             function writeString(pos, w) {
 11010 |     |                 let length := 0
 11011 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11012 |     |                 mstore(pos, length)
 11013 |     |                 let shift := sub(256, shl(3, length))
 11014 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11015 |     |             }
 11016 |     |             m0 := mload(0x00)
 11017 |     |             m1 := mload(0x20)
 11018 |     |             m2 := mload(0x40)
 11019 |     |             m3 := mload(0x60)
 11020 |     |             m4 := mload(0x80)
 11021 |     |             m5 := mload(0xa0)
 11022 |     |             m6 := mload(0xc0)
 11023 |     |             // Selector of `log(string,address,bool,uint256)`.
 11024 |     |             mstore(0x00, 0x3e9f866a)
 11025 |     |             mstore(0x20, 0x80)
 11026 |     |             mstore(0x40, p1)
 11027 |     |             mstore(0x60, p2)
 11028 |     |             mstore(0x80, p3)
 11029 |     |             writeString(0xa0, p0)
 11030 |     |         }
 11031 |     |         _sendLogPayload(0x1c, 0xc4);
 11032 |     |         /// @solidity memory-safe-assembly
 11033 |     |         assembly {
 11034 |     |             mstore(0x00, m0)
 11035 |     |             mstore(0x20, m1)
 11036 |     |             mstore(0x40, m2)
 11037 |     |             mstore(0x60, m3)
 11038 |     |             mstore(0x80, m4)
 11039 |     |             mstore(0xa0, m5)
 11040 |     |             mstore(0xc0, m6)
 11041 |     |         }
 11042 |     |     }
 11043 |     | 
 11044 |     |     function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {
 11045 |     |         bytes32 m0;
 11046 |     |         bytes32 m1;
 11047 |     |         bytes32 m2;
 11048 |     |         bytes32 m3;
 11049 |     |         bytes32 m4;
 11050 |     |         bytes32 m5;
 11051 |     |         bytes32 m6;
 11052 |     |         bytes32 m7;
 11053 |     |         bytes32 m8;
 11054 |     |         /// @solidity memory-safe-assembly
 11055 |     |         assembly {
 11056 |     |             function writeString(pos, w) {
 11057 |     |                 let length := 0
 11058 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11059 |     |                 mstore(pos, length)
 11060 |     |                 let shift := sub(256, shl(3, length))
 11061 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11062 |     |             }
 11063 |     |             m0 := mload(0x00)
 11064 |     |             m1 := mload(0x20)
 11065 |     |             m2 := mload(0x40)
 11066 |     |             m3 := mload(0x60)
 11067 |     |             m4 := mload(0x80)
 11068 |     |             m5 := mload(0xa0)
 11069 |     |             m6 := mload(0xc0)
 11070 |     |             m7 := mload(0xe0)
 11071 |     |             m8 := mload(0x100)
 11072 |     |             // Selector of `log(string,address,bool,string)`.
 11073 |     |             mstore(0x00, 0x0454c079)
 11074 |     |             mstore(0x20, 0x80)
 11075 |     |             mstore(0x40, p1)
 11076 |     |             mstore(0x60, p2)
 11077 |     |             mstore(0x80, 0xc0)
 11078 |     |             writeString(0xa0, p0)
 11079 |     |             writeString(0xe0, p3)
 11080 |     |         }
 11081 |     |         _sendLogPayload(0x1c, 0x104);
 11082 |     |         /// @solidity memory-safe-assembly
 11083 |     |         assembly {
 11084 |     |             mstore(0x00, m0)
 11085 |     |             mstore(0x20, m1)
 11086 |     |             mstore(0x40, m2)
 11087 |     |             mstore(0x60, m3)
 11088 |     |             mstore(0x80, m4)
 11089 |     |             mstore(0xa0, m5)
 11090 |     |             mstore(0xc0, m6)
 11091 |     |             mstore(0xe0, m7)
 11092 |     |             mstore(0x100, m8)
 11093 |     |         }
 11094 |     |     }
 11095 |     | 
 11096 |     |     function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {
 11097 |     |         bytes32 m0;
 11098 |     |         bytes32 m1;
 11099 |     |         bytes32 m2;
 11100 |     |         bytes32 m3;
 11101 |     |         bytes32 m4;
 11102 |     |         bytes32 m5;
 11103 |     |         bytes32 m6;
 11104 |     |         /// @solidity memory-safe-assembly
 11105 |     |         assembly {
 11106 |     |             function writeString(pos, w) {
 11107 |     |                 let length := 0
 11108 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11109 |     |                 mstore(pos, length)
 11110 |     |                 let shift := sub(256, shl(3, length))
 11111 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11112 |     |             }
 11113 |     |             m0 := mload(0x00)
 11114 |     |             m1 := mload(0x20)
 11115 |     |             m2 := mload(0x40)
 11116 |     |             m3 := mload(0x60)
 11117 |     |             m4 := mload(0x80)
 11118 |     |             m5 := mload(0xa0)
 11119 |     |             m6 := mload(0xc0)
 11120 |     |             // Selector of `log(string,address,uint256,address)`.
 11121 |     |             mstore(0x00, 0x63fb8bc5)
 11122 |     |             mstore(0x20, 0x80)
 11123 |     |             mstore(0x40, p1)
 11124 |     |             mstore(0x60, p2)
 11125 |     |             mstore(0x80, p3)
 11126 |     |             writeString(0xa0, p0)
 11127 |     |         }
 11128 |     |         _sendLogPayload(0x1c, 0xc4);
 11129 |     |         /// @solidity memory-safe-assembly
 11130 |     |         assembly {
 11131 |     |             mstore(0x00, m0)
 11132 |     |             mstore(0x20, m1)
 11133 |     |             mstore(0x40, m2)
 11134 |     |             mstore(0x60, m3)
 11135 |     |             mstore(0x80, m4)
 11136 |     |             mstore(0xa0, m5)
 11137 |     |             mstore(0xc0, m6)
 11138 |     |         }
 11139 |     |     }
 11140 |     | 
 11141 |     |     function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {
 11142 |     |         bytes32 m0;
 11143 |     |         bytes32 m1;
 11144 |     |         bytes32 m2;
 11145 |     |         bytes32 m3;
 11146 |     |         bytes32 m4;
 11147 |     |         bytes32 m5;
 11148 |     |         bytes32 m6;
 11149 |     |         /// @solidity memory-safe-assembly
 11150 |     |         assembly {
 11151 |     |             function writeString(pos, w) {
 11152 |     |                 let length := 0
 11153 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11154 |     |                 mstore(pos, length)
 11155 |     |                 let shift := sub(256, shl(3, length))
 11156 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11157 |     |             }
 11158 |     |             m0 := mload(0x00)
 11159 |     |             m1 := mload(0x20)
 11160 |     |             m2 := mload(0x40)
 11161 |     |             m3 := mload(0x60)
 11162 |     |             m4 := mload(0x80)
 11163 |     |             m5 := mload(0xa0)
 11164 |     |             m6 := mload(0xc0)
 11165 |     |             // Selector of `log(string,address,uint256,bool)`.
 11166 |     |             mstore(0x00, 0xfc4845f0)
 11167 |     |             mstore(0x20, 0x80)
 11168 |     |             mstore(0x40, p1)
 11169 |     |             mstore(0x60, p2)
 11170 |     |             mstore(0x80, p3)
 11171 |     |             writeString(0xa0, p0)
 11172 |     |         }
 11173 |     |         _sendLogPayload(0x1c, 0xc4);
 11174 |     |         /// @solidity memory-safe-assembly
 11175 |     |         assembly {
 11176 |     |             mstore(0x00, m0)
 11177 |     |             mstore(0x20, m1)
 11178 |     |             mstore(0x40, m2)
 11179 |     |             mstore(0x60, m3)
 11180 |     |             mstore(0x80, m4)
 11181 |     |             mstore(0xa0, m5)
 11182 |     |             mstore(0xc0, m6)
 11183 |     |         }
 11184 |     |     }
 11185 |     | 
 11186 |     |     function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {
 11187 |     |         bytes32 m0;
 11188 |     |         bytes32 m1;
 11189 |     |         bytes32 m2;
 11190 |     |         bytes32 m3;
 11191 |     |         bytes32 m4;
 11192 |     |         bytes32 m5;
 11193 |     |         bytes32 m6;
 11194 |     |         /// @solidity memory-safe-assembly
 11195 |     |         assembly {
 11196 |     |             function writeString(pos, w) {
 11197 |     |                 let length := 0
 11198 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11199 |     |                 mstore(pos, length)
 11200 |     |                 let shift := sub(256, shl(3, length))
 11201 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11202 |     |             }
 11203 |     |             m0 := mload(0x00)
 11204 |     |             m1 := mload(0x20)
 11205 |     |             m2 := mload(0x40)
 11206 |     |             m3 := mload(0x60)
 11207 |     |             m4 := mload(0x80)
 11208 |     |             m5 := mload(0xa0)
 11209 |     |             m6 := mload(0xc0)
 11210 |     |             // Selector of `log(string,address,uint256,uint256)`.
 11211 |     |             mstore(0x00, 0xf8f51b1e)
 11212 |     |             mstore(0x20, 0x80)
 11213 |     |             mstore(0x40, p1)
 11214 |     |             mstore(0x60, p2)
 11215 |     |             mstore(0x80, p3)
 11216 |     |             writeString(0xa0, p0)
 11217 |     |         }
 11218 |     |         _sendLogPayload(0x1c, 0xc4);
 11219 |     |         /// @solidity memory-safe-assembly
 11220 |     |         assembly {
 11221 |     |             mstore(0x00, m0)
 11222 |     |             mstore(0x20, m1)
 11223 |     |             mstore(0x40, m2)
 11224 |     |             mstore(0x60, m3)
 11225 |     |             mstore(0x80, m4)
 11226 |     |             mstore(0xa0, m5)
 11227 |     |             mstore(0xc0, m6)
 11228 |     |         }
 11229 |     |     }
 11230 |     | 
 11231 |     |     function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {
 11232 |     |         bytes32 m0;
 11233 |     |         bytes32 m1;
 11234 |     |         bytes32 m2;
 11235 |     |         bytes32 m3;
 11236 |     |         bytes32 m4;
 11237 |     |         bytes32 m5;
 11238 |     |         bytes32 m6;
 11239 |     |         bytes32 m7;
 11240 |     |         bytes32 m8;
 11241 |     |         /// @solidity memory-safe-assembly
 11242 |     |         assembly {
 11243 |     |             function writeString(pos, w) {
 11244 |     |                 let length := 0
 11245 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11246 |     |                 mstore(pos, length)
 11247 |     |                 let shift := sub(256, shl(3, length))
 11248 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11249 |     |             }
 11250 |     |             m0 := mload(0x00)
 11251 |     |             m1 := mload(0x20)
 11252 |     |             m2 := mload(0x40)
 11253 |     |             m3 := mload(0x60)
 11254 |     |             m4 := mload(0x80)
 11255 |     |             m5 := mload(0xa0)
 11256 |     |             m6 := mload(0xc0)
 11257 |     |             m7 := mload(0xe0)
 11258 |     |             m8 := mload(0x100)
 11259 |     |             // Selector of `log(string,address,uint256,string)`.
 11260 |     |             mstore(0x00, 0x5a477632)
 11261 |     |             mstore(0x20, 0x80)
 11262 |     |             mstore(0x40, p1)
 11263 |     |             mstore(0x60, p2)
 11264 |     |             mstore(0x80, 0xc0)
 11265 |     |             writeString(0xa0, p0)
 11266 |     |             writeString(0xe0, p3)
 11267 |     |         }
 11268 |     |         _sendLogPayload(0x1c, 0x104);
 11269 |     |         /// @solidity memory-safe-assembly
 11270 |     |         assembly {
 11271 |     |             mstore(0x00, m0)
 11272 |     |             mstore(0x20, m1)
 11273 |     |             mstore(0x40, m2)
 11274 |     |             mstore(0x60, m3)
 11275 |     |             mstore(0x80, m4)
 11276 |     |             mstore(0xa0, m5)
 11277 |     |             mstore(0xc0, m6)
 11278 |     |             mstore(0xe0, m7)
 11279 |     |             mstore(0x100, m8)
 11280 |     |         }
 11281 |     |     }
 11282 |     | 
 11283 |     |     function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {
 11284 |     |         bytes32 m0;
 11285 |     |         bytes32 m1;
 11286 |     |         bytes32 m2;
 11287 |     |         bytes32 m3;
 11288 |     |         bytes32 m4;
 11289 |     |         bytes32 m5;
 11290 |     |         bytes32 m6;
 11291 |     |         bytes32 m7;
 11292 |     |         bytes32 m8;
 11293 |     |         /// @solidity memory-safe-assembly
 11294 |     |         assembly {
 11295 |     |             function writeString(pos, w) {
 11296 |     |                 let length := 0
 11297 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11298 |     |                 mstore(pos, length)
 11299 |     |                 let shift := sub(256, shl(3, length))
 11300 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11301 |     |             }
 11302 |     |             m0 := mload(0x00)
 11303 |     |             m1 := mload(0x20)
 11304 |     |             m2 := mload(0x40)
 11305 |     |             m3 := mload(0x60)
 11306 |     |             m4 := mload(0x80)
 11307 |     |             m5 := mload(0xa0)
 11308 |     |             m6 := mload(0xc0)
 11309 |     |             m7 := mload(0xe0)
 11310 |     |             m8 := mload(0x100)
 11311 |     |             // Selector of `log(string,address,string,address)`.
 11312 |     |             mstore(0x00, 0xaabc9a31)
 11313 |     |             mstore(0x20, 0x80)
 11314 |     |             mstore(0x40, p1)
 11315 |     |             mstore(0x60, 0xc0)
 11316 |     |             mstore(0x80, p3)
 11317 |     |             writeString(0xa0, p0)
 11318 |     |             writeString(0xe0, p2)
 11319 |     |         }
 11320 |     |         _sendLogPayload(0x1c, 0x104);
 11321 |     |         /// @solidity memory-safe-assembly
 11322 |     |         assembly {
 11323 |     |             mstore(0x00, m0)
 11324 |     |             mstore(0x20, m1)
 11325 |     |             mstore(0x40, m2)
 11326 |     |             mstore(0x60, m3)
 11327 |     |             mstore(0x80, m4)
 11328 |     |             mstore(0xa0, m5)
 11329 |     |             mstore(0xc0, m6)
 11330 |     |             mstore(0xe0, m7)
 11331 |     |             mstore(0x100, m8)
 11332 |     |         }
 11333 |     |     }
 11334 |     | 
 11335 |     |     function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {
 11336 |     |         bytes32 m0;
 11337 |     |         bytes32 m1;
 11338 |     |         bytes32 m2;
 11339 |     |         bytes32 m3;
 11340 |     |         bytes32 m4;
 11341 |     |         bytes32 m5;
 11342 |     |         bytes32 m6;
 11343 |     |         bytes32 m7;
 11344 |     |         bytes32 m8;
 11345 |     |         /// @solidity memory-safe-assembly
 11346 |     |         assembly {
 11347 |     |             function writeString(pos, w) {
 11348 |     |                 let length := 0
 11349 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11350 |     |                 mstore(pos, length)
 11351 |     |                 let shift := sub(256, shl(3, length))
 11352 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11353 |     |             }
 11354 |     |             m0 := mload(0x00)
 11355 |     |             m1 := mload(0x20)
 11356 |     |             m2 := mload(0x40)
 11357 |     |             m3 := mload(0x60)
 11358 |     |             m4 := mload(0x80)
 11359 |     |             m5 := mload(0xa0)
 11360 |     |             m6 := mload(0xc0)
 11361 |     |             m7 := mload(0xe0)
 11362 |     |             m8 := mload(0x100)
 11363 |     |             // Selector of `log(string,address,string,bool)`.
 11364 |     |             mstore(0x00, 0x5f15d28c)
 11365 |     |             mstore(0x20, 0x80)
 11366 |     |             mstore(0x40, p1)
 11367 |     |             mstore(0x60, 0xc0)
 11368 |     |             mstore(0x80, p3)
 11369 |     |             writeString(0xa0, p0)
 11370 |     |             writeString(0xe0, p2)
 11371 |     |         }
 11372 |     |         _sendLogPayload(0x1c, 0x104);
 11373 |     |         /// @solidity memory-safe-assembly
 11374 |     |         assembly {
 11375 |     |             mstore(0x00, m0)
 11376 |     |             mstore(0x20, m1)
 11377 |     |             mstore(0x40, m2)
 11378 |     |             mstore(0x60, m3)
 11379 |     |             mstore(0x80, m4)
 11380 |     |             mstore(0xa0, m5)
 11381 |     |             mstore(0xc0, m6)
 11382 |     |             mstore(0xe0, m7)
 11383 |     |             mstore(0x100, m8)
 11384 |     |         }
 11385 |     |     }
 11386 |     | 
 11387 |     |     function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {
 11388 |     |         bytes32 m0;
 11389 |     |         bytes32 m1;
 11390 |     |         bytes32 m2;
 11391 |     |         bytes32 m3;
 11392 |     |         bytes32 m4;
 11393 |     |         bytes32 m5;
 11394 |     |         bytes32 m6;
 11395 |     |         bytes32 m7;
 11396 |     |         bytes32 m8;
 11397 |     |         /// @solidity memory-safe-assembly
 11398 |     |         assembly {
 11399 |     |             function writeString(pos, w) {
 11400 |     |                 let length := 0
 11401 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11402 |     |                 mstore(pos, length)
 11403 |     |                 let shift := sub(256, shl(3, length))
 11404 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11405 |     |             }
 11406 |     |             m0 := mload(0x00)
 11407 |     |             m1 := mload(0x20)
 11408 |     |             m2 := mload(0x40)
 11409 |     |             m3 := mload(0x60)
 11410 |     |             m4 := mload(0x80)
 11411 |     |             m5 := mload(0xa0)
 11412 |     |             m6 := mload(0xc0)
 11413 |     |             m7 := mload(0xe0)
 11414 |     |             m8 := mload(0x100)
 11415 |     |             // Selector of `log(string,address,string,uint256)`.
 11416 |     |             mstore(0x00, 0x91d1112e)
 11417 |     |             mstore(0x20, 0x80)
 11418 |     |             mstore(0x40, p1)
 11419 |     |             mstore(0x60, 0xc0)
 11420 |     |             mstore(0x80, p3)
 11421 |     |             writeString(0xa0, p0)
 11422 |     |             writeString(0xe0, p2)
 11423 |     |         }
 11424 |     |         _sendLogPayload(0x1c, 0x104);
 11425 |     |         /// @solidity memory-safe-assembly
 11426 |     |         assembly {
 11427 |     |             mstore(0x00, m0)
 11428 |     |             mstore(0x20, m1)
 11429 |     |             mstore(0x40, m2)
 11430 |     |             mstore(0x60, m3)
 11431 |     |             mstore(0x80, m4)
 11432 |     |             mstore(0xa0, m5)
 11433 |     |             mstore(0xc0, m6)
 11434 |     |             mstore(0xe0, m7)
 11435 |     |             mstore(0x100, m8)
 11436 |     |         }
 11437 |     |     }
 11438 |     | 
 11439 |     |     function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
 11440 |     |         bytes32 m0;
 11441 |     |         bytes32 m1;
 11442 |     |         bytes32 m2;
 11443 |     |         bytes32 m3;
 11444 |     |         bytes32 m4;
 11445 |     |         bytes32 m5;
 11446 |     |         bytes32 m6;
 11447 |     |         bytes32 m7;
 11448 |     |         bytes32 m8;
 11449 |     |         bytes32 m9;
 11450 |     |         bytes32 m10;
 11451 |     |         /// @solidity memory-safe-assembly
 11452 |     |         assembly {
 11453 |     |             function writeString(pos, w) {
 11454 |     |                 let length := 0
 11455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11456 |     |                 mstore(pos, length)
 11457 |     |                 let shift := sub(256, shl(3, length))
 11458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11459 |     |             }
 11460 |     |             m0 := mload(0x00)
 11461 |     |             m1 := mload(0x20)
 11462 |     |             m2 := mload(0x40)
 11463 |     |             m3 := mload(0x60)
 11464 |     |             m4 := mload(0x80)
 11465 |     |             m5 := mload(0xa0)
 11466 |     |             m6 := mload(0xc0)
 11467 |     |             m7 := mload(0xe0)
 11468 |     |             m8 := mload(0x100)
 11469 |     |             m9 := mload(0x120)
 11470 |     |             m10 := mload(0x140)
 11471 |     |             // Selector of `log(string,address,string,string)`.
 11472 |     |             mstore(0x00, 0x245986f2)
 11473 |     |             mstore(0x20, 0x80)
 11474 |     |             mstore(0x40, p1)
 11475 |     |             mstore(0x60, 0xc0)
 11476 |     |             mstore(0x80, 0x100)
 11477 |     |             writeString(0xa0, p0)
 11478 |     |             writeString(0xe0, p2)
 11479 |     |             writeString(0x120, p3)
 11480 |     |         }
 11481 |     |         _sendLogPayload(0x1c, 0x144);
 11482 |     |         /// @solidity memory-safe-assembly
 11483 |     |         assembly {
 11484 |     |             mstore(0x00, m0)
 11485 |     |             mstore(0x20, m1)
 11486 |     |             mstore(0x40, m2)
 11487 |     |             mstore(0x60, m3)
 11488 |     |             mstore(0x80, m4)
 11489 |     |             mstore(0xa0, m5)
 11490 |     |             mstore(0xc0, m6)
 11491 |     |             mstore(0xe0, m7)
 11492 |     |             mstore(0x100, m8)
 11493 |     |             mstore(0x120, m9)
 11494 |     |             mstore(0x140, m10)
 11495 |     |         }
 11496 |     |     }
 11497 |     | 
 11498 |     |     function log(bytes32 p0, bool p1, address p2, address p3) internal pure {
 11499 |     |         bytes32 m0;
 11500 |     |         bytes32 m1;
 11501 |     |         bytes32 m2;
 11502 |     |         bytes32 m3;
 11503 |     |         bytes32 m4;
 11504 |     |         bytes32 m5;
 11505 |     |         bytes32 m6;
 11506 |     |         /// @solidity memory-safe-assembly
 11507 |     |         assembly {
 11508 |     |             function writeString(pos, w) {
 11509 |     |                 let length := 0
 11510 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11511 |     |                 mstore(pos, length)
 11512 |     |                 let shift := sub(256, shl(3, length))
 11513 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11514 |     |             }
 11515 |     |             m0 := mload(0x00)
 11516 |     |             m1 := mload(0x20)
 11517 |     |             m2 := mload(0x40)
 11518 |     |             m3 := mload(0x60)
 11519 |     |             m4 := mload(0x80)
 11520 |     |             m5 := mload(0xa0)
 11521 |     |             m6 := mload(0xc0)
 11522 |     |             // Selector of `log(string,bool,address,address)`.
 11523 |     |             mstore(0x00, 0x33e9dd1d)
 11524 |     |             mstore(0x20, 0x80)
 11525 |     |             mstore(0x40, p1)
 11526 |     |             mstore(0x60, p2)
 11527 |     |             mstore(0x80, p3)
 11528 |     |             writeString(0xa0, p0)
 11529 |     |         }
 11530 |     |         _sendLogPayload(0x1c, 0xc4);
 11531 |     |         /// @solidity memory-safe-assembly
 11532 |     |         assembly {
 11533 |     |             mstore(0x00, m0)
 11534 |     |             mstore(0x20, m1)
 11535 |     |             mstore(0x40, m2)
 11536 |     |             mstore(0x60, m3)
 11537 |     |             mstore(0x80, m4)
 11538 |     |             mstore(0xa0, m5)
 11539 |     |             mstore(0xc0, m6)
 11540 |     |         }
 11541 |     |     }
 11542 |     | 
 11543 |     |     function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {
 11544 |     |         bytes32 m0;
 11545 |     |         bytes32 m1;
 11546 |     |         bytes32 m2;
 11547 |     |         bytes32 m3;
 11548 |     |         bytes32 m4;
 11549 |     |         bytes32 m5;
 11550 |     |         bytes32 m6;
 11551 |     |         /// @solidity memory-safe-assembly
 11552 |     |         assembly {
 11553 |     |             function writeString(pos, w) {
 11554 |     |                 let length := 0
 11555 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11556 |     |                 mstore(pos, length)
 11557 |     |                 let shift := sub(256, shl(3, length))
 11558 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11559 |     |             }
 11560 |     |             m0 := mload(0x00)
 11561 |     |             m1 := mload(0x20)
 11562 |     |             m2 := mload(0x40)
 11563 |     |             m3 := mload(0x60)
 11564 |     |             m4 := mload(0x80)
 11565 |     |             m5 := mload(0xa0)
 11566 |     |             m6 := mload(0xc0)
 11567 |     |             // Selector of `log(string,bool,address,bool)`.
 11568 |     |             mstore(0x00, 0x958c28c6)
 11569 |     |             mstore(0x20, 0x80)
 11570 |     |             mstore(0x40, p1)
 11571 |     |             mstore(0x60, p2)
 11572 |     |             mstore(0x80, p3)
 11573 |     |             writeString(0xa0, p0)
 11574 |     |         }
 11575 |     |         _sendLogPayload(0x1c, 0xc4);
 11576 |     |         /// @solidity memory-safe-assembly
 11577 |     |         assembly {
 11578 |     |             mstore(0x00, m0)
 11579 |     |             mstore(0x20, m1)
 11580 |     |             mstore(0x40, m2)
 11581 |     |             mstore(0x60, m3)
 11582 |     |             mstore(0x80, m4)
 11583 |     |             mstore(0xa0, m5)
 11584 |     |             mstore(0xc0, m6)
 11585 |     |         }
 11586 |     |     }
 11587 |     | 
 11588 |     |     function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {
 11589 |     |         bytes32 m0;
 11590 |     |         bytes32 m1;
 11591 |     |         bytes32 m2;
 11592 |     |         bytes32 m3;
 11593 |     |         bytes32 m4;
 11594 |     |         bytes32 m5;
 11595 |     |         bytes32 m6;
 11596 |     |         /// @solidity memory-safe-assembly
 11597 |     |         assembly {
 11598 |     |             function writeString(pos, w) {
 11599 |     |                 let length := 0
 11600 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11601 |     |                 mstore(pos, length)
 11602 |     |                 let shift := sub(256, shl(3, length))
 11603 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11604 |     |             }
 11605 |     |             m0 := mload(0x00)
 11606 |     |             m1 := mload(0x20)
 11607 |     |             m2 := mload(0x40)
 11608 |     |             m3 := mload(0x60)
 11609 |     |             m4 := mload(0x80)
 11610 |     |             m5 := mload(0xa0)
 11611 |     |             m6 := mload(0xc0)
 11612 |     |             // Selector of `log(string,bool,address,uint256)`.
 11613 |     |             mstore(0x00, 0x5d08bb05)
 11614 |     |             mstore(0x20, 0x80)
 11615 |     |             mstore(0x40, p1)
 11616 |     |             mstore(0x60, p2)
 11617 |     |             mstore(0x80, p3)
 11618 |     |             writeString(0xa0, p0)
 11619 |     |         }
 11620 |     |         _sendLogPayload(0x1c, 0xc4);
 11621 |     |         /// @solidity memory-safe-assembly
 11622 |     |         assembly {
 11623 |     |             mstore(0x00, m0)
 11624 |     |             mstore(0x20, m1)
 11625 |     |             mstore(0x40, m2)
 11626 |     |             mstore(0x60, m3)
 11627 |     |             mstore(0x80, m4)
 11628 |     |             mstore(0xa0, m5)
 11629 |     |             mstore(0xc0, m6)
 11630 |     |         }
 11631 |     |     }
 11632 |     | 
 11633 |     |     function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {
 11634 |     |         bytes32 m0;
 11635 |     |         bytes32 m1;
 11636 |     |         bytes32 m2;
 11637 |     |         bytes32 m3;
 11638 |     |         bytes32 m4;
 11639 |     |         bytes32 m5;
 11640 |     |         bytes32 m6;
 11641 |     |         bytes32 m7;
 11642 |     |         bytes32 m8;
 11643 |     |         /// @solidity memory-safe-assembly
 11644 |     |         assembly {
 11645 |     |             function writeString(pos, w) {
 11646 |     |                 let length := 0
 11647 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11648 |     |                 mstore(pos, length)
 11649 |     |                 let shift := sub(256, shl(3, length))
 11650 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11651 |     |             }
 11652 |     |             m0 := mload(0x00)
 11653 |     |             m1 := mload(0x20)
 11654 |     |             m2 := mload(0x40)
 11655 |     |             m3 := mload(0x60)
 11656 |     |             m4 := mload(0x80)
 11657 |     |             m5 := mload(0xa0)
 11658 |     |             m6 := mload(0xc0)
 11659 |     |             m7 := mload(0xe0)
 11660 |     |             m8 := mload(0x100)
 11661 |     |             // Selector of `log(string,bool,address,string)`.
 11662 |     |             mstore(0x00, 0x2d8e33a4)
 11663 |     |             mstore(0x20, 0x80)
 11664 |     |             mstore(0x40, p1)
 11665 |     |             mstore(0x60, p2)
 11666 |     |             mstore(0x80, 0xc0)
 11667 |     |             writeString(0xa0, p0)
 11668 |     |             writeString(0xe0, p3)
 11669 |     |         }
 11670 |     |         _sendLogPayload(0x1c, 0x104);
 11671 |     |         /// @solidity memory-safe-assembly
 11672 |     |         assembly {
 11673 |     |             mstore(0x00, m0)
 11674 |     |             mstore(0x20, m1)
 11675 |     |             mstore(0x40, m2)
 11676 |     |             mstore(0x60, m3)
 11677 |     |             mstore(0x80, m4)
 11678 |     |             mstore(0xa0, m5)
 11679 |     |             mstore(0xc0, m6)
 11680 |     |             mstore(0xe0, m7)
 11681 |     |             mstore(0x100, m8)
 11682 |     |         }
 11683 |     |     }
 11684 |     | 
 11685 |     |     function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {
 11686 |     |         bytes32 m0;
 11687 |     |         bytes32 m1;
 11688 |     |         bytes32 m2;
 11689 |     |         bytes32 m3;
 11690 |     |         bytes32 m4;
 11691 |     |         bytes32 m5;
 11692 |     |         bytes32 m6;
 11693 |     |         /// @solidity memory-safe-assembly
 11694 |     |         assembly {
 11695 |     |             function writeString(pos, w) {
 11696 |     |                 let length := 0
 11697 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11698 |     |                 mstore(pos, length)
 11699 |     |                 let shift := sub(256, shl(3, length))
 11700 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11701 |     |             }
 11702 |     |             m0 := mload(0x00)
 11703 |     |             m1 := mload(0x20)
 11704 |     |             m2 := mload(0x40)
 11705 |     |             m3 := mload(0x60)
 11706 |     |             m4 := mload(0x80)
 11707 |     |             m5 := mload(0xa0)
 11708 |     |             m6 := mload(0xc0)
 11709 |     |             // Selector of `log(string,bool,bool,address)`.
 11710 |     |             mstore(0x00, 0x7190a529)
 11711 |     |             mstore(0x20, 0x80)
 11712 |     |             mstore(0x40, p1)
 11713 |     |             mstore(0x60, p2)
 11714 |     |             mstore(0x80, p3)
 11715 |     |             writeString(0xa0, p0)
 11716 |     |         }
 11717 |     |         _sendLogPayload(0x1c, 0xc4);
 11718 |     |         /// @solidity memory-safe-assembly
 11719 |     |         assembly {
 11720 |     |             mstore(0x00, m0)
 11721 |     |             mstore(0x20, m1)
 11722 |     |             mstore(0x40, m2)
 11723 |     |             mstore(0x60, m3)
 11724 |     |             mstore(0x80, m4)
 11725 |     |             mstore(0xa0, m5)
 11726 |     |             mstore(0xc0, m6)
 11727 |     |         }
 11728 |     |     }
 11729 |     | 
 11730 |     |     function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {
 11731 |     |         bytes32 m0;
 11732 |     |         bytes32 m1;
 11733 |     |         bytes32 m2;
 11734 |     |         bytes32 m3;
 11735 |     |         bytes32 m4;
 11736 |     |         bytes32 m5;
 11737 |     |         bytes32 m6;
 11738 |     |         /// @solidity memory-safe-assembly
 11739 |     |         assembly {
 11740 |     |             function writeString(pos, w) {
 11741 |     |                 let length := 0
 11742 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11743 |     |                 mstore(pos, length)
 11744 |     |                 let shift := sub(256, shl(3, length))
 11745 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11746 |     |             }
 11747 |     |             m0 := mload(0x00)
 11748 |     |             m1 := mload(0x20)
 11749 |     |             m2 := mload(0x40)
 11750 |     |             m3 := mload(0x60)
 11751 |     |             m4 := mload(0x80)
 11752 |     |             m5 := mload(0xa0)
 11753 |     |             m6 := mload(0xc0)
 11754 |     |             // Selector of `log(string,bool,bool,bool)`.
 11755 |     |             mstore(0x00, 0x895af8c5)
 11756 |     |             mstore(0x20, 0x80)
 11757 |     |             mstore(0x40, p1)
 11758 |     |             mstore(0x60, p2)
 11759 |     |             mstore(0x80, p3)
 11760 |     |             writeString(0xa0, p0)
 11761 |     |         }
 11762 |     |         _sendLogPayload(0x1c, 0xc4);
 11763 |     |         /// @solidity memory-safe-assembly
 11764 |     |         assembly {
 11765 |     |             mstore(0x00, m0)
 11766 |     |             mstore(0x20, m1)
 11767 |     |             mstore(0x40, m2)
 11768 |     |             mstore(0x60, m3)
 11769 |     |             mstore(0x80, m4)
 11770 |     |             mstore(0xa0, m5)
 11771 |     |             mstore(0xc0, m6)
 11772 |     |         }
 11773 |     |     }
 11774 |     | 
 11775 |     |     function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {
 11776 |     |         bytes32 m0;
 11777 |     |         bytes32 m1;
 11778 |     |         bytes32 m2;
 11779 |     |         bytes32 m3;
 11780 |     |         bytes32 m4;
 11781 |     |         bytes32 m5;
 11782 |     |         bytes32 m6;
 11783 |     |         /// @solidity memory-safe-assembly
 11784 |     |         assembly {
 11785 |     |             function writeString(pos, w) {
 11786 |     |                 let length := 0
 11787 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11788 |     |                 mstore(pos, length)
 11789 |     |                 let shift := sub(256, shl(3, length))
 11790 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11791 |     |             }
 11792 |     |             m0 := mload(0x00)
 11793 |     |             m1 := mload(0x20)
 11794 |     |             m2 := mload(0x40)
 11795 |     |             m3 := mload(0x60)
 11796 |     |             m4 := mload(0x80)
 11797 |     |             m5 := mload(0xa0)
 11798 |     |             m6 := mload(0xc0)
 11799 |     |             // Selector of `log(string,bool,bool,uint256)`.
 11800 |     |             mstore(0x00, 0x8e3f78a9)
 11801 |     |             mstore(0x20, 0x80)
 11802 |     |             mstore(0x40, p1)
 11803 |     |             mstore(0x60, p2)
 11804 |     |             mstore(0x80, p3)
 11805 |     |             writeString(0xa0, p0)
 11806 |     |         }
 11807 |     |         _sendLogPayload(0x1c, 0xc4);
 11808 |     |         /// @solidity memory-safe-assembly
 11809 |     |         assembly {
 11810 |     |             mstore(0x00, m0)
 11811 |     |             mstore(0x20, m1)
 11812 |     |             mstore(0x40, m2)
 11813 |     |             mstore(0x60, m3)
 11814 |     |             mstore(0x80, m4)
 11815 |     |             mstore(0xa0, m5)
 11816 |     |             mstore(0xc0, m6)
 11817 |     |         }
 11818 |     |     }
 11819 |     | 
 11820 |     |     function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {
 11821 |     |         bytes32 m0;
 11822 |     |         bytes32 m1;
 11823 |     |         bytes32 m2;
 11824 |     |         bytes32 m3;
 11825 |     |         bytes32 m4;
 11826 |     |         bytes32 m5;
 11827 |     |         bytes32 m6;
 11828 |     |         bytes32 m7;
 11829 |     |         bytes32 m8;
 11830 |     |         /// @solidity memory-safe-assembly
 11831 |     |         assembly {
 11832 |     |             function writeString(pos, w) {
 11833 |     |                 let length := 0
 11834 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11835 |     |                 mstore(pos, length)
 11836 |     |                 let shift := sub(256, shl(3, length))
 11837 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11838 |     |             }
 11839 |     |             m0 := mload(0x00)
 11840 |     |             m1 := mload(0x20)
 11841 |     |             m2 := mload(0x40)
 11842 |     |             m3 := mload(0x60)
 11843 |     |             m4 := mload(0x80)
 11844 |     |             m5 := mload(0xa0)
 11845 |     |             m6 := mload(0xc0)
 11846 |     |             m7 := mload(0xe0)
 11847 |     |             m8 := mload(0x100)
 11848 |     |             // Selector of `log(string,bool,bool,string)`.
 11849 |     |             mstore(0x00, 0x9d22d5dd)
 11850 |     |             mstore(0x20, 0x80)
 11851 |     |             mstore(0x40, p1)
 11852 |     |             mstore(0x60, p2)
 11853 |     |             mstore(0x80, 0xc0)
 11854 |     |             writeString(0xa0, p0)
 11855 |     |             writeString(0xe0, p3)
 11856 |     |         }
 11857 |     |         _sendLogPayload(0x1c, 0x104);
 11858 |     |         /// @solidity memory-safe-assembly
 11859 |     |         assembly {
 11860 |     |             mstore(0x00, m0)
 11861 |     |             mstore(0x20, m1)
 11862 |     |             mstore(0x40, m2)
 11863 |     |             mstore(0x60, m3)
 11864 |     |             mstore(0x80, m4)
 11865 |     |             mstore(0xa0, m5)
 11866 |     |             mstore(0xc0, m6)
 11867 |     |             mstore(0xe0, m7)
 11868 |     |             mstore(0x100, m8)
 11869 |     |         }
 11870 |     |     }
 11871 |     | 
 11872 |     |     function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {
 11873 |     |         bytes32 m0;
 11874 |     |         bytes32 m1;
 11875 |     |         bytes32 m2;
 11876 |     |         bytes32 m3;
 11877 |     |         bytes32 m4;
 11878 |     |         bytes32 m5;
 11879 |     |         bytes32 m6;
 11880 |     |         /// @solidity memory-safe-assembly
 11881 |     |         assembly {
 11882 |     |             function writeString(pos, w) {
 11883 |     |                 let length := 0
 11884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11885 |     |                 mstore(pos, length)
 11886 |     |                 let shift := sub(256, shl(3, length))
 11887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11888 |     |             }
 11889 |     |             m0 := mload(0x00)
 11890 |     |             m1 := mload(0x20)
 11891 |     |             m2 := mload(0x40)
 11892 |     |             m3 := mload(0x60)
 11893 |     |             m4 := mload(0x80)
 11894 |     |             m5 := mload(0xa0)
 11895 |     |             m6 := mload(0xc0)
 11896 |     |             // Selector of `log(string,bool,uint256,address)`.
 11897 |     |             mstore(0x00, 0x935e09bf)
 11898 |     |             mstore(0x20, 0x80)
 11899 |     |             mstore(0x40, p1)
 11900 |     |             mstore(0x60, p2)
 11901 |     |             mstore(0x80, p3)
 11902 |     |             writeString(0xa0, p0)
 11903 |     |         }
 11904 |     |         _sendLogPayload(0x1c, 0xc4);
 11905 |     |         /// @solidity memory-safe-assembly
 11906 |     |         assembly {
 11907 |     |             mstore(0x00, m0)
 11908 |     |             mstore(0x20, m1)
 11909 |     |             mstore(0x40, m2)
 11910 |     |             mstore(0x60, m3)
 11911 |     |             mstore(0x80, m4)
 11912 |     |             mstore(0xa0, m5)
 11913 |     |             mstore(0xc0, m6)
 11914 |     |         }
 11915 |     |     }
 11916 |     | 
 11917 |     |     function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {
 11918 |     |         bytes32 m0;
 11919 |     |         bytes32 m1;
 11920 |     |         bytes32 m2;
 11921 |     |         bytes32 m3;
 11922 |     |         bytes32 m4;
 11923 |     |         bytes32 m5;
 11924 |     |         bytes32 m6;
 11925 |     |         /// @solidity memory-safe-assembly
 11926 |     |         assembly {
 11927 |     |             function writeString(pos, w) {
 11928 |     |                 let length := 0
 11929 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11930 |     |                 mstore(pos, length)
 11931 |     |                 let shift := sub(256, shl(3, length))
 11932 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11933 |     |             }
 11934 |     |             m0 := mload(0x00)
 11935 |     |             m1 := mload(0x20)
 11936 |     |             m2 := mload(0x40)
 11937 |     |             m3 := mload(0x60)
 11938 |     |             m4 := mload(0x80)
 11939 |     |             m5 := mload(0xa0)
 11940 |     |             m6 := mload(0xc0)
 11941 |     |             // Selector of `log(string,bool,uint256,bool)`.
 11942 |     |             mstore(0x00, 0x8af7cf8a)
 11943 |     |             mstore(0x20, 0x80)
 11944 |     |             mstore(0x40, p1)
 11945 |     |             mstore(0x60, p2)
 11946 |     |             mstore(0x80, p3)
 11947 |     |             writeString(0xa0, p0)
 11948 |     |         }
 11949 |     |         _sendLogPayload(0x1c, 0xc4);
 11950 |     |         /// @solidity memory-safe-assembly
 11951 |     |         assembly {
 11952 |     |             mstore(0x00, m0)
 11953 |     |             mstore(0x20, m1)
 11954 |     |             mstore(0x40, m2)
 11955 |     |             mstore(0x60, m3)
 11956 |     |             mstore(0x80, m4)
 11957 |     |             mstore(0xa0, m5)
 11958 |     |             mstore(0xc0, m6)
 11959 |     |         }
 11960 |     |     }
 11961 |     | 
 11962 |     |     function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {
 11963 |     |         bytes32 m0;
 11964 |     |         bytes32 m1;
 11965 |     |         bytes32 m2;
 11966 |     |         bytes32 m3;
 11967 |     |         bytes32 m4;
 11968 |     |         bytes32 m5;
 11969 |     |         bytes32 m6;
 11970 |     |         /// @solidity memory-safe-assembly
 11971 |     |         assembly {
 11972 |     |             function writeString(pos, w) {
 11973 |     |                 let length := 0
 11974 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11975 |     |                 mstore(pos, length)
 11976 |     |                 let shift := sub(256, shl(3, length))
 11977 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11978 |     |             }
 11979 |     |             m0 := mload(0x00)
 11980 |     |             m1 := mload(0x20)
 11981 |     |             m2 := mload(0x40)
 11982 |     |             m3 := mload(0x60)
 11983 |     |             m4 := mload(0x80)
 11984 |     |             m5 := mload(0xa0)
 11985 |     |             m6 := mload(0xc0)
 11986 |     |             // Selector of `log(string,bool,uint256,uint256)`.
 11987 |     |             mstore(0x00, 0x64b5bb67)
 11988 |     |             mstore(0x20, 0x80)
 11989 |     |             mstore(0x40, p1)
 11990 |     |             mstore(0x60, p2)
 11991 |     |             mstore(0x80, p3)
 11992 |     |             writeString(0xa0, p0)
 11993 |     |         }
 11994 |     |         _sendLogPayload(0x1c, 0xc4);
 11995 |     |         /// @solidity memory-safe-assembly
 11996 |     |         assembly {
 11997 |     |             mstore(0x00, m0)
 11998 |     |             mstore(0x20, m1)
 11999 |     |             mstore(0x40, m2)
 12000 |     |             mstore(0x60, m3)
 12001 |     |             mstore(0x80, m4)
 12002 |     |             mstore(0xa0, m5)
 12003 |     |             mstore(0xc0, m6)
 12004 |     |         }
 12005 |     |     }
 12006 |     | 
 12007 |     |     function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
 12008 |     |         bytes32 m0;
 12009 |     |         bytes32 m1;
 12010 |     |         bytes32 m2;
 12011 |     |         bytes32 m3;
 12012 |     |         bytes32 m4;
 12013 |     |         bytes32 m5;
 12014 |     |         bytes32 m6;
 12015 |     |         bytes32 m7;
 12016 |     |         bytes32 m8;
 12017 |     |         /// @solidity memory-safe-assembly
 12018 |     |         assembly {
 12019 |     |             function writeString(pos, w) {
 12020 |     |                 let length := 0
 12021 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12022 |     |                 mstore(pos, length)
 12023 |     |                 let shift := sub(256, shl(3, length))
 12024 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12025 |     |             }
 12026 |     |             m0 := mload(0x00)
 12027 |     |             m1 := mload(0x20)
 12028 |     |             m2 := mload(0x40)
 12029 |     |             m3 := mload(0x60)
 12030 |     |             m4 := mload(0x80)
 12031 |     |             m5 := mload(0xa0)
 12032 |     |             m6 := mload(0xc0)
 12033 |     |             m7 := mload(0xe0)
 12034 |     |             m8 := mload(0x100)
 12035 |     |             // Selector of `log(string,bool,uint256,string)`.
 12036 |     |             mstore(0x00, 0x742d6ee7)
 12037 |     |             mstore(0x20, 0x80)
 12038 |     |             mstore(0x40, p1)
 12039 |     |             mstore(0x60, p2)
 12040 |     |             mstore(0x80, 0xc0)
 12041 |     |             writeString(0xa0, p0)
 12042 |     |             writeString(0xe0, p3)
 12043 |     |         }
 12044 |     |         _sendLogPayload(0x1c, 0x104);
 12045 |     |         /// @solidity memory-safe-assembly
 12046 |     |         assembly {
 12047 |     |             mstore(0x00, m0)
 12048 |     |             mstore(0x20, m1)
 12049 |     |             mstore(0x40, m2)
 12050 |     |             mstore(0x60, m3)
 12051 |     |             mstore(0x80, m4)
 12052 |     |             mstore(0xa0, m5)
 12053 |     |             mstore(0xc0, m6)
 12054 |     |             mstore(0xe0, m7)
 12055 |     |             mstore(0x100, m8)
 12056 |     |         }
 12057 |     |     }
 12058 |     | 
 12059 |     |     function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {
 12060 |     |         bytes32 m0;
 12061 |     |         bytes32 m1;
 12062 |     |         bytes32 m2;
 12063 |     |         bytes32 m3;
 12064 |     |         bytes32 m4;
 12065 |     |         bytes32 m5;
 12066 |     |         bytes32 m6;
 12067 |     |         bytes32 m7;
 12068 |     |         bytes32 m8;
 12069 |     |         /// @solidity memory-safe-assembly
 12070 |     |         assembly {
 12071 |     |             function writeString(pos, w) {
 12072 |     |                 let length := 0
 12073 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12074 |     |                 mstore(pos, length)
 12075 |     |                 let shift := sub(256, shl(3, length))
 12076 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12077 |     |             }
 12078 |     |             m0 := mload(0x00)
 12079 |     |             m1 := mload(0x20)
 12080 |     |             m2 := mload(0x40)
 12081 |     |             m3 := mload(0x60)
 12082 |     |             m4 := mload(0x80)
 12083 |     |             m5 := mload(0xa0)
 12084 |     |             m6 := mload(0xc0)
 12085 |     |             m7 := mload(0xe0)
 12086 |     |             m8 := mload(0x100)
 12087 |     |             // Selector of `log(string,bool,string,address)`.
 12088 |     |             mstore(0x00, 0xe0625b29)
 12089 |     |             mstore(0x20, 0x80)
 12090 |     |             mstore(0x40, p1)
 12091 |     |             mstore(0x60, 0xc0)
 12092 |     |             mstore(0x80, p3)
 12093 |     |             writeString(0xa0, p0)
 12094 |     |             writeString(0xe0, p2)
 12095 |     |         }
 12096 |     |         _sendLogPayload(0x1c, 0x104);
 12097 |     |         /// @solidity memory-safe-assembly
 12098 |     |         assembly {
 12099 |     |             mstore(0x00, m0)
 12100 |     |             mstore(0x20, m1)
 12101 |     |             mstore(0x40, m2)
 12102 |     |             mstore(0x60, m3)
 12103 |     |             mstore(0x80, m4)
 12104 |     |             mstore(0xa0, m5)
 12105 |     |             mstore(0xc0, m6)
 12106 |     |             mstore(0xe0, m7)
 12107 |     |             mstore(0x100, m8)
 12108 |     |         }
 12109 |     |     }
 12110 |     | 
 12111 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {
 12112 |     |         bytes32 m0;
 12113 |     |         bytes32 m1;
 12114 |     |         bytes32 m2;
 12115 |     |         bytes32 m3;
 12116 |     |         bytes32 m4;
 12117 |     |         bytes32 m5;
 12118 |     |         bytes32 m6;
 12119 |     |         bytes32 m7;
 12120 |     |         bytes32 m8;
 12121 |     |         /// @solidity memory-safe-assembly
 12122 |     |         assembly {
 12123 |     |             function writeString(pos, w) {
 12124 |     |                 let length := 0
 12125 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12126 |     |                 mstore(pos, length)
 12127 |     |                 let shift := sub(256, shl(3, length))
 12128 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12129 |     |             }
 12130 |     |             m0 := mload(0x00)
 12131 |     |             m1 := mload(0x20)
 12132 |     |             m2 := mload(0x40)
 12133 |     |             m3 := mload(0x60)
 12134 |     |             m4 := mload(0x80)
 12135 |     |             m5 := mload(0xa0)
 12136 |     |             m6 := mload(0xc0)
 12137 |     |             m7 := mload(0xe0)
 12138 |     |             m8 := mload(0x100)
 12139 |     |             // Selector of `log(string,bool,string,bool)`.
 12140 |     |             mstore(0x00, 0x3f8a701d)
 12141 |     |             mstore(0x20, 0x80)
 12142 |     |             mstore(0x40, p1)
 12143 |     |             mstore(0x60, 0xc0)
 12144 |     |             mstore(0x80, p3)
 12145 |     |             writeString(0xa0, p0)
 12146 |     |             writeString(0xe0, p2)
 12147 |     |         }
 12148 |     |         _sendLogPayload(0x1c, 0x104);
 12149 |     |         /// @solidity memory-safe-assembly
 12150 |     |         assembly {
 12151 |     |             mstore(0x00, m0)
 12152 |     |             mstore(0x20, m1)
 12153 |     |             mstore(0x40, m2)
 12154 |     |             mstore(0x60, m3)
 12155 |     |             mstore(0x80, m4)
 12156 |     |             mstore(0xa0, m5)
 12157 |     |             mstore(0xc0, m6)
 12158 |     |             mstore(0xe0, m7)
 12159 |     |             mstore(0x100, m8)
 12160 |     |         }
 12161 |     |     }
 12162 |     | 
 12163 |     |     function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
 12164 |     |         bytes32 m0;
 12165 |     |         bytes32 m1;
 12166 |     |         bytes32 m2;
 12167 |     |         bytes32 m3;
 12168 |     |         bytes32 m4;
 12169 |     |         bytes32 m5;
 12170 |     |         bytes32 m6;
 12171 |     |         bytes32 m7;
 12172 |     |         bytes32 m8;
 12173 |     |         /// @solidity memory-safe-assembly
 12174 |     |         assembly {
 12175 |     |             function writeString(pos, w) {
 12176 |     |                 let length := 0
 12177 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12178 |     |                 mstore(pos, length)
 12179 |     |                 let shift := sub(256, shl(3, length))
 12180 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12181 |     |             }
 12182 |     |             m0 := mload(0x00)
 12183 |     |             m1 := mload(0x20)
 12184 |     |             m2 := mload(0x40)
 12185 |     |             m3 := mload(0x60)
 12186 |     |             m4 := mload(0x80)
 12187 |     |             m5 := mload(0xa0)
 12188 |     |             m6 := mload(0xc0)
 12189 |     |             m7 := mload(0xe0)
 12190 |     |             m8 := mload(0x100)
 12191 |     |             // Selector of `log(string,bool,string,uint256)`.
 12192 |     |             mstore(0x00, 0x24f91465)
 12193 |     |             mstore(0x20, 0x80)
 12194 |     |             mstore(0x40, p1)
 12195 |     |             mstore(0x60, 0xc0)
 12196 |     |             mstore(0x80, p3)
 12197 |     |             writeString(0xa0, p0)
 12198 |     |             writeString(0xe0, p2)
 12199 |     |         }
 12200 |     |         _sendLogPayload(0x1c, 0x104);
 12201 |     |         /// @solidity memory-safe-assembly
 12202 |     |         assembly {
 12203 |     |             mstore(0x00, m0)
 12204 |     |             mstore(0x20, m1)
 12205 |     |             mstore(0x40, m2)
 12206 |     |             mstore(0x60, m3)
 12207 |     |             mstore(0x80, m4)
 12208 |     |             mstore(0xa0, m5)
 12209 |     |             mstore(0xc0, m6)
 12210 |     |             mstore(0xe0, m7)
 12211 |     |             mstore(0x100, m8)
 12212 |     |         }
 12213 |     |     }
 12214 |     | 
 12215 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
 12216 |     |         bytes32 m0;
 12217 |     |         bytes32 m1;
 12218 |     |         bytes32 m2;
 12219 |     |         bytes32 m3;
 12220 |     |         bytes32 m4;
 12221 |     |         bytes32 m5;
 12222 |     |         bytes32 m6;
 12223 |     |         bytes32 m7;
 12224 |     |         bytes32 m8;
 12225 |     |         bytes32 m9;
 12226 |     |         bytes32 m10;
 12227 |     |         /// @solidity memory-safe-assembly
 12228 |     |         assembly {
 12229 |     |             function writeString(pos, w) {
 12230 |     |                 let length := 0
 12231 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12232 |     |                 mstore(pos, length)
 12233 |     |                 let shift := sub(256, shl(3, length))
 12234 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12235 |     |             }
 12236 |     |             m0 := mload(0x00)
 12237 |     |             m1 := mload(0x20)
 12238 |     |             m2 := mload(0x40)
 12239 |     |             m3 := mload(0x60)
 12240 |     |             m4 := mload(0x80)
 12241 |     |             m5 := mload(0xa0)
 12242 |     |             m6 := mload(0xc0)
 12243 |     |             m7 := mload(0xe0)
 12244 |     |             m8 := mload(0x100)
 12245 |     |             m9 := mload(0x120)
 12246 |     |             m10 := mload(0x140)
 12247 |     |             // Selector of `log(string,bool,string,string)`.
 12248 |     |             mstore(0x00, 0xa826caeb)
 12249 |     |             mstore(0x20, 0x80)
 12250 |     |             mstore(0x40, p1)
 12251 |     |             mstore(0x60, 0xc0)
 12252 |     |             mstore(0x80, 0x100)
 12253 |     |             writeString(0xa0, p0)
 12254 |     |             writeString(0xe0, p2)
 12255 |     |             writeString(0x120, p3)
 12256 |     |         }
 12257 |     |         _sendLogPayload(0x1c, 0x144);
 12258 |     |         /// @solidity memory-safe-assembly
 12259 |     |         assembly {
 12260 |     |             mstore(0x00, m0)
 12261 |     |             mstore(0x20, m1)
 12262 |     |             mstore(0x40, m2)
 12263 |     |             mstore(0x60, m3)
 12264 |     |             mstore(0x80, m4)
 12265 |     |             mstore(0xa0, m5)
 12266 |     |             mstore(0xc0, m6)
 12267 |     |             mstore(0xe0, m7)
 12268 |     |             mstore(0x100, m8)
 12269 |     |             mstore(0x120, m9)
 12270 |     |             mstore(0x140, m10)
 12271 |     |         }
 12272 |     |     }
 12273 |     | 
 12274 |     |     function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {
 12275 |     |         bytes32 m0;
 12276 |     |         bytes32 m1;
 12277 |     |         bytes32 m2;
 12278 |     |         bytes32 m3;
 12279 |     |         bytes32 m4;
 12280 |     |         bytes32 m5;
 12281 |     |         bytes32 m6;
 12282 |     |         /// @solidity memory-safe-assembly
 12283 |     |         assembly {
 12284 |     |             function writeString(pos, w) {
 12285 |     |                 let length := 0
 12286 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12287 |     |                 mstore(pos, length)
 12288 |     |                 let shift := sub(256, shl(3, length))
 12289 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12290 |     |             }
 12291 |     |             m0 := mload(0x00)
 12292 |     |             m1 := mload(0x20)
 12293 |     |             m2 := mload(0x40)
 12294 |     |             m3 := mload(0x60)
 12295 |     |             m4 := mload(0x80)
 12296 |     |             m5 := mload(0xa0)
 12297 |     |             m6 := mload(0xc0)
 12298 |     |             // Selector of `log(string,uint256,address,address)`.
 12299 |     |             mstore(0x00, 0x5ea2b7ae)
 12300 |     |             mstore(0x20, 0x80)
 12301 |     |             mstore(0x40, p1)
 12302 |     |             mstore(0x60, p2)
 12303 |     |             mstore(0x80, p3)
 12304 |     |             writeString(0xa0, p0)
 12305 |     |         }
 12306 |     |         _sendLogPayload(0x1c, 0xc4);
 12307 |     |         /// @solidity memory-safe-assembly
 12308 |     |         assembly {
 12309 |     |             mstore(0x00, m0)
 12310 |     |             mstore(0x20, m1)
 12311 |     |             mstore(0x40, m2)
 12312 |     |             mstore(0x60, m3)
 12313 |     |             mstore(0x80, m4)
 12314 |     |             mstore(0xa0, m5)
 12315 |     |             mstore(0xc0, m6)
 12316 |     |         }
 12317 |     |     }
 12318 |     | 
 12319 |     |     function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {
 12320 |     |         bytes32 m0;
 12321 |     |         bytes32 m1;
 12322 |     |         bytes32 m2;
 12323 |     |         bytes32 m3;
 12324 |     |         bytes32 m4;
 12325 |     |         bytes32 m5;
 12326 |     |         bytes32 m6;
 12327 |     |         /// @solidity memory-safe-assembly
 12328 |     |         assembly {
 12329 |     |             function writeString(pos, w) {
 12330 |     |                 let length := 0
 12331 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12332 |     |                 mstore(pos, length)
 12333 |     |                 let shift := sub(256, shl(3, length))
 12334 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12335 |     |             }
 12336 |     |             m0 := mload(0x00)
 12337 |     |             m1 := mload(0x20)
 12338 |     |             m2 := mload(0x40)
 12339 |     |             m3 := mload(0x60)
 12340 |     |             m4 := mload(0x80)
 12341 |     |             m5 := mload(0xa0)
 12342 |     |             m6 := mload(0xc0)
 12343 |     |             // Selector of `log(string,uint256,address,bool)`.
 12344 |     |             mstore(0x00, 0x82112a42)
 12345 |     |             mstore(0x20, 0x80)
 12346 |     |             mstore(0x40, p1)
 12347 |     |             mstore(0x60, p2)
 12348 |     |             mstore(0x80, p3)
 12349 |     |             writeString(0xa0, p0)
 12350 |     |         }
 12351 |     |         _sendLogPayload(0x1c, 0xc4);
 12352 |     |         /// @solidity memory-safe-assembly
 12353 |     |         assembly {
 12354 |     |             mstore(0x00, m0)
 12355 |     |             mstore(0x20, m1)
 12356 |     |             mstore(0x40, m2)
 12357 |     |             mstore(0x60, m3)
 12358 |     |             mstore(0x80, m4)
 12359 |     |             mstore(0xa0, m5)
 12360 |     |             mstore(0xc0, m6)
 12361 |     |         }
 12362 |     |     }
 12363 |     | 
 12364 |     |     function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {
 12365 |     |         bytes32 m0;
 12366 |     |         bytes32 m1;
 12367 |     |         bytes32 m2;
 12368 |     |         bytes32 m3;
 12369 |     |         bytes32 m4;
 12370 |     |         bytes32 m5;
 12371 |     |         bytes32 m6;
 12372 |     |         /// @solidity memory-safe-assembly
 12373 |     |         assembly {
 12374 |     |             function writeString(pos, w) {
 12375 |     |                 let length := 0
 12376 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12377 |     |                 mstore(pos, length)
 12378 |     |                 let shift := sub(256, shl(3, length))
 12379 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12380 |     |             }
 12381 |     |             m0 := mload(0x00)
 12382 |     |             m1 := mload(0x20)
 12383 |     |             m2 := mload(0x40)
 12384 |     |             m3 := mload(0x60)
 12385 |     |             m4 := mload(0x80)
 12386 |     |             m5 := mload(0xa0)
 12387 |     |             m6 := mload(0xc0)
 12388 |     |             // Selector of `log(string,uint256,address,uint256)`.
 12389 |     |             mstore(0x00, 0x4f04fdc6)
 12390 |     |             mstore(0x20, 0x80)
 12391 |     |             mstore(0x40, p1)
 12392 |     |             mstore(0x60, p2)
 12393 |     |             mstore(0x80, p3)
 12394 |     |             writeString(0xa0, p0)
 12395 |     |         }
 12396 |     |         _sendLogPayload(0x1c, 0xc4);
 12397 |     |         /// @solidity memory-safe-assembly
 12398 |     |         assembly {
 12399 |     |             mstore(0x00, m0)
 12400 |     |             mstore(0x20, m1)
 12401 |     |             mstore(0x40, m2)
 12402 |     |             mstore(0x60, m3)
 12403 |     |             mstore(0x80, m4)
 12404 |     |             mstore(0xa0, m5)
 12405 |     |             mstore(0xc0, m6)
 12406 |     |         }
 12407 |     |     }
 12408 |     | 
 12409 |     |     function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {
 12410 |     |         bytes32 m0;
 12411 |     |         bytes32 m1;
 12412 |     |         bytes32 m2;
 12413 |     |         bytes32 m3;
 12414 |     |         bytes32 m4;
 12415 |     |         bytes32 m5;
 12416 |     |         bytes32 m6;
 12417 |     |         bytes32 m7;
 12418 |     |         bytes32 m8;
 12419 |     |         /// @solidity memory-safe-assembly
 12420 |     |         assembly {
 12421 |     |             function writeString(pos, w) {
 12422 |     |                 let length := 0
 12423 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12424 |     |                 mstore(pos, length)
 12425 |     |                 let shift := sub(256, shl(3, length))
 12426 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12427 |     |             }
 12428 |     |             m0 := mload(0x00)
 12429 |     |             m1 := mload(0x20)
 12430 |     |             m2 := mload(0x40)
 12431 |     |             m3 := mload(0x60)
 12432 |     |             m4 := mload(0x80)
 12433 |     |             m5 := mload(0xa0)
 12434 |     |             m6 := mload(0xc0)
 12435 |     |             m7 := mload(0xe0)
 12436 |     |             m8 := mload(0x100)
 12437 |     |             // Selector of `log(string,uint256,address,string)`.
 12438 |     |             mstore(0x00, 0x9ffb2f93)
 12439 |     |             mstore(0x20, 0x80)
 12440 |     |             mstore(0x40, p1)
 12441 |     |             mstore(0x60, p2)
 12442 |     |             mstore(0x80, 0xc0)
 12443 |     |             writeString(0xa0, p0)
 12444 |     |             writeString(0xe0, p3)
 12445 |     |         }
 12446 |     |         _sendLogPayload(0x1c, 0x104);
 12447 |     |         /// @solidity memory-safe-assembly
 12448 |     |         assembly {
 12449 |     |             mstore(0x00, m0)
 12450 |     |             mstore(0x20, m1)
 12451 |     |             mstore(0x40, m2)
 12452 |     |             mstore(0x60, m3)
 12453 |     |             mstore(0x80, m4)
 12454 |     |             mstore(0xa0, m5)
 12455 |     |             mstore(0xc0, m6)
 12456 |     |             mstore(0xe0, m7)
 12457 |     |             mstore(0x100, m8)
 12458 |     |         }
 12459 |     |     }
 12460 |     | 
 12461 |     |     function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {
 12462 |     |         bytes32 m0;
 12463 |     |         bytes32 m1;
 12464 |     |         bytes32 m2;
 12465 |     |         bytes32 m3;
 12466 |     |         bytes32 m4;
 12467 |     |         bytes32 m5;
 12468 |     |         bytes32 m6;
 12469 |     |         /// @solidity memory-safe-assembly
 12470 |     |         assembly {
 12471 |     |             function writeString(pos, w) {
 12472 |     |                 let length := 0
 12473 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12474 |     |                 mstore(pos, length)
 12475 |     |                 let shift := sub(256, shl(3, length))
 12476 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12477 |     |             }
 12478 |     |             m0 := mload(0x00)
 12479 |     |             m1 := mload(0x20)
 12480 |     |             m2 := mload(0x40)
 12481 |     |             m3 := mload(0x60)
 12482 |     |             m4 := mload(0x80)
 12483 |     |             m5 := mload(0xa0)
 12484 |     |             m6 := mload(0xc0)
 12485 |     |             // Selector of `log(string,uint256,bool,address)`.
 12486 |     |             mstore(0x00, 0xe0e95b98)
 12487 |     |             mstore(0x20, 0x80)
 12488 |     |             mstore(0x40, p1)
 12489 |     |             mstore(0x60, p2)
 12490 |     |             mstore(0x80, p3)
 12491 |     |             writeString(0xa0, p0)
 12492 |     |         }
 12493 |     |         _sendLogPayload(0x1c, 0xc4);
 12494 |     |         /// @solidity memory-safe-assembly
 12495 |     |         assembly {
 12496 |     |             mstore(0x00, m0)
 12497 |     |             mstore(0x20, m1)
 12498 |     |             mstore(0x40, m2)
 12499 |     |             mstore(0x60, m3)
 12500 |     |             mstore(0x80, m4)
 12501 |     |             mstore(0xa0, m5)
 12502 |     |             mstore(0xc0, m6)
 12503 |     |         }
 12504 |     |     }
 12505 |     | 
 12506 |     |     function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {
 12507 |     |         bytes32 m0;
 12508 |     |         bytes32 m1;
 12509 |     |         bytes32 m2;
 12510 |     |         bytes32 m3;
 12511 |     |         bytes32 m4;
 12512 |     |         bytes32 m5;
 12513 |     |         bytes32 m6;
 12514 |     |         /// @solidity memory-safe-assembly
 12515 |     |         assembly {
 12516 |     |             function writeString(pos, w) {
 12517 |     |                 let length := 0
 12518 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12519 |     |                 mstore(pos, length)
 12520 |     |                 let shift := sub(256, shl(3, length))
 12521 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12522 |     |             }
 12523 |     |             m0 := mload(0x00)
 12524 |     |             m1 := mload(0x20)
 12525 |     |             m2 := mload(0x40)
 12526 |     |             m3 := mload(0x60)
 12527 |     |             m4 := mload(0x80)
 12528 |     |             m5 := mload(0xa0)
 12529 |     |             m6 := mload(0xc0)
 12530 |     |             // Selector of `log(string,uint256,bool,bool)`.
 12531 |     |             mstore(0x00, 0x354c36d6)
 12532 |     |             mstore(0x20, 0x80)
 12533 |     |             mstore(0x40, p1)
 12534 |     |             mstore(0x60, p2)
 12535 |     |             mstore(0x80, p3)
 12536 |     |             writeString(0xa0, p0)
 12537 |     |         }
 12538 |     |         _sendLogPayload(0x1c, 0xc4);
 12539 |     |         /// @solidity memory-safe-assembly
 12540 |     |         assembly {
 12541 |     |             mstore(0x00, m0)
 12542 |     |             mstore(0x20, m1)
 12543 |     |             mstore(0x40, m2)
 12544 |     |             mstore(0x60, m3)
 12545 |     |             mstore(0x80, m4)
 12546 |     |             mstore(0xa0, m5)
 12547 |     |             mstore(0xc0, m6)
 12548 |     |         }
 12549 |     |     }
 12550 |     | 
 12551 |     |     function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {
 12552 |     |         bytes32 m0;
 12553 |     |         bytes32 m1;
 12554 |     |         bytes32 m2;
 12555 |     |         bytes32 m3;
 12556 |     |         bytes32 m4;
 12557 |     |         bytes32 m5;
 12558 |     |         bytes32 m6;
 12559 |     |         /// @solidity memory-safe-assembly
 12560 |     |         assembly {
 12561 |     |             function writeString(pos, w) {
 12562 |     |                 let length := 0
 12563 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12564 |     |                 mstore(pos, length)
 12565 |     |                 let shift := sub(256, shl(3, length))
 12566 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12567 |     |             }
 12568 |     |             m0 := mload(0x00)
 12569 |     |             m1 := mload(0x20)
 12570 |     |             m2 := mload(0x40)
 12571 |     |             m3 := mload(0x60)
 12572 |     |             m4 := mload(0x80)
 12573 |     |             m5 := mload(0xa0)
 12574 |     |             m6 := mload(0xc0)
 12575 |     |             // Selector of `log(string,uint256,bool,uint256)`.
 12576 |     |             mstore(0x00, 0xe41b6f6f)
 12577 |     |             mstore(0x20, 0x80)
 12578 |     |             mstore(0x40, p1)
 12579 |     |             mstore(0x60, p2)
 12580 |     |             mstore(0x80, p3)
 12581 |     |             writeString(0xa0, p0)
 12582 |     |         }
 12583 |     |         _sendLogPayload(0x1c, 0xc4);
 12584 |     |         /// @solidity memory-safe-assembly
 12585 |     |         assembly {
 12586 |     |             mstore(0x00, m0)
 12587 |     |             mstore(0x20, m1)
 12588 |     |             mstore(0x40, m2)
 12589 |     |             mstore(0x60, m3)
 12590 |     |             mstore(0x80, m4)
 12591 |     |             mstore(0xa0, m5)
 12592 |     |             mstore(0xc0, m6)
 12593 |     |         }
 12594 |     |     }
 12595 |     | 
 12596 |     |     function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
 12597 |     |         bytes32 m0;
 12598 |     |         bytes32 m1;
 12599 |     |         bytes32 m2;
 12600 |     |         bytes32 m3;
 12601 |     |         bytes32 m4;
 12602 |     |         bytes32 m5;
 12603 |     |         bytes32 m6;
 12604 |     |         bytes32 m7;
 12605 |     |         bytes32 m8;
 12606 |     |         /// @solidity memory-safe-assembly
 12607 |     |         assembly {
 12608 |     |             function writeString(pos, w) {
 12609 |     |                 let length := 0
 12610 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12611 |     |                 mstore(pos, length)
 12612 |     |                 let shift := sub(256, shl(3, length))
 12613 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12614 |     |             }
 12615 |     |             m0 := mload(0x00)
 12616 |     |             m1 := mload(0x20)
 12617 |     |             m2 := mload(0x40)
 12618 |     |             m3 := mload(0x60)
 12619 |     |             m4 := mload(0x80)
 12620 |     |             m5 := mload(0xa0)
 12621 |     |             m6 := mload(0xc0)
 12622 |     |             m7 := mload(0xe0)
 12623 |     |             m8 := mload(0x100)
 12624 |     |             // Selector of `log(string,uint256,bool,string)`.
 12625 |     |             mstore(0x00, 0xabf73a98)
 12626 |     |             mstore(0x20, 0x80)
 12627 |     |             mstore(0x40, p1)
 12628 |     |             mstore(0x60, p2)
 12629 |     |             mstore(0x80, 0xc0)
 12630 |     |             writeString(0xa0, p0)
 12631 |     |             writeString(0xe0, p3)
 12632 |     |         }
 12633 |     |         _sendLogPayload(0x1c, 0x104);
 12634 |     |         /// @solidity memory-safe-assembly
 12635 |     |         assembly {
 12636 |     |             mstore(0x00, m0)
 12637 |     |             mstore(0x20, m1)
 12638 |     |             mstore(0x40, m2)
 12639 |     |             mstore(0x60, m3)
 12640 |     |             mstore(0x80, m4)
 12641 |     |             mstore(0xa0, m5)
 12642 |     |             mstore(0xc0, m6)
 12643 |     |             mstore(0xe0, m7)
 12644 |     |             mstore(0x100, m8)
 12645 |     |         }
 12646 |     |     }
 12647 |     | 
 12648 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {
 12649 |     |         bytes32 m0;
 12650 |     |         bytes32 m1;
 12651 |     |         bytes32 m2;
 12652 |     |         bytes32 m3;
 12653 |     |         bytes32 m4;
 12654 |     |         bytes32 m5;
 12655 |     |         bytes32 m6;
 12656 |     |         /// @solidity memory-safe-assembly
 12657 |     |         assembly {
 12658 |     |             function writeString(pos, w) {
 12659 |     |                 let length := 0
 12660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12661 |     |                 mstore(pos, length)
 12662 |     |                 let shift := sub(256, shl(3, length))
 12663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12664 |     |             }
 12665 |     |             m0 := mload(0x00)
 12666 |     |             m1 := mload(0x20)
 12667 |     |             m2 := mload(0x40)
 12668 |     |             m3 := mload(0x60)
 12669 |     |             m4 := mload(0x80)
 12670 |     |             m5 := mload(0xa0)
 12671 |     |             m6 := mload(0xc0)
 12672 |     |             // Selector of `log(string,uint256,uint256,address)`.
 12673 |     |             mstore(0x00, 0xe21de278)
 12674 |     |             mstore(0x20, 0x80)
 12675 |     |             mstore(0x40, p1)
 12676 |     |             mstore(0x60, p2)
 12677 |     |             mstore(0x80, p3)
 12678 |     |             writeString(0xa0, p0)
 12679 |     |         }
 12680 |     |         _sendLogPayload(0x1c, 0xc4);
 12681 |     |         /// @solidity memory-safe-assembly
 12682 |     |         assembly {
 12683 |     |             mstore(0x00, m0)
 12684 |     |             mstore(0x20, m1)
 12685 |     |             mstore(0x40, m2)
 12686 |     |             mstore(0x60, m3)
 12687 |     |             mstore(0x80, m4)
 12688 |     |             mstore(0xa0, m5)
 12689 |     |             mstore(0xc0, m6)
 12690 |     |         }
 12691 |     |     }
 12692 |     | 
 12693 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {
 12694 |     |         bytes32 m0;
 12695 |     |         bytes32 m1;
 12696 |     |         bytes32 m2;
 12697 |     |         bytes32 m3;
 12698 |     |         bytes32 m4;
 12699 |     |         bytes32 m5;
 12700 |     |         bytes32 m6;
 12701 |     |         /// @solidity memory-safe-assembly
 12702 |     |         assembly {
 12703 |     |             function writeString(pos, w) {
 12704 |     |                 let length := 0
 12705 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12706 |     |                 mstore(pos, length)
 12707 |     |                 let shift := sub(256, shl(3, length))
 12708 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12709 |     |             }
 12710 |     |             m0 := mload(0x00)
 12711 |     |             m1 := mload(0x20)
 12712 |     |             m2 := mload(0x40)
 12713 |     |             m3 := mload(0x60)
 12714 |     |             m4 := mload(0x80)
 12715 |     |             m5 := mload(0xa0)
 12716 |     |             m6 := mload(0xc0)
 12717 |     |             // Selector of `log(string,uint256,uint256,bool)`.
 12718 |     |             mstore(0x00, 0x7626db92)
 12719 |     |             mstore(0x20, 0x80)
 12720 |     |             mstore(0x40, p1)
 12721 |     |             mstore(0x60, p2)
 12722 |     |             mstore(0x80, p3)
 12723 |     |             writeString(0xa0, p0)
 12724 |     |         }
 12725 |     |         _sendLogPayload(0x1c, 0xc4);
 12726 |     |         /// @solidity memory-safe-assembly
 12727 |     |         assembly {
 12728 |     |             mstore(0x00, m0)
 12729 |     |             mstore(0x20, m1)
 12730 |     |             mstore(0x40, m2)
 12731 |     |             mstore(0x60, m3)
 12732 |     |             mstore(0x80, m4)
 12733 |     |             mstore(0xa0, m5)
 12734 |     |             mstore(0xc0, m6)
 12735 |     |         }
 12736 |     |     }
 12737 |     | 
 12738 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 12739 |     |         bytes32 m0;
 12740 |     |         bytes32 m1;
 12741 |     |         bytes32 m2;
 12742 |     |         bytes32 m3;
 12743 |     |         bytes32 m4;
 12744 |     |         bytes32 m5;
 12745 |     |         bytes32 m6;
 12746 |     |         /// @solidity memory-safe-assembly
 12747 |     |         assembly {
 12748 |     |             function writeString(pos, w) {
 12749 |     |                 let length := 0
 12750 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12751 |     |                 mstore(pos, length)
 12752 |     |                 let shift := sub(256, shl(3, length))
 12753 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12754 |     |             }
 12755 |     |             m0 := mload(0x00)
 12756 |     |             m1 := mload(0x20)
 12757 |     |             m2 := mload(0x40)
 12758 |     |             m3 := mload(0x60)
 12759 |     |             m4 := mload(0x80)
 12760 |     |             m5 := mload(0xa0)
 12761 |     |             m6 := mload(0xc0)
 12762 |     |             // Selector of `log(string,uint256,uint256,uint256)`.
 12763 |     |             mstore(0x00, 0xa7a87853)
 12764 |     |             mstore(0x20, 0x80)
 12765 |     |             mstore(0x40, p1)
 12766 |     |             mstore(0x60, p2)
 12767 |     |             mstore(0x80, p3)
 12768 |     |             writeString(0xa0, p0)
 12769 |     |         }
 12770 |     |         _sendLogPayload(0x1c, 0xc4);
 12771 |     |         /// @solidity memory-safe-assembly
 12772 |     |         assembly {
 12773 |     |             mstore(0x00, m0)
 12774 |     |             mstore(0x20, m1)
 12775 |     |             mstore(0x40, m2)
 12776 |     |             mstore(0x60, m3)
 12777 |     |             mstore(0x80, m4)
 12778 |     |             mstore(0xa0, m5)
 12779 |     |             mstore(0xc0, m6)
 12780 |     |         }
 12781 |     |     }
 12782 |     | 
 12783 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
 12784 |     |         bytes32 m0;
 12785 |     |         bytes32 m1;
 12786 |     |         bytes32 m2;
 12787 |     |         bytes32 m3;
 12788 |     |         bytes32 m4;
 12789 |     |         bytes32 m5;
 12790 |     |         bytes32 m6;
 12791 |     |         bytes32 m7;
 12792 |     |         bytes32 m8;
 12793 |     |         /// @solidity memory-safe-assembly
 12794 |     |         assembly {
 12795 |     |             function writeString(pos, w) {
 12796 |     |                 let length := 0
 12797 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12798 |     |                 mstore(pos, length)
 12799 |     |                 let shift := sub(256, shl(3, length))
 12800 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12801 |     |             }
 12802 |     |             m0 := mload(0x00)
 12803 |     |             m1 := mload(0x20)
 12804 |     |             m2 := mload(0x40)
 12805 |     |             m3 := mload(0x60)
 12806 |     |             m4 := mload(0x80)
 12807 |     |             m5 := mload(0xa0)
 12808 |     |             m6 := mload(0xc0)
 12809 |     |             m7 := mload(0xe0)
 12810 |     |             m8 := mload(0x100)
 12811 |     |             // Selector of `log(string,uint256,uint256,string)`.
 12812 |     |             mstore(0x00, 0x854b3496)
 12813 |     |             mstore(0x20, 0x80)
 12814 |     |             mstore(0x40, p1)
 12815 |     |             mstore(0x60, p2)
 12816 |     |             mstore(0x80, 0xc0)
 12817 |     |             writeString(0xa0, p0)
 12818 |     |             writeString(0xe0, p3)
 12819 |     |         }
 12820 |     |         _sendLogPayload(0x1c, 0x104);
 12821 |     |         /// @solidity memory-safe-assembly
 12822 |     |         assembly {
 12823 |     |             mstore(0x00, m0)
 12824 |     |             mstore(0x20, m1)
 12825 |     |             mstore(0x40, m2)
 12826 |     |             mstore(0x60, m3)
 12827 |     |             mstore(0x80, m4)
 12828 |     |             mstore(0xa0, m5)
 12829 |     |             mstore(0xc0, m6)
 12830 |     |             mstore(0xe0, m7)
 12831 |     |             mstore(0x100, m8)
 12832 |     |         }
 12833 |     |     }
 12834 |     | 
 12835 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {
 12836 |     |         bytes32 m0;
 12837 |     |         bytes32 m1;
 12838 |     |         bytes32 m2;
 12839 |     |         bytes32 m3;
 12840 |     |         bytes32 m4;
 12841 |     |         bytes32 m5;
 12842 |     |         bytes32 m6;
 12843 |     |         bytes32 m7;
 12844 |     |         bytes32 m8;
 12845 |     |         /// @solidity memory-safe-assembly
 12846 |     |         assembly {
 12847 |     |             function writeString(pos, w) {
 12848 |     |                 let length := 0
 12849 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12850 |     |                 mstore(pos, length)
 12851 |     |                 let shift := sub(256, shl(3, length))
 12852 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12853 |     |             }
 12854 |     |             m0 := mload(0x00)
 12855 |     |             m1 := mload(0x20)
 12856 |     |             m2 := mload(0x40)
 12857 |     |             m3 := mload(0x60)
 12858 |     |             m4 := mload(0x80)
 12859 |     |             m5 := mload(0xa0)
 12860 |     |             m6 := mload(0xc0)
 12861 |     |             m7 := mload(0xe0)
 12862 |     |             m8 := mload(0x100)
 12863 |     |             // Selector of `log(string,uint256,string,address)`.
 12864 |     |             mstore(0x00, 0x7c4632a4)
 12865 |     |             mstore(0x20, 0x80)
 12866 |     |             mstore(0x40, p1)
 12867 |     |             mstore(0x60, 0xc0)
 12868 |     |             mstore(0x80, p3)
 12869 |     |             writeString(0xa0, p0)
 12870 |     |             writeString(0xe0, p2)
 12871 |     |         }
 12872 |     |         _sendLogPayload(0x1c, 0x104);
 12873 |     |         /// @solidity memory-safe-assembly
 12874 |     |         assembly {
 12875 |     |             mstore(0x00, m0)
 12876 |     |             mstore(0x20, m1)
 12877 |     |             mstore(0x40, m2)
 12878 |     |             mstore(0x60, m3)
 12879 |     |             mstore(0x80, m4)
 12880 |     |             mstore(0xa0, m5)
 12881 |     |             mstore(0xc0, m6)
 12882 |     |             mstore(0xe0, m7)
 12883 |     |             mstore(0x100, m8)
 12884 |     |         }
 12885 |     |     }
 12886 |     | 
 12887 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
 12888 |     |         bytes32 m0;
 12889 |     |         bytes32 m1;
 12890 |     |         bytes32 m2;
 12891 |     |         bytes32 m3;
 12892 |     |         bytes32 m4;
 12893 |     |         bytes32 m5;
 12894 |     |         bytes32 m6;
 12895 |     |         bytes32 m7;
 12896 |     |         bytes32 m8;
 12897 |     |         /// @solidity memory-safe-assembly
 12898 |     |         assembly {
 12899 |     |             function writeString(pos, w) {
 12900 |     |                 let length := 0
 12901 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12902 |     |                 mstore(pos, length)
 12903 |     |                 let shift := sub(256, shl(3, length))
 12904 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12905 |     |             }
 12906 |     |             m0 := mload(0x00)
 12907 |     |             m1 := mload(0x20)
 12908 |     |             m2 := mload(0x40)
 12909 |     |             m3 := mload(0x60)
 12910 |     |             m4 := mload(0x80)
 12911 |     |             m5 := mload(0xa0)
 12912 |     |             m6 := mload(0xc0)
 12913 |     |             m7 := mload(0xe0)
 12914 |     |             m8 := mload(0x100)
 12915 |     |             // Selector of `log(string,uint256,string,bool)`.
 12916 |     |             mstore(0x00, 0x7d24491d)
 12917 |     |             mstore(0x20, 0x80)
 12918 |     |             mstore(0x40, p1)
 12919 |     |             mstore(0x60, 0xc0)
 12920 |     |             mstore(0x80, p3)
 12921 |     |             writeString(0xa0, p0)
 12922 |     |             writeString(0xe0, p2)
 12923 |     |         }
 12924 |     |         _sendLogPayload(0x1c, 0x104);
 12925 |     |         /// @solidity memory-safe-assembly
 12926 |     |         assembly {
 12927 |     |             mstore(0x00, m0)
 12928 |     |             mstore(0x20, m1)
 12929 |     |             mstore(0x40, m2)
 12930 |     |             mstore(0x60, m3)
 12931 |     |             mstore(0x80, m4)
 12932 |     |             mstore(0xa0, m5)
 12933 |     |             mstore(0xc0, m6)
 12934 |     |             mstore(0xe0, m7)
 12935 |     |             mstore(0x100, m8)
 12936 |     |         }
 12937 |     |     }
 12938 |     | 
 12939 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
 12940 |     |         bytes32 m0;
 12941 |     |         bytes32 m1;
 12942 |     |         bytes32 m2;
 12943 |     |         bytes32 m3;
 12944 |     |         bytes32 m4;
 12945 |     |         bytes32 m5;
 12946 |     |         bytes32 m6;
 12947 |     |         bytes32 m7;
 12948 |     |         bytes32 m8;
 12949 |     |         /// @solidity memory-safe-assembly
 12950 |     |         assembly {
 12951 |     |             function writeString(pos, w) {
 12952 |     |                 let length := 0
 12953 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12954 |     |                 mstore(pos, length)
 12955 |     |                 let shift := sub(256, shl(3, length))
 12956 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12957 |     |             }
 12958 |     |             m0 := mload(0x00)
 12959 |     |             m1 := mload(0x20)
 12960 |     |             m2 := mload(0x40)
 12961 |     |             m3 := mload(0x60)
 12962 |     |             m4 := mload(0x80)
 12963 |     |             m5 := mload(0xa0)
 12964 |     |             m6 := mload(0xc0)
 12965 |     |             m7 := mload(0xe0)
 12966 |     |             m8 := mload(0x100)
 12967 |     |             // Selector of `log(string,uint256,string,uint256)`.
 12968 |     |             mstore(0x00, 0xc67ea9d1)
 12969 |     |             mstore(0x20, 0x80)
 12970 |     |             mstore(0x40, p1)
 12971 |     |             mstore(0x60, 0xc0)
 12972 |     |             mstore(0x80, p3)
 12973 |     |             writeString(0xa0, p0)
 12974 |     |             writeString(0xe0, p2)
 12975 |     |         }
 12976 |     |         _sendLogPayload(0x1c, 0x104);
 12977 |     |         /// @solidity memory-safe-assembly
 12978 |     |         assembly {
 12979 |     |             mstore(0x00, m0)
 12980 |     |             mstore(0x20, m1)
 12981 |     |             mstore(0x40, m2)
 12982 |     |             mstore(0x60, m3)
 12983 |     |             mstore(0x80, m4)
 12984 |     |             mstore(0xa0, m5)
 12985 |     |             mstore(0xc0, m6)
 12986 |     |             mstore(0xe0, m7)
 12987 |     |             mstore(0x100, m8)
 12988 |     |         }
 12989 |     |     }
 12990 |     | 
 12991 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
 12992 |     |         bytes32 m0;
 12993 |     |         bytes32 m1;
 12994 |     |         bytes32 m2;
 12995 |     |         bytes32 m3;
 12996 |     |         bytes32 m4;
 12997 |     |         bytes32 m5;
 12998 |     |         bytes32 m6;
 12999 |     |         bytes32 m7;
 13000 |     |         bytes32 m8;
 13001 |     |         bytes32 m9;
 13002 |     |         bytes32 m10;
 13003 |     |         /// @solidity memory-safe-assembly
 13004 |     |         assembly {
 13005 |     |             function writeString(pos, w) {
 13006 |     |                 let length := 0
 13007 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13008 |     |                 mstore(pos, length)
 13009 |     |                 let shift := sub(256, shl(3, length))
 13010 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13011 |     |             }
 13012 |     |             m0 := mload(0x00)
 13013 |     |             m1 := mload(0x20)
 13014 |     |             m2 := mload(0x40)
 13015 |     |             m3 := mload(0x60)
 13016 |     |             m4 := mload(0x80)
 13017 |     |             m5 := mload(0xa0)
 13018 |     |             m6 := mload(0xc0)
 13019 |     |             m7 := mload(0xe0)
 13020 |     |             m8 := mload(0x100)
 13021 |     |             m9 := mload(0x120)
 13022 |     |             m10 := mload(0x140)
 13023 |     |             // Selector of `log(string,uint256,string,string)`.
 13024 |     |             mstore(0x00, 0x5ab84e1f)
 13025 |     |             mstore(0x20, 0x80)
 13026 |     |             mstore(0x40, p1)
 13027 |     |             mstore(0x60, 0xc0)
 13028 |     |             mstore(0x80, 0x100)
 13029 |     |             writeString(0xa0, p0)
 13030 |     |             writeString(0xe0, p2)
 13031 |     |             writeString(0x120, p3)
 13032 |     |         }
 13033 |     |         _sendLogPayload(0x1c, 0x144);
 13034 |     |         /// @solidity memory-safe-assembly
 13035 |     |         assembly {
 13036 |     |             mstore(0x00, m0)
 13037 |     |             mstore(0x20, m1)
 13038 |     |             mstore(0x40, m2)
 13039 |     |             mstore(0x60, m3)
 13040 |     |             mstore(0x80, m4)
 13041 |     |             mstore(0xa0, m5)
 13042 |     |             mstore(0xc0, m6)
 13043 |     |             mstore(0xe0, m7)
 13044 |     |             mstore(0x100, m8)
 13045 |     |             mstore(0x120, m9)
 13046 |     |             mstore(0x140, m10)
 13047 |     |         }
 13048 |     |     }
 13049 |     | 
 13050 |     |     function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {
 13051 |     |         bytes32 m0;
 13052 |     |         bytes32 m1;
 13053 |     |         bytes32 m2;
 13054 |     |         bytes32 m3;
 13055 |     |         bytes32 m4;
 13056 |     |         bytes32 m5;
 13057 |     |         bytes32 m6;
 13058 |     |         bytes32 m7;
 13059 |     |         bytes32 m8;
 13060 |     |         /// @solidity memory-safe-assembly
 13061 |     |         assembly {
 13062 |     |             function writeString(pos, w) {
 13063 |     |                 let length := 0
 13064 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13065 |     |                 mstore(pos, length)
 13066 |     |                 let shift := sub(256, shl(3, length))
 13067 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13068 |     |             }
 13069 |     |             m0 := mload(0x00)
 13070 |     |             m1 := mload(0x20)
 13071 |     |             m2 := mload(0x40)
 13072 |     |             m3 := mload(0x60)
 13073 |     |             m4 := mload(0x80)
 13074 |     |             m5 := mload(0xa0)
 13075 |     |             m6 := mload(0xc0)
 13076 |     |             m7 := mload(0xe0)
 13077 |     |             m8 := mload(0x100)
 13078 |     |             // Selector of `log(string,string,address,address)`.
 13079 |     |             mstore(0x00, 0x439c7bef)
 13080 |     |             mstore(0x20, 0x80)
 13081 |     |             mstore(0x40, 0xc0)
 13082 |     |             mstore(0x60, p2)
 13083 |     |             mstore(0x80, p3)
 13084 |     |             writeString(0xa0, p0)
 13085 |     |             writeString(0xe0, p1)
 13086 |     |         }
 13087 |     |         _sendLogPayload(0x1c, 0x104);
 13088 |     |         /// @solidity memory-safe-assembly
 13089 |     |         assembly {
 13090 |     |             mstore(0x00, m0)
 13091 |     |             mstore(0x20, m1)
 13092 |     |             mstore(0x40, m2)
 13093 |     |             mstore(0x60, m3)
 13094 |     |             mstore(0x80, m4)
 13095 |     |             mstore(0xa0, m5)
 13096 |     |             mstore(0xc0, m6)
 13097 |     |             mstore(0xe0, m7)
 13098 |     |             mstore(0x100, m8)
 13099 |     |         }
 13100 |     |     }
 13101 |     | 
 13102 |     |     function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {
 13103 |     |         bytes32 m0;
 13104 |     |         bytes32 m1;
 13105 |     |         bytes32 m2;
 13106 |     |         bytes32 m3;
 13107 |     |         bytes32 m4;
 13108 |     |         bytes32 m5;
 13109 |     |         bytes32 m6;
 13110 |     |         bytes32 m7;
 13111 |     |         bytes32 m8;
 13112 |     |         /// @solidity memory-safe-assembly
 13113 |     |         assembly {
 13114 |     |             function writeString(pos, w) {
 13115 |     |                 let length := 0
 13116 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13117 |     |                 mstore(pos, length)
 13118 |     |                 let shift := sub(256, shl(3, length))
 13119 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13120 |     |             }
 13121 |     |             m0 := mload(0x00)
 13122 |     |             m1 := mload(0x20)
 13123 |     |             m2 := mload(0x40)
 13124 |     |             m3 := mload(0x60)
 13125 |     |             m4 := mload(0x80)
 13126 |     |             m5 := mload(0xa0)
 13127 |     |             m6 := mload(0xc0)
 13128 |     |             m7 := mload(0xe0)
 13129 |     |             m8 := mload(0x100)
 13130 |     |             // Selector of `log(string,string,address,bool)`.
 13131 |     |             mstore(0x00, 0x5ccd4e37)
 13132 |     |             mstore(0x20, 0x80)
 13133 |     |             mstore(0x40, 0xc0)
 13134 |     |             mstore(0x60, p2)
 13135 |     |             mstore(0x80, p3)
 13136 |     |             writeString(0xa0, p0)
 13137 |     |             writeString(0xe0, p1)
 13138 |     |         }
 13139 |     |         _sendLogPayload(0x1c, 0x104);
 13140 |     |         /// @solidity memory-safe-assembly
 13141 |     |         assembly {
 13142 |     |             mstore(0x00, m0)
 13143 |     |             mstore(0x20, m1)
 13144 |     |             mstore(0x40, m2)
 13145 |     |             mstore(0x60, m3)
 13146 |     |             mstore(0x80, m4)
 13147 |     |             mstore(0xa0, m5)
 13148 |     |             mstore(0xc0, m6)
 13149 |     |             mstore(0xe0, m7)
 13150 |     |             mstore(0x100, m8)
 13151 |     |         }
 13152 |     |     }
 13153 |     | 
 13154 |     |     function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 13155 |     |         bytes32 m0;
 13156 |     |         bytes32 m1;
 13157 |     |         bytes32 m2;
 13158 |     |         bytes32 m3;
 13159 |     |         bytes32 m4;
 13160 |     |         bytes32 m5;
 13161 |     |         bytes32 m6;
 13162 |     |         bytes32 m7;
 13163 |     |         bytes32 m8;
 13164 |     |         /// @solidity memory-safe-assembly
 13165 |     |         assembly {
 13166 |     |             function writeString(pos, w) {
 13167 |     |                 let length := 0
 13168 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13169 |     |                 mstore(pos, length)
 13170 |     |                 let shift := sub(256, shl(3, length))
 13171 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13172 |     |             }
 13173 |     |             m0 := mload(0x00)
 13174 |     |             m1 := mload(0x20)
 13175 |     |             m2 := mload(0x40)
 13176 |     |             m3 := mload(0x60)
 13177 |     |             m4 := mload(0x80)
 13178 |     |             m5 := mload(0xa0)
 13179 |     |             m6 := mload(0xc0)
 13180 |     |             m7 := mload(0xe0)
 13181 |     |             m8 := mload(0x100)
 13182 |     |             // Selector of `log(string,string,address,uint256)`.
 13183 |     |             mstore(0x00, 0x7cc3c607)
 13184 |     |             mstore(0x20, 0x80)
 13185 |     |             mstore(0x40, 0xc0)
 13186 |     |             mstore(0x60, p2)
 13187 |     |             mstore(0x80, p3)
 13188 |     |             writeString(0xa0, p0)
 13189 |     |             writeString(0xe0, p1)
 13190 |     |         }
 13191 |     |         _sendLogPayload(0x1c, 0x104);
 13192 |     |         /// @solidity memory-safe-assembly
 13193 |     |         assembly {
 13194 |     |             mstore(0x00, m0)
 13195 |     |             mstore(0x20, m1)
 13196 |     |             mstore(0x40, m2)
 13197 |     |             mstore(0x60, m3)
 13198 |     |             mstore(0x80, m4)
 13199 |     |             mstore(0xa0, m5)
 13200 |     |             mstore(0xc0, m6)
 13201 |     |             mstore(0xe0, m7)
 13202 |     |             mstore(0x100, m8)
 13203 |     |         }
 13204 |     |     }
 13205 |     | 
 13206 |     |     function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 13207 |     |         bytes32 m0;
 13208 |     |         bytes32 m1;
 13209 |     |         bytes32 m2;
 13210 |     |         bytes32 m3;
 13211 |     |         bytes32 m4;
 13212 |     |         bytes32 m5;
 13213 |     |         bytes32 m6;
 13214 |     |         bytes32 m7;
 13215 |     |         bytes32 m8;
 13216 |     |         bytes32 m9;
 13217 |     |         bytes32 m10;
 13218 |     |         /// @solidity memory-safe-assembly
 13219 |     |         assembly {
 13220 |     |             function writeString(pos, w) {
 13221 |     |                 let length := 0
 13222 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13223 |     |                 mstore(pos, length)
 13224 |     |                 let shift := sub(256, shl(3, length))
 13225 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13226 |     |             }
 13227 |     |             m0 := mload(0x00)
 13228 |     |             m1 := mload(0x20)
 13229 |     |             m2 := mload(0x40)
 13230 |     |             m3 := mload(0x60)
 13231 |     |             m4 := mload(0x80)
 13232 |     |             m5 := mload(0xa0)
 13233 |     |             m6 := mload(0xc0)
 13234 |     |             m7 := mload(0xe0)
 13235 |     |             m8 := mload(0x100)
 13236 |     |             m9 := mload(0x120)
 13237 |     |             m10 := mload(0x140)
 13238 |     |             // Selector of `log(string,string,address,string)`.
 13239 |     |             mstore(0x00, 0xeb1bff80)
 13240 |     |             mstore(0x20, 0x80)
 13241 |     |             mstore(0x40, 0xc0)
 13242 |     |             mstore(0x60, p2)
 13243 |     |             mstore(0x80, 0x100)
 13244 |     |             writeString(0xa0, p0)
 13245 |     |             writeString(0xe0, p1)
 13246 |     |             writeString(0x120, p3)
 13247 |     |         }
 13248 |     |         _sendLogPayload(0x1c, 0x144);
 13249 |     |         /// @solidity memory-safe-assembly
 13250 |     |         assembly {
 13251 |     |             mstore(0x00, m0)
 13252 |     |             mstore(0x20, m1)
 13253 |     |             mstore(0x40, m2)
 13254 |     |             mstore(0x60, m3)
 13255 |     |             mstore(0x80, m4)
 13256 |     |             mstore(0xa0, m5)
 13257 |     |             mstore(0xc0, m6)
 13258 |     |             mstore(0xe0, m7)
 13259 |     |             mstore(0x100, m8)
 13260 |     |             mstore(0x120, m9)
 13261 |     |             mstore(0x140, m10)
 13262 |     |         }
 13263 |     |     }
 13264 |     | 
 13265 |     |     function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {
 13266 |     |         bytes32 m0;
 13267 |     |         bytes32 m1;
 13268 |     |         bytes32 m2;
 13269 |     |         bytes32 m3;
 13270 |     |         bytes32 m4;
 13271 |     |         bytes32 m5;
 13272 |     |         bytes32 m6;
 13273 |     |         bytes32 m7;
 13274 |     |         bytes32 m8;
 13275 |     |         /// @solidity memory-safe-assembly
 13276 |     |         assembly {
 13277 |     |             function writeString(pos, w) {
 13278 |     |                 let length := 0
 13279 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13280 |     |                 mstore(pos, length)
 13281 |     |                 let shift := sub(256, shl(3, length))
 13282 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13283 |     |             }
 13284 |     |             m0 := mload(0x00)
 13285 |     |             m1 := mload(0x20)
 13286 |     |             m2 := mload(0x40)
 13287 |     |             m3 := mload(0x60)
 13288 |     |             m4 := mload(0x80)
 13289 |     |             m5 := mload(0xa0)
 13290 |     |             m6 := mload(0xc0)
 13291 |     |             m7 := mload(0xe0)
 13292 |     |             m8 := mload(0x100)
 13293 |     |             // Selector of `log(string,string,bool,address)`.
 13294 |     |             mstore(0x00, 0xc371c7db)
 13295 |     |             mstore(0x20, 0x80)
 13296 |     |             mstore(0x40, 0xc0)
 13297 |     |             mstore(0x60, p2)
 13298 |     |             mstore(0x80, p3)
 13299 |     |             writeString(0xa0, p0)
 13300 |     |             writeString(0xe0, p1)
 13301 |     |         }
 13302 |     |         _sendLogPayload(0x1c, 0x104);
 13303 |     |         /// @solidity memory-safe-assembly
 13304 |     |         assembly {
 13305 |     |             mstore(0x00, m0)
 13306 |     |             mstore(0x20, m1)
 13307 |     |             mstore(0x40, m2)
 13308 |     |             mstore(0x60, m3)
 13309 |     |             mstore(0x80, m4)
 13310 |     |             mstore(0xa0, m5)
 13311 |     |             mstore(0xc0, m6)
 13312 |     |             mstore(0xe0, m7)
 13313 |     |             mstore(0x100, m8)
 13314 |     |         }
 13315 |     |     }
 13316 |     | 
 13317 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {
 13318 |     |         bytes32 m0;
 13319 |     |         bytes32 m1;
 13320 |     |         bytes32 m2;
 13321 |     |         bytes32 m3;
 13322 |     |         bytes32 m4;
 13323 |     |         bytes32 m5;
 13324 |     |         bytes32 m6;
 13325 |     |         bytes32 m7;
 13326 |     |         bytes32 m8;
 13327 |     |         /// @solidity memory-safe-assembly
 13328 |     |         assembly {
 13329 |     |             function writeString(pos, w) {
 13330 |     |                 let length := 0
 13331 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13332 |     |                 mstore(pos, length)
 13333 |     |                 let shift := sub(256, shl(3, length))
 13334 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13335 |     |             }
 13336 |     |             m0 := mload(0x00)
 13337 |     |             m1 := mload(0x20)
 13338 |     |             m2 := mload(0x40)
 13339 |     |             m3 := mload(0x60)
 13340 |     |             m4 := mload(0x80)
 13341 |     |             m5 := mload(0xa0)
 13342 |     |             m6 := mload(0xc0)
 13343 |     |             m7 := mload(0xe0)
 13344 |     |             m8 := mload(0x100)
 13345 |     |             // Selector of `log(string,string,bool,bool)`.
 13346 |     |             mstore(0x00, 0x40785869)
 13347 |     |             mstore(0x20, 0x80)
 13348 |     |             mstore(0x40, 0xc0)
 13349 |     |             mstore(0x60, p2)
 13350 |     |             mstore(0x80, p3)
 13351 |     |             writeString(0xa0, p0)
 13352 |     |             writeString(0xe0, p1)
 13353 |     |         }
 13354 |     |         _sendLogPayload(0x1c, 0x104);
 13355 |     |         /// @solidity memory-safe-assembly
 13356 |     |         assembly {
 13357 |     |             mstore(0x00, m0)
 13358 |     |             mstore(0x20, m1)
 13359 |     |             mstore(0x40, m2)
 13360 |     |             mstore(0x60, m3)
 13361 |     |             mstore(0x80, m4)
 13362 |     |             mstore(0xa0, m5)
 13363 |     |             mstore(0xc0, m6)
 13364 |     |             mstore(0xe0, m7)
 13365 |     |             mstore(0x100, m8)
 13366 |     |         }
 13367 |     |     }
 13368 |     | 
 13369 |     |     function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 13370 |     |         bytes32 m0;
 13371 |     |         bytes32 m1;
 13372 |     |         bytes32 m2;
 13373 |     |         bytes32 m3;
 13374 |     |         bytes32 m4;
 13375 |     |         bytes32 m5;
 13376 |     |         bytes32 m6;
 13377 |     |         bytes32 m7;
 13378 |     |         bytes32 m8;
 13379 |     |         /// @solidity memory-safe-assembly
 13380 |     |         assembly {
 13381 |     |             function writeString(pos, w) {
 13382 |     |                 let length := 0
 13383 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13384 |     |                 mstore(pos, length)
 13385 |     |                 let shift := sub(256, shl(3, length))
 13386 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13387 |     |             }
 13388 |     |             m0 := mload(0x00)
 13389 |     |             m1 := mload(0x20)
 13390 |     |             m2 := mload(0x40)
 13391 |     |             m3 := mload(0x60)
 13392 |     |             m4 := mload(0x80)
 13393 |     |             m5 := mload(0xa0)
 13394 |     |             m6 := mload(0xc0)
 13395 |     |             m7 := mload(0xe0)
 13396 |     |             m8 := mload(0x100)
 13397 |     |             // Selector of `log(string,string,bool,uint256)`.
 13398 |     |             mstore(0x00, 0xd6aefad2)
 13399 |     |             mstore(0x20, 0x80)
 13400 |     |             mstore(0x40, 0xc0)
 13401 |     |             mstore(0x60, p2)
 13402 |     |             mstore(0x80, p3)
 13403 |     |             writeString(0xa0, p0)
 13404 |     |             writeString(0xe0, p1)
 13405 |     |         }
 13406 |     |         _sendLogPayload(0x1c, 0x104);
 13407 |     |         /// @solidity memory-safe-assembly
 13408 |     |         assembly {
 13409 |     |             mstore(0x00, m0)
 13410 |     |             mstore(0x20, m1)
 13411 |     |             mstore(0x40, m2)
 13412 |     |             mstore(0x60, m3)
 13413 |     |             mstore(0x80, m4)
 13414 |     |             mstore(0xa0, m5)
 13415 |     |             mstore(0xc0, m6)
 13416 |     |             mstore(0xe0, m7)
 13417 |     |             mstore(0x100, m8)
 13418 |     |         }
 13419 |     |     }
 13420 |     | 
 13421 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 13422 |     |         bytes32 m0;
 13423 |     |         bytes32 m1;
 13424 |     |         bytes32 m2;
 13425 |     |         bytes32 m3;
 13426 |     |         bytes32 m4;
 13427 |     |         bytes32 m5;
 13428 |     |         bytes32 m6;
 13429 |     |         bytes32 m7;
 13430 |     |         bytes32 m8;
 13431 |     |         bytes32 m9;
 13432 |     |         bytes32 m10;
 13433 |     |         /// @solidity memory-safe-assembly
 13434 |     |         assembly {
 13435 |     |             function writeString(pos, w) {
 13436 |     |                 let length := 0
 13437 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13438 |     |                 mstore(pos, length)
 13439 |     |                 let shift := sub(256, shl(3, length))
 13440 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13441 |     |             }
 13442 |     |             m0 := mload(0x00)
 13443 |     |             m1 := mload(0x20)
 13444 |     |             m2 := mload(0x40)
 13445 |     |             m3 := mload(0x60)
 13446 |     |             m4 := mload(0x80)
 13447 |     |             m5 := mload(0xa0)
 13448 |     |             m6 := mload(0xc0)
 13449 |     |             m7 := mload(0xe0)
 13450 |     |             m8 := mload(0x100)
 13451 |     |             m9 := mload(0x120)
 13452 |     |             m10 := mload(0x140)
 13453 |     |             // Selector of `log(string,string,bool,string)`.
 13454 |     |             mstore(0x00, 0x5e84b0ea)
 13455 |     |             mstore(0x20, 0x80)
 13456 |     |             mstore(0x40, 0xc0)
 13457 |     |             mstore(0x60, p2)
 13458 |     |             mstore(0x80, 0x100)
 13459 |     |             writeString(0xa0, p0)
 13460 |     |             writeString(0xe0, p1)
 13461 |     |             writeString(0x120, p3)
 13462 |     |         }
 13463 |     |         _sendLogPayload(0x1c, 0x144);
 13464 |     |         /// @solidity memory-safe-assembly
 13465 |     |         assembly {
 13466 |     |             mstore(0x00, m0)
 13467 |     |             mstore(0x20, m1)
 13468 |     |             mstore(0x40, m2)
 13469 |     |             mstore(0x60, m3)
 13470 |     |             mstore(0x80, m4)
 13471 |     |             mstore(0xa0, m5)
 13472 |     |             mstore(0xc0, m6)
 13473 |     |             mstore(0xe0, m7)
 13474 |     |             mstore(0x100, m8)
 13475 |     |             mstore(0x120, m9)
 13476 |     |             mstore(0x140, m10)
 13477 |     |         }
 13478 |     |     }
 13479 |     | 
 13480 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 13481 |     |         bytes32 m0;
 13482 |     |         bytes32 m1;
 13483 |     |         bytes32 m2;
 13484 |     |         bytes32 m3;
 13485 |     |         bytes32 m4;
 13486 |     |         bytes32 m5;
 13487 |     |         bytes32 m6;
 13488 |     |         bytes32 m7;
 13489 |     |         bytes32 m8;
 13490 |     |         /// @solidity memory-safe-assembly
 13491 |     |         assembly {
 13492 |     |             function writeString(pos, w) {
 13493 |     |                 let length := 0
 13494 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13495 |     |                 mstore(pos, length)
 13496 |     |                 let shift := sub(256, shl(3, length))
 13497 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13498 |     |             }
 13499 |     |             m0 := mload(0x00)
 13500 |     |             m1 := mload(0x20)
 13501 |     |             m2 := mload(0x40)
 13502 |     |             m3 := mload(0x60)
 13503 |     |             m4 := mload(0x80)
 13504 |     |             m5 := mload(0xa0)
 13505 |     |             m6 := mload(0xc0)
 13506 |     |             m7 := mload(0xe0)
 13507 |     |             m8 := mload(0x100)
 13508 |     |             // Selector of `log(string,string,uint256,address)`.
 13509 |     |             mstore(0x00, 0x1023f7b2)
 13510 |     |             mstore(0x20, 0x80)
 13511 |     |             mstore(0x40, 0xc0)
 13512 |     |             mstore(0x60, p2)
 13513 |     |             mstore(0x80, p3)
 13514 |     |             writeString(0xa0, p0)
 13515 |     |             writeString(0xe0, p1)
 13516 |     |         }
 13517 |     |         _sendLogPayload(0x1c, 0x104);
 13518 |     |         /// @solidity memory-safe-assembly
 13519 |     |         assembly {
 13520 |     |             mstore(0x00, m0)
 13521 |     |             mstore(0x20, m1)
 13522 |     |             mstore(0x40, m2)
 13523 |     |             mstore(0x60, m3)
 13524 |     |             mstore(0x80, m4)
 13525 |     |             mstore(0xa0, m5)
 13526 |     |             mstore(0xc0, m6)
 13527 |     |             mstore(0xe0, m7)
 13528 |     |             mstore(0x100, m8)
 13529 |     |         }
 13530 |     |     }
 13531 |     | 
 13532 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 13533 |     |         bytes32 m0;
 13534 |     |         bytes32 m1;
 13535 |     |         bytes32 m2;
 13536 |     |         bytes32 m3;
 13537 |     |         bytes32 m4;
 13538 |     |         bytes32 m5;
 13539 |     |         bytes32 m6;
 13540 |     |         bytes32 m7;
 13541 |     |         bytes32 m8;
 13542 |     |         /// @solidity memory-safe-assembly
 13543 |     |         assembly {
 13544 |     |             function writeString(pos, w) {
 13545 |     |                 let length := 0
 13546 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13547 |     |                 mstore(pos, length)
 13548 |     |                 let shift := sub(256, shl(3, length))
 13549 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13550 |     |             }
 13551 |     |             m0 := mload(0x00)
 13552 |     |             m1 := mload(0x20)
 13553 |     |             m2 := mload(0x40)
 13554 |     |             m3 := mload(0x60)
 13555 |     |             m4 := mload(0x80)
 13556 |     |             m5 := mload(0xa0)
 13557 |     |             m6 := mload(0xc0)
 13558 |     |             m7 := mload(0xe0)
 13559 |     |             m8 := mload(0x100)
 13560 |     |             // Selector of `log(string,string,uint256,bool)`.
 13561 |     |             mstore(0x00, 0xc3a8a654)
 13562 |     |             mstore(0x20, 0x80)
 13563 |     |             mstore(0x40, 0xc0)
 13564 |     |             mstore(0x60, p2)
 13565 |     |             mstore(0x80, p3)
 13566 |     |             writeString(0xa0, p0)
 13567 |     |             writeString(0xe0, p1)
 13568 |     |         }
 13569 |     |         _sendLogPayload(0x1c, 0x104);
 13570 |     |         /// @solidity memory-safe-assembly
 13571 |     |         assembly {
 13572 |     |             mstore(0x00, m0)
 13573 |     |             mstore(0x20, m1)
 13574 |     |             mstore(0x40, m2)
 13575 |     |             mstore(0x60, m3)
 13576 |     |             mstore(0x80, m4)
 13577 |     |             mstore(0xa0, m5)
 13578 |     |             mstore(0xc0, m6)
 13579 |     |             mstore(0xe0, m7)
 13580 |     |             mstore(0x100, m8)
 13581 |     |         }
 13582 |     |     }
 13583 |     | 
 13584 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 13585 |     |         bytes32 m0;
 13586 |     |         bytes32 m1;
 13587 |     |         bytes32 m2;
 13588 |     |         bytes32 m3;
 13589 |     |         bytes32 m4;
 13590 |     |         bytes32 m5;
 13591 |     |         bytes32 m6;
 13592 |     |         bytes32 m7;
 13593 |     |         bytes32 m8;
 13594 |     |         /// @solidity memory-safe-assembly
 13595 |     |         assembly {
 13596 |     |             function writeString(pos, w) {
 13597 |     |                 let length := 0
 13598 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13599 |     |                 mstore(pos, length)
 13600 |     |                 let shift := sub(256, shl(3, length))
 13601 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13602 |     |             }
 13603 |     |             m0 := mload(0x00)
 13604 |     |             m1 := mload(0x20)
 13605 |     |             m2 := mload(0x40)
 13606 |     |             m3 := mload(0x60)
 13607 |     |             m4 := mload(0x80)
 13608 |     |             m5 := mload(0xa0)
 13609 |     |             m6 := mload(0xc0)
 13610 |     |             m7 := mload(0xe0)
 13611 |     |             m8 := mload(0x100)
 13612 |     |             // Selector of `log(string,string,uint256,uint256)`.
 13613 |     |             mstore(0x00, 0xf45d7d2c)
 13614 |     |             mstore(0x20, 0x80)
 13615 |     |             mstore(0x40, 0xc0)
 13616 |     |             mstore(0x60, p2)
 13617 |     |             mstore(0x80, p3)
 13618 |     |             writeString(0xa0, p0)
 13619 |     |             writeString(0xe0, p1)
 13620 |     |         }
 13621 |     |         _sendLogPayload(0x1c, 0x104);
 13622 |     |         /// @solidity memory-safe-assembly
 13623 |     |         assembly {
 13624 |     |             mstore(0x00, m0)
 13625 |     |             mstore(0x20, m1)
 13626 |     |             mstore(0x40, m2)
 13627 |     |             mstore(0x60, m3)
 13628 |     |             mstore(0x80, m4)
 13629 |     |             mstore(0xa0, m5)
 13630 |     |             mstore(0xc0, m6)
 13631 |     |             mstore(0xe0, m7)
 13632 |     |             mstore(0x100, m8)
 13633 |     |         }
 13634 |     |     }
 13635 |     | 
 13636 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 13637 |     |         bytes32 m0;
 13638 |     |         bytes32 m1;
 13639 |     |         bytes32 m2;
 13640 |     |         bytes32 m3;
 13641 |     |         bytes32 m4;
 13642 |     |         bytes32 m5;
 13643 |     |         bytes32 m6;
 13644 |     |         bytes32 m7;
 13645 |     |         bytes32 m8;
 13646 |     |         bytes32 m9;
 13647 |     |         bytes32 m10;
 13648 |     |         /// @solidity memory-safe-assembly
 13649 |     |         assembly {
 13650 |     |             function writeString(pos, w) {
 13651 |     |                 let length := 0
 13652 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13653 |     |                 mstore(pos, length)
 13654 |     |                 let shift := sub(256, shl(3, length))
 13655 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13656 |     |             }
 13657 |     |             m0 := mload(0x00)
 13658 |     |             m1 := mload(0x20)
 13659 |     |             m2 := mload(0x40)
 13660 |     |             m3 := mload(0x60)
 13661 |     |             m4 := mload(0x80)
 13662 |     |             m5 := mload(0xa0)
 13663 |     |             m6 := mload(0xc0)
 13664 |     |             m7 := mload(0xe0)
 13665 |     |             m8 := mload(0x100)
 13666 |     |             m9 := mload(0x120)
 13667 |     |             m10 := mload(0x140)
 13668 |     |             // Selector of `log(string,string,uint256,string)`.
 13669 |     |             mstore(0x00, 0x5d1a971a)
 13670 |     |             mstore(0x20, 0x80)
 13671 |     |             mstore(0x40, 0xc0)
 13672 |     |             mstore(0x60, p2)
 13673 |     |             mstore(0x80, 0x100)
 13674 |     |             writeString(0xa0, p0)
 13675 |     |             writeString(0xe0, p1)
 13676 |     |             writeString(0x120, p3)
 13677 |     |         }
 13678 |     |         _sendLogPayload(0x1c, 0x144);
 13679 |     |         /// @solidity memory-safe-assembly
 13680 |     |         assembly {
 13681 |     |             mstore(0x00, m0)
 13682 |     |             mstore(0x20, m1)
 13683 |     |             mstore(0x40, m2)
 13684 |     |             mstore(0x60, m3)
 13685 |     |             mstore(0x80, m4)
 13686 |     |             mstore(0xa0, m5)
 13687 |     |             mstore(0xc0, m6)
 13688 |     |             mstore(0xe0, m7)
 13689 |     |             mstore(0x100, m8)
 13690 |     |             mstore(0x120, m9)
 13691 |     |             mstore(0x140, m10)
 13692 |     |         }
 13693 |     |     }
 13694 |     | 
 13695 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 13696 |     |         bytes32 m0;
 13697 |     |         bytes32 m1;
 13698 |     |         bytes32 m2;
 13699 |     |         bytes32 m3;
 13700 |     |         bytes32 m4;
 13701 |     |         bytes32 m5;
 13702 |     |         bytes32 m6;
 13703 |     |         bytes32 m7;
 13704 |     |         bytes32 m8;
 13705 |     |         bytes32 m9;
 13706 |     |         bytes32 m10;
 13707 |     |         /// @solidity memory-safe-assembly
 13708 |     |         assembly {
 13709 |     |             function writeString(pos, w) {
 13710 |     |                 let length := 0
 13711 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13712 |     |                 mstore(pos, length)
 13713 |     |                 let shift := sub(256, shl(3, length))
 13714 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13715 |     |             }
 13716 |     |             m0 := mload(0x00)
 13717 |     |             m1 := mload(0x20)
 13718 |     |             m2 := mload(0x40)
 13719 |     |             m3 := mload(0x60)
 13720 |     |             m4 := mload(0x80)
 13721 |     |             m5 := mload(0xa0)
 13722 |     |             m6 := mload(0xc0)
 13723 |     |             m7 := mload(0xe0)
 13724 |     |             m8 := mload(0x100)
 13725 |     |             m9 := mload(0x120)
 13726 |     |             m10 := mload(0x140)
 13727 |     |             // Selector of `log(string,string,string,address)`.
 13728 |     |             mstore(0x00, 0x6d572f44)
 13729 |     |             mstore(0x20, 0x80)
 13730 |     |             mstore(0x40, 0xc0)
 13731 |     |             mstore(0x60, 0x100)
 13732 |     |             mstore(0x80, p3)
 13733 |     |             writeString(0xa0, p0)
 13734 |     |             writeString(0xe0, p1)
 13735 |     |             writeString(0x120, p2)
 13736 |     |         }
 13737 |     |         _sendLogPayload(0x1c, 0x144);
 13738 |     |         /// @solidity memory-safe-assembly
 13739 |     |         assembly {
 13740 |     |             mstore(0x00, m0)
 13741 |     |             mstore(0x20, m1)
 13742 |     |             mstore(0x40, m2)
 13743 |     |             mstore(0x60, m3)
 13744 |     |             mstore(0x80, m4)
 13745 |     |             mstore(0xa0, m5)
 13746 |     |             mstore(0xc0, m6)
 13747 |     |             mstore(0xe0, m7)
 13748 |     |             mstore(0x100, m8)
 13749 |     |             mstore(0x120, m9)
 13750 |     |             mstore(0x140, m10)
 13751 |     |         }
 13752 |     |     }
 13753 |     | 
 13754 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 13755 |     |         bytes32 m0;
 13756 |     |         bytes32 m1;
 13757 |     |         bytes32 m2;
 13758 |     |         bytes32 m3;
 13759 |     |         bytes32 m4;
 13760 |     |         bytes32 m5;
 13761 |     |         bytes32 m6;
 13762 |     |         bytes32 m7;
 13763 |     |         bytes32 m8;
 13764 |     |         bytes32 m9;
 13765 |     |         bytes32 m10;
 13766 |     |         /// @solidity memory-safe-assembly
 13767 |     |         assembly {
 13768 |     |             function writeString(pos, w) {
 13769 |     |                 let length := 0
 13770 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13771 |     |                 mstore(pos, length)
 13772 |     |                 let shift := sub(256, shl(3, length))
 13773 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13774 |     |             }
 13775 |     |             m0 := mload(0x00)
 13776 |     |             m1 := mload(0x20)
 13777 |     |             m2 := mload(0x40)
 13778 |     |             m3 := mload(0x60)
 13779 |     |             m4 := mload(0x80)
 13780 |     |             m5 := mload(0xa0)
 13781 |     |             m6 := mload(0xc0)
 13782 |     |             m7 := mload(0xe0)
 13783 |     |             m8 := mload(0x100)
 13784 |     |             m9 := mload(0x120)
 13785 |     |             m10 := mload(0x140)
 13786 |     |             // Selector of `log(string,string,string,bool)`.
 13787 |     |             mstore(0x00, 0x2c1754ed)
 13788 |     |             mstore(0x20, 0x80)
 13789 |     |             mstore(0x40, 0xc0)
 13790 |     |             mstore(0x60, 0x100)
 13791 |     |             mstore(0x80, p3)
 13792 |     |             writeString(0xa0, p0)
 13793 |     |             writeString(0xe0, p1)
 13794 |     |             writeString(0x120, p2)
 13795 |     |         }
 13796 |     |         _sendLogPayload(0x1c, 0x144);
 13797 |     |         /// @solidity memory-safe-assembly
 13798 |     |         assembly {
 13799 |     |             mstore(0x00, m0)
 13800 |     |             mstore(0x20, m1)
 13801 |     |             mstore(0x40, m2)
 13802 |     |             mstore(0x60, m3)
 13803 |     |             mstore(0x80, m4)
 13804 |     |             mstore(0xa0, m5)
 13805 |     |             mstore(0xc0, m6)
 13806 |     |             mstore(0xe0, m7)
 13807 |     |             mstore(0x100, m8)
 13808 |     |             mstore(0x120, m9)
 13809 |     |             mstore(0x140, m10)
 13810 |     |         }
 13811 |     |     }
 13812 |     | 
 13813 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 13814 |     |         bytes32 m0;
 13815 |     |         bytes32 m1;
 13816 |     |         bytes32 m2;
 13817 |     |         bytes32 m3;
 13818 |     |         bytes32 m4;
 13819 |     |         bytes32 m5;
 13820 |     |         bytes32 m6;
 13821 |     |         bytes32 m7;
 13822 |     |         bytes32 m8;
 13823 |     |         bytes32 m9;
 13824 |     |         bytes32 m10;
 13825 |     |         /// @solidity memory-safe-assembly
 13826 |     |         assembly {
 13827 |     |             function writeString(pos, w) {
 13828 |     |                 let length := 0
 13829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13830 |     |                 mstore(pos, length)
 13831 |     |                 let shift := sub(256, shl(3, length))
 13832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13833 |     |             }
 13834 |     |             m0 := mload(0x00)
 13835 |     |             m1 := mload(0x20)
 13836 |     |             m2 := mload(0x40)
 13837 |     |             m3 := mload(0x60)
 13838 |     |             m4 := mload(0x80)
 13839 |     |             m5 := mload(0xa0)
 13840 |     |             m6 := mload(0xc0)
 13841 |     |             m7 := mload(0xe0)
 13842 |     |             m8 := mload(0x100)
 13843 |     |             m9 := mload(0x120)
 13844 |     |             m10 := mload(0x140)
 13845 |     |             // Selector of `log(string,string,string,uint256)`.
 13846 |     |             mstore(0x00, 0x8eafb02b)
 13847 |     |             mstore(0x20, 0x80)
 13848 |     |             mstore(0x40, 0xc0)
 13849 |     |             mstore(0x60, 0x100)
 13850 |     |             mstore(0x80, p3)
 13851 |     |             writeString(0xa0, p0)
 13852 |     |             writeString(0xe0, p1)
 13853 |     |             writeString(0x120, p2)
 13854 |     |         }
 13855 |     |         _sendLogPayload(0x1c, 0x144);
 13856 |     |         /// @solidity memory-safe-assembly
 13857 |     |         assembly {
 13858 |     |             mstore(0x00, m0)
 13859 |     |             mstore(0x20, m1)
 13860 |     |             mstore(0x40, m2)
 13861 |     |             mstore(0x60, m3)
 13862 |     |             mstore(0x80, m4)
 13863 |     |             mstore(0xa0, m5)
 13864 |     |             mstore(0xc0, m6)
 13865 |     |             mstore(0xe0, m7)
 13866 |     |             mstore(0x100, m8)
 13867 |     |             mstore(0x120, m9)
 13868 |     |             mstore(0x140, m10)
 13869 |     |         }
 13870 |     |     }
 13871 |     | 
 13872 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 13873 |     |         bytes32 m0;
 13874 |     |         bytes32 m1;
 13875 |     |         bytes32 m2;
 13876 |     |         bytes32 m3;
 13877 |     |         bytes32 m4;
 13878 |     |         bytes32 m5;
 13879 |     |         bytes32 m6;
 13880 |     |         bytes32 m7;
 13881 |     |         bytes32 m8;
 13882 |     |         bytes32 m9;
 13883 |     |         bytes32 m10;
 13884 |     |         bytes32 m11;
 13885 |     |         bytes32 m12;
 13886 |     |         /// @solidity memory-safe-assembly
 13887 |     |         assembly {
 13888 |     |             function writeString(pos, w) {
 13889 |     |                 let length := 0
 13890 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13891 |     |                 mstore(pos, length)
 13892 |     |                 let shift := sub(256, shl(3, length))
 13893 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13894 |     |             }
 13895 |     |             m0 := mload(0x00)
 13896 |     |             m1 := mload(0x20)
 13897 |     |             m2 := mload(0x40)
 13898 |     |             m3 := mload(0x60)
 13899 |     |             m4 := mload(0x80)
 13900 |     |             m5 := mload(0xa0)
 13901 |     |             m6 := mload(0xc0)
 13902 |     |             m7 := mload(0xe0)
 13903 |     |             m8 := mload(0x100)
 13904 |     |             m9 := mload(0x120)
 13905 |     |             m10 := mload(0x140)
 13906 |     |             m11 := mload(0x160)
 13907 |     |             m12 := mload(0x180)
 13908 |     |             // Selector of `log(string,string,string,string)`.
 13909 |     |             mstore(0x00, 0xde68f20a)
 13910 |     |             mstore(0x20, 0x80)
 13911 |     |             mstore(0x40, 0xc0)
 13912 |     |             mstore(0x60, 0x100)
 13913 |     |             mstore(0x80, 0x140)
 13914 |     |             writeString(0xa0, p0)
 13915 |     |             writeString(0xe0, p1)
 13916 |     |             writeString(0x120, p2)
 13917 |     |             writeString(0x160, p3)
 13918 |     |         }
 13919 |     |         _sendLogPayload(0x1c, 0x184);
 13920 |     |         /// @solidity memory-safe-assembly
 13921 |     |         assembly {
 13922 |     |             mstore(0x00, m0)
 13923 |     |             mstore(0x20, m1)
 13924 |     |             mstore(0x40, m2)
 13925 |     |             mstore(0x60, m3)
 13926 |     |             mstore(0x80, m4)
 13927 |     |             mstore(0xa0, m5)
 13928 |     |             mstore(0xc0, m6)
 13929 |     |             mstore(0xe0, m7)
 13930 |     |             mstore(0x100, m8)
 13931 |     |             mstore(0x120, m9)
 13932 |     |             mstore(0x140, m10)
 13933 |     |             mstore(0x160, m11)
 13934 |     |             mstore(0x180, m12)
 13935 |     |         }
 13936 |     |     }
 13937 |     | }
 13938 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/FuzzBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Fuzzlib} from "./Fuzzlib.sol";
  5 |     | import {PlatformCrytic} from "./platform/PlatformCrytic.sol";
  6 |     | 
  7 |     | abstract contract FuzzBase {
  8 | *   |     Fuzzlib internal fl = new Fuzzlib();
  9 |     | 
 10 |     |     constructor() {
 11 | *   |         fl.setPlatform(address(new PlatformCrytic()));
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/FuzzLibString.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @notice Efficient library for creating string representations of integers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
   6 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
   7 |     | /// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 | *   | library FuzzLibString {
   9 |     |     bytes16 internal constant HEX_DIGITS = "0123456789abcdef";
  10 |     | 
  11 |     |     function toString(int256 value) internal pure returns (string memory str) {
  12 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
  13 |     |         str = toString(absValue);
  14 |     | 
  15 |     |         if (value < 0) {
  16 |     |             str = string(abi.encodePacked("-", str));
  17 |     |         }
  18 |     |     }
  19 |     | 
  20 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
  21 |     |         /// @solidity memory-safe-assembly
  22 | *   |         assembly {
  23 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
  24 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
  25 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
  26 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
  27 |     | 
  28 |     |             // Update the free memory pointer to avoid overriding our string.
  29 | *   |             mstore(0x40, newFreeMemoryPointer)
  30 |     | 
  31 |     |             // Assign str to the end of the zone of newly allocated memory.
  32 | *   |             str := sub(newFreeMemoryPointer, 32)
  33 |     | 
  34 |     |             // Clean the last word of memory it may not be overwritten.
  35 | *   |             mstore(str, 0)
  36 |     | 
  37 |     |             // Cache the end of the memory to calculate the length later.
  38 | *   |             let end := str
  39 |     | 
  40 |     |             // We write the string from rightmost digit to leftmost digit.
  41 |     |             // The following is essentially a do-while loop that also handles the zero case.
  42 |     |             // prettier-ignore
  43 | *   |             for { let temp := value } 1 {} {
  44 |     |                 // Move the pointer 1 byte to the left.
  45 | *   |                 str := sub(str, 1)
  46 |     | 
  47 |     |                 // Write the character to the pointer.
  48 |     |                 // The ASCII index of the '0' character is 48.
  49 | *   |                 mstore8(str, add(48, mod(temp, 10)))
  50 |     | 
  51 |     |                 // Keep dividing temp until zero.
  52 | *   |                 temp := div(temp, 10)
  53 |     | 
  54 |     |                  // prettier-ignore
  55 | *   |                 if iszero(temp) { break }
  56 |     |             }
  57 |     | 
  58 |     |             // Compute and cache the final total length of the string.
  59 | *   |             let length := sub(end, str)
  60 |     | 
  61 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
  62 | *   |             str := sub(str, 32)
  63 |     | 
  64 |     |             // Store the string's length at the start of memory allocated for our string.
  65 | *   |             mstore(str, length)
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     function toString(address value) internal pure returns (string memory str) {
  70 |     |         bytes memory s = new bytes(40);
  71 |     |         for (uint256 i = 0; i < 20; i++) {
  72 |     |             bytes1 b = bytes1(
  73 |     |                 uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))
  74 |     |             );
  75 |     |             bytes1 hi = bytes1(uint8(b) / 16);
  76 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  77 |     |             s[2 * i] = char(hi);
  78 |     |             s[2 * i + 1] = char(lo);
  79 |     |         }
  80 |     |         return string(s);
  81 |     |     }
  82 |     | 
  83 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
  84 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  85 |     |         else return bytes1(uint8(b) + 0x57);
  86 |     |     }
  87 |     | 
  88 |     |     // based on OZ's toHexString
  89 |     |     // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol
  90 |     |     function toHexString(bytes memory value)
  91 |     |         internal
  92 |     |         pure
  93 |     |         returns (string memory)
  94 |     |     {
  95 |     |         bytes memory buffer = new bytes(2 * value.length + 2);
  96 |     |         buffer[0] = "0";
  97 |     |         buffer[1] = "x";
  98 |     |         for (uint256 i = 0; i < value.length; i++) {
  99 |     |             uint8 valueByte = uint8(value[i]);
 100 |     |             buffer[2 * i + 2] = HEX_DIGITS[valueByte >> 4];
 101 |     |             buffer[2 * i + 3] = HEX_DIGITS[valueByte & 0xf];
 102 |     |         }
 103 |     |         return string(buffer);
 104 |     |     }
 105 |     | 
 106 |     |     // https://ethereum.stackexchange.com/a/83577
 107 |     |     function getRevertMsg(bytes memory returnData)
 108 |     |         internal
 109 |     |         pure
 110 |     |         returns (string memory)
 111 |     |     {
 112 |     |         // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code
 113 |     |         if (returnData.length == 4 + 32) {
 114 |     |             // Check that the data starts with the Panic signature
 115 |     |             bytes4 panicSignature = bytes4(keccak256(bytes("Panic(uint256)")));
 116 |     |             for (uint256 i = 0; i < 4; i++) {
 117 |     |                 if (returnData[i] != panicSignature[i])
 118 |     |                     return "Undefined signature";
 119 |     |             }
 120 |     | 
 121 |     |             uint256 panicCode;
 122 |     |             for (uint256 i = 4; i < 36; i++) {
 123 |     |                 panicCode = panicCode << 8;
 124 |     |                 panicCode |= uint8(returnData[i]);
 125 |     |             }
 126 |     | 
 127 |     |             // Now convert the panic code into its string representation
 128 |     |             if (panicCode == 17) {
 129 |     |                 return "Panic(17)";
 130 |     |             }
 131 |     | 
 132 |     |             // Add other panic codes as needed or return a generic "Unknown panic"
 133 |     |             return "Undefined panic code";
 134 |     |         }
 135 |     | 
 136 |     |         // If the returnData length is less than 68, then the transaction failed silently (without a revert message)
 137 |     |         if (returnData.length < 68) return "Transaction reverted silently";
 138 |     | 
 139 |     |         assembly {
 140 |     |             // Slice the sighash.
 141 |     |             returnData := add(returnData, 0x04)
 142 |     |         }
 143 |     |         return abi.decode(returnData, (string)); // All that remains is the revert string
 144 |     |     }
 145 |     | 
 146 |     |     function isRevertReasonEqual(bytes memory returnData, string memory reason)
 147 |     |         internal
 148 |     |         pure
 149 |     |         returns (bool)
 150 |     |     {
 151 |     |         return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==
 152 |     |             keccak256(abi.encodePacked(reason)));
 153 |     |     }
 154 |     | }
 155 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/Fuzzlib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {HelperBase} from "./helpers/HelperBase.sol";
  5 |     | import {HelperAssert} from "./helpers/HelperAssert.sol";
  6 |     | import {HelperClamp} from "./helpers/HelperClamp.sol";
  7 |     | import {HelperLog} from "./helpers/HelperLog.sol";
  8 |     | import {HelperMath} from "./helpers/HelperMath.sol";
  9 |     | import {HelperRandom} from "./helpers/HelperRandom.sol";
 10 |     | import {HelperCall} from "./helpers/HelperCall.sol";
 11 |     | 
 12 | *   | contract Fuzzlib is
 13 |     |     HelperBase,
 14 |     |     HelperAssert,
 15 |     |     HelperClamp,
 16 |     |     HelperLog,
 17 |     |     HelperMath,
 18 |     |     HelperRandom,
 19 |     |     HelperCall
 20 |     | {}
 21 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperAssert.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./HelperBase.sol";
   5 |     | 
   6 |     | import "../FuzzLibString.sol";
   7 |     | 
   8 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   9 |     | abstract contract HelperAssert is HelperBase {
  10 |     |     event AssertFail(string);
  11 |     |     event AssertEqFail(string);
  12 |     |     event AssertNeqFail(string);
  13 |     |     event AssertGteFail(string);
  14 |     |     event AssertGtFail(string);
  15 |     |     event AssertLteFail(string);
  16 |     |     event AssertLtFail(string);
  17 |     | 
  18 | *   |     function t(bool b, string memory reason) public {
  19 | *   |         if (!b) {
  20 | *   |             emit AssertFail(reason);
  21 | *   |             platform.assertFail();
  22 |     |         }
  23 |     |     }
  24 |     | 
  25 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  26 |     |     function eq(
  27 |     |         uint256 a,
  28 |     |         uint256 b,
  29 |     |         string memory reason
  30 |     |     ) public {
  31 |     |         if (a != b) {
  32 |     |             string memory aStr = FuzzLibString.toString(a);
  33 |     |             string memory bStr = FuzzLibString.toString(b);
  34 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  35 |     |             emit AssertEqFail(assertMsg);
  36 |     |             platform.assertFail();
  37 |     |         }
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of eq
  41 |     |     function eq(
  42 |     |         int256 a,
  43 |     |         int256 b,
  44 |     |         string memory reason
  45 |     |     ) public {
  46 |     |         if (a != b) {
  47 |     |             string memory aStr = FuzzLibString.toString(a);
  48 |     |             string memory bStr = FuzzLibString.toString(b);
  49 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  50 |     |            emit AssertEqFail(assertMsg);
  51 |     |             platform.assertFail();
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice bool version of eq
  56 |     |     function eq(
  57 |     |         bool a,
  58 |     |         bool b,
  59 |     |         string memory reason
  60 |     |     ) public {
  61 |     |         if (a != b) {
  62 |     |             string memory aStr = a ? "true" : "false";
  63 |     |             string memory bStr = b ? "true" : "false";
  64 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  65 |     |             emit AssertEqFail(assertMsg);
  66 |     |             platform.assertFail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice address version of eq
  71 |     |     function eq(
  72 |     |         address a,
  73 |     |         address b,
  74 |     |         string memory reason
  75 |     |     ) public {
  76 |     |         if (a != b) {
  77 |     |             string memory aStr = FuzzLibString.toString(a);
  78 |     |             string memory bStr = FuzzLibString.toString(b);
  79 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  80 |     |             emit AssertEqFail(assertMsg);
  81 |     |             platform.assertFail();
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice bytes4 version of eq
  86 |     |     function eq(
  87 |     |         bytes4 a,
  88 |     |         bytes4 b,
  89 |     |         string memory reason
  90 |     |     ) public {
  91 |     |         if (a != b) {
  92 |     |             bytes memory aBytes = abi.encodePacked(a);
  93 |     |             bytes memory bBytes = abi.encodePacked(b);
  94 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
  95 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
  96 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  97 |     |             emit AssertEqFail(assertMsg);
  98 |     |             platform.assertFail();
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
 103 |     |     function neq(
 104 |     |         uint256 a,
 105 |     |         uint256 b,
 106 |     |         string memory reason
 107 |     |     ) public {
 108 |     |         if (a == b) {
 109 |     |             string memory aStr = FuzzLibString.toString(a);
 110 |     |             string memory bStr = FuzzLibString.toString(b);
 111 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 112 |     |             emit AssertNeqFail(assertMsg);
 113 |     |             platform.assertFail();
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /// @notice int256 version of neq
 118 |     |     function neq(
 119 |     |         int256 a,
 120 |     |         int256 b,
 121 |     |         string memory reason
 122 |     |     ) public {
 123 |     |         if (a == b) {
 124 |     |             string memory aStr = FuzzLibString.toString(a);
 125 |     |             string memory bStr = FuzzLibString.toString(b);
 126 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 127 |     |             emit AssertNeqFail(assertMsg);
 128 |     |             platform.assertFail();
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
 133 |     |     function gte(
 134 |     |         uint256 a,
 135 |     |         uint256 b,
 136 |     |         string memory reason
 137 |     |     ) public {
 138 |     |         if (!(a >= b)) {
 139 |     |             string memory aStr = FuzzLibString.toString(a);
 140 |     |             string memory bStr = FuzzLibString.toString(b);
 141 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 142 |     |             emit AssertGteFail(assertMsg);
 143 |     |             platform.assertFail();
 144 |     |         }
 145 |     |     }
 146 |     | 
 147 |     |     /// @notice int256 version of gte
 148 |     |     function gte(
 149 |     |         int256 a,
 150 |     |         int256 b,
 151 |     |         string memory reason
 152 |     |     ) public {
 153 |     |         if (!(a >= b)) {
 154 |     |             string memory aStr = FuzzLibString.toString(a);
 155 |     |             string memory bStr = FuzzLibString.toString(b);
 156 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 157 |     |             emit AssertGteFail(assertMsg);
 158 |     |             platform.assertFail();
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 163 |     |     function gt(
 164 |     |         uint256 a,
 165 |     |         uint256 b,
 166 |     |         string memory reason
 167 |     |     ) public {
 168 |     |         if (!(a > b)) {
 169 |     |             string memory aStr = FuzzLibString.toString(a);
 170 |     |             string memory bStr = FuzzLibString.toString(b);
 171 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 172 |     |             emit AssertGtFail(assertMsg);
 173 |     |             platform.assertFail();
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     /// @notice int256 version of gt
 178 |     |     function gt(
 179 |     |         int256 a,
 180 |     |         int256 b,
 181 |     |         string memory reason
 182 |     |     ) public {
 183 |     |         if (!(a > b)) {
 184 |     |             string memory aStr = FuzzLibString.toString(a);
 185 |     |             string memory bStr = FuzzLibString.toString(b);
 186 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 187 |     |             emit AssertGtFail(assertMsg);
 188 |     |             platform.assertFail();
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 193 |     |     function lte(
 194 |     |         uint256 a,
 195 |     |         uint256 b,
 196 |     |         string memory reason
 197 |     |     ) public {
 198 |     |         if (!(a <= b)) {
 199 |     |             string memory aStr = FuzzLibString.toString(a);
 200 |     |             string memory bStr = FuzzLibString.toString(b);
 201 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 202 |     |             emit AssertLteFail(assertMsg);
 203 |     |             platform.assertFail();
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     /// @notice int256 version of lte
 208 |     |     function lte(
 209 |     |         int256 a,
 210 |     |         int256 b,
 211 |     |         string memory reason
 212 |     |     ) public {
 213 |     |         if (!(a <= b)) {
 214 |     |             string memory aStr = FuzzLibString.toString(a);
 215 |     |             string memory bStr = FuzzLibString.toString(b);
 216 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 217 |     |             emit AssertLteFail(assertMsg);
 218 |     |             platform.assertFail();
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 223 |     |     function lt(
 224 |     |         uint256 a,
 225 |     |         uint256 b,
 226 |     |         string memory reason
 227 |     |     ) public {
 228 |     |         if (!(a < b)) {
 229 |     |             string memory aStr = FuzzLibString.toString(a);
 230 |     |             string memory bStr = FuzzLibString.toString(b);
 231 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 232 |     |             emit AssertLtFail(assertMsg);
 233 |     |             platform.assertFail();
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     /// @notice int256 version of lt
 238 |     |     function lt(
 239 |     |         int256 a,
 240 |     |         int256 b,
 241 |     |         string memory reason
 242 |     |     ) public {
 243 |     |         if (!(a < b)) {
 244 |     |             string memory aStr = FuzzLibString.toString(a);
 245 |     |             string memory bStr = FuzzLibString.toString(b);
 246 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 247 |     |             emit AssertLtFail(assertMsg);
 248 |     |             platform.assertFail();
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     function assertRevertReasonNotEqual(
 253 |     |         bytes memory returnData,
 254 |     |         string memory reason
 255 |     |     ) public {
 256 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 257 |     |         t(!isEqual, reason);
 258 |     |     }
 259 |     | 
 260 |     |     function assertRevertReasonEqual(
 261 |     |         bytes memory returnData,
 262 |     |         string memory reason
 263 |     |     ) public {
 264 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 265 |     |         t(isEqual, reason);
 266 |     |     }
 267 |     | 
 268 |     |     function assertRevertReasonEqual(
 269 |     |         bytes memory returnData,
 270 |     |         string memory reason1,
 271 |     |         string memory reason2
 272 |     |     ) public {
 273 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 274 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2);
 275 |     |         string memory assertMsg = string(
 276 |     |             abi.encodePacked(reason1, " OR ", reason2)
 277 |     |         );
 278 |     |         t(isEqual, assertMsg);
 279 |     |     }
 280 |     | 
 281 |     |     function assertRevertReasonEqual(
 282 |     |         bytes memory returnData,
 283 |     |         string memory reason1,
 284 |     |         string memory reason2,
 285 |     |         string memory reason3
 286 |     |     ) public {
 287 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 288 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 289 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3);
 290 |     |         string memory assertMsg = string(
 291 |     |             abi.encodePacked(reason1, " OR ", reason2, " OR ", reason3)
 292 |     |         );
 293 |     |         t(isEqual, assertMsg);
 294 |     |     }
 295 |     | 
 296 |     |     function assertRevertReasonEqual(
 297 |     |         bytes memory returnData,
 298 |     |         string memory reason1,
 299 |     |         string memory reason2,
 300 |     |         string memory reason3,
 301 |     |         string memory reason4
 302 |     |     ) public {
 303 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 304 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 305 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3) ||
 306 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason4);
 307 |     |         string memory assertMsg = string(
 308 |     |             abi.encodePacked(
 309 |     |                 reason1,
 310 |     |                 " OR ",
 311 |     |                 reason2,
 312 |     |                 " OR ",
 313 |     |                 reason3,
 314 |     |                 " OR ",
 315 |     |                 reason4
 316 |     |             )
 317 |     |         );
 318 |     |         t(isEqual, assertMsg);
 319 |     |     }
 320 |     | 
 321 |     |     function errAllow(
 322 |     |         bytes4 errorSelector,
 323 |     |         bytes4[] memory allowedErrors,
 324 |     |         string memory message
 325 |     |     ) public {
 326 |     |         bool allowed = false;
 327 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 328 |     |             if (errorSelector == allowedErrors[i]) {
 329 |     |                 allowed = true;
 330 |     |                 break;
 331 |     |             }
 332 |     |         }
 333 |     |         t(allowed, message);
 334 |     |     }
 335 |     | 
 336 |     |     function errsAllow(
 337 |     |         bytes4 errorSelector,
 338 |     |         bytes4[] memory allowedErrors,
 339 |     |         string[] memory messages
 340 |     |     ) public {
 341 |     |         bool allowed = false;
 342 |     |         uint256 passIndex = 0;
 343 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 344 |     |             if (errorSelector == allowedErrors[i]) {
 345 |     |                 allowed = true;
 346 |     |                 passIndex = i;
 347 |     |                 break;
 348 |     |             }
 349 |     |         }
 350 |     |         t(allowed, messages[passIndex]);
 351 |     |     }
 352 |     | 
 353 |     |     function createAssertFailMessage(string memory aStr, string memory bStr, string memory operator, string memory reason)internal pure returns (string memory) {
 354 |     |         return string(abi.encodePacked("Invalid: ", aStr, operator, bStr, ", reason: ", reason));
 355 |     |     }
 356 |     | 
 357 |     | }
 358 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {IPlatform} from "../platform/IPlatform.sol";
  5 |     | 
  6 |     | contract HelperBase {
  7 |     |     IPlatform public platform;
  8 |     | 
  9 | *   |     function setPlatform(address _platform) public {
 10 | *   |         platform = IPlatform(_platform);
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperCall {
  5 |     |     // Private temporary vm to remain unopinionated from naming clashes
  6 |     |     IPrank constant private tempvm = IPrank(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
  7 |     | 
  8 |     |     function doFunctionCall(address target, bytes memory callData)
  9 |     |         public
 10 |     |         payable
 11 |     |         returns (bool success, bytes memory returnData)
 12 |     |     {
 13 |     |         tempvm.prank(msg.sender);
 14 |     |         (success, returnData) = target.call{value: msg.value}(callData);
 15 |     |     }
 16 |     | 
 17 |     |     function doFunctionCall(address target, bytes memory callData, address actor)
 18 |     |         public
 19 |     |         payable
 20 |     |         returns (bool success, bytes memory returnData)
 21 |     |     {
 22 |     |         tempvm.prank(actor);
 23 |     |         (success, returnData) = target.call{value: msg.value}(callData);
 24 |     |     }
 25 |     | 
 26 |     |     function doFunctionStaticCall(address target, bytes memory callData)
 27 |     |         public
 28 |     |         view
 29 |     |         returns (bool success, bytes memory returnData)
 30 |     |     {
 31 |     |         (success, returnData) = target.staticcall(callData);
 32 |     |     }
 33 |     | }
 34 |     | 
 35 |     | interface IPrank {
 36 |     |     function prank(address actor) external;
 37 |     | }
 38 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperClamp.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../FuzzLibString.sol";
   5 |     | import "./HelperAssert.sol";
   6 |     | 
   7 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | abstract contract HelperClamp is HelperAssert {
   9 |     |     event Clamped(string);
  10 |     | 
  11 |     |     /*
  12 |     |      **************************************************************************
  13 |     |      * Clamp functions with logging enabled
  14 |     |      **************************************************************************
  15 |     |      */
  16 |     | 
  17 |     |     /// @notice Clamps value to be between low and high, both inclusive
  18 | *   |     function clamp(
  19 |     |         uint256 value,
  20 |     |         uint256 low,
  21 |     |         uint256 high
  22 | *   |     ) public returns (uint256) {
  23 | *   |         return clamp(value, low, high, true);
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice int256 version of clamp
  27 |     |     function clamp(
  28 |     |         int256 value,
  29 |     |         int256 low,
  30 |     |         int256 high
  31 |     |     ) public returns (int256) {
  32 |     |         return clamp(value, low, high, true);
  33 |     |     }
  34 |     | 
  35 |     |     /// @notice clamps a to be less than b
  36 |     |     function clampLt(uint256 a, uint256 b) public returns (uint256) {
  37 |     |         return clampLt(a, b);
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of clampLt
  41 |     |     function clampLt(int256 a, int256 b) public returns (int256) {
  42 |     |         return clampLt(a, b, true);
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice clamps a to be less than or equal to b
  46 |     |     function clampLte(uint256 a, uint256 b) public returns (uint256) {
  47 |     |         return clampLte(a, b, true);
  48 |     |     }
  49 |     | 
  50 |     |     /// @notice int256 version of clampLte
  51 |     |     function clampLte(int256 a, int256 b) public returns (int256) {
  52 |     |         return clampLte(a, b, true);
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice clamps a to be greater than b
  56 |     |     function clampGt(uint256 a, uint256 b) public returns (uint256) {
  57 |     |         return clampGt(a, b, true);
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice int256 version of clampGt
  61 |     |     function clampGt(int256 a, int256 b) public returns (int256) {
  62 |     |         return clampGt(a, b, true);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice clamps a to be greater than or equal to b
  66 |     |     function clampGte(uint256 a, uint256 b) public returns (uint256) {
  67 |     |         return clampGte(a, b, true);
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice int256 version of clampGte
  71 |     |     function clampGte(int256 a, int256 b) public returns (int256) {
  72 |     |         return clampGte(a, b, true);
  73 |     |     }
  74 |     | 
  75 |     |     /*
  76 |     |      **************************************************************************
  77 |     |      * Clamp functions with optional logging
  78 |     |      **************************************************************************
  79 |     |      */
  80 |     | 
  81 |     |     /// @notice Clamps value to be between low and high, both inclusive
  82 | *   |     function clamp(
  83 |     |         uint256 value,
  84 |     |         uint256 low,
  85 |     |         uint256 high,
  86 |     |         bool enableLogs
  87 | *   |     ) public returns (uint256) {
  88 | *   |         if (value < low || value > high) {
  89 | *   |             uint256 ans = low + (value % (high - low + 1));
  90 | *   |             if (enableLogs) {
  91 | *   |                 string memory valueStr = FuzzLibString.toString(value);
  92 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
  93 | *   |                 bytes memory message = abi.encodePacked(
  94 |     |                     "Clamping value ",
  95 | *   |                     valueStr,
  96 |     |                     " to ",
  97 | *   |                     ansStr
  98 |     |                 );
  99 | *   |                 emit Clamped(string(message));
 100 |     |             }
 101 | *   |             return ans;
 102 |     |         }
 103 | *   |         return value;
 104 |     |     }
 105 |     | 
 106 |     |     /// @notice int256 version of clamp
 107 |     |     function clamp(
 108 |     |         int256 value,
 109 |     |         int256 low,
 110 |     |         int256 high,
 111 |     |         bool enableLogs
 112 |     |     ) public returns (int256) {
 113 |     |         if (value < low || value > high) {
 114 |     |             int256 range = high - low + 1;
 115 |     |             int256 clamped = (value - low) % (range);
 116 |     |             if (clamped < 0) clamped += range;
 117 |     |             int256 ans = low + clamped;
 118 |     |             if (enableLogs) {
 119 |     |                 string memory valueStr = FuzzLibString.toString(value);
 120 |     |                 string memory ansStr = FuzzLibString.toString(ans);
 121 |     |                 bytes memory message = abi.encodePacked(
 122 |     |                     "Clamping value ",
 123 |     |                     valueStr,
 124 |     |                     " to ",
 125 |     |                     ansStr
 126 |     |                 );
 127 |     |                 emit Clamped(string(message));
 128 |     |             }
 129 |     |             return ans;
 130 |     |         }
 131 |     |         return value;
 132 |     |     }
 133 |     | 
 134 |     |     /// @notice clamps a to be less than b
 135 |     |     function clampLt(
 136 |     |         uint256 a,
 137 |     |         uint256 b,
 138 |     |         bool enableLogs
 139 |     |     ) public returns (uint256) {
 140 |     |         if (!(a < b)) {
 141 |     |             neq(
 142 |     |                 b,
 143 |     |                 0,
 144 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 145 |     |             );
 146 |     |             uint256 value = a % b;
 147 |     |             if (enableLogs) {
 148 |     |                 string memory aStr = FuzzLibString.toString(a);
 149 |     |                 string memory valueStr = FuzzLibString.toString(value);
 150 |     |                 bytes memory message = abi.encodePacked(
 151 |     |                     "Clamping value ",
 152 |     |                     aStr,
 153 |     |                     " to ",
 154 |     |                     valueStr
 155 |     |                 );
 156 |     |                 emit Clamped(string(message));
 157 |     |             }
 158 |     |             return value;
 159 |     |         }
 160 |     |         return a;
 161 |     |     }
 162 |     | 
 163 |     |     /// @notice int256 version of clampLt
 164 |     |     function clampLt(
 165 |     |         int256 a,
 166 |     |         int256 b,
 167 |     |         bool enableLogs
 168 |     |     ) public returns (int256) {
 169 |     |         if (!(a < b)) {
 170 |     |             int256 value = b - 1;
 171 |     |             if (enableLogs) {
 172 |     |                 string memory aStr = FuzzLibString.toString(a);
 173 |     |                 string memory valueStr = FuzzLibString.toString(value);
 174 |     |                 bytes memory message = abi.encodePacked(
 175 |     |                     "Clamping value ",
 176 |     |                     aStr,
 177 |     |                     " to ",
 178 |     |                     valueStr
 179 |     |                 );
 180 |     |                 emit Clamped(string(message));
 181 |     |             }
 182 |     |             return value;
 183 |     |         }
 184 |     |         return a;
 185 |     |     }
 186 |     | 
 187 |     |     /// @notice clamps a to be less than or equal to b
 188 |     |     function clampLte(
 189 |     |         uint256 a,
 190 |     |         uint256 b,
 191 |     |         bool enableLogs
 192 |     |     ) public returns (uint256) {
 193 |     |         if (!(a <= b)) {
 194 |     |             uint256 value = a % (b + 1);
 195 |     |             if (enableLogs) {
 196 |     |                 string memory aStr = FuzzLibString.toString(a);
 197 |     |                 string memory valueStr = FuzzLibString.toString(value);
 198 |     |                 bytes memory message = abi.encodePacked(
 199 |     |                     "Clamping value ",
 200 |     |                     aStr,
 201 |     |                     " to ",
 202 |     |                     valueStr
 203 |     |                 );
 204 |     |                 emit Clamped(string(message));
 205 |     |             }
 206 |     |             return value;
 207 |     |         }
 208 |     |         return a;
 209 |     |     }
 210 |     | 
 211 |     |     /// @notice int256 version of clampLte
 212 |     |     function clampLte(
 213 |     |         int256 a,
 214 |     |         int256 b,
 215 |     |         bool enableLogs
 216 |     |     ) public returns (int256) {
 217 |     |         if (!(a <= b)) {
 218 |     |             int256 value = b;
 219 |     |             if (enableLogs) {
 220 |     |                 string memory aStr = FuzzLibString.toString(a);
 221 |     |                 string memory valueStr = FuzzLibString.toString(value);
 222 |     |                 bytes memory message = abi.encodePacked(
 223 |     |                     "Clamping value ",
 224 |     |                     aStr,
 225 |     |                     " to ",
 226 |     |                     valueStr
 227 |     |                 );
 228 |     |                 emit Clamped(string(message));
 229 |     |             }
 230 |     |             return value;
 231 |     |         }
 232 |     |         return a;
 233 |     |     }
 234 |     | 
 235 |     |     /// @notice clamps a to be greater than b
 236 |     |     function clampGt(
 237 |     |         uint256 a,
 238 |     |         uint256 b,
 239 |     |         bool enableLogs
 240 |     |     ) public returns (uint256) {
 241 |     |         if (!(a > b)) {
 242 |     |             neq(
 243 |     |                 b,
 244 |     |                 type(uint256).max,
 245 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 246 |     |             );
 247 |     |             uint256 value = b + 1;
 248 |     |             if (enableLogs) {
 249 |     |                 string memory aStr = FuzzLibString.toString(a);
 250 |     |                 string memory valueStr = FuzzLibString.toString(value);
 251 |     |                 bytes memory message = abi.encodePacked(
 252 |     |                     "Clamping value ",
 253 |     |                     aStr,
 254 |     |                     " to ",
 255 |     |                     valueStr
 256 |     |                 );
 257 |     |                 emit Clamped(string(message));
 258 |     |             }
 259 |     |             return value;
 260 |     |         } else {
 261 |     |             return a;
 262 |     |         }
 263 |     |     }
 264 |     | 
 265 |     |     /// @notice int256 version of clampGt
 266 |     |     function clampGt(
 267 |     |         int256 a,
 268 |     |         int256 b,
 269 |     |         bool enableLogs
 270 |     |     ) public returns (int256) {
 271 |     |         if (!(a > b)) {
 272 |     |             int256 value = b + 1;
 273 |     |             if (enableLogs) {
 274 |     |                 string memory aStr = FuzzLibString.toString(a);
 275 |     |                 string memory valueStr = FuzzLibString.toString(value);
 276 |     |                 bytes memory message = abi.encodePacked(
 277 |     |                     "Clamping value ",
 278 |     |                     aStr,
 279 |     |                     " to ",
 280 |     |                     valueStr
 281 |     |                 );
 282 |     |                 emit Clamped(string(message));
 283 |     |             }
 284 |     |             return value;
 285 |     |         } else {
 286 |     |             return a;
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 |     |     /// @notice clamps a to be greater than or equal to b
 291 |     |     function clampGte(
 292 |     |         uint256 a,
 293 |     |         uint256 b,
 294 |     |         bool enableLogs
 295 |     |     ) public returns (uint256) {
 296 |     |         if (!(a > b)) {
 297 |     |             uint256 value = b;
 298 |     |             if (enableLogs) {
 299 |     |                 string memory aStr = FuzzLibString.toString(a);
 300 |     |                 string memory valueStr = FuzzLibString.toString(value);
 301 |     |                 bytes memory message = abi.encodePacked(
 302 |     |                     "Clamping value ",
 303 |     |                     aStr,
 304 |     |                     " to ",
 305 |     |                     valueStr
 306 |     |                 );
 307 |     |                 emit Clamped(string(message));
 308 |     |             }
 309 |     |             return value;
 310 |     |         }
 311 |     |         return a;
 312 |     |     }
 313 |     | 
 314 |     |     /// @notice int256 version of clampGte
 315 |     |     function clampGte(
 316 |     |         int256 a,
 317 |     |         int256 b,
 318 |     |         bool enableLogs
 319 |     |     ) public returns (int256) {
 320 |     |         if (!(a > b)) {
 321 |     |             int256 value = b;
 322 |     |             if (enableLogs) {
 323 |     |                 string memory aStr = FuzzLibString.toString(a);
 324 |     |                 string memory valueStr = FuzzLibString.toString(value);
 325 |     |                 bytes memory message = abi.encodePacked(
 326 |     |                     "Clamping value ",
 327 |     |                     aStr,
 328 |     |                     " to ",
 329 |     |                     valueStr
 330 |     |                 );
 331 |     |                 emit Clamped(string(message));
 332 |     |             }
 333 |     |             return value;
 334 |     |         }
 335 |     |         return a;
 336 |     |     }
 337 |     | }
 338 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {LibLog} from "../libraries/LibLog.sol";
  5 |     | 
  6 |     | abstract contract HelperLog {
  7 |     |     function log(string memory message) public {
  8 |     |         LibLog.log(message);
  9 |     |     }
 10 |     | 
 11 | *   |     function log(string memory message, string memory data) public {
 12 | *   |         LibLog.log(message, data);
 13 |     |     }
 14 |     | 
 15 |     |     function log(string memory message, bytes memory data) public {
 16 |     |         LibLog.log(message, data);
 17 |     |     }
 18 |     | 
 19 |     |     function log(string memory message, uint256 data) public {
 20 |     |         LibLog.log(message, data);
 21 |     |     }
 22 |     | 
 23 |     |     function log(string memory message, int256 data) public {
 24 |     |         LibLog.log(message, data);
 25 |     |     }
 26 |     | 
 27 |     |     function log(string memory message, address data) public {
 28 |     |         LibLog.log(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bool data) public {
 32 |     |         LibLog.log(message, data);
 33 |     |     }
 34 |     | 
 35 |     |     function log(string memory message, bytes32 data) public {
 36 |     |         LibLog.log(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function logFail() public {
 40 |     |         LibLog.logFail();
 41 |     |     }
 42 |     | 
 43 |     |     function logFail(string memory message) public {
 44 |     |         LibLog.logFail(message);
 45 |     |     }
 46 |     | 
 47 |     |     function logFail(string memory message, string memory data) public {
 48 |     |         LibLog.logFail(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function logFail(string memory message, bytes memory data) public {
 52 |     |         LibLog.logFail(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail(string memory message, uint256 data) public {
 56 |     |         LibLog.logFail(message, data);
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message, int256 data) public {
 60 |     |         LibLog.logFail(message, data);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, address data) public {
 64 |     |         LibLog.logFail(message, data);
 65 |     |     }
 66 |     | 
 67 |     |     function logFail(string memory message, bool data) public {
 68 |     |         LibLog.logFail(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, bytes32 data) public {
 72 |     |         LibLog.log(message, data);
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperMath {
  5 |     |     function min(uint256 a, uint256 b) public pure returns (uint256) {
  6 |     |         return a < b ? a : b;
  7 |     |     }
  8 |     | 
  9 |     |     function max(uint256 a, uint256 b) public pure returns (uint256) {
 10 |     |         return a > b ? a : b;
 11 |     |     }
 12 |     | 
 13 |     |     // Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/utils/math/SignedMath.sol
 14 |     |     function max(int256 a, int256 b) public pure returns (int256) {
 15 |     |         return a > b ? a : b;
 16 |     |     }
 17 |     | 
 18 |     |     // Forked with modifications from https://ethereum.stackexchange.com/a/84391
 19 |     |     function abs(int128 n) public pure returns (int128) {
 20 |     |         return n >= 0 ? n : -n;
 21 |     |     }
 22 |     | 
 23 |     |     function abs(int256 n) public pure returns (uint256) {
 24 |     |         return n >= 0 ? uint256(n) : uint256(-n);
 25 |     |     }
 26 |     | 
 27 |     |     function diff(int256 a, int256 b) public pure returns (uint256) {
 28 |     |         return a >= b ? uint256(a - b) : uint256(b - a);
 29 |     |     }
 30 |     | 
 31 |     |     function diff(uint256 a, uint256 b) public pure returns (uint256) {
 32 |     |         return a >= b ? a - b : b - a;
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/helpers/HelperRandom.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperRandom {
  5 |     |     /// @notice Shuffle an array using Fisher-Yates algorithm
  6 |     |     /// @dev Based on https://gist.github.com/scammi/602387a22e04c77beb73c0ebc0f0bc18
  7 |     |     function shuffleArray(
  8 |     |         uint256[] memory shuffle,
  9 |     |         uint256 entropy
 10 |     |     ) public pure {
 11 |     |         for (uint256 i = shuffle.length - 1; i > 0; i--) {
 12 |     |             uint256 swapIndex = entropy % (shuffle.length - i);
 13 |     | 
 14 |     |             uint256 currentIndex = shuffle[i];
 15 |     |             uint256 indexToSwap = shuffle[swapIndex];
 16 |     | 
 17 |     |             shuffle[i] = indexToSwap;
 18 |     |             shuffle[swapIndex] = currentIndex;
 19 |     |         }
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/libraries/LibLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 | *   | library LibLog {
  5 |     |     event Log(string message);
  6 |     |     event LogString(string message, string data);
  7 |     |     event LogBytes(string message, bytes data);
  8 |     |     event LogUint(string message, uint256 data);
  9 |     |     event LogInt(string message, int256 data);
 10 |     |     event LogAddress(string message, address data);
 11 |     |     event LogBool(string message, bool data);
 12 |     |     event LogBytes32(string message, bytes32 data);
 13 |     | 
 14 |     |     event AssertionFailed();
 15 |     |     event AssertionFailed(string message);
 16 |     |     event AssertionFailed(string message, string data);
 17 |     |     event AssertionFailed(string message, bytes data);
 18 |     |     event AssertionFailed(string message, uint256 data);
 19 |     |     event AssertionFailed(string message, int256 data);
 20 |     |     event AssertionFailed(string message, address data);
 21 |     |     event AssertionFailed(string message, bool data);
 22 |     | 
 23 |     |     function log(string memory message) internal {
 24 |     |         emit Log(message);
 25 |     |     }
 26 |     | 
 27 | *   |     function log(string memory message, string memory data) internal {
 28 | *   |         emit LogString(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bytes memory data) internal {
 32 |     |         emit LogBytes(message, data);
 33 |     |     }
 34 |     | 
 35 |     |     function log(string memory message, uint256 data) internal {
 36 |     |         emit LogUint(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function log(string memory message, int256 data) internal {
 40 |     |         emit LogInt(message, data);
 41 |     |     }
 42 |     | 
 43 |     |     function log(string memory message, address data) internal {
 44 |     |         emit LogAddress(message, data);
 45 |     |     }
 46 |     | 
 47 |     |     function log(string memory message, bool data) internal {
 48 |     |         emit LogBool(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function log(string memory message, bytes32 data) internal {
 52 |     |         emit LogBytes32(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail() internal {
 56 |     |         emit AssertionFailed();
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message) internal {
 60 |     |         emit AssertionFailed(message);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, string memory data) internal {
 64 |     |         emit AssertionFailed(message, data);
 65 |     |     }
 66 |     | 
 67 |     |     function logFail(string memory message, bytes memory data) internal {
 68 |     |         emit AssertionFailed(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, uint256 data) internal {
 72 |     |         emit AssertionFailed(message, data);
 73 |     |     }
 74 |     | 
 75 |     |     function logFail(string memory message, int256 data) internal {
 76 |     |         emit AssertionFailed(message, data);
 77 |     |     }
 78 |     | 
 79 |     |     function logFail(string memory message, address data) internal {
 80 |     |         emit AssertionFailed(message, data);
 81 |     |     }
 82 |     | 
 83 |     |     function logFail(string memory message, bool data) internal {
 84 |     |         emit AssertionFailed(message, data);
 85 |     |     }
 86 |     | 
 87 |     |     function logFail(string memory message, bytes32 data) internal {
 88 |     |         emit LogBytes32(message, data);
 89 |     |     }
 90 |     | }
 91 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/platform/IPlatform.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | interface IPlatform {
 5 |     |     function assertFail() pure external;
 6 |     | }
 7 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/fuzzlib/src/platform/PlatformCrytic.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: MIT
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {IPlatform} from "./IPlatform.sol";
  6 |     | 
  7 | *   | contract PlatformCrytic is IPlatform {
  8 | *   |     function assertFail() pure public override{
  9 | *   |         assert(false);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/lib/solady/src/utils/SafeTransferLib.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)
   6 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)
   7 |     | /// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)
   8 |     | ///
   9 |     | /// @dev Note:
  10 |     | /// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.
  11 | *   | library SafeTransferLib {
  12 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  13 |     |     /*                       CUSTOM ERRORS                        */
  14 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  15 |     | 
  16 |     |     /// @dev The ETH transfer has failed.
  17 |     |     error ETHTransferFailed();
  18 |     | 
  19 |     |     /// @dev The ERC20 `transferFrom` has failed.
  20 |     |     error TransferFromFailed();
  21 |     | 
  22 |     |     /// @dev The ERC20 `transfer` has failed.
  23 |     |     error TransferFailed();
  24 |     | 
  25 |     |     /// @dev The ERC20 `approve` has failed.
  26 |     |     error ApproveFailed();
  27 |     | 
  28 |     |     /// @dev The ERC20 `totalSupply` query has failed.
  29 |     |     error TotalSupplyQueryFailed();
  30 |     | 
  31 |     |     /// @dev The Permit2 operation has failed.
  32 |     |     error Permit2Failed();
  33 |     | 
  34 |     |     /// @dev The Permit2 amount must be less than `2**160 - 1`.
  35 |     |     error Permit2AmountOverflow();
  36 |     | 
  37 |     |     /// @dev The Permit2 approve operation has failed.
  38 |     |     error Permit2ApproveFailed();
  39 |     | 
  40 |     |     /// @dev The Permit2 lockdown operation has failed.
  41 |     |     error Permit2LockdownFailed();
  42 |     | 
  43 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  44 |     |     /*                         CONSTANTS                          */
  45 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  46 |     | 
  47 |     |     /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.
  48 |     |     uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;
  49 |     | 
  50 |     |     /// @dev Suggested gas stipend for contract receiving ETH to perform a few
  51 |     |     /// storage reads and writes, but low enough to prevent griefing.
  52 |     |     uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;
  53 |     | 
  54 |     |     /// @dev The unique EIP-712 domain separator for the DAI token contract.
  55 |     |     bytes32 internal constant DAI_DOMAIN_SEPARATOR =
  56 |     |         0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;
  57 |     | 
  58 |     |     /// @dev The address for the WETH9 contract on Ethereum mainnet.
  59 |     |     address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
  60 |     | 
  61 |     |     /// @dev The canonical Permit2 address.
  62 |     |     /// [Github](https://github.com/Uniswap/permit2)
  63 |     |     /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)
  64 |     |     address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;
  65 |     | 
  66 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
  67 |     |     /*                       ETH OPERATIONS                       */
  68 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
  69 |     | 
  70 |     |     // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.
  71 |     |     //
  72 |     |     // The regular variants:
  73 |     |     // - Forwards all remaining gas to the target.
  74 |     |     // - Reverts if the target reverts.
  75 |     |     // - Reverts if the current contract has insufficient balance.
  76 |     |     //
  77 |     |     // The force variants:
  78 |     |     // - Forwards with an optional gas stipend
  79 |     |     //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).
  80 |     |     // - If the target reverts, or if the gas stipend is exhausted,
  81 |     |     //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.
  82 |     |     //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.
  83 |     |     // - Reverts if the current contract has insufficient balance.
  84 |     |     //
  85 |     |     // The try variants:
  86 |     |     // - Forwards with a mandatory gas stipend.
  87 |     |     // - Instead of reverting, returns whether the transfer succeeded.
  88 |     | 
  89 |     |     /// @dev Sends `amount` (in wei) ETH to `to`.
  90 |     |     function safeTransferETH(address to, uint256 amount) internal {
  91 |     |         /// @solidity memory-safe-assembly
  92 |     |         assembly {
  93 |     |             if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {
  94 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
  95 |     |                 revert(0x1c, 0x04)
  96 |     |             }
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /// @dev Sends all the ETH in the current contract to `to`.
 101 |     |     function safeTransferAllETH(address to) internal {
 102 |     |         /// @solidity memory-safe-assembly
 103 |     |         assembly {
 104 |     |             // Transfer all the ETH and check if it succeeded or not.
 105 |     |             if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {
 106 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
 107 |     |                 revert(0x1c, 0x04)
 108 |     |             }
 109 |     |         }
 110 |     |     }
 111 |     | 
 112 |     |     /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.
 113 |     |     function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {
 114 |     |         /// @solidity memory-safe-assembly
 115 |     |         assembly {
 116 |     |             if lt(selfbalance(), amount) {
 117 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
 118 |     |                 revert(0x1c, 0x04)
 119 |     |             }
 120 |     |             if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {
 121 |     |                 mstore(0x00, to) // Store the address in scratch space.
 122 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 123 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 124 |     |                 if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 125 |     |             }
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.
 130 |     |     function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {
 131 |     |         /// @solidity memory-safe-assembly
 132 |     |         assembly {
 133 |     |             if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {
 134 |     |                 mstore(0x00, to) // Store the address in scratch space.
 135 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 136 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 137 |     |                 if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 138 |     |             }
 139 |     |         }
 140 |     |     }
 141 |     | 
 142 |     |     /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.
 143 |     |     function forceSafeTransferETH(address to, uint256 amount) internal {
 144 |     |         /// @solidity memory-safe-assembly
 145 |     |         assembly {
 146 |     |             if lt(selfbalance(), amount) {
 147 |     |                 mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.
 148 |     |                 revert(0x1c, 0x04)
 149 |     |             }
 150 |     |             if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {
 151 |     |                 mstore(0x00, to) // Store the address in scratch space.
 152 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 153 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 154 |     |                 if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 155 |     |             }
 156 |     |         }
 157 |     |     }
 158 |     | 
 159 |     |     /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.
 160 |     |     function forceSafeTransferAllETH(address to) internal {
 161 |     |         /// @solidity memory-safe-assembly
 162 |     |         assembly {
 163 |     |             // forgefmt: disable-next-item
 164 |     |             if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {
 165 |     |                 mstore(0x00, to) // Store the address in scratch space.
 166 |     |                 mstore8(0x0b, 0x73) // Opcode `PUSH20`.
 167 |     |                 mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.
 168 |     |                 if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.
 169 |     |             }
 170 |     |         }
 171 |     |     }
 172 |     | 
 173 |     |     /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.
 174 |     |     function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)
 175 |     |         internal
 176 |     |         returns (bool success)
 177 |     |     {
 178 |     |         /// @solidity memory-safe-assembly
 179 |     |         assembly {
 180 |     |             success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.
 185 |     |     function trySafeTransferAllETH(address to, uint256 gasStipend)
 186 |     |         internal
 187 |     |         returns (bool success)
 188 |     |     {
 189 |     |         /// @solidity memory-safe-assembly
 190 |     |         assembly {
 191 |     |             success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
 196 |     |     /*                      ERC20 OPERATIONS                      */
 197 |     |     /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/
 198 |     | 
 199 |     |     /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.
 200 |     |     /// Reverts upon failure.
 201 |     |     ///
 202 |     |     /// The `from` account must have at least `amount` approved for
 203 |     |     /// the current contract to manage.
 204 |     |     function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
 205 |     |         /// @solidity memory-safe-assembly
 206 |     |         assembly {
 207 |     |             let m := mload(0x40) // Cache the free memory pointer.
 208 |     |             mstore(0x60, amount) // Store the `amount` argument.
 209 |     |             mstore(0x40, to) // Store the `to` argument.
 210 |     |             mstore(0x2c, shl(96, from)) // Store the `from` argument.
 211 |     |             mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.
 212 |     |             let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
 213 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 214 |     |                 if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 215 |     |                     mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
 216 |     |                     revert(0x1c, 0x04)
 217 |     |                 }
 218 |     |             }
 219 |     |             mstore(0x60, 0) // Restore the zero slot to zero.
 220 |     |             mstore(0x40, m) // Restore the free memory pointer.
 221 |     |         }
 222 |     |     }
 223 |     | 
 224 |     |     /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.
 225 |     |     ///
 226 |     |     /// The `from` account must have at least `amount` approved for the current contract to manage.
 227 |     |     function trySafeTransferFrom(address token, address from, address to, uint256 amount)
 228 |     |         internal
 229 |     |         returns (bool success)
 230 |     |     {
 231 |     |         /// @solidity memory-safe-assembly
 232 |     |         assembly {
 233 |     |             let m := mload(0x40) // Cache the free memory pointer.
 234 |     |             mstore(0x60, amount) // Store the `amount` argument.
 235 |     |             mstore(0x40, to) // Store the `to` argument.
 236 |     |             mstore(0x2c, shl(96, from)) // Store the `from` argument.
 237 |     |             mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.
 238 |     |             success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
 239 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 240 |     |                 success := lt(or(iszero(extcodesize(token)), returndatasize()), success)
 241 |     |             }
 242 |     |             mstore(0x60, 0) // Restore the zero slot to zero.
 243 |     |             mstore(0x40, m) // Restore the free memory pointer.
 244 |     |         }
 245 |     |     }
 246 |     | 
 247 |     |     /// @dev Sends all of ERC20 `token` from `from` to `to`.
 248 |     |     /// Reverts upon failure.
 249 |     |     ///
 250 |     |     /// The `from` account must have their entire balance approved for the current contract to manage.
 251 |     |     function safeTransferAllFrom(address token, address from, address to)
 252 |     |         internal
 253 |     |         returns (uint256 amount)
 254 |     |     {
 255 |     |         /// @solidity memory-safe-assembly
 256 |     |         assembly {
 257 |     |             let m := mload(0x40) // Cache the free memory pointer.
 258 |     |             mstore(0x40, to) // Store the `to` argument.
 259 |     |             mstore(0x2c, shl(96, from)) // Store the `from` argument.
 260 |     |             mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
 261 |     |             // Read the balance, reverting upon failure.
 262 |     |             if iszero(
 263 |     |                 and( // The arguments of `and` are evaluated from right to left.
 264 |     |                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 265 |     |                     staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)
 266 |     |                 )
 267 |     |             ) {
 268 |     |                 mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
 269 |     |                 revert(0x1c, 0x04)
 270 |     |             }
 271 |     |             mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.
 272 |     |             amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.
 273 |     |             // Perform the transfer, reverting upon failure.
 274 |     |             let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
 275 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 276 |     |                 if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 277 |     |                     mstore(0x00, 0x7939f424) // `TransferFromFailed()`.
 278 |     |                     revert(0x1c, 0x04)
 279 |     |                 }
 280 |     |             }
 281 |     |             mstore(0x60, 0) // Restore the zero slot to zero.
 282 |     |             mstore(0x40, m) // Restore the free memory pointer.
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     |     /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.
 287 |     |     /// Reverts upon failure.
 288 |     |     function safeTransfer(address token, address to, uint256 amount) internal {
 289 |     |         /// @solidity memory-safe-assembly
 290 |     |         assembly {
 291 |     |             mstore(0x14, to) // Store the `to` argument.
 292 |     |             mstore(0x34, amount) // Store the `amount` argument.
 293 |     |             mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.
 294 |     |             // Perform the transfer, reverting upon failure.
 295 |     |             let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 296 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 297 |     |                 if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 298 |     |                     mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
 299 |     |                     revert(0x1c, 0x04)
 300 |     |                 }
 301 |     |             }
 302 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 303 |     |         }
 304 |     |     }
 305 |     | 
 306 |     |     /// @dev Sends all of ERC20 `token` from the current contract to `to`.
 307 |     |     /// Reverts upon failure.
 308 |     |     function safeTransferAll(address token, address to) internal returns (uint256 amount) {
 309 |     |         /// @solidity memory-safe-assembly
 310 |     |         assembly {
 311 |     |             mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.
 312 |     |             mstore(0x20, address()) // Store the address of the current contract.
 313 |     |             // Read the balance, reverting upon failure.
 314 |     |             if iszero(
 315 |     |                 and( // The arguments of `and` are evaluated from right to left.
 316 |     |                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 317 |     |                     staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)
 318 |     |                 )
 319 |     |             ) {
 320 |     |                 mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
 321 |     |                 revert(0x1c, 0x04)
 322 |     |             }
 323 |     |             mstore(0x14, to) // Store the `to` argument.
 324 |     |             amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.
 325 |     |             mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.
 326 |     |             // Perform the transfer, reverting upon failure.
 327 |     |             let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 328 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 329 |     |                 if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 330 |     |                     mstore(0x00, 0x90b8ec18) // `TransferFailed()`.
 331 |     |                     revert(0x1c, 0x04)
 332 |     |                 }
 333 |     |             }
 334 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 335 |     |         }
 336 |     |     }
 337 |     | 
 338 |     |     /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.
 339 |     |     /// Reverts upon failure.
 340 |     |     function safeApprove(address token, address to, uint256 amount) internal {
 341 |     |         /// @solidity memory-safe-assembly
 342 |     |         assembly {
 343 |     |             mstore(0x14, to) // Store the `to` argument.
 344 |     |             mstore(0x34, amount) // Store the `amount` argument.
 345 |     |             mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
 346 |     |             let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 347 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 348 |     |                 if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 349 |     |                     mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.
 350 |     |                     revert(0x1c, 0x04)
 351 |     |                 }
 352 |     |             }
 353 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 354 |     |         }
 355 |     |     }
 356 |     | 
 357 |     |     /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.
 358 |     |     /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,
 359 |     |     /// then retries the approval again (some tokens, e.g. USDT, requires this).
 360 |     |     /// Reverts upon failure.
 361 |     |     function safeApproveWithRetry(address token, address to, uint256 amount) internal {
 362 |     |         /// @solidity memory-safe-assembly
 363 |     |         assembly {
 364 |     |             mstore(0x14, to) // Store the `to` argument.
 365 |     |             mstore(0x34, amount) // Store the `amount` argument.
 366 |     |             mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
 367 |     |             // Perform the approval, retrying upon failure.
 368 |     |             let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 369 |     |             if iszero(and(eq(mload(0x00), 1), success)) {
 370 |     |                 if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 371 |     |                     mstore(0x34, 0) // Store 0 for the `amount`.
 372 |     |                     mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.
 373 |     |                     pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.
 374 |     |                     mstore(0x34, amount) // Store back the original `amount`.
 375 |     |                     // Retry the approval, reverting upon failure.
 376 |     |                     success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)
 377 |     |                     if iszero(and(eq(mload(0x00), 1), success)) {
 378 |     |                         // Check the `extcodesize` again just in case the token selfdestructs lol.
 379 |     |                         if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {
 380 |     |                             mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.
 381 |     |                             revert(0x1c, 0x04)
 382 |     |                         }
 383 |     |                     }
 384 |     |                 }
 385 |     |             }
 386 |     |             mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.
 387 |     |         }
 388 |     |     }
 389 |     | 
 390 |     |     /// @dev Returns the amount of ERC20 `token` owned by `account`.
 391 |     |     /// Returns zero if the `token` does not exist.
 392 |     |     function balanceOf(address token, address account) internal view returns (uint256 amount) {
 393 |     |         /// @solidity memory-safe-assembly
 394 |     |         assembly {
 395 |     |             mstore(0x14, account) // Store the `account` argument.
 396 |     |             mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
 397 |     |             amount :=
 398 |     |                 mul( // The arguments of `mul` are evaluated from right to left.
 399 |     |                     mload(0x20),
 400 |     |                     and( // The arguments of `and` are evaluated from right to left.
 401 |     |                         gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 402 |     |                         staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)
 403 |     |                     )
 404 |     |                 )
 405 |     |         }
 406 |     |     }
 407 |     | 
 408 |     |     /// @dev Performs a `token.balanceOf(account)` check.
 409 |     |     /// `implemented` denotes whether the `token` does not implement `balanceOf`.
 410 |     |     /// `amount` is zero if the `token` does not implement `balanceOf`.
 411 |     |     function checkBalanceOf(address token, address account)
 412 |     |         internal
 413 |     |         view
 414 |     |         returns (bool implemented, uint256 amount)
 415 |     |     {
 416 |     |         /// @solidity memory-safe-assembly
 417 |     |         assembly {
 418 |     |             mstore(0x14, account) // Store the `account` argument.
 419 |     |             mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.
 420 |     |             implemented :=
 421 |     |                 and( // The arguments of `and` are evaluated from right to left.
 422 |     |                     gt(returndatasize(), 0x1f), // At least 32 bytes returned.
 423 |     |                     staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)
 424 |     |                 )
 425 |     |             amount := mul(mload(0x20), implemented)
 426 |     |         }
 427 |     |     }
 428 |     | 
 429 |     |     /// @dev Returns the total supply of the `token`.
 430 |     |     /// Reverts if the token does not exist or does not implement `totalSupply()`.
 431 |     |     function totalSupply(address token) internal view returns (uint256 result) {
 432 |     |         /// @solidity memory-safe-assembly
 433 |     |         assembly {
 434 |     |             mstore(0x00, 0x18160ddd) // `totalSupply()`.
 435 |     |             if iszero(
 436 |     |                 and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))
 437 |     |             ) {
 438 |     |                 mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.
 439 |     |                 revert(0x1c, 0x04)
 440 |     |             }
 441 |     |             result := mload(0x00)
 442 |     |         }
 443 |     |     }
 444 |     | 
 445 |     |     /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.
 446 |     |     /// If the initial attempt fails, try to use Permit2 to transfer the token.
 447 |     |     /// Reverts upon failure.
 448 |     |     ///
 449 |     |     /// The `from` account must have at least `amount` approved for the current contract to manage.
 450 |     |     function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {
 451 |     |         if (!trySafeTransferFrom(token, from, to, amount)) {
 452 |     |             permit2TransferFrom(token, from, to, amount);
 453 |     |         }
 454 |     |     }
 455 |     | 
 456 |     |     /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.
 457 |     |     /// Reverts upon failure.
 458 |     |     function permit2TransferFrom(address token, address from, address to, uint256 amount)
 459 |     |         internal
 460 |     |     {
 461 |     |         /// @solidity memory-safe-assembly
 462 |     |         assembly {
 463 |     |             let m := mload(0x40)
 464 |     |             mstore(add(m, 0x74), shr(96, shl(96, token)))
 465 |     |             mstore(add(m, 0x54), amount)
 466 |     |             mstore(add(m, 0x34), to)
 467 |     |             mstore(add(m, 0x20), shl(96, from))
 468 |     |             // `transferFrom(address,address,uint160,address)`.
 469 |     |             mstore(m, 0x36c78516000000000000000000000000)
 470 |     |             let p := PERMIT2
 471 |     |             let exists := eq(chainid(), 1)
 472 |     |             if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }
 473 |     |             if iszero(
 474 |     |                 and(
 475 |     |                     call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),
 476 |     |                     lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.
 477 |     |                 )
 478 |     |             ) {
 479 |     |                 mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.
 480 |     |                 revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)
 481 |     |             }
 482 |     |         }
 483 |     |     }
 484 |     | 
 485 |     |     /// @dev Permit a user to spend a given amount of
 486 |     |     /// another user's tokens via native EIP-2612 permit if possible, falling
 487 |     |     /// back to Permit2 if native permit fails or is not implemented on the token.
 488 |     |     function permit2(
 489 |     |         address token,
 490 |     |         address owner,
 491 |     |         address spender,
 492 |     |         uint256 amount,
 493 |     |         uint256 deadline,
 494 |     |         uint8 v,
 495 |     |         bytes32 r,
 496 |     |         bytes32 s
 497 |     |     ) internal {
 498 |     |         bool success;
 499 |     |         /// @solidity memory-safe-assembly
 500 |     |         assembly {
 501 |     |             for {} shl(96, xor(token, WETH9)) {} {
 502 |     |                 mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.
 503 |     |                 if iszero(
 504 |     |                     and( // The arguments of `and` are evaluated from right to left.
 505 |     |                         lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.
 506 |     |                         // Gas stipend to limit gas burn for tokens that don't refund gas when
 507 |     |                         // an non-existing function is called. 5K should be enough for a SLOAD.
 508 |     |                         staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)
 509 |     |                     )
 510 |     |                 ) { break }
 511 |     |                 // After here, we can be sure that token is a contract.
 512 |     |                 let m := mload(0x40)
 513 |     |                 mstore(add(m, 0x34), spender)
 514 |     |                 mstore(add(m, 0x20), shl(96, owner))
 515 |     |                 mstore(add(m, 0x74), deadline)
 516 |     |                 if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {
 517 |     |                     mstore(0x14, owner)
 518 |     |                     mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.
 519 |     |                     mstore(
 520 |     |                         add(m, 0x94),
 521 |     |                         lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))
 522 |     |                     )
 523 |     |                     mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.
 524 |     |                     // `nonces` is already at `add(m, 0x54)`.
 525 |     |                     // `amount != 0` is already stored at `add(m, 0x94)`.
 526 |     |                     mstore(add(m, 0xb4), and(0xff, v))
 527 |     |                     mstore(add(m, 0xd4), r)
 528 |     |                     mstore(add(m, 0xf4), s)
 529 |     |                     success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)
 530 |     |                     break
 531 |     |                 }
 532 |     |                 mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.
 533 |     |                 mstore(add(m, 0x54), amount)
 534 |     |                 mstore(add(m, 0x94), and(0xff, v))
 535 |     |                 mstore(add(m, 0xb4), r)
 536 |     |                 mstore(add(m, 0xd4), s)
 537 |     |                 success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)
 538 |     |                 break
 539 |     |             }
 540 |     |         }
 541 |     |         if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);
 542 |     |     }
 543 |     | 
 544 |     |     /// @dev Simple permit on the Permit2 contract.
 545 |     |     function simplePermit2(
 546 |     |         address token,
 547 |     |         address owner,
 548 |     |         address spender,
 549 |     |         uint256 amount,
 550 |     |         uint256 deadline,
 551 |     |         uint8 v,
 552 |     |         bytes32 r,
 553 |     |         bytes32 s
 554 |     |     ) internal {
 555 |     |         /// @solidity memory-safe-assembly
 556 |     |         assembly {
 557 |     |             let m := mload(0x40)
 558 |     |             mstore(m, 0x927da105) // `allowance(address,address,address)`.
 559 |     |             {
 560 |     |                 let addressMask := shr(96, not(0))
 561 |     |                 mstore(add(m, 0x20), and(addressMask, owner))
 562 |     |                 mstore(add(m, 0x40), and(addressMask, token))
 563 |     |                 mstore(add(m, 0x60), and(addressMask, spender))
 564 |     |                 mstore(add(m, 0xc0), and(addressMask, spender))
 565 |     |             }
 566 |     |             let p := mul(PERMIT2, iszero(shr(160, amount)))
 567 |     |             if iszero(
 568 |     |                 and( // The arguments of `and` are evaluated from right to left.
 569 |     |                     gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.
 570 |     |                     staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)
 571 |     |                 )
 572 |     |             ) {
 573 |     |                 mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.
 574 |     |                 revert(add(0x18, shl(2, iszero(p))), 0x04)
 575 |     |             }
 576 |     |             mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).
 577 |     |             // `owner` is already `add(m, 0x20)`.
 578 |     |             // `token` is already at `add(m, 0x40)`.
 579 |     |             mstore(add(m, 0x60), amount)
 580 |     |             mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.
 581 |     |             // `nonce` is already at `add(m, 0xa0)`.
 582 |     |             // `spender` is already at `add(m, 0xc0)`.
 583 |     |             mstore(add(m, 0xe0), deadline)
 584 |     |             mstore(add(m, 0x100), 0x100) // `signature` offset.
 585 |     |             mstore(add(m, 0x120), 0x41) // `signature` length.
 586 |     |             mstore(add(m, 0x140), r)
 587 |     |             mstore(add(m, 0x160), s)
 588 |     |             mstore(add(m, 0x180), shl(248, v))
 589 |     |             if iszero( // Revert if token does not have code, or if the call fails.
 590 |     |             mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {
 591 |     |                 mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.
 592 |     |                 revert(0x1c, 0x04)
 593 |     |             }
 594 |     |         }
 595 |     |     }
 596 |     | 
 597 |     |     /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.
 598 |     |     function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)
 599 |     |         internal
 600 |     |     {
 601 |     |         /// @solidity memory-safe-assembly
 602 |     |         assembly {
 603 |     |             let addressMask := shr(96, not(0))
 604 |     |             let m := mload(0x40)
 605 |     |             mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.
 606 |     |             mstore(add(m, 0x20), and(addressMask, token))
 607 |     |             mstore(add(m, 0x40), and(addressMask, spender))
 608 |     |             mstore(add(m, 0x60), and(addressMask, amount))
 609 |     |             mstore(add(m, 0x80), and(0xffffffffffff, expiration))
 610 |     |             if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {
 611 |     |                 mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.
 612 |     |                 revert(0x1c, 0x04)
 613 |     |             }
 614 |     |         }
 615 |     |     }
 616 |     | 
 617 |     |     /// @dev Revokes an approval for `token` and `spender` for `address(this)`.
 618 |     |     function permit2Lockdown(address token, address spender) internal {
 619 |     |         /// @solidity memory-safe-assembly
 620 |     |         assembly {
 621 |     |             let m := mload(0x40)
 622 |     |             mstore(m, 0xcc53287f) // `Permit2.lockdown`.
 623 |     |             mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.
 624 |     |             mstore(add(m, 0x40), 1) // `approvals.length`.
 625 |     |             mstore(add(m, 0x60), shr(96, shl(96, token)))
 626 |     |             mstore(add(m, 0x80), shr(96, shl(96, spender)))
 627 |     |             if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {
 628 |     |                 mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.
 629 |     |                 revert(0x1c, 0x04)
 630 |     |             }
 631 |     |         }
 632 |     |     }
 633 |     | }
 634 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "./IAccessControl.sol";
   7 |     | import {Context} from "../utils/Context.sol";
   8 |     | import {ERC165} from "../utils/introspection/ERC165.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Contract module that allows children to implement role-based access
  12 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  13 |     |  * members except through off-chain means by accessing the contract event logs. Some
  14 |     |  * applications may benefit from on-chain enumerability, for those cases see
  15 |     |  * {AccessControlEnumerable}.
  16 |     |  *
  17 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  18 |     |  * in the external API and be unique. The best way to achieve this is by
  19 |     |  * using `public constant` hash digests:
  20 |     |  *
  21 |     |  * ```solidity
  22 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  23 |     |  * ```
  24 |     |  *
  25 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  26 |     |  * function call, use {hasRole}:
  27 |     |  *
  28 |     |  * ```solidity
  29 |     |  * function foo() public {
  30 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  31 |     |  *     ...
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  36 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  37 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  38 |     |  *
  39 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  40 |     |  * that only accounts with this role will be able to grant or revoke other
  41 |     |  * roles. More complex role relationships can be created by using
  42 |     |  * {_setRoleAdmin}.
  43 |     |  *
  44 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  45 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  46 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  47 |     |  * to enforce additional security measures for this role.
  48 |     |  */
  49 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  50 |     |     struct RoleData {
  51 |     |         mapping(address account => bool) hasRole;
  52 |     |         bytes32 adminRole;
  53 |     |     }
  54 |     | 
  55 |     |     mapping(bytes32 role => RoleData) private _roles;
  56 |     | 
  57 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  61 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  62 |     |      */
  63 |     |     modifier onlyRole(bytes32 role) {
  64 | *   |         _checkRole(role);
  65 |     |         _;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev See {IERC165-supportsInterface}.
  70 |     |      */
  71 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  72 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Returns `true` if `account` has been granted `role`.
  77 |     |      */
  78 | *   |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  79 | *   |         return _roles[role].hasRole[account];
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
  84 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
  85 |     |      */
  86 | *   |     function _checkRole(bytes32 role) internal view virtual {
  87 | *   |         _checkRole(role, _msgSender());
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
  92 |     |      * is missing `role`.
  93 |     |      */
  94 | *   |     function _checkRole(bytes32 role, address account) internal view virtual {
  95 | *   |         if (!hasRole(role, account)) {
  96 |     |             revert AccessControlUnauthorizedAccount(account, role);
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 102 |     |      * {revokeRole}.
 103 |     |      *
 104 |     |      * To change a role's admin, use {_setRoleAdmin}.
 105 |     |      */
 106 | *   |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 107 | *   |         return _roles[role].adminRole;
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Grants `role` to `account`.
 112 |     |      *
 113 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 114 |     |      * event.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - the caller must have ``role``'s admin role.
 119 |     |      *
 120 |     |      * May emit a {RoleGranted} event.
 121 |     |      */
 122 | *   |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 123 | *   |         _grantRole(role, account);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Revokes `role` from `account`.
 128 |     |      *
 129 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 130 |     |      *
 131 |     |      * Requirements:
 132 |     |      *
 133 |     |      * - the caller must have ``role``'s admin role.
 134 |     |      *
 135 |     |      * May emit a {RoleRevoked} event.
 136 |     |      */
 137 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 138 |     |         _revokeRole(role, account);
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Revokes `role` from the calling account.
 143 |     |      *
 144 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 145 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 146 |     |      * if they are compromised (such as when a trusted device is misplaced).
 147 |     |      *
 148 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 149 |     |      * event.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - the caller must be `callerConfirmation`.
 154 |     |      *
 155 |     |      * May emit a {RoleRevoked} event.
 156 |     |      */
 157 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 158 |     |         if (callerConfirmation != _msgSender()) {
 159 |     |             revert AccessControlBadConfirmation();
 160 |     |         }
 161 |     | 
 162 |     |         _revokeRole(role, callerConfirmation);
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 167 |     |      *
 168 |     |      * Emits a {RoleAdminChanged} event.
 169 |     |      */
 170 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 171 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 172 |     |         _roles[role].adminRole = adminRole;
 173 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 178 |     |      *
 179 |     |      * Internal function without access restriction.
 180 |     |      *
 181 |     |      * May emit a {RoleGranted} event.
 182 |     |      */
 183 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 184 | *   |         if (!hasRole(role, account)) {
 185 | *   |             _roles[role].hasRole[account] = true;
 186 | *   |             emit RoleGranted(role, account, _msgSender());
 187 | *   |             return true;
 188 |     |         } else {
 189 | *   |             return false;
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
 195 |     |      *
 196 |     |      * Internal function without access restriction.
 197 |     |      *
 198 |     |      * May emit a {RoleRevoked} event.
 199 |     |      */
 200 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 201 |     |         if (hasRole(role, account)) {
 202 |     |             _roles[role].hasRole[account] = false;
 203 |     |             emit RoleRevoked(role, account, _msgSender());
 204 |     |             return true;
 205 |     |         } else {
 206 |     |             return false;
 207 |     |         }
 208 |     |     }
 209 |     | }
 210 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted signaling this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call, an admin role
  34 |     |      * bearer except when using {AccessControl-_setupRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/access/Ownable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Context} from "../utils/Context.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Contract module which provides a basic access control mechanism, where
  10 |     |  * there is an account (an owner) that can be granted exclusive access to
  11 |     |  * specific functions.
  12 |     |  *
  13 |     |  * The initial owner is set to the address provided by the deployer. This can
  14 |     |  * later be changed with {transferOwnership}.
  15 |     |  *
  16 |     |  * This module is used through inheritance. It will make available the modifier
  17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
  18 |     |  * the owner.
  19 |     |  */
  20 |     | abstract contract Ownable is Context {
  21 |     |     address private _owner;
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev The caller account is not authorized to perform an operation.
  25 |     |      */
  26 |     |     error OwnableUnauthorizedAccount(address account);
  27 |     | 
  28 |     |     /**
  29 |     |      * @dev The owner is not a valid owner account. (eg. `address(0)`)
  30 |     |      */
  31 |     |     error OwnableInvalidOwner(address owner);
  32 |     | 
  33 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
  37 |     |      */
  38 | *   |     constructor(address initialOwner) {
  39 | *   |         if (initialOwner == address(0)) {
  40 |     |             revert OwnableInvalidOwner(address(0));
  41 |     |         }
  42 | *   |         _transferOwnership(initialOwner);
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Throws if called by any account other than the owner.
  47 |     |      */
  48 |     |     modifier onlyOwner() {
  49 |     |         _checkOwner();
  50 |     |         _;
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Returns the address of the current owner.
  55 |     |      */
  56 |     |     function owner() public view virtual returns (address) {
  57 |     |         return _owner;
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Throws if the sender is not the owner.
  62 |     |      */
  63 |     |     function _checkOwner() internal view virtual {
  64 |     |         if (owner() != _msgSender()) {
  65 |     |             revert OwnableUnauthorizedAccount(_msgSender());
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Leaves the contract without owner. It will not be possible to call
  71 |     |      * `onlyOwner` functions. Can only be called by the current owner.
  72 |     |      *
  73 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
  74 |     |      * thereby disabling any functionality that is only available to the owner.
  75 |     |      */
  76 |     |     function renounceOwnership() public virtual onlyOwner {
  77 |     |         _transferOwnership(address(0));
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  82 |     |      * Can only be called by the current owner.
  83 |     |      */
  84 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
  85 |     |         if (newOwner == address(0)) {
  86 |     |             revert OwnableInvalidOwner(address(0));
  87 |     |         }
  88 |     |         _transferOwnership(newOwner);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  93 |     |      * Internal function without access restriction.
  94 |     |      */
  95 | *   |     function _transferOwnership(address newOwner) internal virtual {
  96 | *   |         address oldOwner = _owner;
  97 | *   |         _owner = newOwner;
  98 | *   |         emit OwnershipTransferred(oldOwner, newOwner);
  99 |     |     }
 100 |     | }
 101 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC165} from "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC1155 compliant contract, as defined in the
  10 |     |  * https://eips.ethereum.org/EIPS/eip-1155[EIP].
  11 |     |  */
  12 |     | interface IERC1155 is IERC165 {
  13 |     |     /**
  14 |     |      * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.
  15 |     |      */
  16 |     |     event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
  20 |     |      * transfers.
  21 |     |      */
  22 |     |     event TransferBatch(
  23 |     |         address indexed operator,
  24 |     |         address indexed from,
  25 |     |         address indexed to,
  26 |     |         uint256[] ids,
  27 |     |         uint256[] values
  28 |     |     );
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
  32 |     |      * `approved`.
  33 |     |      */
  34 |     |     event ApprovalForAll(address indexed account, address indexed operator, bool approved);
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
  38 |     |      *
  39 |     |      * If an {URI} event was emitted for `id`, the standard
  40 |     |      * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
  41 |     |      * returned by {IERC1155MetadataURI-uri}.
  42 |     |      */
  43 |     |     event URI(string value, uint256 indexed id);
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Returns the value of tokens of token type `id` owned by `account`.
  47 |     |      *
  48 |     |      * Requirements:
  49 |     |      *
  50 |     |      * - `account` cannot be the zero address.
  51 |     |      */
  52 |     |     function balanceOf(address account, uint256 id) external view returns (uint256);
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - `accounts` and `ids` must have the same length.
  60 |     |      */
  61 |     |     function balanceOfBatch(
  62 |     |         address[] calldata accounts,
  63 |     |         uint256[] calldata ids
  64 |     |     ) external view returns (uint256[] memory);
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
  68 |     |      *
  69 |     |      * Emits an {ApprovalForAll} event.
  70 |     |      *
  71 |     |      * Requirements:
  72 |     |      *
  73 |     |      * - `operator` cannot be the caller.
  74 |     |      */
  75 |     |     function setApprovalForAll(address operator, bool approved) external;
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
  79 |     |      *
  80 |     |      * See {setApprovalForAll}.
  81 |     |      */
  82 |     |     function isApprovedForAll(address account, address operator) external view returns (bool);
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.
  86 |     |      *
  87 |     |      * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
  88 |     |      * to an untrusted contract, when invoking {onERC1155Received} on the receiver.
  89 |     |      * Ensure to follow the checks-effects-interactions pattern and consider employing
  90 |     |      * reentrancy guards when interacting with untrusted contracts.
  91 |     |      *
  92 |     |      * Emits a {TransferSingle} event.
  93 |     |      *
  94 |     |      * Requirements:
  95 |     |      *
  96 |     |      * - `to` cannot be the zero address.
  97 |     |      * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
  98 |     |      * - `from` must have a balance of tokens of type `id` of at least `value` amount.
  99 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
 100 |     |      * acceptance magic value.
 101 |     |      */
 102 |     |     function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
 106 |     |      *
 107 |     |      * WARNING: This function can potentially allow a reentrancy attack when transferring tokens
 108 |     |      * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.
 109 |     |      * Ensure to follow the checks-effects-interactions pattern and consider employing
 110 |     |      * reentrancy guards when interacting with untrusted contracts.
 111 |     |      *
 112 |     |      * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.
 113 |     |      *
 114 |     |      * Requirements:
 115 |     |      *
 116 |     |      * - `ids` and `values` must have the same length.
 117 |     |      * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
 118 |     |      * acceptance magic value.
 119 |     |      */
 120 |     |     function safeBatchTransferFrom(
 121 |     |         address from,
 122 |     |         address to,
 123 |     |         uint256[] calldata ids,
 124 |     |         uint256[] calldata values,
 125 |     |         bytes calldata data
 126 |     |     ) external;
 127 |     | }
 128 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "../../utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface that must be implemented by smart contracts in order to receive
 10 |     |  * ERC-1155 token transfers.
 11 |     |  */
 12 |     | interface IERC1155Receiver is IERC165 {
 13 |     |     /**
 14 |     |      * @dev Handles the receipt of a single ERC1155 token type. This function is
 15 |     |      * called at the end of a `safeTransferFrom` after the balance has been updated.
 16 |     |      *
 17 |     |      * NOTE: To accept the transfer, this must return
 18 |     |      * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
 19 |     |      * (i.e. 0xf23a6e61, or its own function selector).
 20 |     |      *
 21 |     |      * @param operator The address which initiated the transfer (i.e. msg.sender)
 22 |     |      * @param from The address which previously owned the token
 23 |     |      * @param id The ID of the token being transferred
 24 |     |      * @param value The amount of tokens being transferred
 25 |     |      * @param data Additional data with no specified format
 26 |     |      * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
 27 |     |      */
 28 |     |     function onERC1155Received(
 29 |     |         address operator,
 30 |     |         address from,
 31 |     |         uint256 id,
 32 |     |         uint256 value,
 33 |     |         bytes calldata data
 34 |     |     ) external returns (bytes4);
 35 |     | 
 36 |     |     /**
 37 |     |      * @dev Handles the receipt of a multiple ERC1155 token types. This function
 38 |     |      * is called at the end of a `safeBatchTransferFrom` after the balances have
 39 |     |      * been updated.
 40 |     |      *
 41 |     |      * NOTE: To accept the transfer(s), this must return
 42 |     |      * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
 43 |     |      * (i.e. 0xbc197c81, or its own function selector).
 44 |     |      *
 45 |     |      * @param operator The address which initiated the batch transfer (i.e. msg.sender)
 46 |     |      * @param from The address which previously owned the token
 47 |     |      * @param ids An array containing ids of each token being transferred (order and length must match values array)
 48 |     |      * @param values An array containing amounts of each token being transferred (order and length must match ids array)
 49 |     |      * @param data Additional data with no specified format
 50 |     |      * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
 51 |     |      */
 52 |     |     function onERC1155BatchReceived(
 53 |     |         address operator,
 54 |     |         address from,
 55 |     |         uint256[] calldata ids,
 56 |     |         uint256[] calldata values,
 57 |     |         bytes calldata data
 58 |     |     ) external returns (bytes4);
 59 |     | }
 60 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165, ERC165} from "../../../utils/introspection/ERC165.sol";
  7 |     | import {IERC1155Receiver} from "../IERC1155Receiver.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.
 11 |     |  *
 12 |     |  * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 13 |     |  * stuck.
 14 |     |  */
 15 |     | abstract contract ERC1155Holder is ERC165, IERC1155Receiver {
 16 |     |     /**
 17 |     |      * @dev See {IERC165-supportsInterface}.
 18 |     |      */
 19 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
 20 |     |         return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
 21 |     |     }
 22 |     | 
 23 |     |     function onERC1155Received(
 24 |     |         address,
 25 |     |         address,
 26 |     |         uint256,
 27 |     |         uint256,
 28 |     |         bytes memory
 29 |     |     ) public virtual override returns (bytes4) {
 30 |     |         return this.onERC1155Received.selector;
 31 |     |     }
 32 |     | 
 33 |     |     function onERC1155BatchReceived(
 34 |     |         address,
 35 |     |         address,
 36 |     |         uint256[] memory,
 37 |     |         uint256[] memory,
 38 |     |         bytes memory
 39 |     |     ) public virtual override returns (bytes4) {
 40 |     |         return this.onERC1155BatchReceived.selector;
 41 |     |     }
 42 |     | }
 43 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  */
  34 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  35 |     |     mapping(address account => uint256) private _balances;
  36 |     | 
  37 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  38 |     | 
  39 |     |     uint256 private _totalSupply;
  40 |     | 
  41 |     |     string private _name;
  42 |     |     string private _symbol;
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Sets the values for {name} and {symbol}.
  46 |     |      *
  47 |     |      * All two of these values are immutable: they can only be set once during
  48 |     |      * construction.
  49 |     |      */
  50 | *   |     constructor(string memory name_, string memory symbol_) {
  51 | *   |         _name = name_;
  52 | *   |         _symbol = symbol_;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Returns the name of the token.
  57 |     |      */
  58 | *   |     function name() public view virtual returns (string memory) {
  59 | *   |         return _name;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  64 |     |      * name.
  65 |     |      */
  66 |     |     function symbol() public view virtual returns (string memory) {
  67 |     |         return _symbol;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Returns the number of decimals used to get its user representation.
  72 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  73 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  74 |     |      *
  75 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  76 |     |      * Ether and Wei. This is the default value returned by this function, unless
  77 |     |      * it's overridden.
  78 |     |      *
  79 |     |      * NOTE: This information is only used for _display_ purposes: it in
  80 |     |      * no way affects any of the arithmetic of the contract, including
  81 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  82 |     |      */
  83 |     |     function decimals() public view virtual returns (uint8) {
  84 |     |         return 18;
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev See {IERC20-totalSupply}.
  89 |     |      */
  90 | *   |     function totalSupply() public view virtual returns (uint256) {
  91 | *   |         return _totalSupply;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev See {IERC20-balanceOf}.
  96 |     |      */
  97 | *   |     function balanceOf(address account) public view virtual returns (uint256) {
  98 | *   |         return _balances[account];
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev See {IERC20-transfer}.
 103 |     |      *
 104 |     |      * Requirements:
 105 |     |      *
 106 |     |      * - `to` cannot be the zero address.
 107 |     |      * - the caller must have a balance of at least `value`.
 108 |     |      */
 109 | *   |     function transfer(address to, uint256 value) public virtual returns (bool) {
 110 | *   |         address owner = _msgSender();
 111 | *   |         _transfer(owner, to, value);
 112 | *   |         return true;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev See {IERC20-allowance}.
 117 |     |      */
 118 | *   |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 119 | *   |         return _allowances[owner][spender];
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev See {IERC20-approve}.
 124 |     |      *
 125 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 126 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 127 |     |      *
 128 |     |      * Requirements:
 129 |     |      *
 130 |     |      * - `spender` cannot be the zero address.
 131 |     |      */
 132 | *   |     function approve(address spender, uint256 value) public virtual returns (bool) {
 133 | *   |         address owner = _msgSender();
 134 | *   |         _approve(owner, spender, value);
 135 | *   |         return true;
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev See {IERC20-transferFrom}.
 140 |     |      *
 141 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 142 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 143 |     |      *
 144 |     |      * NOTE: Does not update the allowance if the current allowance
 145 |     |      * is the maximum `uint256`.
 146 |     |      *
 147 |     |      * Requirements:
 148 |     |      *
 149 |     |      * - `from` and `to` cannot be the zero address.
 150 |     |      * - `from` must have a balance of at least `value`.
 151 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 152 |     |      * `value`.
 153 |     |      */
 154 | *   |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 155 | *   |         address spender = _msgSender();
 156 | *   |         _spendAllowance(from, spender, value);
 157 | *   |         _transfer(from, to, value);
 158 | *   |         return true;
 159 |     |     }
 160 |     | 
 161 |     |     /**
 162 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 163 |     |      *
 164 |     |      * This internal function is equivalent to {transfer}, and can be used to
 165 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 166 |     |      *
 167 |     |      * Emits a {Transfer} event.
 168 |     |      *
 169 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 170 |     |      */
 171 | *   |     function _transfer(address from, address to, uint256 value) internal {
 172 | *   |         if (from == address(0)) {
 173 |     |             revert ERC20InvalidSender(address(0));
 174 |     |         }
 175 | *   |         if (to == address(0)) {
 176 |     |             revert ERC20InvalidReceiver(address(0));
 177 |     |         }
 178 | *   |         _update(from, to, value);
 179 |     |     }
 180 |     | 
 181 |     |     /**
 182 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 183 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 184 |     |      * this function.
 185 |     |      *
 186 |     |      * Emits a {Transfer} event.
 187 |     |      */
 188 | *   |     function _update(address from, address to, uint256 value) internal virtual {
 189 | *   |         if (from == address(0)) {
 190 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 191 | *   |             _totalSupply += value;
 192 | *   |         } else {
 193 | *   |             uint256 fromBalance = _balances[from];
 194 | *   |             if (fromBalance < value) {
 195 |     |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 196 |     |             }
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 199 | *   |                 _balances[from] = fromBalance - value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 | *   |         if (to == address(0)) {
 204 |     |             unchecked {
 205 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 206 |     |                 _totalSupply -= value;
 207 |     |             }
 208 |     |         } else {
 209 |     |             unchecked {
 210 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 211 | *   |                 _balances[to] += value;
 212 |     |             }
 213 |     |         }
 214 |     | 
 215 | *   |         emit Transfer(from, to, value);
 216 |     |     }
 217 |     | 
 218 |     |     /**
 219 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 220 |     |      * Relies on the `_update` mechanism
 221 |     |      *
 222 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 223 |     |      *
 224 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 225 |     |      */
 226 | *   |     function _mint(address account, uint256 value) internal {
 227 | *   |         if (account == address(0)) {
 228 |     |             revert ERC20InvalidReceiver(address(0));
 229 |     |         }
 230 | *   |         _update(address(0), account, value);
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 235 |     |      * Relies on the `_update` mechanism.
 236 |     |      *
 237 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 238 |     |      *
 239 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 240 |     |      */
 241 |     |     function _burn(address account, uint256 value) internal {
 242 |     |         if (account == address(0)) {
 243 |     |             revert ERC20InvalidSender(address(0));
 244 |     |         }
 245 |     |         _update(account, address(0), value);
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.
 250 |     |      *
 251 |     |      * This internal function is equivalent to `approve`, and can be used to
 252 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 253 |     |      *
 254 |     |      * Emits an {Approval} event.
 255 |     |      *
 256 |     |      * Requirements:
 257 |     |      *
 258 |     |      * - `owner` cannot be the zero address.
 259 |     |      * - `spender` cannot be the zero address.
 260 |     |      *
 261 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 262 |     |      */
 263 | *   |     function _approve(address owner, address spender, uint256 value) internal {
 264 | *   |         _approve(owner, spender, value, true);
 265 |     |     }
 266 |     | 
 267 |     |     /**
 268 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 269 |     |      *
 270 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 271 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 272 |     |      * `Approval` event during `transferFrom` operations.
 273 |     |      *
 274 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 275 |     |      * true using the following override:
 276 |     |      * ```
 277 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 278 |     |      *     super._approve(owner, spender, value, true);
 279 |     |      * }
 280 |     |      * ```
 281 |     |      *
 282 |     |      * Requirements are the same as {_approve}.
 283 |     |      */
 284 | *   |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 285 | *   |         if (owner == address(0)) {
 286 |     |             revert ERC20InvalidApprover(address(0));
 287 |     |         }
 288 | *   |         if (spender == address(0)) {
 289 |     |             revert ERC20InvalidSpender(address(0));
 290 |     |         }
 291 | *   |         _allowances[owner][spender] = value;
 292 | *   |         if (emitEvent) {
 293 | *   |             emit Approval(owner, spender, value);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `value`.
 299 |     |      *
 300 |     |      * Does not update the allowance value in case of infinite allowance.
 301 |     |      * Revert if not enough allowance is available.
 302 |     |      *
 303 |     |      * Does not emit an {Approval} event.
 304 |     |      */
 305 | *   |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 306 | *   |         uint256 currentAllowance = allowance(owner, spender);
 307 | *   |         if (currentAllowance != type(uint256).max) {
 308 |     |             if (currentAllowance < value) {
 309 |     |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 310 |     |             }
 311 |     |             unchecked {
 312 |     |                 _approve(owner, spender, currentAllowance - value, false);
 313 |     |             }
 314 |     |         }
 315 |     |     }
 316 |     | }
 317 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {ERC20} from "../ERC20.sol";
  7 |     | import {Context} from "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys a `value` amount of tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 value) public virtual {
 21 |     |         _burn(_msgSender(), value);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys a `value` amount of tokens from `account`, deducting from
 26 |     |      * the caller's allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `value`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 value) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), value);
 37 |     |         _burn(account, value);
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "../IERC20.sol";
   7 |     | import {IERC20Permit} from "../extensions/IERC20Permit.sol";
   8 |     | import {Address} from "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 | *   | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev An operation with an ERC20 token failed.
  24 |     |      */
  25 |     |     error SafeERC20FailedOperation(address token);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Indicates a failed `decreaseAllowance` request.
  29 |     |      */
  30 |     |     error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  34 |     |      * non-reverting calls are assumed to be successful.
  35 |     |      */
  36 | *   |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  37 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  42 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  43 |     |      */
  44 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  45 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  50 |     |      * non-reverting calls are assumed to be successful.
  51 |     |      */
  52 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  53 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  54 |     |         forceApprove(token, spender, oldAllowance + value);
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
  59 |     |      * value, non-reverting calls are assumed to be successful.
  60 |     |      */
  61 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
  62 |     |         unchecked {
  63 |     |             uint256 currentAllowance = token.allowance(address(this), spender);
  64 |     |             if (currentAllowance < requestedDecrease) {
  65 |     |                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
  66 |     |             }
  67 |     |             forceApprove(token, spender, currentAllowance - requestedDecrease);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  73 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  74 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  75 |     |      */
  76 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  77 |     |         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
  78 |     | 
  79 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  80 |     |             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
  81 |     |             _callOptionalReturn(token, approvalCall);
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
  87 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
  88 |     |      * @param token The token targeted by the call.
  89 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
  90 |     |      */
  91 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
  92 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
  93 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
  94 |     |         // the target address contains contract code and also asserts for success in the low-level call.
  95 |     | 
  96 | *   |         bytes memory returndata = address(token).functionCall(data);
  97 | *   |         if (returndata.length != 0 && !abi.decode(returndata, (bool))) {
  98 |     |             revert SafeERC20FailedOperation(address(token));
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 104 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 105 |     |      * @param token The token targeted by the call.
 106 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 107 |     |      *
 108 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 109 |     |      */
 110 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 111 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 112 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 113 |     |         // and not revert is the subcall reverts.
 114 |     | 
 115 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 116 |     |         return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;
 117 |     |     }
 118 |     | }
 119 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC165} from "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
  51 |     |      *   a safe transfer.
  52 |     |      *
  53 |     |      * Emits a {Transfer} event.
  54 |     |      */
  55 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  59 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  60 |     |      *
  61 |     |      * Requirements:
  62 |     |      *
  63 |     |      * - `from` cannot be the zero address.
  64 |     |      * - `to` cannot be the zero address.
  65 |     |      * - `tokenId` token must exist and be owned by `from`.
  66 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or
  67 |     |      *   {setApprovalForAll}.
  68 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon
  69 |     |      *   a safe transfer.
  70 |     |      *
  71 |     |      * Emits a {Transfer} event.
  72 |     |      */
  73 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  77 |     |      *
  78 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  79 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  80 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `from` cannot be the zero address.
  85 |     |      * - `to` cannot be the zero address.
  86 |     |      * - `tokenId` token must be owned by `from`.
  87 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  88 |     |      *
  89 |     |      * Emits a {Transfer} event.
  90 |     |      */
  91 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
  95 |     |      * The approval is cleared when the token is transferred.
  96 |     |      *
  97 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
  98 |     |      *
  99 |     |      * Requirements:
 100 |     |      *
 101 |     |      * - The caller must own the token or be an approved operator.
 102 |     |      * - `tokenId` must exist.
 103 |     |      *
 104 |     |      * Emits an {Approval} event.
 105 |     |      */
 106 |     |     function approve(address to, uint256 tokenId) external;
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 110 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 111 |     |      *
 112 |     |      * Requirements:
 113 |     |      *
 114 |     |      * - The `operator` cannot be the address zero.
 115 |     |      *
 116 |     |      * Emits an {ApprovalForAll} event.
 117 |     |      */
 118 |     |     function setApprovalForAll(address operator, bool approved) external;
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Returns the account approved for `tokenId` token.
 122 |     |      *
 123 |     |      * Requirements:
 124 |     |      *
 125 |     |      * - `tokenId` must exist.
 126 |     |      */
 127 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 131 |     |      *
 132 |     |      * See {setApprovalForAll}
 133 |     |      */
 134 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 135 |     | }
 136 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be
 18 |     |      * reverted.
 19 |     |      *
 20 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 21 |     |      */
 22 |     |     function onERC721Received(
 23 |     |         address operator,
 24 |     |         address from,
 25 |     |         uint256 tokenId,
 26 |     |         bytes calldata data
 27 |     |     ) external returns (bytes4);
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC721Receiver} from "../IERC721Receiver.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC721Receiver} interface.
 10 |     |  *
 11 |     |  * Accepts all token transfers.
 12 |     |  * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or
 13 |     |  * {IERC721-setApprovalForAll}.
 14 |     |  */
 15 |     | abstract contract ERC721Holder is IERC721Receiver {
 16 |     |     /**
 17 |     |      * @dev See {IERC721Receiver-onERC721Received}.
 18 |     |      *
 19 |     |      * Always returns `IERC721Receiver.onERC721Received.selector`.
 20 |     |      */
 21 |     |     function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {
 22 |     |         return this.onERC721Received.selector;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 | *   | library Address {
  10 |     |     /**
  11 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
  12 |     |      */
  13 |     |     error AddressInsufficientBalance(address account);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev There's no code at `target` (it is not a contract).
  17 |     |      */
  18 |     |     error AddressEmptyCode(address target);
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev A call to an address target failed. The target may have reverted.
  22 |     |      */
  23 |     |     error FailedInnerCall();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  27 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  28 |     |      *
  29 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  30 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  31 |     |      * imposed by `transfer`, making them unable to receive funds via
  32 |     |      * `transfer`. {sendValue} removes this limitation.
  33 |     |      *
  34 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  35 |     |      *
  36 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  37 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  38 |     |      * {ReentrancyGuard} or the
  39 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  40 |     |      */
  41 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  42 |     |         if (address(this).balance < amount) {
  43 |     |             revert AddressInsufficientBalance(address(this));
  44 |     |         }
  45 |     | 
  46 |     |         (bool success, ) = recipient.call{value: amount}("");
  47 |     |         if (!success) {
  48 |     |             revert FailedInnerCall();
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  54 |     |      * plain `call` is an unsafe replacement for a function call: use this
  55 |     |      * function instead.
  56 |     |      *
  57 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  58 |     |      * up by this function (like regular Solidity function calls). However, if
  59 |     |      * the call reverted with no returned reason, this function reverts with a
  60 |     |      * {FailedInnerCall} error.
  61 |     |      *
  62 |     |      * Returns the raw returned data. To convert to the expected return value,
  63 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  64 |     |      *
  65 |     |      * Requirements:
  66 |     |      *
  67 |     |      * - `target` must be a contract.
  68 |     |      * - calling `target` with `data` must not revert.
  69 |     |      */
  70 | *   |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  71 | *   |         return functionCallWithValue(target, data, 0);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  76 |     |      * but also transferring `value` wei to `target`.
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - the calling contract must have an ETH balance of at least `value`.
  81 |     |      * - the called Solidity function must be `payable`.
  82 |     |      */
  83 | *   |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  84 | *   |         if (address(this).balance < value) {
  85 |     |             revert AddressInsufficientBalance(address(this));
  86 |     |         }
  87 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  88 | *   |         return verifyCallResultFromTarget(target, success, returndata);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  93 |     |      * but performing a static call.
  94 |     |      */
  95 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  96 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  97 |     |         return verifyCallResultFromTarget(target, success, returndata);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 102 |     |      * but performing a delegate call.
 103 |     |      */
 104 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 105 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 106 |     |         return verifyCallResultFromTarget(target, success, returndata);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 111 |     |      * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
 112 |     |      * unsuccessful call.
 113 |     |      */
 114 | *   |     function verifyCallResultFromTarget(
 115 |     |         address target,
 116 |     |         bool success,
 117 |     |         bytes memory returndata
 118 | *   |     ) internal view returns (bytes memory) {
 119 | *   |         if (!success) {
 120 |     |             _revert(returndata);
 121 |     |         } else {
 122 |     |             // only check if target is a contract if the call was successful and the return data is empty
 123 |     |             // otherwise we already know that it was a contract
 124 | *   |             if (returndata.length == 0 && target.code.length == 0) {
 125 |     |                 revert AddressEmptyCode(target);
 126 |     |             }
 127 | *   |             return returndata;
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 133 |     |      * revert reason or with a default {FailedInnerCall} error.
 134 |     |      */
 135 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 136 |     |         if (!success) {
 137 |     |             _revert(returndata);
 138 |     |         } else {
 139 |     |             return returndata;
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
 145 |     |      */
 146 |     |     function _revert(bytes memory returndata) private pure {
 147 |     |         // Look for revert reason and bubble it up if present
 148 |     |         if (returndata.length > 0) {
 149 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 150 |     |             /// @solidity memory-safe-assembly
 151 |     |             assembly {
 152 |     |                 let returndata_size := mload(returndata)
 153 |     |                 revert(add(32, returndata), returndata_size)
 154 |     |             }
 155 |     |         } else {
 156 |     |             revert FailedInnerCall();
 157 |     |         }
 158 |     |     }
 159 |     | }
 160 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {Math} from "./math/Math.sol";
  7 |     | import {SignedMath} from "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 | *   | library Strings {
 13 |     |     bytes16 private constant HEX_DIGITS = "0123456789abcdef";
 14 |     |     uint8 private constant ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev The `value` string doesn't fit in the specified `length`.
 18 |     |      */
 19 |     |     error StringsInsufficientHexLength(uint256 value, uint256 length);
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 23 |     |      */
 24 |     |     function toString(uint256 value) internal pure returns (string memory) {
 25 |     |         unchecked {
 26 |     |             uint256 length = Math.log10(value) + 1;
 27 |     |             string memory buffer = new string(length);
 28 |     |             uint256 ptr;
 29 |     |             /// @solidity memory-safe-assembly
 30 |     |             assembly {
 31 |     |                 ptr := add(buffer, add(32, length))
 32 |     |             }
 33 |     |             while (true) {
 34 |     |                 ptr--;
 35 |     |                 /// @solidity memory-safe-assembly
 36 |     |                 assembly {
 37 |     |                     mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))
 38 |     |                 }
 39 |     |                 value /= 10;
 40 |     |                 if (value == 0) break;
 41 |     |             }
 42 |     |             return buffer;
 43 |     |         }
 44 |     |     }
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 48 |     |      */
 49 |     |     function toStringSigned(int256 value) internal pure returns (string memory) {
 50 |     |         return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));
 51 |     |     }
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 55 |     |      */
 56 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 57 |     |         unchecked {
 58 |     |             return toHexString(value, Math.log256(value) + 1);
 59 |     |         }
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 64 |     |      */
 65 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 66 |     |         uint256 localValue = value;
 67 |     |         bytes memory buffer = new bytes(2 * length + 2);
 68 |     |         buffer[0] = "0";
 69 |     |         buffer[1] = "x";
 70 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 71 |     |             buffer[i] = HEX_DIGITS[localValue & 0xf];
 72 |     |             localValue >>= 4;
 73 |     |         }
 74 |     |         if (localValue != 0) {
 75 |     |             revert StringsInsufficientHexLength(value, length);
 76 |     |         }
 77 |     |         return string(buffer);
 78 |     |     }
 79 |     | 
 80 |     |     /**
 81 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal
 82 |     |      * representation.
 83 |     |      */
 84 |     |     function toHexString(address addr) internal pure returns (string memory) {
 85 |     |         return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);
 86 |     |     }
 87 |     | 
 88 |     |     /**
 89 |     |      * @dev Returns true if the two strings are equal.
 90 |     |      */
 91 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 92 |     |         return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));
 93 |     |     }
 94 |     | }
 95 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
   8 |     |  *
   9 |     |  * These functions can be used to verify that a message was signed by the holder
  10 |     |  * of the private keys of a given address.
  11 |     |  */
  12 | *   | library ECDSA {
  13 |     |     enum RecoverError {
  14 |     |         NoError,
  15 |     |         InvalidSignature,
  16 |     |         InvalidSignatureLength,
  17 |     |         InvalidSignatureS
  18 |     |     }
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev The signature derives the `address(0)`.
  22 |     |      */
  23 |     |     error ECDSAInvalidSignature();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev The signature has an invalid length.
  27 |     |      */
  28 |     |     error ECDSAInvalidSignatureLength(uint256 length);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev The signature has an S value that is in the upper half order.
  32 |     |      */
  33 |     |     error ECDSAInvalidSignatureS(bytes32 s);
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not
  37 |     |      * return address(0) without also returning an error description. Errors are documented using an enum (error type)
  38 |     |      * and a bytes32 providing additional information about the error.
  39 |     |      *
  40 |     |      * If no error is returned, then the address can be used for verification purposes.
  41 |     |      *
  42 |     |      * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
  43 |     |      * this function rejects them by requiring the `s` value to be in the lower
  44 |     |      * half order, and the `v` value to be either 27 or 28.
  45 |     |      *
  46 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  47 |     |      * verification to be secure: it is possible to craft signatures that
  48 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  49 |     |      * this is by receiving a hash of the original message (which may otherwise
  50 |     |      * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
  51 |     |      *
  52 |     |      * Documentation for signature generation:
  53 |     |      * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
  54 |     |      * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
  55 |     |      */
  56 |     |     function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {
  57 |     |         if (signature.length == 65) {
  58 |     |             bytes32 r;
  59 |     |             bytes32 s;
  60 |     |             uint8 v;
  61 |     |             // ecrecover takes the signature parameters, and the only way to get them
  62 |     |             // currently is to use assembly.
  63 |     |             /// @solidity memory-safe-assembly
  64 |     |             assembly {
  65 |     |                 r := mload(add(signature, 0x20))
  66 |     |                 s := mload(add(signature, 0x40))
  67 |     |                 v := byte(0, mload(add(signature, 0x60)))
  68 |     |             }
  69 |     |             return tryRecover(hash, v, r, s);
  70 |     |         } else {
  71 |     |             return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));
  72 |     |         }
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  77 |     |      * `signature`. This address can then be used for verification purposes.
  78 |     |      *
  79 |     |      * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:
  80 |     |      * this function rejects them by requiring the `s` value to be in the lower
  81 |     |      * half order, and the `v` value to be either 27 or 28.
  82 |     |      *
  83 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  84 |     |      * verification to be secure: it is possible to craft signatures that
  85 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  86 |     |      * this is by receiving a hash of the original message (which may otherwise
  87 |     |      * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.
  88 |     |      */
  89 |     |     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
  90 |     |         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);
  91 |     |         _throwError(error, errorArg);
  92 |     |         return recovered;
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
  97 |     |      *
  98 |     |      * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
  99 |     |      */
 100 |     |     function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {
 101 |     |         unchecked {
 102 |     |             bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 103 |     |             // We do not check for an overflow here since the shift operation results in 0 or 1.
 104 |     |             uint8 v = uint8((uint256(vs) >> 255) + 27);
 105 |     |             return tryRecover(hash, v, r, s);
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
 111 |     |      */
 112 |     |     function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
 113 |     |         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);
 114 |     |         _throwError(error, errorArg);
 115 |     |         return recovered;
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
 120 |     |      * `r` and `s` signature fields separately.
 121 |     |      */
 122 |     |     function tryRecover(
 123 |     |         bytes32 hash,
 124 |     |         uint8 v,
 125 |     |         bytes32 r,
 126 |     |         bytes32 s
 127 |     |     ) internal pure returns (address, RecoverError, bytes32) {
 128 |     |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
 129 |     |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 130 |     |         // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
 131 |     |         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
 132 |     |         //
 133 |     |         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
 134 |     |         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
 135 |     |         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
 136 |     |         // these malleable signatures as well.
 137 |     |         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
 138 |     |             return (address(0), RecoverError.InvalidSignatureS, s);
 139 |     |         }
 140 |     | 
 141 |     |         // If the signature is valid (and not malleable), return the signer address
 142 |     |         address signer = ecrecover(hash, v, r, s);
 143 |     |         if (signer == address(0)) {
 144 |     |             return (address(0), RecoverError.InvalidSignature, bytes32(0));
 145 |     |         }
 146 |     | 
 147 |     |         return (signer, RecoverError.NoError, bytes32(0));
 148 |     |     }
 149 |     | 
 150 |     |     /**
 151 |     |      * @dev Overload of {ECDSA-recover} that receives the `v`,
 152 |     |      * `r` and `s` signature fields separately.
 153 |     |      */
 154 |     |     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
 155 |     |         (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);
 156 |     |         _throwError(error, errorArg);
 157 |     |         return recovered;
 158 |     |     }
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.
 162 |     |      */
 163 |     |     function _throwError(RecoverError error, bytes32 errorArg) private pure {
 164 |     |         if (error == RecoverError.NoError) {
 165 |     |             return; // no error: do nothing
 166 |     |         } else if (error == RecoverError.InvalidSignature) {
 167 |     |             revert ECDSAInvalidSignature();
 168 |     |         } else if (error == RecoverError.InvalidSignatureLength) {
 169 |     |             revert ECDSAInvalidSignatureLength(uint256(errorArg));
 170 |     |         } else if (error == RecoverError.InvalidSignatureS) {
 171 |     |             revert ECDSAInvalidSignatureS(errorArg);
 172 |     |         }
 173 |     |     }
 174 |     | }
 175 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {Strings} from "../Strings.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.
 10 |     |  *
 11 |     |  * The library provides methods for generating a hash of a message that conforms to the
 12 |     |  * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]
 13 |     |  * specifications.
 14 |     |  */
 15 | *   | library MessageHashUtils {
 16 |     |     /**
 17 |     |      * @dev Returns the keccak256 digest of an EIP-191 signed data with version
 18 |     |      * `0x45` (`personal_sign` messages).
 19 |     |      *
 20 |     |      * The digest is calculated by prefixing a bytes32 `messageHash` with
 21 |     |      * `"\x19Ethereum Signed Message:\n32"` and hashing the result. It corresponds with the
 22 |     |      * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.
 23 |     |      *
 24 |     |      * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with
 25 |     |      * keccak256, although any bytes32 value can be safely used because the final digest will
 26 |     |      * be re-hashed.
 27 |     |      *
 28 |     |      * See {ECDSA-recover}.
 29 |     |      */
 30 |     |     function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {
 31 |     |         /// @solidity memory-safe-assembly
 32 |     |         assembly {
 33 |     |             mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
 34 |     |             mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
 35 |     |             digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
 36 |     |         }
 37 |     |     }
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Returns the keccak256 digest of an EIP-191 signed data with version
 41 |     |      * `0x45` (`personal_sign` messages).
 42 |     |      *
 43 |     |      * The digest is calculated by prefixing an arbitrary `message` with
 44 |     |      * `"\x19Ethereum Signed Message:\n" + len(message)` and hashing the result. It corresponds with the
 45 |     |      * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.
 46 |     |      *
 47 |     |      * See {ECDSA-recover}.
 48 |     |      */
 49 |     |     function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {
 50 |     |         return
 51 |     |             keccak256(bytes.concat("\x19Ethereum Signed Message:\n", bytes(Strings.toString(message.length)), message));
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Returns the keccak256 digest of an EIP-191 signed data with version
 56 |     |      * `0x00` (data with intended validator).
 57 |     |      *
 58 |     |      * The digest is calculated by prefixing an arbitrary `data` with `"\x19\x00"` and the intended
 59 |     |      * `validator` address. Then hashing the result.
 60 |     |      *
 61 |     |      * See {ECDSA-recover}.
 62 |     |      */
 63 |     |     function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {
 64 |     |         return keccak256(abi.encodePacked(hex"19_00", validator, data));
 65 |     |     }
 66 |     | 
 67 |     |     /**
 68 |     |      * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).
 69 |     |      *
 70 |     |      * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with
 71 |     |      * `\x19\x01` and hashing the result. It corresponds to the hash signed by the
 72 |     |      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.
 73 |     |      *
 74 |     |      * See {ECDSA-recover}.
 75 |     |      */
 76 |     |     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {
 77 |     |         /// @solidity memory-safe-assembly
 78 |     |         assembly {
 79 |     |             let ptr := mload(0x40)
 80 |     |             mstore(ptr, hex"19_01")
 81 |     |             mstore(add(ptr, 0x02), domainSeparator)
 82 |     |             mstore(add(ptr, 0x22), structHash)
 83 |     |             digest := keccak256(ptr, 0x42)
 84 |     |         }
 85 |     |     }
 86 |     | }
 87 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  */
 20 |     | abstract contract ERC165 is IERC165 {
 21 |     |     /**
 22 |     |      * @dev See {IERC165-supportsInterface}.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 25 |     |         return interfaceId == type(IERC165).interfaceId;
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 | *   | library Math {
  10 |     |     /**
  11 |     |      * @dev Muldiv operation overflow.
  12 |     |      */
  13 |     |     error MathOverflowedMulDiv();
  14 |     | 
  15 |     |     enum Rounding {
  16 |     |         Floor, // Toward negative infinity
  17 |     |         Ceil, // Toward positive infinity
  18 |     |         Trunc, // Toward zero
  19 |     |         Expand // Away from zero
  20 |     |     }
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Returns the addition of two unsigned integers, with an overflow flag.
  24 |     |      */
  25 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  26 |     |         unchecked {
  27 |     |             uint256 c = a + b;
  28 |     |             if (c < a) return (false, 0);
  29 |     |             return (true, c);
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
  35 |     |      */
  36 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  37 |     |         unchecked {
  38 |     |             if (b > a) return (false, 0);
  39 |     |             return (true, a - b);
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
  45 |     |      */
  46 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  47 |     |         unchecked {
  48 |     |             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  49 |     |             // benefit is lost if 'b' is also tested.
  50 |     |             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  51 |     |             if (a == 0) return (true, 0);
  52 |     |             uint256 c = a * b;
  53 |     |             if (c / a != b) return (false, 0);
  54 |     |             return (true, c);
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Returns the division of two unsigned integers, with a division by zero flag.
  60 |     |      */
  61 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  62 |     |         unchecked {
  63 |     |             if (b == 0) return (false, 0);
  64 |     |             return (true, a / b);
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
  70 |     |      */
  71 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  72 |     |         unchecked {
  73 |     |             if (b == 0) return (false, 0);
  74 |     |             return (true, a % b);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the largest of two numbers.
  80 |     |      */
  81 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  82 |     |         return a > b ? a : b;
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Returns the smallest of two numbers.
  87 |     |      */
  88 | *   |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  89 | *   |         return a < b ? a : b;
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  94 |     |      * zero.
  95 |     |      */
  96 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  97 |     |         // (a + b) / 2 can overflow.
  98 |     |         return (a & b) + (a ^ b) / 2;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns the ceiling of the division of two numbers.
 103 |     |      *
 104 |     |      * This differs from standard division with `/` in that it rounds towards infinity instead
 105 |     |      * of rounding towards zero.
 106 |     |      */
 107 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
 108 |     |         if (b == 0) {
 109 |     |             // Guarantee the same behavior as in a regular Solidity division.
 110 |     |             return a / b;
 111 |     |         }
 112 |     | 
 113 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
 114 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
 119 |     |      * denominator == 0.
 120 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
 121 |     |      * Uniswap Labs also under MIT license.
 122 |     |      */
 123 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
 124 |     |         unchecked {
 125 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
 126 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
 127 |     |             // variables such that product = prod1 * 2^256 + prod0.
 128 |     |             uint256 prod0 = x * y; // Least significant 256 bits of the product
 129 |     |             uint256 prod1; // Most significant 256 bits of the product
 130 |     |             assembly {
 131 |     |                 let mm := mulmod(x, y, not(0))
 132 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
 133 |     |             }
 134 |     | 
 135 |     |             // Handle non-overflow cases, 256 by 256 division.
 136 |     |             if (prod1 == 0) {
 137 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
 138 |     |                 // The surrounding unchecked block does not change this fact.
 139 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
 140 |     |                 return prod0 / denominator;
 141 |     |             }
 142 |     | 
 143 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
 144 |     |             if (denominator <= prod1) {
 145 |     |                 revert MathOverflowedMulDiv();
 146 |     |             }
 147 |     | 
 148 |     |             ///////////////////////////////////////////////
 149 |     |             // 512 by 256 division.
 150 |     |             ///////////////////////////////////////////////
 151 |     | 
 152 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
 153 |     |             uint256 remainder;
 154 |     |             assembly {
 155 |     |                 // Compute remainder using mulmod.
 156 |     |                 remainder := mulmod(x, y, denominator)
 157 |     | 
 158 |     |                 // Subtract 256 bit number from 512 bit number.
 159 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
 160 |     |                 prod0 := sub(prod0, remainder)
 161 |     |             }
 162 |     | 
 163 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
 164 |     |             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.
 165 |     | 
 166 |     |             uint256 twos = denominator & (0 - denominator);
 167 |     |             assembly {
 168 |     |                 // Divide denominator by twos.
 169 |     |                 denominator := div(denominator, twos)
 170 |     | 
 171 |     |                 // Divide [prod1 prod0] by twos.
 172 |     |                 prod0 := div(prod0, twos)
 173 |     | 
 174 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 175 |     |                 twos := add(div(sub(0, twos), twos), 1)
 176 |     |             }
 177 |     | 
 178 |     |             // Shift in bits from prod1 into prod0.
 179 |     |             prod0 |= prod1 * twos;
 180 |     | 
 181 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 182 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 183 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 184 |     |             uint256 inverse = (3 * denominator) ^ 2;
 185 |     | 
 186 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
 187 |     |             // works in modular arithmetic, doubling the correct bits in each step.
 188 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 189 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 190 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 191 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 192 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 193 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 194 |     | 
 195 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 196 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 197 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 198 |     |             // is no longer required.
 199 |     |             result = prod0 * inverse;
 200 |     |             return result;
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 206 |     |      */
 207 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 208 |     |         uint256 result = mulDiv(x, y, denominator);
 209 |     |         if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {
 210 |     |             result += 1;
 211 |     |         }
 212 |     |         return result;
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
 217 |     |      * towards zero.
 218 |     |      *
 219 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 220 |     |      */
 221 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 222 |     |         if (a == 0) {
 223 |     |             return 0;
 224 |     |         }
 225 |     | 
 226 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 227 |     |         //
 228 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 229 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 230 |     |         //
 231 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 232 |     |         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 233 |     |         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 234 |     |         //
 235 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 236 |     |         uint256 result = 1 << (log2(a) >> 1);
 237 |     | 
 238 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 239 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 240 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 241 |     |         // into the expected uint128 result.
 242 |     |         unchecked {
 243 |     |             result = (result + a / result) >> 1;
 244 |     |             result = (result + a / result) >> 1;
 245 |     |             result = (result + a / result) >> 1;
 246 |     |             result = (result + a / result) >> 1;
 247 |     |             result = (result + a / result) >> 1;
 248 |     |             result = (result + a / result) >> 1;
 249 |     |             result = (result + a / result) >> 1;
 250 |     |             return min(result, a / result);
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 256 |     |      */
 257 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 258 |     |         unchecked {
 259 |     |             uint256 result = sqrt(a);
 260 |     |             return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);
 261 |     |         }
 262 |     |     }
 263 |     | 
 264 |     |     /**
 265 |     |      * @dev Return the log in base 2 of a positive value rounded towards zero.
 266 |     |      * Returns 0 if given 0.
 267 |     |      */
 268 |     |     function log2(uint256 value) internal pure returns (uint256) {
 269 |     |         uint256 result = 0;
 270 |     |         unchecked {
 271 |     |             if (value >> 128 > 0) {
 272 |     |                 value >>= 128;
 273 |     |                 result += 128;
 274 |     |             }
 275 |     |             if (value >> 64 > 0) {
 276 |     |                 value >>= 64;
 277 |     |                 result += 64;
 278 |     |             }
 279 |     |             if (value >> 32 > 0) {
 280 |     |                 value >>= 32;
 281 |     |                 result += 32;
 282 |     |             }
 283 |     |             if (value >> 16 > 0) {
 284 |     |                 value >>= 16;
 285 |     |                 result += 16;
 286 |     |             }
 287 |     |             if (value >> 8 > 0) {
 288 |     |                 value >>= 8;
 289 |     |                 result += 8;
 290 |     |             }
 291 |     |             if (value >> 4 > 0) {
 292 |     |                 value >>= 4;
 293 |     |                 result += 4;
 294 |     |             }
 295 |     |             if (value >> 2 > 0) {
 296 |     |                 value >>= 2;
 297 |     |                 result += 2;
 298 |     |             }
 299 |     |             if (value >> 1 > 0) {
 300 |     |                 result += 1;
 301 |     |             }
 302 |     |         }
 303 |     |         return result;
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 308 |     |      * Returns 0 if given 0.
 309 |     |      */
 310 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 311 |     |         unchecked {
 312 |     |             uint256 result = log2(value);
 313 |     |             return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);
 314 |     |         }
 315 |     |     }
 316 |     | 
 317 |     |     /**
 318 |     |      * @dev Return the log in base 10 of a positive value rounded towards zero.
 319 |     |      * Returns 0 if given 0.
 320 |     |      */
 321 |     |     function log10(uint256 value) internal pure returns (uint256) {
 322 |     |         uint256 result = 0;
 323 |     |         unchecked {
 324 |     |             if (value >= 10 ** 64) {
 325 |     |                 value /= 10 ** 64;
 326 |     |                 result += 64;
 327 |     |             }
 328 |     |             if (value >= 10 ** 32) {
 329 |     |                 value /= 10 ** 32;
 330 |     |                 result += 32;
 331 |     |             }
 332 |     |             if (value >= 10 ** 16) {
 333 |     |                 value /= 10 ** 16;
 334 |     |                 result += 16;
 335 |     |             }
 336 |     |             if (value >= 10 ** 8) {
 337 |     |                 value /= 10 ** 8;
 338 |     |                 result += 8;
 339 |     |             }
 340 |     |             if (value >= 10 ** 4) {
 341 |     |                 value /= 10 ** 4;
 342 |     |                 result += 4;
 343 |     |             }
 344 |     |             if (value >= 10 ** 2) {
 345 |     |                 value /= 10 ** 2;
 346 |     |                 result += 2;
 347 |     |             }
 348 |     |             if (value >= 10 ** 1) {
 349 |     |                 result += 1;
 350 |     |             }
 351 |     |         }
 352 |     |         return result;
 353 |     |     }
 354 |     | 
 355 |     |     /**
 356 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 357 |     |      * Returns 0 if given 0.
 358 |     |      */
 359 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 360 |     |         unchecked {
 361 |     |             uint256 result = log10(value);
 362 |     |             return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);
 363 |     |         }
 364 |     |     }
 365 |     | 
 366 |     |     /**
 367 |     |      * @dev Return the log in base 256 of a positive value rounded towards zero.
 368 |     |      * Returns 0 if given 0.
 369 |     |      *
 370 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 371 |     |      */
 372 |     |     function log256(uint256 value) internal pure returns (uint256) {
 373 |     |         uint256 result = 0;
 374 |     |         unchecked {
 375 |     |             if (value >> 128 > 0) {
 376 |     |                 value >>= 128;
 377 |     |                 result += 16;
 378 |     |             }
 379 |     |             if (value >> 64 > 0) {
 380 |     |                 value >>= 64;
 381 |     |                 result += 8;
 382 |     |             }
 383 |     |             if (value >> 32 > 0) {
 384 |     |                 value >>= 32;
 385 |     |                 result += 4;
 386 |     |             }
 387 |     |             if (value >> 16 > 0) {
 388 |     |                 value >>= 16;
 389 |     |                 result += 2;
 390 |     |             }
 391 |     |             if (value >> 8 > 0) {
 392 |     |                 result += 1;
 393 |     |             }
 394 |     |         }
 395 |     |         return result;
 396 |     |     }
 397 |     | 
 398 |     |     /**
 399 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 400 |     |      * Returns 0 if given 0.
 401 |     |      */
 402 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 403 |     |         unchecked {
 404 |     |             uint256 result = log256(value);
 405 |     |             return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);
 406 |     |         }
 407 |     |     }
 408 |     | 
 409 |     |     /**
 410 |     |      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
 411 |     |      */
 412 |     |     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
 413 |     |         return uint8(rounding) % 2 == 1;
 414 |     |     }
 415 |     | }
 416 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)
    3 |     | // This file was procedurally generated from scripts/generate/templates/SafeCast.js.
    4 |     | 
    5 |     | pragma solidity ^0.8.20;
    6 |     | 
    7 |     | /**
    8 |     |  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
    9 |     |  * checks.
   10 |     |  *
   11 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
   12 |     |  * easily result in undesired exploitation or bugs, since developers usually
   13 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
   14 |     |  * reverting the transaction when such an operation overflows.
   15 |     |  *
   16 |     |  * Using this library instead of the unchecked operations eliminates an entire
   17 |     |  * class of bugs, so it's recommended to use it always.
   18 |     |  */
   19 | *   | library SafeCast {
   20 |     |     /**
   21 |     |      * @dev Value doesn't fit in an uint of `bits` size.
   22 |     |      */
   23 |     |     error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
   24 |     | 
   25 |     |     /**
   26 |     |      * @dev An int value doesn't fit in an uint of `bits` size.
   27 |     |      */
   28 |     |     error SafeCastOverflowedIntToUint(int256 value);
   29 |     | 
   30 |     |     /**
   31 |     |      * @dev Value doesn't fit in an int of `bits` size.
   32 |     |      */
   33 |     |     error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);
   34 |     | 
   35 |     |     /**
   36 |     |      * @dev An uint value doesn't fit in an int of `bits` size.
   37 |     |      */
   38 |     |     error SafeCastOverflowedUintToInt(uint256 value);
   39 |     | 
   40 |     |     /**
   41 |     |      * @dev Returns the downcasted uint248 from uint256, reverting on
   42 |     |      * overflow (when the input is greater than largest uint248).
   43 |     |      *
   44 |     |      * Counterpart to Solidity's `uint248` operator.
   45 |     |      *
   46 |     |      * Requirements:
   47 |     |      *
   48 |     |      * - input must fit into 248 bits
   49 |     |      */
   50 |     |     function toUint248(uint256 value) internal pure returns (uint248) {
   51 |     |         if (value > type(uint248).max) {
   52 |     |             revert SafeCastOverflowedUintDowncast(248, value);
   53 |     |         }
   54 |     |         return uint248(value);
   55 |     |     }
   56 |     | 
   57 |     |     /**
   58 |     |      * @dev Returns the downcasted uint240 from uint256, reverting on
   59 |     |      * overflow (when the input is greater than largest uint240).
   60 |     |      *
   61 |     |      * Counterpart to Solidity's `uint240` operator.
   62 |     |      *
   63 |     |      * Requirements:
   64 |     |      *
   65 |     |      * - input must fit into 240 bits
   66 |     |      */
   67 |     |     function toUint240(uint256 value) internal pure returns (uint240) {
   68 |     |         if (value > type(uint240).max) {
   69 |     |             revert SafeCastOverflowedUintDowncast(240, value);
   70 |     |         }
   71 |     |         return uint240(value);
   72 |     |     }
   73 |     | 
   74 |     |     /**
   75 |     |      * @dev Returns the downcasted uint232 from uint256, reverting on
   76 |     |      * overflow (when the input is greater than largest uint232).
   77 |     |      *
   78 |     |      * Counterpart to Solidity's `uint232` operator.
   79 |     |      *
   80 |     |      * Requirements:
   81 |     |      *
   82 |     |      * - input must fit into 232 bits
   83 |     |      */
   84 |     |     function toUint232(uint256 value) internal pure returns (uint232) {
   85 |     |         if (value > type(uint232).max) {
   86 |     |             revert SafeCastOverflowedUintDowncast(232, value);
   87 |     |         }
   88 |     |         return uint232(value);
   89 |     |     }
   90 |     | 
   91 |     |     /**
   92 |     |      * @dev Returns the downcasted uint224 from uint256, reverting on
   93 |     |      * overflow (when the input is greater than largest uint224).
   94 |     |      *
   95 |     |      * Counterpart to Solidity's `uint224` operator.
   96 |     |      *
   97 |     |      * Requirements:
   98 |     |      *
   99 |     |      * - input must fit into 224 bits
  100 |     |      */
  101 |     |     function toUint224(uint256 value) internal pure returns (uint224) {
  102 |     |         if (value > type(uint224).max) {
  103 |     |             revert SafeCastOverflowedUintDowncast(224, value);
  104 |     |         }
  105 |     |         return uint224(value);
  106 |     |     }
  107 |     | 
  108 |     |     /**
  109 |     |      * @dev Returns the downcasted uint216 from uint256, reverting on
  110 |     |      * overflow (when the input is greater than largest uint216).
  111 |     |      *
  112 |     |      * Counterpart to Solidity's `uint216` operator.
  113 |     |      *
  114 |     |      * Requirements:
  115 |     |      *
  116 |     |      * - input must fit into 216 bits
  117 |     |      */
  118 |     |     function toUint216(uint256 value) internal pure returns (uint216) {
  119 |     |         if (value > type(uint216).max) {
  120 |     |             revert SafeCastOverflowedUintDowncast(216, value);
  121 |     |         }
  122 |     |         return uint216(value);
  123 |     |     }
  124 |     | 
  125 |     |     /**
  126 |     |      * @dev Returns the downcasted uint208 from uint256, reverting on
  127 |     |      * overflow (when the input is greater than largest uint208).
  128 |     |      *
  129 |     |      * Counterpart to Solidity's `uint208` operator.
  130 |     |      *
  131 |     |      * Requirements:
  132 |     |      *
  133 |     |      * - input must fit into 208 bits
  134 |     |      */
  135 |     |     function toUint208(uint256 value) internal pure returns (uint208) {
  136 |     |         if (value > type(uint208).max) {
  137 |     |             revert SafeCastOverflowedUintDowncast(208, value);
  138 |     |         }
  139 |     |         return uint208(value);
  140 |     |     }
  141 |     | 
  142 |     |     /**
  143 |     |      * @dev Returns the downcasted uint200 from uint256, reverting on
  144 |     |      * overflow (when the input is greater than largest uint200).
  145 |     |      *
  146 |     |      * Counterpart to Solidity's `uint200` operator.
  147 |     |      *
  148 |     |      * Requirements:
  149 |     |      *
  150 |     |      * - input must fit into 200 bits
  151 |     |      */
  152 |     |     function toUint200(uint256 value) internal pure returns (uint200) {
  153 |     |         if (value > type(uint200).max) {
  154 |     |             revert SafeCastOverflowedUintDowncast(200, value);
  155 |     |         }
  156 |     |         return uint200(value);
  157 |     |     }
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the downcasted uint192 from uint256, reverting on
  161 |     |      * overflow (when the input is greater than largest uint192).
  162 |     |      *
  163 |     |      * Counterpart to Solidity's `uint192` operator.
  164 |     |      *
  165 |     |      * Requirements:
  166 |     |      *
  167 |     |      * - input must fit into 192 bits
  168 |     |      */
  169 |     |     function toUint192(uint256 value) internal pure returns (uint192) {
  170 |     |         if (value > type(uint192).max) {
  171 |     |             revert SafeCastOverflowedUintDowncast(192, value);
  172 |     |         }
  173 |     |         return uint192(value);
  174 |     |     }
  175 |     | 
  176 |     |     /**
  177 |     |      * @dev Returns the downcasted uint184 from uint256, reverting on
  178 |     |      * overflow (when the input is greater than largest uint184).
  179 |     |      *
  180 |     |      * Counterpart to Solidity's `uint184` operator.
  181 |     |      *
  182 |     |      * Requirements:
  183 |     |      *
  184 |     |      * - input must fit into 184 bits
  185 |     |      */
  186 |     |     function toUint184(uint256 value) internal pure returns (uint184) {
  187 |     |         if (value > type(uint184).max) {
  188 |     |             revert SafeCastOverflowedUintDowncast(184, value);
  189 |     |         }
  190 |     |         return uint184(value);
  191 |     |     }
  192 |     | 
  193 |     |     /**
  194 |     |      * @dev Returns the downcasted uint176 from uint256, reverting on
  195 |     |      * overflow (when the input is greater than largest uint176).
  196 |     |      *
  197 |     |      * Counterpart to Solidity's `uint176` operator.
  198 |     |      *
  199 |     |      * Requirements:
  200 |     |      *
  201 |     |      * - input must fit into 176 bits
  202 |     |      */
  203 |     |     function toUint176(uint256 value) internal pure returns (uint176) {
  204 |     |         if (value > type(uint176).max) {
  205 |     |             revert SafeCastOverflowedUintDowncast(176, value);
  206 |     |         }
  207 |     |         return uint176(value);
  208 |     |     }
  209 |     | 
  210 |     |     /**
  211 |     |      * @dev Returns the downcasted uint168 from uint256, reverting on
  212 |     |      * overflow (when the input is greater than largest uint168).
  213 |     |      *
  214 |     |      * Counterpart to Solidity's `uint168` operator.
  215 |     |      *
  216 |     |      * Requirements:
  217 |     |      *
  218 |     |      * - input must fit into 168 bits
  219 |     |      */
  220 |     |     function toUint168(uint256 value) internal pure returns (uint168) {
  221 |     |         if (value > type(uint168).max) {
  222 |     |             revert SafeCastOverflowedUintDowncast(168, value);
  223 |     |         }
  224 |     |         return uint168(value);
  225 |     |     }
  226 |     | 
  227 |     |     /**
  228 |     |      * @dev Returns the downcasted uint160 from uint256, reverting on
  229 |     |      * overflow (when the input is greater than largest uint160).
  230 |     |      *
  231 |     |      * Counterpart to Solidity's `uint160` operator.
  232 |     |      *
  233 |     |      * Requirements:
  234 |     |      *
  235 |     |      * - input must fit into 160 bits
  236 |     |      */
  237 |     |     function toUint160(uint256 value) internal pure returns (uint160) {
  238 |     |         if (value > type(uint160).max) {
  239 |     |             revert SafeCastOverflowedUintDowncast(160, value);
  240 |     |         }
  241 |     |         return uint160(value);
  242 |     |     }
  243 |     | 
  244 |     |     /**
  245 |     |      * @dev Returns the downcasted uint152 from uint256, reverting on
  246 |     |      * overflow (when the input is greater than largest uint152).
  247 |     |      *
  248 |     |      * Counterpart to Solidity's `uint152` operator.
  249 |     |      *
  250 |     |      * Requirements:
  251 |     |      *
  252 |     |      * - input must fit into 152 bits
  253 |     |      */
  254 |     |     function toUint152(uint256 value) internal pure returns (uint152) {
  255 |     |         if (value > type(uint152).max) {
  256 |     |             revert SafeCastOverflowedUintDowncast(152, value);
  257 |     |         }
  258 |     |         return uint152(value);
  259 |     |     }
  260 |     | 
  261 |     |     /**
  262 |     |      * @dev Returns the downcasted uint144 from uint256, reverting on
  263 |     |      * overflow (when the input is greater than largest uint144).
  264 |     |      *
  265 |     |      * Counterpart to Solidity's `uint144` operator.
  266 |     |      *
  267 |     |      * Requirements:
  268 |     |      *
  269 |     |      * - input must fit into 144 bits
  270 |     |      */
  271 |     |     function toUint144(uint256 value) internal pure returns (uint144) {
  272 |     |         if (value > type(uint144).max) {
  273 |     |             revert SafeCastOverflowedUintDowncast(144, value);
  274 |     |         }
  275 |     |         return uint144(value);
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @dev Returns the downcasted uint136 from uint256, reverting on
  280 |     |      * overflow (when the input is greater than largest uint136).
  281 |     |      *
  282 |     |      * Counterpart to Solidity's `uint136` operator.
  283 |     |      *
  284 |     |      * Requirements:
  285 |     |      *
  286 |     |      * - input must fit into 136 bits
  287 |     |      */
  288 |     |     function toUint136(uint256 value) internal pure returns (uint136) {
  289 |     |         if (value > type(uint136).max) {
  290 |     |             revert SafeCastOverflowedUintDowncast(136, value);
  291 |     |         }
  292 |     |         return uint136(value);
  293 |     |     }
  294 |     | 
  295 |     |     /**
  296 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  297 |     |      * overflow (when the input is greater than largest uint128).
  298 |     |      *
  299 |     |      * Counterpart to Solidity's `uint128` operator.
  300 |     |      *
  301 |     |      * Requirements:
  302 |     |      *
  303 |     |      * - input must fit into 128 bits
  304 |     |      */
  305 | *   |     function toUint128(uint256 value) internal pure returns (uint128) {
  306 | *   |         if (value > type(uint128).max) {
  307 |     |             revert SafeCastOverflowedUintDowncast(128, value);
  308 |     |         }
  309 | *   |         return uint128(value);
  310 |     |     }
  311 |     | 
  312 |     |     /**
  313 |     |      * @dev Returns the downcasted uint120 from uint256, reverting on
  314 |     |      * overflow (when the input is greater than largest uint120).
  315 |     |      *
  316 |     |      * Counterpart to Solidity's `uint120` operator.
  317 |     |      *
  318 |     |      * Requirements:
  319 |     |      *
  320 |     |      * - input must fit into 120 bits
  321 |     |      */
  322 |     |     function toUint120(uint256 value) internal pure returns (uint120) {
  323 |     |         if (value > type(uint120).max) {
  324 |     |             revert SafeCastOverflowedUintDowncast(120, value);
  325 |     |         }
  326 |     |         return uint120(value);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @dev Returns the downcasted uint112 from uint256, reverting on
  331 |     |      * overflow (when the input is greater than largest uint112).
  332 |     |      *
  333 |     |      * Counterpart to Solidity's `uint112` operator.
  334 |     |      *
  335 |     |      * Requirements:
  336 |     |      *
  337 |     |      * - input must fit into 112 bits
  338 |     |      */
  339 |     |     function toUint112(uint256 value) internal pure returns (uint112) {
  340 |     |         if (value > type(uint112).max) {
  341 |     |             revert SafeCastOverflowedUintDowncast(112, value);
  342 |     |         }
  343 |     |         return uint112(value);
  344 |     |     }
  345 |     | 
  346 |     |     /**
  347 |     |      * @dev Returns the downcasted uint104 from uint256, reverting on
  348 |     |      * overflow (when the input is greater than largest uint104).
  349 |     |      *
  350 |     |      * Counterpart to Solidity's `uint104` operator.
  351 |     |      *
  352 |     |      * Requirements:
  353 |     |      *
  354 |     |      * - input must fit into 104 bits
  355 |     |      */
  356 |     |     function toUint104(uint256 value) internal pure returns (uint104) {
  357 |     |         if (value > type(uint104).max) {
  358 |     |             revert SafeCastOverflowedUintDowncast(104, value);
  359 |     |         }
  360 |     |         return uint104(value);
  361 |     |     }
  362 |     | 
  363 |     |     /**
  364 |     |      * @dev Returns the downcasted uint96 from uint256, reverting on
  365 |     |      * overflow (when the input is greater than largest uint96).
  366 |     |      *
  367 |     |      * Counterpart to Solidity's `uint96` operator.
  368 |     |      *
  369 |     |      * Requirements:
  370 |     |      *
  371 |     |      * - input must fit into 96 bits
  372 |     |      */
  373 |     |     function toUint96(uint256 value) internal pure returns (uint96) {
  374 |     |         if (value > type(uint96).max) {
  375 |     |             revert SafeCastOverflowedUintDowncast(96, value);
  376 |     |         }
  377 |     |         return uint96(value);
  378 |     |     }
  379 |     | 
  380 |     |     /**
  381 |     |      * @dev Returns the downcasted uint88 from uint256, reverting on
  382 |     |      * overflow (when the input is greater than largest uint88).
  383 |     |      *
  384 |     |      * Counterpart to Solidity's `uint88` operator.
  385 |     |      *
  386 |     |      * Requirements:
  387 |     |      *
  388 |     |      * - input must fit into 88 bits
  389 |     |      */
  390 |     |     function toUint88(uint256 value) internal pure returns (uint88) {
  391 |     |         if (value > type(uint88).max) {
  392 |     |             revert SafeCastOverflowedUintDowncast(88, value);
  393 |     |         }
  394 |     |         return uint88(value);
  395 |     |     }
  396 |     | 
  397 |     |     /**
  398 |     |      * @dev Returns the downcasted uint80 from uint256, reverting on
  399 |     |      * overflow (when the input is greater than largest uint80).
  400 |     |      *
  401 |     |      * Counterpart to Solidity's `uint80` operator.
  402 |     |      *
  403 |     |      * Requirements:
  404 |     |      *
  405 |     |      * - input must fit into 80 bits
  406 |     |      */
  407 |     |     function toUint80(uint256 value) internal pure returns (uint80) {
  408 |     |         if (value > type(uint80).max) {
  409 |     |             revert SafeCastOverflowedUintDowncast(80, value);
  410 |     |         }
  411 |     |         return uint80(value);
  412 |     |     }
  413 |     | 
  414 |     |     /**
  415 |     |      * @dev Returns the downcasted uint72 from uint256, reverting on
  416 |     |      * overflow (when the input is greater than largest uint72).
  417 |     |      *
  418 |     |      * Counterpart to Solidity's `uint72` operator.
  419 |     |      *
  420 |     |      * Requirements:
  421 |     |      *
  422 |     |      * - input must fit into 72 bits
  423 |     |      */
  424 |     |     function toUint72(uint256 value) internal pure returns (uint72) {
  425 |     |         if (value > type(uint72).max) {
  426 |     |             revert SafeCastOverflowedUintDowncast(72, value);
  427 |     |         }
  428 |     |         return uint72(value);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  433 |     |      * overflow (when the input is greater than largest uint64).
  434 |     |      *
  435 |     |      * Counterpart to Solidity's `uint64` operator.
  436 |     |      *
  437 |     |      * Requirements:
  438 |     |      *
  439 |     |      * - input must fit into 64 bits
  440 |     |      */
  441 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  442 |     |         if (value > type(uint64).max) {
  443 |     |             revert SafeCastOverflowedUintDowncast(64, value);
  444 |     |         }
  445 |     |         return uint64(value);
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @dev Returns the downcasted uint56 from uint256, reverting on
  450 |     |      * overflow (when the input is greater than largest uint56).
  451 |     |      *
  452 |     |      * Counterpart to Solidity's `uint56` operator.
  453 |     |      *
  454 |     |      * Requirements:
  455 |     |      *
  456 |     |      * - input must fit into 56 bits
  457 |     |      */
  458 |     |     function toUint56(uint256 value) internal pure returns (uint56) {
  459 |     |         if (value > type(uint56).max) {
  460 |     |             revert SafeCastOverflowedUintDowncast(56, value);
  461 |     |         }
  462 |     |         return uint56(value);
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @dev Returns the downcasted uint48 from uint256, reverting on
  467 |     |      * overflow (when the input is greater than largest uint48).
  468 |     |      *
  469 |     |      * Counterpart to Solidity's `uint48` operator.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - input must fit into 48 bits
  474 |     |      */
  475 |     |     function toUint48(uint256 value) internal pure returns (uint48) {
  476 |     |         if (value > type(uint48).max) {
  477 |     |             revert SafeCastOverflowedUintDowncast(48, value);
  478 |     |         }
  479 |     |         return uint48(value);
  480 |     |     }
  481 |     | 
  482 |     |     /**
  483 |     |      * @dev Returns the downcasted uint40 from uint256, reverting on
  484 |     |      * overflow (when the input is greater than largest uint40).
  485 |     |      *
  486 |     |      * Counterpart to Solidity's `uint40` operator.
  487 |     |      *
  488 |     |      * Requirements:
  489 |     |      *
  490 |     |      * - input must fit into 40 bits
  491 |     |      */
  492 |     |     function toUint40(uint256 value) internal pure returns (uint40) {
  493 |     |         if (value > type(uint40).max) {
  494 |     |             revert SafeCastOverflowedUintDowncast(40, value);
  495 |     |         }
  496 |     |         return uint40(value);
  497 |     |     }
  498 |     | 
  499 |     |     /**
  500 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  501 |     |      * overflow (when the input is greater than largest uint32).
  502 |     |      *
  503 |     |      * Counterpart to Solidity's `uint32` operator.
  504 |     |      *
  505 |     |      * Requirements:
  506 |     |      *
  507 |     |      * - input must fit into 32 bits
  508 |     |      */
  509 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  510 |     |         if (value > type(uint32).max) {
  511 |     |             revert SafeCastOverflowedUintDowncast(32, value);
  512 |     |         }
  513 |     |         return uint32(value);
  514 |     |     }
  515 |     | 
  516 |     |     /**
  517 |     |      * @dev Returns the downcasted uint24 from uint256, reverting on
  518 |     |      * overflow (when the input is greater than largest uint24).
  519 |     |      *
  520 |     |      * Counterpart to Solidity's `uint24` operator.
  521 |     |      *
  522 |     |      * Requirements:
  523 |     |      *
  524 |     |      * - input must fit into 24 bits
  525 |     |      */
  526 |     |     function toUint24(uint256 value) internal pure returns (uint24) {
  527 |     |         if (value > type(uint24).max) {
  528 |     |             revert SafeCastOverflowedUintDowncast(24, value);
  529 |     |         }
  530 |     |         return uint24(value);
  531 |     |     }
  532 |     | 
  533 |     |     /**
  534 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  535 |     |      * overflow (when the input is greater than largest uint16).
  536 |     |      *
  537 |     |      * Counterpart to Solidity's `uint16` operator.
  538 |     |      *
  539 |     |      * Requirements:
  540 |     |      *
  541 |     |      * - input must fit into 16 bits
  542 |     |      */
  543 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  544 |     |         if (value > type(uint16).max) {
  545 |     |             revert SafeCastOverflowedUintDowncast(16, value);
  546 |     |         }
  547 |     |         return uint16(value);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  552 |     |      * overflow (when the input is greater than largest uint8).
  553 |     |      *
  554 |     |      * Counterpart to Solidity's `uint8` operator.
  555 |     |      *
  556 |     |      * Requirements:
  557 |     |      *
  558 |     |      * - input must fit into 8 bits
  559 |     |      */
  560 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  561 |     |         if (value > type(uint8).max) {
  562 |     |             revert SafeCastOverflowedUintDowncast(8, value);
  563 |     |         }
  564 |     |         return uint8(value);
  565 |     |     }
  566 |     | 
  567 |     |     /**
  568 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  569 |     |      *
  570 |     |      * Requirements:
  571 |     |      *
  572 |     |      * - input must be greater than or equal to 0.
  573 |     |      */
  574 |     |     function toUint256(int256 value) internal pure returns (uint256) {
  575 |     |         if (value < 0) {
  576 |     |             revert SafeCastOverflowedIntToUint(value);
  577 |     |         }
  578 |     |         return uint256(value);
  579 |     |     }
  580 |     | 
  581 |     |     /**
  582 |     |      * @dev Returns the downcasted int248 from int256, reverting on
  583 |     |      * overflow (when the input is less than smallest int248 or
  584 |     |      * greater than largest int248).
  585 |     |      *
  586 |     |      * Counterpart to Solidity's `int248` operator.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - input must fit into 248 bits
  591 |     |      */
  592 |     |     function toInt248(int256 value) internal pure returns (int248 downcasted) {
  593 |     |         downcasted = int248(value);
  594 |     |         if (downcasted != value) {
  595 |     |             revert SafeCastOverflowedIntDowncast(248, value);
  596 |     |         }
  597 |     |     }
  598 |     | 
  599 |     |     /**
  600 |     |      * @dev Returns the downcasted int240 from int256, reverting on
  601 |     |      * overflow (when the input is less than smallest int240 or
  602 |     |      * greater than largest int240).
  603 |     |      *
  604 |     |      * Counterpart to Solidity's `int240` operator.
  605 |     |      *
  606 |     |      * Requirements:
  607 |     |      *
  608 |     |      * - input must fit into 240 bits
  609 |     |      */
  610 |     |     function toInt240(int256 value) internal pure returns (int240 downcasted) {
  611 |     |         downcasted = int240(value);
  612 |     |         if (downcasted != value) {
  613 |     |             revert SafeCastOverflowedIntDowncast(240, value);
  614 |     |         }
  615 |     |     }
  616 |     | 
  617 |     |     /**
  618 |     |      * @dev Returns the downcasted int232 from int256, reverting on
  619 |     |      * overflow (when the input is less than smallest int232 or
  620 |     |      * greater than largest int232).
  621 |     |      *
  622 |     |      * Counterpart to Solidity's `int232` operator.
  623 |     |      *
  624 |     |      * Requirements:
  625 |     |      *
  626 |     |      * - input must fit into 232 bits
  627 |     |      */
  628 |     |     function toInt232(int256 value) internal pure returns (int232 downcasted) {
  629 |     |         downcasted = int232(value);
  630 |     |         if (downcasted != value) {
  631 |     |             revert SafeCastOverflowedIntDowncast(232, value);
  632 |     |         }
  633 |     |     }
  634 |     | 
  635 |     |     /**
  636 |     |      * @dev Returns the downcasted int224 from int256, reverting on
  637 |     |      * overflow (when the input is less than smallest int224 or
  638 |     |      * greater than largest int224).
  639 |     |      *
  640 |     |      * Counterpart to Solidity's `int224` operator.
  641 |     |      *
  642 |     |      * Requirements:
  643 |     |      *
  644 |     |      * - input must fit into 224 bits
  645 |     |      */
  646 |     |     function toInt224(int256 value) internal pure returns (int224 downcasted) {
  647 |     |         downcasted = int224(value);
  648 |     |         if (downcasted != value) {
  649 |     |             revert SafeCastOverflowedIntDowncast(224, value);
  650 |     |         }
  651 |     |     }
  652 |     | 
  653 |     |     /**
  654 |     |      * @dev Returns the downcasted int216 from int256, reverting on
  655 |     |      * overflow (when the input is less than smallest int216 or
  656 |     |      * greater than largest int216).
  657 |     |      *
  658 |     |      * Counterpart to Solidity's `int216` operator.
  659 |     |      *
  660 |     |      * Requirements:
  661 |     |      *
  662 |     |      * - input must fit into 216 bits
  663 |     |      */
  664 |     |     function toInt216(int256 value) internal pure returns (int216 downcasted) {
  665 |     |         downcasted = int216(value);
  666 |     |         if (downcasted != value) {
  667 |     |             revert SafeCastOverflowedIntDowncast(216, value);
  668 |     |         }
  669 |     |     }
  670 |     | 
  671 |     |     /**
  672 |     |      * @dev Returns the downcasted int208 from int256, reverting on
  673 |     |      * overflow (when the input is less than smallest int208 or
  674 |     |      * greater than largest int208).
  675 |     |      *
  676 |     |      * Counterpart to Solidity's `int208` operator.
  677 |     |      *
  678 |     |      * Requirements:
  679 |     |      *
  680 |     |      * - input must fit into 208 bits
  681 |     |      */
  682 |     |     function toInt208(int256 value) internal pure returns (int208 downcasted) {
  683 |     |         downcasted = int208(value);
  684 |     |         if (downcasted != value) {
  685 |     |             revert SafeCastOverflowedIntDowncast(208, value);
  686 |     |         }
  687 |     |     }
  688 |     | 
  689 |     |     /**
  690 |     |      * @dev Returns the downcasted int200 from int256, reverting on
  691 |     |      * overflow (when the input is less than smallest int200 or
  692 |     |      * greater than largest int200).
  693 |     |      *
  694 |     |      * Counterpart to Solidity's `int200` operator.
  695 |     |      *
  696 |     |      * Requirements:
  697 |     |      *
  698 |     |      * - input must fit into 200 bits
  699 |     |      */
  700 |     |     function toInt200(int256 value) internal pure returns (int200 downcasted) {
  701 |     |         downcasted = int200(value);
  702 |     |         if (downcasted != value) {
  703 |     |             revert SafeCastOverflowedIntDowncast(200, value);
  704 |     |         }
  705 |     |     }
  706 |     | 
  707 |     |     /**
  708 |     |      * @dev Returns the downcasted int192 from int256, reverting on
  709 |     |      * overflow (when the input is less than smallest int192 or
  710 |     |      * greater than largest int192).
  711 |     |      *
  712 |     |      * Counterpart to Solidity's `int192` operator.
  713 |     |      *
  714 |     |      * Requirements:
  715 |     |      *
  716 |     |      * - input must fit into 192 bits
  717 |     |      */
  718 |     |     function toInt192(int256 value) internal pure returns (int192 downcasted) {
  719 |     |         downcasted = int192(value);
  720 |     |         if (downcasted != value) {
  721 |     |             revert SafeCastOverflowedIntDowncast(192, value);
  722 |     |         }
  723 |     |     }
  724 |     | 
  725 |     |     /**
  726 |     |      * @dev Returns the downcasted int184 from int256, reverting on
  727 |     |      * overflow (when the input is less than smallest int184 or
  728 |     |      * greater than largest int184).
  729 |     |      *
  730 |     |      * Counterpart to Solidity's `int184` operator.
  731 |     |      *
  732 |     |      * Requirements:
  733 |     |      *
  734 |     |      * - input must fit into 184 bits
  735 |     |      */
  736 |     |     function toInt184(int256 value) internal pure returns (int184 downcasted) {
  737 |     |         downcasted = int184(value);
  738 |     |         if (downcasted != value) {
  739 |     |             revert SafeCastOverflowedIntDowncast(184, value);
  740 |     |         }
  741 |     |     }
  742 |     | 
  743 |     |     /**
  744 |     |      * @dev Returns the downcasted int176 from int256, reverting on
  745 |     |      * overflow (when the input is less than smallest int176 or
  746 |     |      * greater than largest int176).
  747 |     |      *
  748 |     |      * Counterpart to Solidity's `int176` operator.
  749 |     |      *
  750 |     |      * Requirements:
  751 |     |      *
  752 |     |      * - input must fit into 176 bits
  753 |     |      */
  754 |     |     function toInt176(int256 value) internal pure returns (int176 downcasted) {
  755 |     |         downcasted = int176(value);
  756 |     |         if (downcasted != value) {
  757 |     |             revert SafeCastOverflowedIntDowncast(176, value);
  758 |     |         }
  759 |     |     }
  760 |     | 
  761 |     |     /**
  762 |     |      * @dev Returns the downcasted int168 from int256, reverting on
  763 |     |      * overflow (when the input is less than smallest int168 or
  764 |     |      * greater than largest int168).
  765 |     |      *
  766 |     |      * Counterpart to Solidity's `int168` operator.
  767 |     |      *
  768 |     |      * Requirements:
  769 |     |      *
  770 |     |      * - input must fit into 168 bits
  771 |     |      */
  772 |     |     function toInt168(int256 value) internal pure returns (int168 downcasted) {
  773 |     |         downcasted = int168(value);
  774 |     |         if (downcasted != value) {
  775 |     |             revert SafeCastOverflowedIntDowncast(168, value);
  776 |     |         }
  777 |     |     }
  778 |     | 
  779 |     |     /**
  780 |     |      * @dev Returns the downcasted int160 from int256, reverting on
  781 |     |      * overflow (when the input is less than smallest int160 or
  782 |     |      * greater than largest int160).
  783 |     |      *
  784 |     |      * Counterpart to Solidity's `int160` operator.
  785 |     |      *
  786 |     |      * Requirements:
  787 |     |      *
  788 |     |      * - input must fit into 160 bits
  789 |     |      */
  790 |     |     function toInt160(int256 value) internal pure returns (int160 downcasted) {
  791 |     |         downcasted = int160(value);
  792 |     |         if (downcasted != value) {
  793 |     |             revert SafeCastOverflowedIntDowncast(160, value);
  794 |     |         }
  795 |     |     }
  796 |     | 
  797 |     |     /**
  798 |     |      * @dev Returns the downcasted int152 from int256, reverting on
  799 |     |      * overflow (when the input is less than smallest int152 or
  800 |     |      * greater than largest int152).
  801 |     |      *
  802 |     |      * Counterpart to Solidity's `int152` operator.
  803 |     |      *
  804 |     |      * Requirements:
  805 |     |      *
  806 |     |      * - input must fit into 152 bits
  807 |     |      */
  808 |     |     function toInt152(int256 value) internal pure returns (int152 downcasted) {
  809 |     |         downcasted = int152(value);
  810 |     |         if (downcasted != value) {
  811 |     |             revert SafeCastOverflowedIntDowncast(152, value);
  812 |     |         }
  813 |     |     }
  814 |     | 
  815 |     |     /**
  816 |     |      * @dev Returns the downcasted int144 from int256, reverting on
  817 |     |      * overflow (when the input is less than smallest int144 or
  818 |     |      * greater than largest int144).
  819 |     |      *
  820 |     |      * Counterpart to Solidity's `int144` operator.
  821 |     |      *
  822 |     |      * Requirements:
  823 |     |      *
  824 |     |      * - input must fit into 144 bits
  825 |     |      */
  826 |     |     function toInt144(int256 value) internal pure returns (int144 downcasted) {
  827 |     |         downcasted = int144(value);
  828 |     |         if (downcasted != value) {
  829 |     |             revert SafeCastOverflowedIntDowncast(144, value);
  830 |     |         }
  831 |     |     }
  832 |     | 
  833 |     |     /**
  834 |     |      * @dev Returns the downcasted int136 from int256, reverting on
  835 |     |      * overflow (when the input is less than smallest int136 or
  836 |     |      * greater than largest int136).
  837 |     |      *
  838 |     |      * Counterpart to Solidity's `int136` operator.
  839 |     |      *
  840 |     |      * Requirements:
  841 |     |      *
  842 |     |      * - input must fit into 136 bits
  843 |     |      */
  844 |     |     function toInt136(int256 value) internal pure returns (int136 downcasted) {
  845 |     |         downcasted = int136(value);
  846 |     |         if (downcasted != value) {
  847 |     |             revert SafeCastOverflowedIntDowncast(136, value);
  848 |     |         }
  849 |     |     }
  850 |     | 
  851 |     |     /**
  852 |     |      * @dev Returns the downcasted int128 from int256, reverting on
  853 |     |      * overflow (when the input is less than smallest int128 or
  854 |     |      * greater than largest int128).
  855 |     |      *
  856 |     |      * Counterpart to Solidity's `int128` operator.
  857 |     |      *
  858 |     |      * Requirements:
  859 |     |      *
  860 |     |      * - input must fit into 128 bits
  861 |     |      */
  862 |     |     function toInt128(int256 value) internal pure returns (int128 downcasted) {
  863 |     |         downcasted = int128(value);
  864 |     |         if (downcasted != value) {
  865 |     |             revert SafeCastOverflowedIntDowncast(128, value);
  866 |     |         }
  867 |     |     }
  868 |     | 
  869 |     |     /**
  870 |     |      * @dev Returns the downcasted int120 from int256, reverting on
  871 |     |      * overflow (when the input is less than smallest int120 or
  872 |     |      * greater than largest int120).
  873 |     |      *
  874 |     |      * Counterpart to Solidity's `int120` operator.
  875 |     |      *
  876 |     |      * Requirements:
  877 |     |      *
  878 |     |      * - input must fit into 120 bits
  879 |     |      */
  880 |     |     function toInt120(int256 value) internal pure returns (int120 downcasted) {
  881 |     |         downcasted = int120(value);
  882 |     |         if (downcasted != value) {
  883 |     |             revert SafeCastOverflowedIntDowncast(120, value);
  884 |     |         }
  885 |     |     }
  886 |     | 
  887 |     |     /**
  888 |     |      * @dev Returns the downcasted int112 from int256, reverting on
  889 |     |      * overflow (when the input is less than smallest int112 or
  890 |     |      * greater than largest int112).
  891 |     |      *
  892 |     |      * Counterpart to Solidity's `int112` operator.
  893 |     |      *
  894 |     |      * Requirements:
  895 |     |      *
  896 |     |      * - input must fit into 112 bits
  897 |     |      */
  898 |     |     function toInt112(int256 value) internal pure returns (int112 downcasted) {
  899 |     |         downcasted = int112(value);
  900 |     |         if (downcasted != value) {
  901 |     |             revert SafeCastOverflowedIntDowncast(112, value);
  902 |     |         }
  903 |     |     }
  904 |     | 
  905 |     |     /**
  906 |     |      * @dev Returns the downcasted int104 from int256, reverting on
  907 |     |      * overflow (when the input is less than smallest int104 or
  908 |     |      * greater than largest int104).
  909 |     |      *
  910 |     |      * Counterpart to Solidity's `int104` operator.
  911 |     |      *
  912 |     |      * Requirements:
  913 |     |      *
  914 |     |      * - input must fit into 104 bits
  915 |     |      */
  916 |     |     function toInt104(int256 value) internal pure returns (int104 downcasted) {
  917 |     |         downcasted = int104(value);
  918 |     |         if (downcasted != value) {
  919 |     |             revert SafeCastOverflowedIntDowncast(104, value);
  920 |     |         }
  921 |     |     }
  922 |     | 
  923 |     |     /**
  924 |     |      * @dev Returns the downcasted int96 from int256, reverting on
  925 |     |      * overflow (when the input is less than smallest int96 or
  926 |     |      * greater than largest int96).
  927 |     |      *
  928 |     |      * Counterpart to Solidity's `int96` operator.
  929 |     |      *
  930 |     |      * Requirements:
  931 |     |      *
  932 |     |      * - input must fit into 96 bits
  933 |     |      */
  934 | *   |     function toInt96(int256 value) internal pure returns (int96 downcasted) {
  935 | *   |         downcasted = int96(value);
  936 | *   |         if (downcasted != value) {
  937 |     |             revert SafeCastOverflowedIntDowncast(96, value);
  938 |     |         }
  939 |     |     }
  940 |     | 
  941 |     |     /**
  942 |     |      * @dev Returns the downcasted int88 from int256, reverting on
  943 |     |      * overflow (when the input is less than smallest int88 or
  944 |     |      * greater than largest int88).
  945 |     |      *
  946 |     |      * Counterpart to Solidity's `int88` operator.
  947 |     |      *
  948 |     |      * Requirements:
  949 |     |      *
  950 |     |      * - input must fit into 88 bits
  951 |     |      */
  952 |     |     function toInt88(int256 value) internal pure returns (int88 downcasted) {
  953 |     |         downcasted = int88(value);
  954 |     |         if (downcasted != value) {
  955 |     |             revert SafeCastOverflowedIntDowncast(88, value);
  956 |     |         }
  957 |     |     }
  958 |     | 
  959 |     |     /**
  960 |     |      * @dev Returns the downcasted int80 from int256, reverting on
  961 |     |      * overflow (when the input is less than smallest int80 or
  962 |     |      * greater than largest int80).
  963 |     |      *
  964 |     |      * Counterpart to Solidity's `int80` operator.
  965 |     |      *
  966 |     |      * Requirements:
  967 |     |      *
  968 |     |      * - input must fit into 80 bits
  969 |     |      */
  970 |     |     function toInt80(int256 value) internal pure returns (int80 downcasted) {
  971 |     |         downcasted = int80(value);
  972 |     |         if (downcasted != value) {
  973 |     |             revert SafeCastOverflowedIntDowncast(80, value);
  974 |     |         }
  975 |     |     }
  976 |     | 
  977 |     |     /**
  978 |     |      * @dev Returns the downcasted int72 from int256, reverting on
  979 |     |      * overflow (when the input is less than smallest int72 or
  980 |     |      * greater than largest int72).
  981 |     |      *
  982 |     |      * Counterpart to Solidity's `int72` operator.
  983 |     |      *
  984 |     |      * Requirements:
  985 |     |      *
  986 |     |      * - input must fit into 72 bits
  987 |     |      */
  988 |     |     function toInt72(int256 value) internal pure returns (int72 downcasted) {
  989 |     |         downcasted = int72(value);
  990 |     |         if (downcasted != value) {
  991 |     |             revert SafeCastOverflowedIntDowncast(72, value);
  992 |     |         }
  993 |     |     }
  994 |     | 
  995 |     |     /**
  996 |     |      * @dev Returns the downcasted int64 from int256, reverting on
  997 |     |      * overflow (when the input is less than smallest int64 or
  998 |     |      * greater than largest int64).
  999 |     |      *
 1000 |     |      * Counterpart to Solidity's `int64` operator.
 1001 |     |      *
 1002 |     |      * Requirements:
 1003 |     |      *
 1004 |     |      * - input must fit into 64 bits
 1005 |     |      */
 1006 |     |     function toInt64(int256 value) internal pure returns (int64 downcasted) {
 1007 |     |         downcasted = int64(value);
 1008 |     |         if (downcasted != value) {
 1009 |     |             revert SafeCastOverflowedIntDowncast(64, value);
 1010 |     |         }
 1011 |     |     }
 1012 |     | 
 1013 |     |     /**
 1014 |     |      * @dev Returns the downcasted int56 from int256, reverting on
 1015 |     |      * overflow (when the input is less than smallest int56 or
 1016 |     |      * greater than largest int56).
 1017 |     |      *
 1018 |     |      * Counterpart to Solidity's `int56` operator.
 1019 |     |      *
 1020 |     |      * Requirements:
 1021 |     |      *
 1022 |     |      * - input must fit into 56 bits
 1023 |     |      */
 1024 |     |     function toInt56(int256 value) internal pure returns (int56 downcasted) {
 1025 |     |         downcasted = int56(value);
 1026 |     |         if (downcasted != value) {
 1027 |     |             revert SafeCastOverflowedIntDowncast(56, value);
 1028 |     |         }
 1029 |     |     }
 1030 |     | 
 1031 |     |     /**
 1032 |     |      * @dev Returns the downcasted int48 from int256, reverting on
 1033 |     |      * overflow (when the input is less than smallest int48 or
 1034 |     |      * greater than largest int48).
 1035 |     |      *
 1036 |     |      * Counterpart to Solidity's `int48` operator.
 1037 |     |      *
 1038 |     |      * Requirements:
 1039 |     |      *
 1040 |     |      * - input must fit into 48 bits
 1041 |     |      */
 1042 |     |     function toInt48(int256 value) internal pure returns (int48 downcasted) {
 1043 |     |         downcasted = int48(value);
 1044 |     |         if (downcasted != value) {
 1045 |     |             revert SafeCastOverflowedIntDowncast(48, value);
 1046 |     |         }
 1047 |     |     }
 1048 |     | 
 1049 |     |     /**
 1050 |     |      * @dev Returns the downcasted int40 from int256, reverting on
 1051 |     |      * overflow (when the input is less than smallest int40 or
 1052 |     |      * greater than largest int40).
 1053 |     |      *
 1054 |     |      * Counterpart to Solidity's `int40` operator.
 1055 |     |      *
 1056 |     |      * Requirements:
 1057 |     |      *
 1058 |     |      * - input must fit into 40 bits
 1059 |     |      */
 1060 |     |     function toInt40(int256 value) internal pure returns (int40 downcasted) {
 1061 |     |         downcasted = int40(value);
 1062 |     |         if (downcasted != value) {
 1063 |     |             revert SafeCastOverflowedIntDowncast(40, value);
 1064 |     |         }
 1065 |     |     }
 1066 |     | 
 1067 |     |     /**
 1068 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 1069 |     |      * overflow (when the input is less than smallest int32 or
 1070 |     |      * greater than largest int32).
 1071 |     |      *
 1072 |     |      * Counterpart to Solidity's `int32` operator.
 1073 |     |      *
 1074 |     |      * Requirements:
 1075 |     |      *
 1076 |     |      * - input must fit into 32 bits
 1077 |     |      */
 1078 |     |     function toInt32(int256 value) internal pure returns (int32 downcasted) {
 1079 |     |         downcasted = int32(value);
 1080 |     |         if (downcasted != value) {
 1081 |     |             revert SafeCastOverflowedIntDowncast(32, value);
 1082 |     |         }
 1083 |     |     }
 1084 |     | 
 1085 |     |     /**
 1086 |     |      * @dev Returns the downcasted int24 from int256, reverting on
 1087 |     |      * overflow (when the input is less than smallest int24 or
 1088 |     |      * greater than largest int24).
 1089 |     |      *
 1090 |     |      * Counterpart to Solidity's `int24` operator.
 1091 |     |      *
 1092 |     |      * Requirements:
 1093 |     |      *
 1094 |     |      * - input must fit into 24 bits
 1095 |     |      */
 1096 |     |     function toInt24(int256 value) internal pure returns (int24 downcasted) {
 1097 |     |         downcasted = int24(value);
 1098 |     |         if (downcasted != value) {
 1099 |     |             revert SafeCastOverflowedIntDowncast(24, value);
 1100 |     |         }
 1101 |     |     }
 1102 |     | 
 1103 |     |     /**
 1104 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 1105 |     |      * overflow (when the input is less than smallest int16 or
 1106 |     |      * greater than largest int16).
 1107 |     |      *
 1108 |     |      * Counterpart to Solidity's `int16` operator.
 1109 |     |      *
 1110 |     |      * Requirements:
 1111 |     |      *
 1112 |     |      * - input must fit into 16 bits
 1113 |     |      */
 1114 |     |     function toInt16(int256 value) internal pure returns (int16 downcasted) {
 1115 |     |         downcasted = int16(value);
 1116 |     |         if (downcasted != value) {
 1117 |     |             revert SafeCastOverflowedIntDowncast(16, value);
 1118 |     |         }
 1119 |     |     }
 1120 |     | 
 1121 |     |     /**
 1122 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 1123 |     |      * overflow (when the input is less than smallest int8 or
 1124 |     |      * greater than largest int8).
 1125 |     |      *
 1126 |     |      * Counterpart to Solidity's `int8` operator.
 1127 |     |      *
 1128 |     |      * Requirements:
 1129 |     |      *
 1130 |     |      * - input must fit into 8 bits
 1131 |     |      */
 1132 |     |     function toInt8(int256 value) internal pure returns (int8 downcasted) {
 1133 |     |         downcasted = int8(value);
 1134 |     |         if (downcasted != value) {
 1135 |     |             revert SafeCastOverflowedIntDowncast(8, value);
 1136 |     |         }
 1137 |     |     }
 1138 |     | 
 1139 |     |     /**
 1140 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 1141 |     |      *
 1142 |     |      * Requirements:
 1143 |     |      *
 1144 |     |      * - input must be less than or equal to maxInt256.
 1145 |     |      */
 1146 | *   |     function toInt256(uint256 value) internal pure returns (int256) {
 1147 |     |         // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
 1148 | *   |         if (value > uint256(type(int256).max)) {
 1149 |     |             revert SafeCastOverflowedUintToInt(value);
 1150 |     |         }
 1151 | *   |         return int256(value);
 1152 |     |     }
 1153 |     | }
 1154 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 | *   | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@prb/math/contracts/PRBMath.sol
   1 |     | // SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity >=0.8.4;
   3 |     | 
   4 |     | /// @notice Emitted when the result overflows uint256.
   5 |     | error PRBMath__MulDivFixedPointOverflow(uint256 prod1);
   6 |     | 
   7 |     | /// @notice Emitted when the result overflows uint256.
   8 |     | error PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);
   9 |     | 
  10 |     | /// @notice Emitted when one of the inputs is type(int256).min.
  11 |     | error PRBMath__MulDivSignedInputTooSmall();
  12 |     | 
  13 |     | /// @notice Emitted when the intermediary absolute result overflows int256.
  14 |     | error PRBMath__MulDivSignedOverflow(uint256 rAbs);
  15 |     | 
  16 |     | /// @notice Emitted when the input is MIN_SD59x18.
  17 |     | error PRBMathSD59x18__AbsInputTooSmall();
  18 |     | 
  19 |     | /// @notice Emitted when ceiling a number overflows SD59x18.
  20 |     | error PRBMathSD59x18__CeilOverflow(int256 x);
  21 |     | 
  22 |     | /// @notice Emitted when one of the inputs is MIN_SD59x18.
  23 |     | error PRBMathSD59x18__DivInputTooSmall();
  24 |     | 
  25 |     | /// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.
  26 |     | error PRBMathSD59x18__DivOverflow(uint256 rAbs);
  27 |     | 
  28 |     | /// @notice Emitted when the input is greater than 133.084258667509499441.
  29 |     | error PRBMathSD59x18__ExpInputTooBig(int256 x);
  30 |     | 
  31 |     | /// @notice Emitted when the input is greater than 192.
  32 |     | error PRBMathSD59x18__Exp2InputTooBig(int256 x);
  33 |     | 
  34 |     | /// @notice Emitted when flooring a number underflows SD59x18.
  35 |     | error PRBMathSD59x18__FloorUnderflow(int256 x);
  36 |     | 
  37 |     | /// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.
  38 |     | error PRBMathSD59x18__FromIntOverflow(int256 x);
  39 |     | 
  40 |     | /// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.
  41 |     | error PRBMathSD59x18__FromIntUnderflow(int256 x);
  42 |     | 
  43 |     | /// @notice Emitted when the product of the inputs is negative.
  44 |     | error PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);
  45 |     | 
  46 |     | /// @notice Emitted when multiplying the inputs overflows SD59x18.
  47 |     | error PRBMathSD59x18__GmOverflow(int256 x, int256 y);
  48 |     | 
  49 |     | /// @notice Emitted when the input is less than or equal to zero.
  50 |     | error PRBMathSD59x18__LogInputTooSmall(int256 x);
  51 |     | 
  52 |     | /// @notice Emitted when one of the inputs is MIN_SD59x18.
  53 |     | error PRBMathSD59x18__MulInputTooSmall();
  54 |     | 
  55 |     | /// @notice Emitted when the intermediary absolute result overflows SD59x18.
  56 |     | error PRBMathSD59x18__MulOverflow(uint256 rAbs);
  57 |     | 
  58 |     | /// @notice Emitted when the intermediary absolute result overflows SD59x18.
  59 |     | error PRBMathSD59x18__PowuOverflow(uint256 rAbs);
  60 |     | 
  61 |     | /// @notice Emitted when the input is negative.
  62 |     | error PRBMathSD59x18__SqrtNegativeInput(int256 x);
  63 |     | 
  64 |     | /// @notice Emitted when the calculating the square root overflows SD59x18.
  65 |     | error PRBMathSD59x18__SqrtOverflow(int256 x);
  66 |     | 
  67 |     | /// @notice Emitted when addition overflows UD60x18.
  68 |     | error PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);
  69 |     | 
  70 |     | /// @notice Emitted when ceiling a number overflows UD60x18.
  71 |     | error PRBMathUD60x18__CeilOverflow(uint256 x);
  72 |     | 
  73 |     | /// @notice Emitted when the input is greater than 133.084258667509499441.
  74 |     | error PRBMathUD60x18__ExpInputTooBig(uint256 x);
  75 |     | 
  76 |     | /// @notice Emitted when the input is greater than 192.
  77 |     | error PRBMathUD60x18__Exp2InputTooBig(uint256 x);
  78 |     | 
  79 |     | /// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.
  80 |     | error PRBMathUD60x18__FromUintOverflow(uint256 x);
  81 |     | 
  82 |     | /// @notice Emitted when multiplying the inputs overflows UD60x18.
  83 |     | error PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);
  84 |     | 
  85 |     | /// @notice Emitted when the input is less than 1.
  86 |     | error PRBMathUD60x18__LogInputTooSmall(uint256 x);
  87 |     | 
  88 |     | /// @notice Emitted when the calculating the square root overflows UD60x18.
  89 |     | error PRBMathUD60x18__SqrtOverflow(uint256 x);
  90 |     | 
  91 |     | /// @notice Emitted when subtraction underflows UD60x18.
  92 |     | error PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);
  93 |     | 
  94 |     | /// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library
  95 |     | /// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point
  96 |     | /// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.
  97 | *   | library PRBMath {
  98 |     |     /// STRUCTS ///
  99 |     | 
 100 |     |     struct SD59x18 {
 101 |     |         int256 value;
 102 |     |     }
 103 |     | 
 104 |     |     struct UD60x18 {
 105 |     |         uint256 value;
 106 |     |     }
 107 |     | 
 108 |     |     /// STORAGE ///
 109 |     | 
 110 |     |     /// @dev How many trailing decimals can be represented.
 111 |     |     uint256 internal constant SCALE = 1e18;
 112 |     | 
 113 |     |     /// @dev Largest power of two divisor of SCALE.
 114 |     |     uint256 internal constant SCALE_LPOTD = 262144;
 115 |     | 
 116 |     |     /// @dev SCALE inverted mod 2^256.
 117 |     |     uint256 internal constant SCALE_INVERSE =
 118 |     |         78156646155174841979727994598816262306175212592076161876661_508869554232690281;
 119 |     | 
 120 |     |     /// FUNCTIONS ///
 121 |     | 
 122 |     |     /// @notice Calculates the binary exponent of x using the binary fraction method.
 123 |     |     /// @dev Has to use 192.64-bit fixed-point numbers.
 124 |     |     /// See https://ethereum.stackexchange.com/a/96594/24693.
 125 |     |     /// @param x The exponent as an unsigned 192.64-bit fixed-point number.
 126 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point number.
 127 |     |     function exp2(uint256 x) internal pure returns (uint256 result) {
 128 |     |         unchecked {
 129 |     |             // Start from 0.5 in the 192.64-bit fixed-point format.
 130 |     |             result = 0x800000000000000000000000000000000000000000000000;
 131 |     | 
 132 |     |             // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows
 133 |     |             // because the initial result is 2^191 and all magic factors are less than 2^65.
 134 |     |             if (x & 0x8000000000000000 > 0) {
 135 |     |                 result = (result * 0x16A09E667F3BCC909) >> 64;
 136 |     |             }
 137 |     |             if (x & 0x4000000000000000 > 0) {
 138 |     |                 result = (result * 0x1306FE0A31B7152DF) >> 64;
 139 |     |             }
 140 |     |             if (x & 0x2000000000000000 > 0) {
 141 |     |                 result = (result * 0x1172B83C7D517ADCE) >> 64;
 142 |     |             }
 143 |     |             if (x & 0x1000000000000000 > 0) {
 144 |     |                 result = (result * 0x10B5586CF9890F62A) >> 64;
 145 |     |             }
 146 |     |             if (x & 0x800000000000000 > 0) {
 147 |     |                 result = (result * 0x1059B0D31585743AE) >> 64;
 148 |     |             }
 149 |     |             if (x & 0x400000000000000 > 0) {
 150 |     |                 result = (result * 0x102C9A3E778060EE7) >> 64;
 151 |     |             }
 152 |     |             if (x & 0x200000000000000 > 0) {
 153 |     |                 result = (result * 0x10163DA9FB33356D8) >> 64;
 154 |     |             }
 155 |     |             if (x & 0x100000000000000 > 0) {
 156 |     |                 result = (result * 0x100B1AFA5ABCBED61) >> 64;
 157 |     |             }
 158 |     |             if (x & 0x80000000000000 > 0) {
 159 |     |                 result = (result * 0x10058C86DA1C09EA2) >> 64;
 160 |     |             }
 161 |     |             if (x & 0x40000000000000 > 0) {
 162 |     |                 result = (result * 0x1002C605E2E8CEC50) >> 64;
 163 |     |             }
 164 |     |             if (x & 0x20000000000000 > 0) {
 165 |     |                 result = (result * 0x100162F3904051FA1) >> 64;
 166 |     |             }
 167 |     |             if (x & 0x10000000000000 > 0) {
 168 |     |                 result = (result * 0x1000B175EFFDC76BA) >> 64;
 169 |     |             }
 170 |     |             if (x & 0x8000000000000 > 0) {
 171 |     |                 result = (result * 0x100058BA01FB9F96D) >> 64;
 172 |     |             }
 173 |     |             if (x & 0x4000000000000 > 0) {
 174 |     |                 result = (result * 0x10002C5CC37DA9492) >> 64;
 175 |     |             }
 176 |     |             if (x & 0x2000000000000 > 0) {
 177 |     |                 result = (result * 0x1000162E525EE0547) >> 64;
 178 |     |             }
 179 |     |             if (x & 0x1000000000000 > 0) {
 180 |     |                 result = (result * 0x10000B17255775C04) >> 64;
 181 |     |             }
 182 |     |             if (x & 0x800000000000 > 0) {
 183 |     |                 result = (result * 0x1000058B91B5BC9AE) >> 64;
 184 |     |             }
 185 |     |             if (x & 0x400000000000 > 0) {
 186 |     |                 result = (result * 0x100002C5C89D5EC6D) >> 64;
 187 |     |             }
 188 |     |             if (x & 0x200000000000 > 0) {
 189 |     |                 result = (result * 0x10000162E43F4F831) >> 64;
 190 |     |             }
 191 |     |             if (x & 0x100000000000 > 0) {
 192 |     |                 result = (result * 0x100000B1721BCFC9A) >> 64;
 193 |     |             }
 194 |     |             if (x & 0x80000000000 > 0) {
 195 |     |                 result = (result * 0x10000058B90CF1E6E) >> 64;
 196 |     |             }
 197 |     |             if (x & 0x40000000000 > 0) {
 198 |     |                 result = (result * 0x1000002C5C863B73F) >> 64;
 199 |     |             }
 200 |     |             if (x & 0x20000000000 > 0) {
 201 |     |                 result = (result * 0x100000162E430E5A2) >> 64;
 202 |     |             }
 203 |     |             if (x & 0x10000000000 > 0) {
 204 |     |                 result = (result * 0x1000000B172183551) >> 64;
 205 |     |             }
 206 |     |             if (x & 0x8000000000 > 0) {
 207 |     |                 result = (result * 0x100000058B90C0B49) >> 64;
 208 |     |             }
 209 |     |             if (x & 0x4000000000 > 0) {
 210 |     |                 result = (result * 0x10000002C5C8601CC) >> 64;
 211 |     |             }
 212 |     |             if (x & 0x2000000000 > 0) {
 213 |     |                 result = (result * 0x1000000162E42FFF0) >> 64;
 214 |     |             }
 215 |     |             if (x & 0x1000000000 > 0) {
 216 |     |                 result = (result * 0x10000000B17217FBB) >> 64;
 217 |     |             }
 218 |     |             if (x & 0x800000000 > 0) {
 219 |     |                 result = (result * 0x1000000058B90BFCE) >> 64;
 220 |     |             }
 221 |     |             if (x & 0x400000000 > 0) {
 222 |     |                 result = (result * 0x100000002C5C85FE3) >> 64;
 223 |     |             }
 224 |     |             if (x & 0x200000000 > 0) {
 225 |     |                 result = (result * 0x10000000162E42FF1) >> 64;
 226 |     |             }
 227 |     |             if (x & 0x100000000 > 0) {
 228 |     |                 result = (result * 0x100000000B17217F8) >> 64;
 229 |     |             }
 230 |     |             if (x & 0x80000000 > 0) {
 231 |     |                 result = (result * 0x10000000058B90BFC) >> 64;
 232 |     |             }
 233 |     |             if (x & 0x40000000 > 0) {
 234 |     |                 result = (result * 0x1000000002C5C85FE) >> 64;
 235 |     |             }
 236 |     |             if (x & 0x20000000 > 0) {
 237 |     |                 result = (result * 0x100000000162E42FF) >> 64;
 238 |     |             }
 239 |     |             if (x & 0x10000000 > 0) {
 240 |     |                 result = (result * 0x1000000000B17217F) >> 64;
 241 |     |             }
 242 |     |             if (x & 0x8000000 > 0) {
 243 |     |                 result = (result * 0x100000000058B90C0) >> 64;
 244 |     |             }
 245 |     |             if (x & 0x4000000 > 0) {
 246 |     |                 result = (result * 0x10000000002C5C860) >> 64;
 247 |     |             }
 248 |     |             if (x & 0x2000000 > 0) {
 249 |     |                 result = (result * 0x1000000000162E430) >> 64;
 250 |     |             }
 251 |     |             if (x & 0x1000000 > 0) {
 252 |     |                 result = (result * 0x10000000000B17218) >> 64;
 253 |     |             }
 254 |     |             if (x & 0x800000 > 0) {
 255 |     |                 result = (result * 0x1000000000058B90C) >> 64;
 256 |     |             }
 257 |     |             if (x & 0x400000 > 0) {
 258 |     |                 result = (result * 0x100000000002C5C86) >> 64;
 259 |     |             }
 260 |     |             if (x & 0x200000 > 0) {
 261 |     |                 result = (result * 0x10000000000162E43) >> 64;
 262 |     |             }
 263 |     |             if (x & 0x100000 > 0) {
 264 |     |                 result = (result * 0x100000000000B1721) >> 64;
 265 |     |             }
 266 |     |             if (x & 0x80000 > 0) {
 267 |     |                 result = (result * 0x10000000000058B91) >> 64;
 268 |     |             }
 269 |     |             if (x & 0x40000 > 0) {
 270 |     |                 result = (result * 0x1000000000002C5C8) >> 64;
 271 |     |             }
 272 |     |             if (x & 0x20000 > 0) {
 273 |     |                 result = (result * 0x100000000000162E4) >> 64;
 274 |     |             }
 275 |     |             if (x & 0x10000 > 0) {
 276 |     |                 result = (result * 0x1000000000000B172) >> 64;
 277 |     |             }
 278 |     |             if (x & 0x8000 > 0) {
 279 |     |                 result = (result * 0x100000000000058B9) >> 64;
 280 |     |             }
 281 |     |             if (x & 0x4000 > 0) {
 282 |     |                 result = (result * 0x10000000000002C5D) >> 64;
 283 |     |             }
 284 |     |             if (x & 0x2000 > 0) {
 285 |     |                 result = (result * 0x1000000000000162E) >> 64;
 286 |     |             }
 287 |     |             if (x & 0x1000 > 0) {
 288 |     |                 result = (result * 0x10000000000000B17) >> 64;
 289 |     |             }
 290 |     |             if (x & 0x800 > 0) {
 291 |     |                 result = (result * 0x1000000000000058C) >> 64;
 292 |     |             }
 293 |     |             if (x & 0x400 > 0) {
 294 |     |                 result = (result * 0x100000000000002C6) >> 64;
 295 |     |             }
 296 |     |             if (x & 0x200 > 0) {
 297 |     |                 result = (result * 0x10000000000000163) >> 64;
 298 |     |             }
 299 |     |             if (x & 0x100 > 0) {
 300 |     |                 result = (result * 0x100000000000000B1) >> 64;
 301 |     |             }
 302 |     |             if (x & 0x80 > 0) {
 303 |     |                 result = (result * 0x10000000000000059) >> 64;
 304 |     |             }
 305 |     |             if (x & 0x40 > 0) {
 306 |     |                 result = (result * 0x1000000000000002C) >> 64;
 307 |     |             }
 308 |     |             if (x & 0x20 > 0) {
 309 |     |                 result = (result * 0x10000000000000016) >> 64;
 310 |     |             }
 311 |     |             if (x & 0x10 > 0) {
 312 |     |                 result = (result * 0x1000000000000000B) >> 64;
 313 |     |             }
 314 |     |             if (x & 0x8 > 0) {
 315 |     |                 result = (result * 0x10000000000000006) >> 64;
 316 |     |             }
 317 |     |             if (x & 0x4 > 0) {
 318 |     |                 result = (result * 0x10000000000000003) >> 64;
 319 |     |             }
 320 |     |             if (x & 0x2 > 0) {
 321 |     |                 result = (result * 0x10000000000000001) >> 64;
 322 |     |             }
 323 |     |             if (x & 0x1 > 0) {
 324 |     |                 result = (result * 0x10000000000000001) >> 64;
 325 |     |             }
 326 |     | 
 327 |     |             // We're doing two things at the same time:
 328 |     |             //
 329 |     |             //   1. Multiply the result by 2^n + 1, where "2^n" is the integer part and the one is added to account for
 330 |     |             //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191
 331 |     |             //      rather than 192.
 332 |     |             //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.
 333 |     |             //
 334 |     |             // This works because 2^(191-ip) = 2^ip / 2^191, where "ip" is the integer part "2^n".
 335 |     |             result *= SCALE;
 336 |     |             result >>= (191 - (x >> 64));
 337 |     |         }
 338 |     |     }
 339 |     | 
 340 |     |     /// @notice Finds the zero-based index of the first one in the binary representation of x.
 341 |     |     /// @dev See the note on msb in the "Find First Set" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set
 342 |     |     /// @param x The uint256 number for which to find the index of the most significant bit.
 343 |     |     /// @return msb The index of the most significant bit as an uint256.
 344 |     |     function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {
 345 |     |         if (x >= 2**128) {
 346 |     |             x >>= 128;
 347 |     |             msb += 128;
 348 |     |         }
 349 |     |         if (x >= 2**64) {
 350 |     |             x >>= 64;
 351 |     |             msb += 64;
 352 |     |         }
 353 |     |         if (x >= 2**32) {
 354 |     |             x >>= 32;
 355 |     |             msb += 32;
 356 |     |         }
 357 |     |         if (x >= 2**16) {
 358 |     |             x >>= 16;
 359 |     |             msb += 16;
 360 |     |         }
 361 |     |         if (x >= 2**8) {
 362 |     |             x >>= 8;
 363 |     |             msb += 8;
 364 |     |         }
 365 |     |         if (x >= 2**4) {
 366 |     |             x >>= 4;
 367 |     |             msb += 4;
 368 |     |         }
 369 |     |         if (x >= 2**2) {
 370 |     |             x >>= 2;
 371 |     |             msb += 2;
 372 |     |         }
 373 |     |         if (x >= 2**1) {
 374 |     |             // No need to shift x any more.
 375 |     |             msb += 1;
 376 |     |         }
 377 |     |     }
 378 |     | 
 379 |     |     /// @notice Calculates floor(x*y÷denominator) with full precision.
 380 |     |     ///
 381 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.
 382 |     |     ///
 383 |     |     /// Requirements:
 384 |     |     /// - The denominator cannot be zero.
 385 |     |     /// - The result must fit within uint256.
 386 |     |     ///
 387 |     |     /// Caveats:
 388 |     |     /// - This function does not work with fixed-point numbers.
 389 |     |     ///
 390 |     |     /// @param x The multiplicand as an uint256.
 391 |     |     /// @param y The multiplier as an uint256.
 392 |     |     /// @param denominator The divisor as an uint256.
 393 |     |     /// @return result The result as an uint256.
 394 |     |     function mulDiv(
 395 |     |         uint256 x,
 396 |     |         uint256 y,
 397 |     |         uint256 denominator
 398 |     |     ) internal pure returns (uint256 result) {
 399 |     |         // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
 400 |     |         // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
 401 |     |         // variables such that product = prod1 * 2^256 + prod0.
 402 |     |         uint256 prod0; // Least significant 256 bits of the product
 403 |     |         uint256 prod1; // Most significant 256 bits of the product
 404 |     |         assembly {
 405 |     |             let mm := mulmod(x, y, not(0))
 406 |     |             prod0 := mul(x, y)
 407 |     |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
 408 |     |         }
 409 |     | 
 410 |     |         // Handle non-overflow cases, 256 by 256 division.
 411 |     |         if (prod1 == 0) {
 412 |     |             unchecked {
 413 |     |                 result = prod0 / denominator;
 414 |     |             }
 415 |     |             return result;
 416 |     |         }
 417 |     | 
 418 |     |         // Make sure the result is less than 2^256. Also prevents denominator == 0.
 419 |     |         if (prod1 >= denominator) {
 420 |     |             revert PRBMath__MulDivOverflow(prod1, denominator);
 421 |     |         }
 422 |     | 
 423 |     |         ///////////////////////////////////////////////
 424 |     |         // 512 by 256 division.
 425 |     |         ///////////////////////////////////////////////
 426 |     | 
 427 |     |         // Make division exact by subtracting the remainder from [prod1 prod0].
 428 |     |         uint256 remainder;
 429 |     |         assembly {
 430 |     |             // Compute remainder using mulmod.
 431 |     |             remainder := mulmod(x, y, denominator)
 432 |     | 
 433 |     |             // Subtract 256 bit number from 512 bit number.
 434 |     |             prod1 := sub(prod1, gt(remainder, prod0))
 435 |     |             prod0 := sub(prod0, remainder)
 436 |     |         }
 437 |     | 
 438 |     |         // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
 439 |     |         // See https://cs.stackexchange.com/q/138556/92363.
 440 |     |         unchecked {
 441 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
 442 |     |             uint256 lpotdod = denominator & (~denominator + 1);
 443 |     |             assembly {
 444 |     |                 // Divide denominator by lpotdod.
 445 |     |                 denominator := div(denominator, lpotdod)
 446 |     | 
 447 |     |                 // Divide [prod1 prod0] by lpotdod.
 448 |     |                 prod0 := div(prod0, lpotdod)
 449 |     | 
 450 |     |                 // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.
 451 |     |                 lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)
 452 |     |             }
 453 |     | 
 454 |     |             // Shift in bits from prod1 into prod0.
 455 |     |             prod0 |= prod1 * lpotdod;
 456 |     | 
 457 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 458 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 459 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 460 |     |             uint256 inverse = (3 * denominator) ^ 2;
 461 |     | 
 462 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 463 |     |             // in modular arithmetic, doubling the correct bits in each step.
 464 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 465 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 466 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 467 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 468 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 469 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 470 |     | 
 471 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 472 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 473 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 474 |     |             // is no longer required.
 475 |     |             result = prod0 * inverse;
 476 |     |             return result;
 477 |     |         }
 478 |     |     }
 479 |     | 
 480 |     |     /// @notice Calculates floor(x*y÷1e18) with full precision.
 481 |     |     ///
 482 |     |     /// @dev Variant of "mulDiv" with constant folding, i.e. in which the denominator is always 1e18. Before returning the
 483 |     |     /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of
 484 |     |     /// being rounded to 1e-18.  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717.
 485 |     |     ///
 486 |     |     /// Requirements:
 487 |     |     /// - The result must fit within uint256.
 488 |     |     ///
 489 |     |     /// Caveats:
 490 |     |     /// - The body is purposely left uncommented; see the NatSpec comments in "PRBMath.mulDiv" to understand how this works.
 491 |     |     /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:
 492 |     |     ///     1. x * y = type(uint256).max * SCALE
 493 |     |     ///     2. (x * y) % SCALE >= SCALE / 2
 494 |     |     ///
 495 |     |     /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.
 496 |     |     /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.
 497 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point number.
 498 |     |     function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {
 499 |     |         uint256 prod0;
 500 |     |         uint256 prod1;
 501 |     |         assembly {
 502 |     |             let mm := mulmod(x, y, not(0))
 503 |     |             prod0 := mul(x, y)
 504 |     |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
 505 |     |         }
 506 |     | 
 507 |     |         if (prod1 >= SCALE) {
 508 |     |             revert PRBMath__MulDivFixedPointOverflow(prod1);
 509 |     |         }
 510 |     | 
 511 |     |         uint256 remainder;
 512 |     |         uint256 roundUpUnit;
 513 |     |         assembly {
 514 |     |             remainder := mulmod(x, y, SCALE)
 515 |     |             roundUpUnit := gt(remainder, 499999999999999999)
 516 |     |         }
 517 |     | 
 518 |     |         if (prod1 == 0) {
 519 |     |             unchecked {
 520 |     |                 result = (prod0 / SCALE) + roundUpUnit;
 521 |     |                 return result;
 522 |     |             }
 523 |     |         }
 524 |     | 
 525 |     |         assembly {
 526 |     |             result := add(
 527 |     |                 mul(
 528 |     |                     or(
 529 |     |                         div(sub(prod0, remainder), SCALE_LPOTD),
 530 |     |                         mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))
 531 |     |                     ),
 532 |     |                     SCALE_INVERSE
 533 |     |                 ),
 534 |     |                 roundUpUnit
 535 |     |             )
 536 |     |         }
 537 |     |     }
 538 |     | 
 539 |     |     /// @notice Calculates floor(x*y÷denominator) with full precision.
 540 |     |     ///
 541 |     |     /// @dev An extension of "mulDiv" for signed numbers. Works by computing the signs and the absolute values separately.
 542 |     |     ///
 543 |     |     /// Requirements:
 544 |     |     /// - None of the inputs can be type(int256).min.
 545 |     |     /// - The result must fit within int256.
 546 |     |     ///
 547 |     |     /// @param x The multiplicand as an int256.
 548 |     |     /// @param y The multiplier as an int256.
 549 |     |     /// @param denominator The divisor as an int256.
 550 |     |     /// @return result The result as an int256.
 551 |     |     function mulDivSigned(
 552 |     |         int256 x,
 553 |     |         int256 y,
 554 |     |         int256 denominator
 555 |     |     ) internal pure returns (int256 result) {
 556 |     |         if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {
 557 |     |             revert PRBMath__MulDivSignedInputTooSmall();
 558 |     |         }
 559 |     | 
 560 |     |         // Get hold of the absolute values of x, y and the denominator.
 561 |     |         uint256 ax;
 562 |     |         uint256 ay;
 563 |     |         uint256 ad;
 564 |     |         unchecked {
 565 |     |             ax = x < 0 ? uint256(-x) : uint256(x);
 566 |     |             ay = y < 0 ? uint256(-y) : uint256(y);
 567 |     |             ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);
 568 |     |         }
 569 |     | 
 570 |     |         // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.
 571 |     |         uint256 rAbs = mulDiv(ax, ay, ad);
 572 |     |         if (rAbs > uint256(type(int256).max)) {
 573 |     |             revert PRBMath__MulDivSignedOverflow(rAbs);
 574 |     |         }
 575 |     | 
 576 |     |         // Get the signs of x, y and the denominator.
 577 |     |         uint256 sx;
 578 |     |         uint256 sy;
 579 |     |         uint256 sd;
 580 |     |         assembly {
 581 |     |             sx := sgt(x, sub(0, 1))
 582 |     |             sy := sgt(y, sub(0, 1))
 583 |     |             sd := sgt(denominator, sub(0, 1))
 584 |     |         }
 585 |     | 
 586 |     |         // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.
 587 |     |         // If yes, the result should be negative.
 588 |     |         result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);
 589 |     |     }
 590 |     | 
 591 |     |     /// @notice Calculates the square root of x, rounding down.
 592 |     |     /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.
 593 |     |     ///
 594 |     |     /// Caveats:
 595 |     |     /// - This function does not work with fixed-point numbers.
 596 |     |     ///
 597 |     |     /// @param x The uint256 number for which to calculate the square root.
 598 |     |     /// @return result The result as an uint256.
 599 |     |     function sqrt(uint256 x) internal pure returns (uint256 result) {
 600 |     |         if (x == 0) {
 601 |     |             return 0;
 602 |     |         }
 603 |     | 
 604 |     |         // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).
 605 |     |         uint256 xAux = uint256(x);
 606 |     |         result = 1;
 607 |     |         if (xAux >= 0x100000000000000000000000000000000) {
 608 |     |             xAux >>= 128;
 609 |     |             result <<= 64;
 610 |     |         }
 611 |     |         if (xAux >= 0x10000000000000000) {
 612 |     |             xAux >>= 64;
 613 |     |             result <<= 32;
 614 |     |         }
 615 |     |         if (xAux >= 0x100000000) {
 616 |     |             xAux >>= 32;
 617 |     |             result <<= 16;
 618 |     |         }
 619 |     |         if (xAux >= 0x10000) {
 620 |     |             xAux >>= 16;
 621 |     |             result <<= 8;
 622 |     |         }
 623 |     |         if (xAux >= 0x100) {
 624 |     |             xAux >>= 8;
 625 |     |             result <<= 4;
 626 |     |         }
 627 |     |         if (xAux >= 0x10) {
 628 |     |             xAux >>= 4;
 629 |     |             result <<= 2;
 630 |     |         }
 631 |     |         if (xAux >= 0x8) {
 632 |     |             result <<= 1;
 633 |     |         }
 634 |     | 
 635 |     |         // The operations can never overflow because the result is max 2^127 when it enters this block.
 636 |     |         unchecked {
 637 |     |             result = (result + x / result) >> 1;
 638 |     |             result = (result + x / result) >> 1;
 639 |     |             result = (result + x / result) >> 1;
 640 |     |             result = (result + x / result) >> 1;
 641 |     |             result = (result + x / result) >> 1;
 642 |     |             result = (result + x / result) >> 1;
 643 |     |             result = (result + x / result) >> 1; // Seven iterations should be enough
 644 |     |             uint256 roundedDownResult = x / result;
 645 |     |             return result >= roundedDownResult ? roundedDownResult : result;
 646 |     |         }
 647 |     |     }
 648 |     | }
 649 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@prb/math/contracts/PRBMathUD60x18.sol
   1 |     | // SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity >=0.8.4;
   3 |     | 
   4 |     | import "./PRBMath.sol";
   5 |     | 
   6 |     | /// @title PRBMathUD60x18
   7 |     | /// @author Paul Razvan Berg
   8 |     | /// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18
   9 |     | /// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60
  10 |     | /// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the
  11 |     | /// maximum values permitted by the Solidity type uint256.
  12 | *   | library PRBMathUD60x18 {
  13 |     |     /// @dev Half the SCALE number.
  14 |     |     uint256 internal constant HALF_SCALE = 5e17;
  15 |     | 
  16 |     |     /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.
  17 |     |     uint256 internal constant LOG2_E = 1_442695040888963407;
  18 |     | 
  19 |     |     /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.
  20 |     |     uint256 internal constant MAX_UD60x18 =
  21 |     |         115792089237316195423570985008687907853269984665640564039457_584007913129639935;
  22 |     | 
  23 |     |     /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.
  24 |     |     uint256 internal constant MAX_WHOLE_UD60x18 =
  25 |     |         115792089237316195423570985008687907853269984665640564039457_000000000000000000;
  26 |     | 
  27 |     |     /// @dev How many trailing decimals can be represented.
  28 |     |     uint256 internal constant SCALE = 1e18;
  29 |     | 
  30 |     |     /// @notice Calculates the arithmetic average of x and y, rounding down.
  31 |     |     /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.
  32 |     |     /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.
  33 |     |     /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.
  34 |     |     function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {
  35 |     |         // The operations can never overflow.
  36 |     |         unchecked {
  37 |     |             // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need
  38 |     |             // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.
  39 |     |             result = (x >> 1) + (y >> 1) + (x & y & 1);
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.
  44 |     |     ///
  45 |     |     /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.
  46 |     |     /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.
  47 |     |     ///
  48 |     |     /// Requirements:
  49 |     |     /// - x must be less than or equal to MAX_WHOLE_UD60x18.
  50 |     |     ///
  51 |     |     /// @param x The unsigned 60.18-decimal fixed-point number to ceil.
  52 |     |     /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.
  53 |     |     function ceil(uint256 x) internal pure returns (uint256 result) {
  54 |     |         if (x > MAX_WHOLE_UD60x18) {
  55 |     |             revert PRBMathUD60x18__CeilOverflow(x);
  56 |     |         }
  57 |     |         assembly {
  58 |     |             // Equivalent to "x % SCALE" but faster.
  59 |     |             let remainder := mod(x, SCALE)
  60 |     | 
  61 |     |             // Equivalent to "SCALE - remainder" but faster.
  62 |     |             let delta := sub(SCALE, remainder)
  63 |     | 
  64 |     |             // Equivalent to "x + delta * (remainder > 0 ? 1 : 0)" but faster.
  65 |     |             result := add(x, mul(delta, gt(remainder, 0)))
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.
  70 |     |     ///
  71 |     |     /// @dev Uses mulDiv to enable overflow-safe multiplication and division.
  72 |     |     ///
  73 |     |     /// Requirements:
  74 |     |     /// - The denominator cannot be zero.
  75 |     |     ///
  76 |     |     /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.
  77 |     |     /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.
  78 |     |     /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.
  79 |     |     function div(uint256 x, uint256 y) internal pure returns (uint256 result) {
  80 |     |         result = PRBMath.mulDiv(x, SCALE, y);
  81 |     |     }
  82 |     | 
  83 |     |     /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.
  84 |     |     /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).
  85 |     |     function e() internal pure returns (uint256 result) {
  86 |     |         result = 2_718281828459045235;
  87 |     |     }
  88 |     | 
  89 |     |     /// @notice Calculates the natural exponent of x.
  90 |     |     ///
  91 |     |     /// @dev Based on the insight that e^x = 2^(x * log2(e)).
  92 |     |     ///
  93 |     |     /// Requirements:
  94 |     |     /// - All from "log2".
  95 |     |     /// - x must be less than 133.084258667509499441.
  96 |     |     ///
  97 |     |     /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.
  98 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point number.
  99 |     |     function exp(uint256 x) internal pure returns (uint256 result) {
 100 |     |         // Without this check, the value passed to "exp2" would be greater than 192.
 101 |     |         if (x >= 133_084258667509499441) {
 102 |     |             revert PRBMathUD60x18__ExpInputTooBig(x);
 103 |     |         }
 104 |     | 
 105 |     |         // Do the fixed-point multiplication inline to save gas.
 106 |     |         unchecked {
 107 |     |             uint256 doubleScaleProduct = x * LOG2_E;
 108 |     |             result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);
 109 |     |         }
 110 |     |     }
 111 |     | 
 112 |     |     /// @notice Calculates the binary exponent of x using the binary fraction method.
 113 |     |     ///
 114 |     |     /// @dev See https://ethereum.stackexchange.com/q/79903/24693.
 115 |     |     ///
 116 |     |     /// Requirements:
 117 |     |     /// - x must be 192 or less.
 118 |     |     /// - The result must fit within MAX_UD60x18.
 119 |     |     ///
 120 |     |     /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.
 121 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point number.
 122 |     |     function exp2(uint256 x) internal pure returns (uint256 result) {
 123 |     |         // 2^192 doesn't fit within the 192.64-bit format used internally in this function.
 124 |     |         if (x >= 192e18) {
 125 |     |             revert PRBMathUD60x18__Exp2InputTooBig(x);
 126 |     |         }
 127 |     | 
 128 |     |         unchecked {
 129 |     |             // Convert x to the 192.64-bit fixed-point format.
 130 |     |             uint256 x192x64 = (x << 64) / SCALE;
 131 |     | 
 132 |     |             // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.
 133 |     |             result = PRBMath.exp2(x192x64);
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.
 138 |     |     /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.
 139 |     |     /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.
 140 |     |     /// @param x The unsigned 60.18-decimal fixed-point number to floor.
 141 |     |     /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.
 142 |     |     function floor(uint256 x) internal pure returns (uint256 result) {
 143 |     |         assembly {
 144 |     |             // Equivalent to "x % SCALE" but faster.
 145 |     |             let remainder := mod(x, SCALE)
 146 |     | 
 147 |     |             // Equivalent to "x - remainder * (remainder > 0 ? 1 : 0)" but faster.
 148 |     |             result := sub(x, mul(remainder, gt(remainder, 0)))
 149 |     |         }
 150 |     |     }
 151 |     | 
 152 |     |     /// @notice Yields the excess beyond the floor of x.
 153 |     |     /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.
 154 |     |     /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.
 155 |     |     /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.
 156 |     |     function frac(uint256 x) internal pure returns (uint256 result) {
 157 |     |         assembly {
 158 |     |             result := mod(x, SCALE)
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.
 163 |     |     ///
 164 |     |     /// @dev Requirements:
 165 |     |     /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.
 166 |     |     ///
 167 |     |     /// @param x The basic integer to convert.
 168 |     |     /// @param result The same number in unsigned 60.18-decimal fixed-point representation.
 169 |     |     function fromUint(uint256 x) internal pure returns (uint256 result) {
 170 |     |         unchecked {
 171 |     |             if (x > MAX_UD60x18 / SCALE) {
 172 |     |                 revert PRBMathUD60x18__FromUintOverflow(x);
 173 |     |             }
 174 |     |             result = x * SCALE;
 175 |     |         }
 176 |     |     }
 177 |     | 
 178 |     |     /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.
 179 |     |     ///
 180 |     |     /// @dev Requirements:
 181 |     |     /// - x * y must fit within MAX_UD60x18, lest it overflows.
 182 |     |     ///
 183 |     |     /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.
 184 |     |     /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.
 185 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point number.
 186 |     |     function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {
 187 |     |         if (x == 0) {
 188 |     |             return 0;
 189 |     |         }
 190 |     | 
 191 |     |         unchecked {
 192 |     |             // Checking for overflow this way is faster than letting Solidity do it.
 193 |     |             uint256 xy = x * y;
 194 |     |             if (xy / x != y) {
 195 |     |                 revert PRBMathUD60x18__GmOverflow(x, y);
 196 |     |             }
 197 |     | 
 198 |     |             // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE
 199 |     |             // during multiplication. See the comments within the "sqrt" function.
 200 |     |             result = PRBMath.sqrt(xy);
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /// @notice Calculates 1 / x, rounding toward zero.
 205 |     |     ///
 206 |     |     /// @dev Requirements:
 207 |     |     /// - x cannot be zero.
 208 |     |     ///
 209 |     |     /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.
 210 |     |     /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.
 211 |     |     function inv(uint256 x) internal pure returns (uint256 result) {
 212 |     |         unchecked {
 213 |     |             // 1e36 is SCALE * SCALE.
 214 |     |             result = 1e36 / x;
 215 |     |         }
 216 |     |     }
 217 |     | 
 218 |     |     /// @notice Calculates the natural logarithm of x.
 219 |     |     ///
 220 |     |     /// @dev Based on the insight that ln(x) = log2(x) / log2(e).
 221 |     |     ///
 222 |     |     /// Requirements:
 223 |     |     /// - All from "log2".
 224 |     |     ///
 225 |     |     /// Caveats:
 226 |     |     /// - All from "log2".
 227 |     |     /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.
 228 |     |     ///
 229 |     |     /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.
 230 |     |     /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.
 231 |     |     function ln(uint256 x) internal pure returns (uint256 result) {
 232 |     |         // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)
 233 |     |         // can return is 196205294292027477728.
 234 |     |         unchecked {
 235 |     |             result = (log2(x) * SCALE) / LOG2_E;
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @notice Calculates the common logarithm of x.
 240 |     |     ///
 241 |     |     /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common
 242 |     |     /// logarithm based on the insight that log10(x) = log2(x) / log2(10).
 243 |     |     ///
 244 |     |     /// Requirements:
 245 |     |     /// - All from "log2".
 246 |     |     ///
 247 |     |     /// Caveats:
 248 |     |     /// - All from "log2".
 249 |     |     ///
 250 |     |     /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.
 251 |     |     /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.
 252 |     |     function log10(uint256 x) internal pure returns (uint256 result) {
 253 |     |         if (x < SCALE) {
 254 |     |             revert PRBMathUD60x18__LogInputTooSmall(x);
 255 |     |         }
 256 |     | 
 257 |     |         // Note that the "mul" in this block is the assembly multiplication operation, not the "mul" function defined
 258 |     |         // in this contract.
 259 |     |         // prettier-ignore
 260 |     |         assembly {
 261 |     |             switch x
 262 |     |             case 1 { result := mul(SCALE, sub(0, 18)) }
 263 |     |             case 10 { result := mul(SCALE, sub(1, 18)) }
 264 |     |             case 100 { result := mul(SCALE, sub(2, 18)) }
 265 |     |             case 1000 { result := mul(SCALE, sub(3, 18)) }
 266 |     |             case 10000 { result := mul(SCALE, sub(4, 18)) }
 267 |     |             case 100000 { result := mul(SCALE, sub(5, 18)) }
 268 |     |             case 1000000 { result := mul(SCALE, sub(6, 18)) }
 269 |     |             case 10000000 { result := mul(SCALE, sub(7, 18)) }
 270 |     |             case 100000000 { result := mul(SCALE, sub(8, 18)) }
 271 |     |             case 1000000000 { result := mul(SCALE, sub(9, 18)) }
 272 |     |             case 10000000000 { result := mul(SCALE, sub(10, 18)) }
 273 |     |             case 100000000000 { result := mul(SCALE, sub(11, 18)) }
 274 |     |             case 1000000000000 { result := mul(SCALE, sub(12, 18)) }
 275 |     |             case 10000000000000 { result := mul(SCALE, sub(13, 18)) }
 276 |     |             case 100000000000000 { result := mul(SCALE, sub(14, 18)) }
 277 |     |             case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }
 278 |     |             case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }
 279 |     |             case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }
 280 |     |             case 1000000000000000000 { result := 0 }
 281 |     |             case 10000000000000000000 { result := SCALE }
 282 |     |             case 100000000000000000000 { result := mul(SCALE, 2) }
 283 |     |             case 1000000000000000000000 { result := mul(SCALE, 3) }
 284 |     |             case 10000000000000000000000 { result := mul(SCALE, 4) }
 285 |     |             case 100000000000000000000000 { result := mul(SCALE, 5) }
 286 |     |             case 1000000000000000000000000 { result := mul(SCALE, 6) }
 287 |     |             case 10000000000000000000000000 { result := mul(SCALE, 7) }
 288 |     |             case 100000000000000000000000000 { result := mul(SCALE, 8) }
 289 |     |             case 1000000000000000000000000000 { result := mul(SCALE, 9) }
 290 |     |             case 10000000000000000000000000000 { result := mul(SCALE, 10) }
 291 |     |             case 100000000000000000000000000000 { result := mul(SCALE, 11) }
 292 |     |             case 1000000000000000000000000000000 { result := mul(SCALE, 12) }
 293 |     |             case 10000000000000000000000000000000 { result := mul(SCALE, 13) }
 294 |     |             case 100000000000000000000000000000000 { result := mul(SCALE, 14) }
 295 |     |             case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }
 296 |     |             case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }
 297 |     |             case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }
 298 |     |             case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }
 299 |     |             case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }
 300 |     |             case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }
 301 |     |             case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }
 302 |     |             case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }
 303 |     |             case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }
 304 |     |             case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }
 305 |     |             case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }
 306 |     |             case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }
 307 |     |             case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }
 308 |     |             case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }
 309 |     |             case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }
 310 |     |             case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }
 311 |     |             case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }
 312 |     |             case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }
 313 |     |             case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }
 314 |     |             case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }
 315 |     |             case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }
 316 |     |             case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }
 317 |     |             case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }
 318 |     |             case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }
 319 |     |             case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }
 320 |     |             case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }
 321 |     |             case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }
 322 |     |             case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }
 323 |     |             case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }
 324 |     |             case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }
 325 |     |             case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }
 326 |     |             case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }
 327 |     |             case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }
 328 |     |             case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }
 329 |     |             case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }
 330 |     |             case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }
 331 |     |             case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }
 332 |     |             case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }
 333 |     |             case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }
 334 |     |             case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }
 335 |     |             case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }
 336 |     |             case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }
 337 |     |             case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }
 338 |     |             case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }
 339 |     |             case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }
 340 |     |             default {
 341 |     |                 result := MAX_UD60x18
 342 |     |             }
 343 |     |         }
 344 |     | 
 345 |     |         if (result == MAX_UD60x18) {
 346 |     |             // Do the fixed-point division inline to save gas. The denominator is log2(10).
 347 |     |             unchecked {
 348 |     |                 result = (log2(x) * SCALE) / 3_321928094887362347;
 349 |     |             }
 350 |     |         }
 351 |     |     }
 352 |     | 
 353 |     |     /// @notice Calculates the binary logarithm of x.
 354 |     |     ///
 355 |     |     /// @dev Based on the iterative approximation algorithm.
 356 |     |     /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation
 357 |     |     ///
 358 |     |     /// Requirements:
 359 |     |     /// - x must be greater than or equal to SCALE, otherwise the result would be negative.
 360 |     |     ///
 361 |     |     /// Caveats:
 362 |     |     /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.
 363 |     |     ///
 364 |     |     /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.
 365 |     |     /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.
 366 |     |     function log2(uint256 x) internal pure returns (uint256 result) {
 367 |     |         if (x < SCALE) {
 368 |     |             revert PRBMathUD60x18__LogInputTooSmall(x);
 369 |     |         }
 370 |     |         unchecked {
 371 |     |             // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).
 372 |     |             uint256 n = PRBMath.mostSignificantBit(x / SCALE);
 373 |     | 
 374 |     |             // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow
 375 |     |             // because n is maximum 255 and SCALE is 1e18.
 376 |     |             result = n * SCALE;
 377 |     | 
 378 |     |             // This is y = x * 2^(-n).
 379 |     |             uint256 y = x >> n;
 380 |     | 
 381 |     |             // If y = 1, the fractional part is zero.
 382 |     |             if (y == SCALE) {
 383 |     |                 return result;
 384 |     |             }
 385 |     | 
 386 |     |             // Calculate the fractional part via the iterative approximation.
 387 |     |             // The "delta >>= 1" part is equivalent to "delta /= 2", but shifting bits is faster.
 388 |     |             for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {
 389 |     |                 y = (y * y) / SCALE;
 390 |     | 
 391 |     |                 // Is y^2 > 2 and so in the range [2,4)?
 392 |     |                 if (y >= 2 * SCALE) {
 393 |     |                     // Add the 2^(-m) factor to the logarithm.
 394 |     |                     result += delta;
 395 |     | 
 396 |     |                     // Corresponds to z/2 on Wikipedia.
 397 |     |                     y >>= 1;
 398 |     |                 }
 399 |     |             }
 400 |     |         }
 401 |     |     }
 402 |     | 
 403 |     |     /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal
 404 |     |     /// fixed-point number.
 405 |     |     /// @dev See the documentation for the "PRBMath.mulDivFixedPoint" function.
 406 |     |     /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.
 407 |     |     /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.
 408 |     |     /// @return result The product as an unsigned 60.18-decimal fixed-point number.
 409 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {
 410 |     |         result = PRBMath.mulDivFixedPoint(x, y);
 411 |     |     }
 412 |     | 
 413 |     |     /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.
 414 |     |     function pi() internal pure returns (uint256 result) {
 415 |     |         result = 3_141592653589793238;
 416 |     |     }
 417 |     | 
 418 |     |     /// @notice Raises x to the power of y.
 419 |     |     ///
 420 |     |     /// @dev Based on the insight that x^y = 2^(log2(x) * y).
 421 |     |     ///
 422 |     |     /// Requirements:
 423 |     |     /// - All from "exp2", "log2" and "mul".
 424 |     |     ///
 425 |     |     /// Caveats:
 426 |     |     /// - All from "exp2", "log2" and "mul".
 427 |     |     /// - Assumes 0^0 is 1.
 428 |     |     ///
 429 |     |     /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.
 430 |     |     /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.
 431 |     |     /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.
 432 |     |     function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {
 433 |     |         if (x == 0) {
 434 |     |             result = y == 0 ? SCALE : uint256(0);
 435 |     |         } else {
 436 |     |             result = exp2(mul(log2(x), y));
 437 |     |         }
 438 |     |     }
 439 |     | 
 440 |     |     /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the
 441 |     |     /// famous algorithm "exponentiation by squaring".
 442 |     |     ///
 443 |     |     /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring
 444 |     |     ///
 445 |     |     /// Requirements:
 446 |     |     /// - The result must fit within MAX_UD60x18.
 447 |     |     ///
 448 |     |     /// Caveats:
 449 |     |     /// - All from "mul".
 450 |     |     /// - Assumes 0^0 is 1.
 451 |     |     ///
 452 |     |     /// @param x The base as an unsigned 60.18-decimal fixed-point number.
 453 |     |     /// @param y The exponent as an uint256.
 454 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point number.
 455 |     |     function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {
 456 |     |         // Calculate the first iteration of the loop in advance.
 457 |     |         result = y & 1 > 0 ? x : SCALE;
 458 |     | 
 459 |     |         // Equivalent to "for(y /= 2; y > 0; y /= 2)" but faster.
 460 |     |         for (y >>= 1; y > 0; y >>= 1) {
 461 |     |             x = PRBMath.mulDivFixedPoint(x, x);
 462 |     | 
 463 |     |             // Equivalent to "y % 2 == 1" but faster.
 464 |     |             if (y & 1 > 0) {
 465 |     |                 result = PRBMath.mulDivFixedPoint(result, x);
 466 |     |             }
 467 |     |         }
 468 |     |     }
 469 |     | 
 470 |     |     /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.
 471 |     |     function scale() internal pure returns (uint256 result) {
 472 |     |         result = SCALE;
 473 |     |     }
 474 |     | 
 475 |     |     /// @notice Calculates the square root of x, rounding down.
 476 |     |     /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.
 477 |     |     ///
 478 |     |     /// Requirements:
 479 |     |     /// - x must be less than MAX_UD60x18 / SCALE.
 480 |     |     ///
 481 |     |     /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.
 482 |     |     /// @return result The result as an unsigned 60.18-decimal fixed-point .
 483 |     |     function sqrt(uint256 x) internal pure returns (uint256 result) {
 484 |     |         unchecked {
 485 |     |             if (x > MAX_UD60x18 / SCALE) {
 486 |     |                 revert PRBMathUD60x18__SqrtOverflow(x);
 487 |     |             }
 488 |     |             // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned
 489 |     |             // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).
 490 |     |             result = PRBMath.sqrt(x * SCALE);
 491 |     |         }
 492 |     |     }
 493 |     | 
 494 |     |     /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.
 495 |     |     /// @param x The unsigned 60.18-decimal fixed-point number to convert.
 496 |     |     /// @return result The same number in basic integer form.
 497 |     |     function toUint(uint256 x) internal pure returns (uint256 result) {
 498 |     |         unchecked {
 499 |     |             result = x / SCALE;
 500 |     |         }
 501 |     |     }
 502 |     | }
 503 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import {IUniswapV3PoolImmutables} from './pool/IUniswapV3PoolImmutables.sol';
  5 |     | import {IUniswapV3PoolState} from './pool/IUniswapV3PoolState.sol';
  6 |     | import {IUniswapV3PoolDerivedState} from './pool/IUniswapV3PoolDerivedState.sol';
  7 |     | import {IUniswapV3PoolActions} from './pool/IUniswapV3PoolActions.sol';
  8 |     | import {IUniswapV3PoolOwnerActions} from './pool/IUniswapV3PoolOwnerActions.sol';
  9 |     | import {IUniswapV3PoolErrors} from './pool/IUniswapV3PoolErrors.sol';
 10 |     | import {IUniswapV3PoolEvents} from './pool/IUniswapV3PoolEvents.sol';
 11 |     | 
 12 |     | /// @title The interface for a Uniswap V3 Pool
 13 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 14 |     | /// to the ERC20 specification
 15 |     | /// @dev The pool interface is broken up into many smaller pieces
 16 |     | interface IUniswapV3Pool is
 17 |     |     IUniswapV3PoolImmutables,
 18 |     |     IUniswapV3PoolState,
 19 |     |     IUniswapV3PoolDerivedState,
 20 |     |     IUniswapV3PoolActions,
 21 |     |     IUniswapV3PoolOwnerActions,
 22 |     |     IUniswapV3PoolErrors,
 23 |     |     IUniswapV3PoolEvents
 24 |     | {
 25 |     | 
 26 |     | }
 27 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title An interface for a contract that is capable of deploying Uniswap V3 Pools
  5 |     | /// @notice A contract that constructs a pool must implement this to pass arguments to the pool
  6 |     | /// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash
  7 |     | /// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain
  8 |     | interface IUniswapV3PoolDeployer {
  9 |     |     /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.
 10 |     |     /// @dev Called by the pool constructor to fetch the parameters of the pool
 11 |     |     /// Returns factory The factory address
 12 |     |     /// Returns token0 The first token of the pool by address sort order
 13 |     |     /// Returns token1 The second token of the pool by address sort order
 14 |     |     /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// Returns tickSpacing The minimum number of ticks between initialized ticks
 16 |     |     function parameters()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             address factory,
 21 |     |             address token0,
 22 |     |             address token1,
 23 |     |             uint24 fee,
 24 |     |             int24 tickSpacing
 25 |     |         );
 26 |     | }
 27 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }
 104 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }
 41 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolErrors.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Errors emitted by a pool
  5 |     | /// @notice Contains all events emitted by the pool
  6 |     | interface IUniswapV3PoolErrors {
  7 |     |     error LOK();
  8 |     |     error TLU();
  9 |     |     error TLM();
 10 |     |     error TUM();
 11 |     |     error AI();
 12 |     |     error M0();
 13 |     |     error M1();
 14 |     |     error AS();
 15 |     |     error IIA();
 16 |     |     error L();
 17 |     |     error F0();
 18 |     |     error F1();
 19 |     | }
 20 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }
 122 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }
 36 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }
 24 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// @return observationIndex The index of the last oracle observation that was written,
  15 |     |     /// @return observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// @return feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     /// @return The liquidity at the current price of the pool
  49 |     |     function liquidity() external view returns (uint128);
  50 |     | 
  51 |     |     /// @notice Look up information about a specific tick in the pool
  52 |     |     /// @param tick The tick to look up
  53 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  54 |     |     /// tick upper
  55 |     |     /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,
  56 |     |     /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  57 |     |     /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  58 |     |     /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  59 |     |     /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  60 |     |     /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,
  61 |     |     /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  62 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  63 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  64 |     |     /// a specific position.
  65 |     |     function ticks(int24 tick)
  66 |     |         external
  67 |     |         view
  68 |     |         returns (
  69 |     |             uint128 liquidityGross,
  70 |     |             int128 liquidityNet,
  71 |     |             uint256 feeGrowthOutside0X128,
  72 |     |             uint256 feeGrowthOutside1X128,
  73 |     |             int56 tickCumulativeOutside,
  74 |     |             uint160 secondsPerLiquidityOutsideX128,
  75 |     |             uint32 secondsOutside,
  76 |     |             bool initialized
  77 |     |         );
  78 |     | 
  79 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  80 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  81 |     | 
  82 |     |     /// @notice Returns the information about a position by the position's key
  83 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  84 |     |     /// @return liquidity The amount of liquidity in the position,
  85 |     |     /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  87 |     |     /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  88 |     |     /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  89 |     |     function positions(bytes32 key)
  90 |     |         external
  91 |     |         view
  92 |     |         returns (
  93 |     |             uint128 liquidity,
  94 |     |             uint256 feeGrowthInside0LastX128,
  95 |     |             uint256 feeGrowthInside1LastX128,
  96 |     |             uint128 tokensOwed0,
  97 |     |             uint128 tokensOwed1
  98 |     |         );
  99 |     | 
 100 |     |     /// @notice Returns data about a specific observation index
 101 |     |     /// @param index The element of the observations array to fetch
 102 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 103 |     |     /// ago, rather than at a specific index in the array.
 104 |     |     /// @return blockTimestamp The timestamp of the observation,
 105 |     |     /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 106 |     |     /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 107 |     |     /// @return initialized whether the observation has been initialized and the values are safe to use
 108 |     |     function observations(uint256 index)
 109 |     |         external
 110 |     |         view
 111 |     |         returns (
 112 |     |             uint32 blockTimestamp,
 113 |     |             int56 tickCumulative,
 114 |     |             uint160 secondsPerLiquidityCumulativeX128,
 115 |     |             bool initialized
 116 |     |         );
 117 |     | }
 118 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 | *   | library FullMath {
   8 |     |     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 |     |     function mulDiv(
  15 |     |         uint256 a,
  16 |     |         uint256 b,
  17 |     |         uint256 denominator
  18 |     |     ) internal pure returns (uint256 result) {
  19 |     |         unchecked {
  20 |     |             // 512-bit multiply [prod1 prod0] = a * b
  21 |     |             // Compute the product mod 2**256 and mod 2**256 - 1
  22 |     |             // then use the Chinese Remainder Theorem to reconstruct
  23 |     |             // the 512 bit result. The result is stored in two 256
  24 |     |             // variables such that product = prod1 * 2**256 + prod0
  25 |     |             uint256 prod0; // Least significant 256 bits of the product
  26 |     |             uint256 prod1; // Most significant 256 bits of the product
  27 |     |             assembly {
  28 |     |                 let mm := mulmod(a, b, not(0))
  29 |     |                 prod0 := mul(a, b)
  30 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  31 |     |             }
  32 |     | 
  33 |     |             // Handle non-overflow cases, 256 by 256 division
  34 |     |             if (prod1 == 0) {
  35 |     |                 require(denominator > 0);
  36 |     |                 assembly {
  37 |     |                     result := div(prod0, denominator)
  38 |     |                 }
  39 |     |                 return result;
  40 |     |             }
  41 |     | 
  42 |     |             // Make sure the result is less than 2**256.
  43 |     |             // Also prevents denominator == 0
  44 |     |             require(denominator > prod1);
  45 |     | 
  46 |     |             ///////////////////////////////////////////////
  47 |     |             // 512 by 256 division.
  48 |     |             ///////////////////////////////////////////////
  49 |     | 
  50 |     |             // Make division exact by subtracting the remainder from [prod1 prod0]
  51 |     |             // Compute remainder using mulmod
  52 |     |             uint256 remainder;
  53 |     |             assembly {
  54 |     |                 remainder := mulmod(a, b, denominator)
  55 |     |             }
  56 |     |             // Subtract 256 bit number from 512 bit number
  57 |     |             assembly {
  58 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  59 |     |                 prod0 := sub(prod0, remainder)
  60 |     |             }
  61 |     | 
  62 |     |             // Factor powers of two out of denominator
  63 |     |             // Compute largest power of two divisor of denominator.
  64 |     |             // Always >= 1.
  65 |     |             uint256 twos = (0 - denominator) & denominator;
  66 |     |             // Divide denominator by power of two
  67 |     |             assembly {
  68 |     |                 denominator := div(denominator, twos)
  69 |     |             }
  70 |     | 
  71 |     |             // Divide [prod1 prod0] by the factors of two
  72 |     |             assembly {
  73 |     |                 prod0 := div(prod0, twos)
  74 |     |             }
  75 |     |             // Shift in bits from prod1 into prod0. For this we need
  76 |     |             // to flip `twos` such that it is 2**256 / twos.
  77 |     |             // If twos is zero, then it becomes one
  78 |     |             assembly {
  79 |     |                 twos := add(div(sub(0, twos), twos), 1)
  80 |     |             }
  81 |     |             prod0 |= prod1 * twos;
  82 |     | 
  83 |     |             // Invert denominator mod 2**256
  84 |     |             // Now that denominator is an odd number, it has an inverse
  85 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  86 |     |             // Compute the inverse by starting with a seed that is correct
  87 |     |             // correct for four bits. That is, denominator * inv = 1 mod 2**4
  88 |     |             uint256 inv = (3 * denominator) ^ 2;
  89 |     |             // Now use Newton-Raphson iteration to improve the precision.
  90 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  91 |     |             // arithmetic, doubling the correct bits in each step.
  92 |     |             inv *= 2 - denominator * inv; // inverse mod 2**8
  93 |     |             inv *= 2 - denominator * inv; // inverse mod 2**16
  94 |     |             inv *= 2 - denominator * inv; // inverse mod 2**32
  95 |     |             inv *= 2 - denominator * inv; // inverse mod 2**64
  96 |     |             inv *= 2 - denominator * inv; // inverse mod 2**128
  97 |     |             inv *= 2 - denominator * inv; // inverse mod 2**256
  98 |     | 
  99 |     |             // Because the division is now exact we can divide by multiplying
 100 |     |             // with the modular inverse of denominator. This will give us the
 101 |     |             // correct result modulo 2**256. Since the precoditions guarantee
 102 |     |             // that the outcome is less than 2**256, this is the final result.
 103 |     |             // We don't need to compute the high bits of the result and prod1
 104 |     |             // is no longer required.
 105 |     |             result = prod0 * inv;
 106 |     |             return result;
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 111 |     |     /// @param a The multiplicand
 112 |     |     /// @param b The multiplier
 113 |     |     /// @param denominator The divisor
 114 |     |     /// @return result The 256-bit result
 115 |     |     function mulDivRoundingUp(
 116 |     |         uint256 a,
 117 |     |         uint256 b,
 118 |     |         uint256 denominator
 119 |     |     ) internal pure returns (uint256 result) {
 120 |     |         unchecked {
 121 |     |             result = mulDiv(a, b, denominator);
 122 |     |             if (mulmod(a, b, denominator) > 0) {
 123 |     |                 require(result < type(uint256).max);
 124 |     |                 result++;
 125 |     |             }
 126 |     |         }
 127 |     |     }
 128 |     | }
 129 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/Oracle.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @title Oracle
   5 |     | /// @notice Provides price and liquidity data useful for a wide variety of system designs
   6 |     | /// @dev Instances of stored oracle data, "observations", are collected in the oracle array
   7 |     | /// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
   8 |     | /// maximum length of the oracle array. New slots will be added when the array is fully populated.
   9 |     | /// Observations are overwritten when the full length of the oracle array is populated.
  10 |     | /// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()
  11 | *   | library Oracle {
  12 |     |     error I();
  13 |     |     error OLD();
  14 |     | 
  15 |     |     struct Observation {
  16 |     |         // the block timestamp of the observation
  17 |     |         uint32 blockTimestamp;
  18 |     |         // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
  19 |     |         int56 tickCumulative;
  20 |     |         // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
  21 |     |         uint160 secondsPerLiquidityCumulativeX128;
  22 |     |         // whether or not the observation is initialized
  23 |     |         bool initialized;
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values
  27 |     |     /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows
  28 |     |     /// @param last The specified observation to be transformed
  29 |     |     /// @param blockTimestamp The timestamp of the new observation
  30 |     |     /// @param tick The active tick at the time of the new observation
  31 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  32 |     |     /// @return Observation The newly populated observation
  33 |     |     function transform(
  34 |     |         Observation memory last,
  35 |     |         uint32 blockTimestamp,
  36 |     |         int24 tick,
  37 |     |         uint128 liquidity
  38 |     |     ) private pure returns (Observation memory) {
  39 |     |         unchecked {
  40 |     |             uint32 delta = blockTimestamp - last.blockTimestamp;
  41 |     |             return
  42 |     |                 Observation({
  43 |     |                     blockTimestamp: blockTimestamp,
  44 |     |                     tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),
  45 |     |                     secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
  46 |     |                         ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
  47 |     |                     initialized: true
  48 |     |                 });
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
  53 |     |     /// @param self The stored oracle array
  54 |     |     /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
  55 |     |     /// @return cardinality The number of populated elements in the oracle array
  56 |     |     /// @return cardinalityNext The new length of the oracle array, independent of population
  57 |     |     function initialize(Observation[65535] storage self, uint32 time)
  58 |     |         internal
  59 |     |         returns (uint16 cardinality, uint16 cardinalityNext)
  60 |     |     {
  61 |     |         self[0] = Observation({
  62 |     |             blockTimestamp: time,
  63 |     |             tickCumulative: 0,
  64 |     |             secondsPerLiquidityCumulativeX128: 0,
  65 |     |             initialized: true
  66 |     |         });
  67 |     |         return (1, 1);
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice Writes an oracle observation to the array
  71 |     |     /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
  72 |     |     /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
  73 |     |     /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
  74 |     |     /// @param self The stored oracle array
  75 |     |     /// @param index The index of the observation that was most recently written to the observations array
  76 |     |     /// @param blockTimestamp The timestamp of the new observation
  77 |     |     /// @param tick The active tick at the time of the new observation
  78 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  79 |     |     /// @param cardinality The number of populated elements in the oracle array
  80 |     |     /// @param cardinalityNext The new length of the oracle array, independent of population
  81 |     |     /// @return indexUpdated The new index of the most recently written element in the oracle array
  82 |     |     /// @return cardinalityUpdated The new cardinality of the oracle array
  83 |     |     function write(
  84 |     |         Observation[65535] storage self,
  85 |     |         uint16 index,
  86 |     |         uint32 blockTimestamp,
  87 |     |         int24 tick,
  88 |     |         uint128 liquidity,
  89 |     |         uint16 cardinality,
  90 |     |         uint16 cardinalityNext
  91 |     |     ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
  92 |     |         unchecked {
  93 |     |             Observation memory last = self[index];
  94 |     | 
  95 |     |             // early return if we've already written an observation this block
  96 |     |             if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
  97 |     | 
  98 |     |             // if the conditions are right, we can bump the cardinality
  99 |     |             if (cardinalityNext > cardinality && index == (cardinality - 1)) {
 100 |     |                 cardinalityUpdated = cardinalityNext;
 101 |     |             } else {
 102 |     |                 cardinalityUpdated = cardinality;
 103 |     |             }
 104 |     | 
 105 |     |             indexUpdated = (index + 1) % cardinalityUpdated;
 106 |     |             self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /// @notice Prepares the oracle array to store up to `next` observations
 111 |     |     /// @param self The stored oracle array
 112 |     |     /// @param current The current next cardinality of the oracle array
 113 |     |     /// @param next The proposed next cardinality which will be populated in the oracle array
 114 |     |     /// @return next The next cardinality which will be populated in the oracle array
 115 |     |     function grow(
 116 |     |         Observation[65535] storage self,
 117 |     |         uint16 current,
 118 |     |         uint16 next
 119 |     |     ) internal returns (uint16) {
 120 |     |         unchecked {
 121 |     |             if (current <= 0) revert I();
 122 |     |             // no-op if the passed next value isn't greater than the current next value
 123 |     |             if (next <= current) return current;
 124 |     |             // store in each slot to prevent fresh SSTOREs in swaps
 125 |     |             // this data will not be used because the initialized boolean is still false
 126 |     |             for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
 127 |     |             return next;
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @notice comparator for 32-bit timestamps
 132 |     |     /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
 133 |     |     /// @param time A timestamp truncated to 32 bits
 134 |     |     /// @param a A comparison timestamp from which to determine the relative position of `time`
 135 |     |     /// @param b From which to determine the relative position of `time`
 136 |     |     /// @return Whether `a` is chronologically <= `b`
 137 |     |     function lte(
 138 |     |         uint32 time,
 139 |     |         uint32 a,
 140 |     |         uint32 b
 141 |     |     ) private pure returns (bool) {
 142 |     |         unchecked {
 143 |     |             // if there hasn't been overflow, no need to adjust
 144 |     |             if (a <= time && b <= time) return a <= b;
 145 |     | 
 146 |     |             uint256 aAdjusted = a > time ? a : a + 2**32;
 147 |     |             uint256 bAdjusted = b > time ? b : b + 2**32;
 148 |     | 
 149 |     |             return aAdjusted <= bAdjusted;
 150 |     |         }
 151 |     |     }
 152 |     | 
 153 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
 154 |     |     /// The result may be the same observation, or adjacent observations.
 155 |     |     /// @dev The answer must be contained in the array, used when the target is located within the stored observation
 156 |     |     /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
 157 |     |     /// @param self The stored oracle array
 158 |     |     /// @param time The current block.timestamp
 159 |     |     /// @param target The timestamp at which the reserved observation should be for
 160 |     |     /// @param index The index of the observation that was most recently written to the observations array
 161 |     |     /// @param cardinality The number of populated elements in the oracle array
 162 |     |     /// @return beforeOrAt The observation recorded before, or at, the target
 163 |     |     /// @return atOrAfter The observation recorded at, or after, the target
 164 |     |     function binarySearch(
 165 |     |         Observation[65535] storage self,
 166 |     |         uint32 time,
 167 |     |         uint32 target,
 168 |     |         uint16 index,
 169 |     |         uint16 cardinality
 170 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 171 |     |         unchecked {
 172 |     |             uint256 l = (index + 1) % cardinality; // oldest observation
 173 |     |             uint256 r = l + cardinality - 1; // newest observation
 174 |     |             uint256 i;
 175 |     |             while (true) {
 176 |     |                 i = (l + r) / 2;
 177 |     | 
 178 |     |                 beforeOrAt = self[i % cardinality];
 179 |     | 
 180 |     |                 // we've landed on an uninitialized tick, keep searching higher (more recently)
 181 |     |                 if (!beforeOrAt.initialized) {
 182 |     |                     l = i + 1;
 183 |     |                     continue;
 184 |     |                 }
 185 |     | 
 186 |     |                 atOrAfter = self[(i + 1) % cardinality];
 187 |     | 
 188 |     |                 bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
 189 |     | 
 190 |     |                 // check if we've found the answer!
 191 |     |                 if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
 192 |     | 
 193 |     |                 if (!targetAtOrAfter) r = i - 1;
 194 |     |                 else l = i + 1;
 195 |     |             }
 196 |     |         }
 197 |     |     }
 198 |     | 
 199 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied
 200 |     |     /// @dev Assumes there is at least 1 initialized observation.
 201 |     |     /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.
 202 |     |     /// @param self The stored oracle array
 203 |     |     /// @param time The current block.timestamp
 204 |     |     /// @param target The timestamp at which the reserved observation should be for
 205 |     |     /// @param tick The active tick at the time of the returned or simulated observation
 206 |     |     /// @param index The index of the observation that was most recently written to the observations array
 207 |     |     /// @param liquidity The total pool liquidity at the time of the call
 208 |     |     /// @param cardinality The number of populated elements in the oracle array
 209 |     |     /// @return beforeOrAt The observation which occurred at, or before, the given timestamp
 210 |     |     /// @return atOrAfter The observation which occurred at, or after, the given timestamp
 211 |     |     function getSurroundingObservations(
 212 |     |         Observation[65535] storage self,
 213 |     |         uint32 time,
 214 |     |         uint32 target,
 215 |     |         int24 tick,
 216 |     |         uint16 index,
 217 |     |         uint128 liquidity,
 218 |     |         uint16 cardinality
 219 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 220 |     |         unchecked {
 221 |     |             // optimistically set before to the newest observation
 222 |     |             beforeOrAt = self[index];
 223 |     | 
 224 |     |             // if the target is chronologically at or after the newest observation, we can early return
 225 |     |             if (lte(time, beforeOrAt.blockTimestamp, target)) {
 226 |     |                 if (beforeOrAt.blockTimestamp == target) {
 227 |     |                     // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
 228 |     |                     return (beforeOrAt, atOrAfter);
 229 |     |                 } else {
 230 |     |                     // otherwise, we need to transform
 231 |     |                     return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
 232 |     |                 }
 233 |     |             }
 234 |     | 
 235 |     |             // now, set before to the oldest observation
 236 |     |             beforeOrAt = self[(index + 1) % cardinality];
 237 |     |             if (!beforeOrAt.initialized) beforeOrAt = self[0];
 238 |     | 
 239 |     |             // ensure that the target is chronologically at or after the oldest observation
 240 |     |             if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();
 241 |     | 
 242 |     |             // if we've reached this point, we have to binary search
 243 |     |             return binarySearch(self, time, target, index, cardinality);
 244 |     |         }
 245 |     |     }
 246 |     | 
 247 |     |     /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
 248 |     |     /// 0 may be passed as `secondsAgo' to return the current cumulative values.
 249 |     |     /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values
 250 |     |     /// at exactly the timestamp between the two observations.
 251 |     |     /// @param self The stored oracle array
 252 |     |     /// @param time The current block timestamp
 253 |     |     /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation
 254 |     |     /// @param tick The current tick
 255 |     |     /// @param index The index of the observation that was most recently written to the observations array
 256 |     |     /// @param liquidity The current in-range pool liquidity
 257 |     |     /// @param cardinality The number of populated elements in the oracle array
 258 |     |     /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`
 259 |     |     /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`
 260 |     |     function observeSingle(
 261 |     |         Observation[65535] storage self,
 262 |     |         uint32 time,
 263 |     |         uint32 secondsAgo,
 264 |     |         int24 tick,
 265 |     |         uint16 index,
 266 |     |         uint128 liquidity,
 267 |     |         uint16 cardinality
 268 |     |     ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
 269 |     |         unchecked {
 270 |     |             if (secondsAgo == 0) {
 271 |     |                 Observation memory last = self[index];
 272 |     |                 if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
 273 |     |                 return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
 274 |     |             }
 275 |     | 
 276 |     |             uint32 target = time - secondsAgo;
 277 |     | 
 278 |     |             (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(
 279 |     |                 self,
 280 |     |                 time,
 281 |     |                 target,
 282 |     |                 tick,
 283 |     |                 index,
 284 |     |                 liquidity,
 285 |     |                 cardinality
 286 |     |             );
 287 |     | 
 288 |     |             if (target == beforeOrAt.blockTimestamp) {
 289 |     |                 // we're at the left boundary
 290 |     |                 return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
 291 |     |             } else if (target == atOrAfter.blockTimestamp) {
 292 |     |                 // we're at the right boundary
 293 |     |                 return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
 294 |     |             } else {
 295 |     |                 // we're in the middle
 296 |     |                 uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
 297 |     |                 uint32 targetDelta = target - beforeOrAt.blockTimestamp;
 298 |     |                 return (
 299 |     |                     beforeOrAt.tickCumulative +
 300 |     |                         ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *
 301 |     |                         int56(uint56(targetDelta)),
 302 |     |                     beforeOrAt.secondsPerLiquidityCumulativeX128 +
 303 |     |                         uint160(
 304 |     |                             (uint256(
 305 |     |                                 atOrAfter.secondsPerLiquidityCumulativeX128 -
 306 |     |                                     beforeOrAt.secondsPerLiquidityCumulativeX128
 307 |     |                             ) * targetDelta) / observationTimeDelta
 308 |     |                         )
 309 |     |                 );
 310 |     |             }
 311 |     |         }
 312 |     |     }
 313 |     | 
 314 |     |     /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
 315 |     |     /// @dev Reverts if `secondsAgos` > oldest observation
 316 |     |     /// @param self The stored oracle array
 317 |     |     /// @param time The current block.timestamp
 318 |     |     /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
 319 |     |     /// @param tick The current tick
 320 |     |     /// @param index The index of the observation that was most recently written to the observations array
 321 |     |     /// @param liquidity The current in-range pool liquidity
 322 |     |     /// @param cardinality The number of populated elements in the oracle array
 323 |     |     /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
 324 |     |     /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
 325 |     |     function observe(
 326 |     |         Observation[65535] storage self,
 327 |     |         uint32 time,
 328 |     |         uint32[] memory secondsAgos,
 329 |     |         int24 tick,
 330 |     |         uint16 index,
 331 |     |         uint128 liquidity,
 332 |     |         uint16 cardinality
 333 |     |     ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
 334 |     |         unchecked {
 335 |     |             if (cardinality <= 0) revert I();
 336 |     | 
 337 |     |             tickCumulatives = new int56[](secondsAgos.length);
 338 |     |             secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 339 |     |             for (uint256 i = 0; i < secondsAgos.length; i++) {
 340 |     |                 (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
 341 |     |                     self,
 342 |     |                     time,
 343 |     |                     secondsAgos[i],
 344 |     |                     tick,
 345 |     |                     index,
 346 |     |                     liquidity,
 347 |     |                     cardinality
 348 |     |                 );
 349 |     |             }
 350 |     |         }
 351 |     |     }
 352 |     | }
 353 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 | *   | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint160
 10 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 11 |     |         require((z = uint160(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 15 |     |     /// @param y The int256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type int128
 17 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 18 |     |         require((z = int128(y)) == y);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 22 |     |     /// @param y The uint256 to be casted
 23 |     |     /// @return z The casted integer, now type int256
 24 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 25 |     |         require(y < 2**255);
 26 |     |         z = int256(y);
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/Tick.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import {SafeCast} from './SafeCast.sol';
   5 |     | 
   6 |     | import {TickMath} from './TickMath.sol';
   7 |     | 
   8 |     | /// @title Tick
   9 |     | /// @notice Contains functions for managing tick processes and relevant calculations
  10 | *   | library Tick {
  11 |     |     error LO();
  12 |     | 
  13 |     |     using SafeCast for int256;
  14 |     | 
  15 |     |     // info stored for each initialized individual tick
  16 |     |     struct Info {
  17 |     |         // the total position liquidity that references this tick
  18 |     |         uint128 liquidityGross;
  19 |     |         // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
  20 |     |         int128 liquidityNet;
  21 |     |         // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  22 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  23 |     |         uint256 feeGrowthOutside0X128;
  24 |     |         uint256 feeGrowthOutside1X128;
  25 |     |         // the cumulative tick value on the other side of the tick
  26 |     |         int56 tickCumulativeOutside;
  27 |     |         // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  28 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  29 |     |         uint160 secondsPerLiquidityOutsideX128;
  30 |     |         // the seconds spent on the other side of the tick (relative to the current tick)
  31 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  32 |     |         uint32 secondsOutside;
  33 |     |         // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
  34 |     |         // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
  35 |     |         bool initialized;
  36 |     |     }
  37 |     | 
  38 |     |     /// @notice Derives max liquidity per tick from given tick spacing
  39 |     |     /// @dev Executed within the pool constructor
  40 |     |     /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`
  41 |     |     ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...
  42 |     |     /// @return The max liquidity per tick
  43 | *   |     function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {
  44 |     |         unchecked {
  45 | *   |             int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;
  46 | *   |             int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;
  47 | *   |             uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;
  48 | *   |             return type(uint128).max / numTicks;
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @notice Retrieves fee growth data
  53 |     |     /// @param self The mapping containing all tick information for initialized ticks
  54 |     |     /// @param tickLower The lower tick boundary of the position
  55 |     |     /// @param tickUpper The upper tick boundary of the position
  56 |     |     /// @param tickCurrent The current tick
  57 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
  58 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
  59 |     |     /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
  60 |     |     /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
  61 |     |     function getFeeGrowthInside(
  62 |     |         mapping(int24 => Tick.Info) storage self,
  63 |     |         int24 tickLower,
  64 |     |         int24 tickUpper,
  65 |     |         int24 tickCurrent,
  66 |     |         uint256 feeGrowthGlobal0X128,
  67 |     |         uint256 feeGrowthGlobal1X128
  68 |     |     ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {
  69 |     |         unchecked {
  70 |     |             Info storage lower = self[tickLower];
  71 |     |             Info storage upper = self[tickUpper];
  72 |     | 
  73 |     |             // calculate fee growth below
  74 |     |             uint256 feeGrowthBelow0X128;
  75 |     |             uint256 feeGrowthBelow1X128;
  76 |     |             if (tickCurrent >= tickLower) {
  77 |     |                 feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;
  78 |     |                 feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;
  79 |     |             } else {
  80 |     |                 feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;
  81 |     |                 feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;
  82 |     |             }
  83 |     | 
  84 |     |             // calculate fee growth above
  85 |     |             uint256 feeGrowthAbove0X128;
  86 |     |             uint256 feeGrowthAbove1X128;
  87 |     |             if (tickCurrent < tickUpper) {
  88 |     |                 feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;
  89 |     |                 feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;
  90 |     |             } else {
  91 |     |                 feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;
  92 |     |                 feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;
  93 |     |             }
  94 |     | 
  95 |     |             feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
  96 |     |             feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
  97 |     |         }
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa
 101 |     |     /// @param self The mapping containing all tick information for initialized ticks
 102 |     |     /// @param tick The tick that will be updated
 103 |     |     /// @param tickCurrent The current tick
 104 |     |     /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)
 105 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 106 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 107 |     |     /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool
 108 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 109 |     |     /// @param time The current block timestamp cast to a uint32
 110 |     |     /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick
 111 |     |     /// @param maxLiquidity The maximum liquidity allocation for a single tick
 112 |     |     /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa
 113 |     |     function update(
 114 |     |         mapping(int24 => Tick.Info) storage self,
 115 |     |         int24 tick,
 116 |     |         int24 tickCurrent,
 117 |     |         int128 liquidityDelta,
 118 |     |         uint256 feeGrowthGlobal0X128,
 119 |     |         uint256 feeGrowthGlobal1X128,
 120 |     |         uint160 secondsPerLiquidityCumulativeX128,
 121 |     |         int56 tickCumulative,
 122 |     |         uint32 time,
 123 |     |         bool upper,
 124 |     |         uint128 maxLiquidity
 125 |     |     ) internal returns (bool flipped) {
 126 |     |         Tick.Info storage info = self[tick];
 127 |     | 
 128 |     |         uint128 liquidityGrossBefore = info.liquidityGross;
 129 |     |         uint128 liquidityGrossAfter = liquidityDelta < 0
 130 |     |             ? liquidityGrossBefore - uint128(-liquidityDelta)
 131 |     |             : liquidityGrossBefore + uint128(liquidityDelta);
 132 |     | 
 133 |     |         if (liquidityGrossAfter > maxLiquidity) revert LO();
 134 |     | 
 135 |     |         flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);
 136 |     | 
 137 |     |         if (liquidityGrossBefore == 0) {
 138 |     |             // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
 139 |     |             if (tick <= tickCurrent) {
 140 |     |                 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;
 141 |     |                 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;
 142 |     |                 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;
 143 |     |                 info.tickCumulativeOutside = tickCumulative;
 144 |     |                 info.secondsOutside = time;
 145 |     |             }
 146 |     |             info.initialized = true;
 147 |     |         }
 148 |     | 
 149 |     |         info.liquidityGross = liquidityGrossAfter;
 150 |     | 
 151 |     |         // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
 152 |     |         info.liquidityNet = upper ? info.liquidityNet - liquidityDelta : info.liquidityNet + liquidityDelta;
 153 |     |     }
 154 |     | 
 155 |     |     /// @notice Clears tick data
 156 |     |     /// @param self The mapping containing all initialized tick information for initialized ticks
 157 |     |     /// @param tick The tick that will be cleared
 158 |     |     function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {
 159 |     |         delete self[tick];
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice Transitions to next tick as needed by price movement
 163 |     |     /// @param self The mapping containing all tick information for initialized ticks
 164 |     |     /// @param tick The destination tick of the transition
 165 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 166 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 167 |     |     /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
 168 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 169 |     |     /// @param time The current block.timestamp
 170 |     |     /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
 171 |     |     function cross(
 172 |     |         mapping(int24 => Tick.Info) storage self,
 173 |     |         int24 tick,
 174 |     |         uint256 feeGrowthGlobal0X128,
 175 |     |         uint256 feeGrowthGlobal1X128,
 176 |     |         uint160 secondsPerLiquidityCumulativeX128,
 177 |     |         int56 tickCumulative,
 178 |     |         uint32 time
 179 |     |     ) internal returns (int128 liquidityNet) {
 180 |     |         unchecked {
 181 |     |             Tick.Info storage info = self[tick];
 182 |     |             info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
 183 |     |             info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
 184 |     |             info.secondsPerLiquidityOutsideX128 =
 185 |     |                 secondsPerLiquidityCumulativeX128 -
 186 |     |                 info.secondsPerLiquidityOutsideX128;
 187 |     |             info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;
 188 |     |             info.secondsOutside = time - info.secondsOutside;
 189 |     |             liquidityNet = info.liquidityNet;
 190 |     |         }
 191 |     |     }
 192 |     | }
 193 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   5 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   6 |     | /// prices between 2**-128 and 2**128
   7 | *   | library TickMath {
   8 |     |     error T();
   9 |     |     error R();
  10 |     | 
  11 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
  12 | *   |     int24 internal constant MIN_TICK = -887272;
  13 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  14 | *   |     int24 internal constant MAX_TICK = -MIN_TICK;
  15 |     | 
  16 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  17 | *   |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  18 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  19 | *   |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  20 |     | 
  21 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  22 |     |     /// @dev Throws if |tick| > max tick
  23 |     |     /// @param tick The input tick for the above formula
  24 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  25 |     |     /// at the given tick
  26 | *   |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  27 | *   |         unchecked {
  28 | *   |             uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  29 | *   |             if (absTick > uint256(int256(MAX_TICK))) revert T();
  30 |     | 
  31 | *   |             uint256 ratio = absTick & 0x1 != 0
  32 | *   |                 ? 0xfffcb933bd6fad37aa2d162d1a594001
  33 | *   |                 : 0x100000000000000000000000000000000;
  34 | *   |             if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  35 | *   |             if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  36 | *   |             if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  37 | *   |             if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  38 | *   |             if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  39 | *   |             if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  40 | *   |             if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  41 | *   |             if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  42 | *   |             if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  43 | *   |             if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  44 | *   |             if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  45 | *   |             if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  46 | *   |             if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  47 | *   |             if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  48 | *   |             if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  49 | *   |             if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  50 | *   |             if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  51 | *   |             if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  52 | *   |             if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  53 |     | 
  54 | *   |             if (tick > 0) ratio = type(uint256).max / ratio;
  55 |     | 
  56 |     |             // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  57 |     |             // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  58 |     |             // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  59 | *   |             sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  60 |     |         }
  61 |     |     }
  62 |     | 
  63 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  64 |     |     /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  65 |     |     /// ever return.
  66 |     |     /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  67 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  68 | *   |     function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
  69 | *   |         unchecked {
  70 |     |             // second inequality must be < because the price can never reach the price at the max tick
  71 | *   |             if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();
  72 | *   |             uint256 ratio = uint256(sqrtPriceX96) << 32;
  73 |     | 
  74 | *   |             uint256 r = ratio;
  75 | *   |             uint256 msb = 0;
  76 |     | 
  77 | *   |             assembly {
  78 | *   |                 let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  79 | *   |                 msb := or(msb, f)
  80 | *   |                 r := shr(f, r)
  81 |     |             }
  82 | *   |             assembly {
  83 | *   |                 let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  84 | *   |                 msb := or(msb, f)
  85 | *   |                 r := shr(f, r)
  86 |     |             }
  87 | *   |             assembly {
  88 | *   |                 let f := shl(5, gt(r, 0xFFFFFFFF))
  89 | *   |                 msb := or(msb, f)
  90 | *   |                 r := shr(f, r)
  91 |     |             }
  92 | *   |             assembly {
  93 | *   |                 let f := shl(4, gt(r, 0xFFFF))
  94 | *   |                 msb := or(msb, f)
  95 | *   |                 r := shr(f, r)
  96 |     |             }
  97 | *   |             assembly {
  98 | *   |                 let f := shl(3, gt(r, 0xFF))
  99 | *   |                 msb := or(msb, f)
 100 | *   |                 r := shr(f, r)
 101 |     |             }
 102 | *   |             assembly {
 103 | *   |                 let f := shl(2, gt(r, 0xF))
 104 | *   |                 msb := or(msb, f)
 105 | *   |                 r := shr(f, r)
 106 |     |             }
 107 | *   |             assembly {
 108 | *   |                 let f := shl(1, gt(r, 0x3))
 109 | *   |                 msb := or(msb, f)
 110 | *   |                 r := shr(f, r)
 111 |     |             }
 112 | *   |             assembly {
 113 | *   |                 let f := gt(r, 0x1)
 114 | *   |                 msb := or(msb, f)
 115 |     |             }
 116 |     | 
 117 | *   |             if (msb >= 128) r = ratio >> (msb - 127);
 118 |     |             else r = ratio << (127 - msb);
 119 |     | 
 120 | *   |             int256 log_2 = (int256(msb) - 128) << 64;
 121 |     | 
 122 | *   |             assembly {
 123 | *   |                 r := shr(127, mul(r, r))
 124 | *   |                 let f := shr(128, r)
 125 | *   |                 log_2 := or(log_2, shl(63, f))
 126 | *   |                 r := shr(f, r)
 127 |     |             }
 128 | *   |             assembly {
 129 | *   |                 r := shr(127, mul(r, r))
 130 | *   |                 let f := shr(128, r)
 131 | *   |                 log_2 := or(log_2, shl(62, f))
 132 | *   |                 r := shr(f, r)
 133 |     |             }
 134 | *   |             assembly {
 135 | *   |                 r := shr(127, mul(r, r))
 136 | *   |                 let f := shr(128, r)
 137 | *   |                 log_2 := or(log_2, shl(61, f))
 138 | *   |                 r := shr(f, r)
 139 |     |             }
 140 | *   |             assembly {
 141 | *   |                 r := shr(127, mul(r, r))
 142 | *   |                 let f := shr(128, r)
 143 | *   |                 log_2 := or(log_2, shl(60, f))
 144 | *   |                 r := shr(f, r)
 145 |     |             }
 146 | *   |             assembly {
 147 | *   |                 r := shr(127, mul(r, r))
 148 | *   |                 let f := shr(128, r)
 149 | *   |                 log_2 := or(log_2, shl(59, f))
 150 | *   |                 r := shr(f, r)
 151 |     |             }
 152 | *   |             assembly {
 153 | *   |                 r := shr(127, mul(r, r))
 154 | *   |                 let f := shr(128, r)
 155 | *   |                 log_2 := or(log_2, shl(58, f))
 156 | *   |                 r := shr(f, r)
 157 |     |             }
 158 | *   |             assembly {
 159 | *   |                 r := shr(127, mul(r, r))
 160 | *   |                 let f := shr(128, r)
 161 | *   |                 log_2 := or(log_2, shl(57, f))
 162 | *   |                 r := shr(f, r)
 163 |     |             }
 164 | *   |             assembly {
 165 | *   |                 r := shr(127, mul(r, r))
 166 | *   |                 let f := shr(128, r)
 167 | *   |                 log_2 := or(log_2, shl(56, f))
 168 | *   |                 r := shr(f, r)
 169 |     |             }
 170 | *   |             assembly {
 171 | *   |                 r := shr(127, mul(r, r))
 172 | *   |                 let f := shr(128, r)
 173 | *   |                 log_2 := or(log_2, shl(55, f))
 174 | *   |                 r := shr(f, r)
 175 |     |             }
 176 | *   |             assembly {
 177 | *   |                 r := shr(127, mul(r, r))
 178 | *   |                 let f := shr(128, r)
 179 | *   |                 log_2 := or(log_2, shl(54, f))
 180 | *   |                 r := shr(f, r)
 181 |     |             }
 182 | *   |             assembly {
 183 | *   |                 r := shr(127, mul(r, r))
 184 | *   |                 let f := shr(128, r)
 185 | *   |                 log_2 := or(log_2, shl(53, f))
 186 | *   |                 r := shr(f, r)
 187 |     |             }
 188 | *   |             assembly {
 189 | *   |                 r := shr(127, mul(r, r))
 190 | *   |                 let f := shr(128, r)
 191 | *   |                 log_2 := or(log_2, shl(52, f))
 192 | *   |                 r := shr(f, r)
 193 |     |             }
 194 | *   |             assembly {
 195 | *   |                 r := shr(127, mul(r, r))
 196 | *   |                 let f := shr(128, r)
 197 | *   |                 log_2 := or(log_2, shl(51, f))
 198 | *   |                 r := shr(f, r)
 199 |     |             }
 200 | *   |             assembly {
 201 | *   |                 r := shr(127, mul(r, r))
 202 | *   |                 let f := shr(128, r)
 203 | *   |                 log_2 := or(log_2, shl(50, f))
 204 |     |             }
 205 |     | 
 206 | *   |             int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 207 |     | 
 208 | *   |             int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 209 | *   |             int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 210 |     | 
 211 | *   |             tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
 212 |     |         }
 213 |     |     }
 214 |     | }
 215 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/Fuzz.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./FuzzGuided.sol";
  5 |     | 
  6 | *r  | contract Fuzz is FuzzGuided {
  7 |     |     constructor() payable {
  8 | *   |         fuzzSetup();
  9 |     |     }
 10 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/FuzzGuided.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./fuzz_calls/farm/FuzzDepotFacet.sol";
  5 |     | import "./fuzz_calls/silo/FuzzSiloFacet.sol";
  6 |     | import "./fuzz_calls/silo/FuzzApprovalFacet.sol";
  7 |     | 
  8 | *r  | contract FuzzGuided is FuzzDepotFacet, FuzzSiloFacet, FuzzApprovalFacet {
  9 |     | 
 10 |     |     /// ===========
 11 |     |     /// SILO FACET
 12 |     |     /// ===========
 13 | *   |     function fuzz_guided_deposit_silo(uint256 x, uint256 y) public setCurrentActor {
 14 | *   |         fuzz_deposit_silo_facet(x, y);
 15 |     |     }
 16 |     | 
 17 | *   |     function fuzz_guided_withdraw_silo_facet(uint256 x, uint256 y) public setCurrentActor {
 18 | *   |         fuzz_withdraw_silo_facet(x, y);
 19 |     |     }
 20 | *   |     function fuzz_guided_multi_withdraw_silo_facet(uint256 x, uint256 y, uint256 z) public setCurrentActor {
 21 | *   |         fuzz_multi_withdraw_silo_facet(x, y, z);
 22 |     |     }
 23 | *   |     function fuzz_guided_transfer_deposit_silo_facet(uint256 x, uint256 y, uint256 z) public setCurrentActor {
 24 | *   |         fuzz_transfer_deposit_silo_facet(x, y, z);
 25 |     |     }
 26 |     | 
 27 | *   |     function fuzz_guided_multi_transfer_silo_facet(uint256 w, uint256 x, uint256 y) public setCurrentActor {
 28 | *   |         fuzz_multi_transfer_silo_facet(w, x, y);
 29 |     |     }
 30 |     | 
 31 | *   |     function fuzz_guided_transfer_from_silo_facet(uint256 x, uint256 y) public setCurrentActor() {
 32 | *   |         fuzz_transfer_from_silo_facet(x, y);
 33 |     |     }
 34 |     | 
 35 | *   |     function fuzz_guided_multi_transfer_from_silo_facet(uint256 x, uint256 y, uint256 z) public setCurrentActor() {
 36 | *   |         fuzz_multi_transfer_from_silo_facet(x, y, z);
 37 |     |     }
 38 |     | 
 39 |     | 
 40 |     |     /// ===============
 41 |     |     /// APPROVAL FACET
 42 |     |     /// ===============
 43 |     | 
 44 | *   |     function fuzz_guided_approve_approval_facet(uint256 x, uint256 y) public {
 45 | *   |         fuzz_approve_approval_facet(x, y);
 46 |     |     }
 47 |     | 
 48 | *   |     function fuzz_guided_increase_approval_facet(uint256 x, uint256 y) public {
 49 | *   |         fuzz_increase_approval_facet(x, y);
 50 |     |     }
 51 |     | 
 52 | *   |     function fuzz_guided_decrease_approval_facet(uint256 x, uint256 y) public {
 53 | *   |         fuzz_decrease_approval_facet(x, y);
 54 |     |     }
 55 | *   |     function fuzz_guided_approve_all_approval_facet(uint256 x, uint256 y) public {
 56 | *   |         fuzz_approve_all_approval_facet(x, y);
 57 |     |     }
 58 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/FuzzSetup.sol
   1 |     | // SPDX-License-Identifier: UNTITLED
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./utils/FunctionCalls.sol";
   5 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
   6 |     | 
   7 |     | import {MockToken} from "contracts/mocks/MockToken.sol";
   8 |     | import {IMockFBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
   9 |     | import {MockSeasonFacet} from "contracts/mocks/mockFacets/MockSeasonFacet.sol";
  10 |     | import {MockChainlinkAggregator} from "contracts/mocks/MockChainlinkAggregator.sol";
  11 |     | 
  12 |     | ///// TEST HELPERS //////
  13 |     | import {BeanstalkDeployer} from "test/foundry/utils/BeanstalkDeployer.sol";
  14 |     | import {BasinDeployer} from "test/foundry/utils/BasinDeployer.sol";
  15 |     | import {DepotDeployer} from "test/foundry/utils/DepotDeployer.sol";
  16 |     | import {OracleDeployer} from "test/foundry/utils/OracleDeployer.sol";
  17 |     | import {ShipmentDeployer} from "test/foundry/utils/ShipmentDeployer.sol";
  18 |     | import {IWell, IERC20} from "contracts/interfaces/basin/IWell.sol";
  19 |     | import {C} from "contracts/C.sol";
  20 |     | 
  21 |     | ///// COMMON IMPORTED LIBRARIES //////
  22 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  23 |     | import {LibConvertData} from "contracts/libraries/Convert/LibConvertData.sol";
  24 |     | 
  25 |     | ///// ECOSYSTEM //////
  26 |     | import {Pipeline} from "contracts/pipeline/Pipeline.sol";
  27 |     | 
  28 |     | // OTHER INTERFACES //
  29 |     | import {IUSDC} from "contracts/interfaces/IUSDC.sol";
  30 |     | 
  31 |     | import {IDiamondCut} from "contracts/interfaces/IDiamondCut.sol";
  32 |     | import {LibDiamond} from "contracts/libraries/LibDiamond.sol";
  33 |     | 
  34 |     | 
  35 |     | 
  36 |     | contract FuzzSetup is FunctionCalls {
  37 |     | 
  38 | *   |     MockUniswapV3Factory public uniFactory;
  39 | *r  |     uint256[][] public uniPriceData = [[uint256(1e18), 18], [uint256(500e6), 8]];
  40 |     | 
  41 | *   |     function fuzzSetup() internal {
  42 | *   |         deploySampleContract();
  43 | *   |         labelAll();
  44 |     |     }
  45 |     | 
  46 |     |     // facet selectors
  47 | *   |     bytes4[] depotSelects = [bytes4(0xb452c7ae), bytes4(0x6e47d07b), bytes4(0xcabec62b), bytes4(0x08e1a0ab), bytes4(0xdd756c4f)];
  48 | *   |     bytes4[] farmSelects = [bytes4(0x36bfafbd), bytes4(0x300dd6cf)];
  49 | *   |     bytes4[] tokenSelects = [bytes4(0xda3e3397), bytes4(0x0bc33ce4), bytes4(0xfdb28811), bytes4(0xb6fc38f9), bytes4(0xd4fac45d), bytes4(0x6a385ae9), bytes4(0x4667fa3d), bytes4(0xc3714723), bytes4(0x8a65d2e0), bytes4(0xa98edb17), bytes4(0xb39062e6), bytes4(0xbc197c81), bytes4(0xf23a6e61), bytes4(0x8e8758d8), bytes4(0xd3f4ec6f), bytes4(0x6204aa43), bytes4(0xbd32fac3), bytes4(0x1c059365)];
  50 | *   |     bytes4[] tokenSupportSelects = [bytes4(0xa9412a59), bytes4(0x0a7e880c), bytes4(0x1aca6376)];
  51 | *   |     bytes4[] tractorSelects = [bytes4(0x563957a8), bytes4(0x5723cc60), bytes4(0x5ebc32e6), bytes4(0x5993514b), bytes4(0x2be32f6a), bytes4(0x91a45154), bytes4(0x454972dd), bytes4(0x570ca735), bytes4(0xcc8a429d), bytes4(0xca1e71ae), bytes4(0xfe414fc8), bytes4(0x507cea25), bytes4(0xdf8d26bb), bytes4(0x04cb49dc)];
  52 | *   |     bytes4[] fieldSelects = [bytes4(0xd1eba544), bytes4(0xb94e871c), bytes4(0x9a337c1d), bytes4(0xbb485bbd), bytes4(0xd7254577), bytes4(0x253fcfb5), bytes4(0x91b24284), bytes4(0xe9bbb033), bytes4(0xb511654d), bytes4(0x5487cc45), bytes4(0x4bea67c4), bytes4(0x7907091f), bytes4(0x9ee7ea12), bytes4(0xccda40b9), bytes4(0x56ba3e24), bytes4(0x057c571b), bytes4(0x32ab68ce), bytes4(0x553030d0), bytes4(0xadccea12), bytes4(0x2e76f597), bytes4(0x352525a6), bytes4(0xf1e0a211), bytes4(0x3285008a), bytes4(0xf29ffe94), bytes4(0xb6032721)];
  53 | *   |     bytes4[] marketplaceSelects = [bytes4(0xb151226a), bytes4(0x0711f012), bytes4(0x8d398973), bytes4(0x9ed2801b), bytes4(0x65865af6), bytes4(0x37b4d2ec), bytes4(0xf7f228a2), bytes4(0xed8c792f), bytes4(0x631076dd), bytes4(0x98c02432), bytes4(0x674a3e67), bytes4(0xceb39673), bytes4(0x31ed3796)];
  54 | *   |     bytes4[] metadataSelects = [bytes4(0x18a51858), bytes4(0x06fdde03), bytes4(0x95d89b41), bytes4(0x0e89341c)];
  55 | *   |     bytes4[] approvalSelects = [bytes4(0x1302afc2), bytes4(0xd9ee1269), bytes4(0x2a6a8ef5), bytes4(0x5793e485), bytes4(0xe985e9c5), bytes4(0xa22cb465)];
  56 | *   |     bytes4[] bdvSelects = [bytes4(0x5a049a47), bytes4(0xc84c7727)];
  57 | *   |     bytes4[] claimSelects = [bytes4(0xfa2e2617), bytes4(0x0d509999), bytes4(0x150d5173), bytes4(0x9d5e1f96), bytes4(0x74412e48), bytes4(0x7d44f5bb), bytes4(0xc5a13699), bytes4(0x779b3c5c)];
  58 | *   |     bytes4[] convertSelects = [bytes4(0xb362a6e8)];
  59 | *   |     bytes4[] convertGettersSelects = [bytes4(0xd052f0d5), bytes4(0xb325d2ef), bytes4(0x6842f2b3), bytes4(0x527ec6ba), bytes4(0x4aa06652), bytes4(0x24dd285c), bytes4(0xf66d5589), bytes4(0xb905065b), bytes4(0x3e8b56f1), bytes4(0xb267ea07), bytes4(0x24568abf)];
  60 | *   |     bytes4[] pipelineConvertSelects = [bytes4(0xbb25c1c2)];
  61 | *   |     bytes4[] siloSelects = [bytes4(0xf19ed6be), bytes4(0x2eb2c2d6), bytes4(0xf242432a), bytes4(0x081d77ba), bytes4(0xc56411f6), bytes4(0x297e6c69), bytes4(0xe348f82b), bytes4(0x27e047f1)];
  62 | *   |     bytes4[] siloGettersSelects = [bytes4(0x00fdd58e), bytes4(0x4e1273f4), bytes4(0xbc8514cf), bytes4(0x3e465a2e), bytes4(0x341b94d5), bytes4(0xc063989e), bytes4(0x838082b5), bytes4(0x8915ba24), bytes4(0xcb65f1b1), bytes4(0x80c9084b), bytes4(0xb02e7162), bytes4(0x69fbad94), bytes4(0xba39dc02), bytes4(0xa7bf680f), bytes4(0x8eeae310), bytes4(0x0fb01e05), bytes4(0x8c1e6f22), bytes4(0xd31e4d66), bytes4(0x0b6413b0), bytes4(0x805a343f), bytes4(0xb592d450), bytes4(0x91a38626), bytes4(0x61449212), bytes4(0x98f2b8ad), bytes4(0x823ccbe9), bytes4(0xe73c165b), bytes4(0x1ca5f625), bytes4(0x96e7f21e), bytes4(0x4118140a), bytes4(0x9256dccd), bytes4(0xa953f06d), bytes4(0xe5b17f2a), bytes4(0xc25a156c), bytes4(0x9b3ec513), bytes4(0xff1b540f), bytes4(0x6a9c931d), bytes4(0x55d0807e), bytes4(0x7fc06e12), bytes4(0x047c92cf), bytes4(0xdc25a650), bytes4(0xf6225118), bytes4(0x85167e51), bytes4(0x9cf67d70), bytes4(0x54369b5b), bytes4(0xe49b77f5), bytes4(0x0c9c31bd), bytes4(0x9d6a924e), bytes4(0xb45ef2eb), bytes4(0x9dcf67f0), bytes4(0x7d4a51cb), bytes4(0xb13d3024), bytes4(0xbd637860), bytes4(0x5a8e63e3), bytes4(0x3a1b0606), bytes4(0xbe6547d2), bytes4(0xcb03fb1e), bytes4(0xedd2d167), bytes4(0xabed2d41), bytes4(0xe923e8d4), bytes4(0xfd9de166), bytes4(0xaea72f96), bytes4(0x46544166), bytes4(0x7b52fadf)];
  63 | *   |     bytes4[] whitelistSelects = [bytes4(0x86b40a1b), bytes4(0x738cb80b), bytes4(0x8104d586), bytes4(0x56b7b49c), bytes4(0xe9522c08), bytes4(0xd9ba32fc), bytes4(0x170cf084), bytes4(0x9d1d2877), bytes4(0xe26f7900), bytes4(0x76a7bc84), bytes4(0x19b8f518), bytes4(0x4fb907a0), bytes4(0x85657e12), bytes4(0x874b87b9), bytes4(0x79325704), bytes4(0x4b6f418c), bytes4(0x52d7f632)];
  64 | *   |     bytes4[] gaugeSelects = [bytes4(0x44811f70), bytes4(0x6c07c340), bytes4(0xd7b77ea4), bytes4(0xafa1704e), bytes4(0xc26072fe), bytes4(0x8bd47e79), bytes4(0x0333f5c1), bytes4(0xcbab033f), bytes4(0xaa229a47), bytes4(0x5117bef5), bytes4(0x3ad6d656), bytes4(0x925150c9)];
  65 | *   |     bytes4[] gaugeGettersSelects = [bytes4(0x7046c9a6), bytes4(0x7ba6cbf8), bytes4(0xeb0e1215), bytes4(0x69aa7e02), bytes4(0xcc88d4f9), bytes4(0x673c75f0), bytes4(0x64b3496b), bytes4(0x93523425), bytes4(0x64887852), bytes4(0xb2b0556d), bytes4(0x141933bf), bytes4(0xf98da2de), bytes4(0x383f170f), bytes4(0x6bbf3305), bytes4(0xcb2d0a3c), bytes4(0x11242145), bytes4(0x6af8e5a4), bytes4(0x50539159)];
  66 | *   |     bytes4[] liquidityWeightSelects = [bytes4(0x2c5fa218), bytes4(0x225f8659)];
  67 | *   |     bytes4[] oracleSelects = [bytes4(0xd48274a0), bytes4(0x052c3990), bytes4(0x00593bcf), bytes4(0x054ce3bd), bytes4(0xc4c5140f), bytes4(0x8b7750c2), bytes4(0x399ff0b5), bytes4(0xdd455fbf)];
  68 | *   |     bytes4[] seasonSelects = [bytes4(0xfd497a68), bytes4(0x64ee4b80), bytes4(0xca7b7d7b), bytes4(0xf1e2dfb0), bytes4(0xfc06d2a6)];
  69 | *   |     bytes4[] seasonGettersSelects = [bytes4(0x2a27c499), bytes4(0x89a218d2), bytes4(0xe53b479e), bytes4(0x3cee5dea), bytes4(0x8097f0ca), bytes4(0x065cb594), bytes4(0x43e0156a), bytes4(0x57801d87), bytes4(0x70fd1b06), bytes4(0xda61af62), bytes4(0x44fb7cc3), bytes4(0x2507644c), bytes4(0xd1943f7f), bytes4(0x1eedbfbb), bytes4(0x1f48a553), bytes4(0x11a8d895), bytes4(0xab843b34), bytes4(0xb3c39ce5), bytes4(0xfd6d1483), bytes4(0xdd9330d2), bytes4(0x08fa96d3), bytes4(0x35870a7a), bytes4(0x4d65f762), bytes4(0x738ad142), bytes4(0xf07f0760), bytes4(0xcb677411), bytes4(0xbbf459a7), bytes4(0xf788b47c), bytes4(0xa13a3742), bytes4(0x93c9e531), bytes4(0xbf170533), bytes4(0x5c975abb), bytes4(0x3fccd20c), bytes4(0x8223eac8), bytes4(0x471bcdbe), bytes4(0xc1cf248f), bytes4(0x43def26e), bytes4(0xc50b0fb0), bytes4(0x3b2ecb70), bytes4(0x16ada547), bytes4(0x06c499d8), bytes4(0x0e3c557a), bytes4(0x4a2c357e), bytes4(0x686b6159), bytes4(0x597490c0)];
  70 | *   |     bytes4[] ownershipSelects = [bytes4(0x4e71e0c8), bytes4(0x8da5cb5b), bytes4(0x5f504a82), bytes4(0xf2fde38b)];
  71 |     | 
  72 | *   |     int256[] initialPrices = [
  73 | *   |         int256(1000e6), // ETH/USD
  74 | *   |         1e6, // wstETH/ETH
  75 | *   |         1e6, // USDC/USD
  76 | *   |         50000e6 // WBTC/USD
  77 |     |     ];
  78 |     | 
  79 |     | 
  80 |     |     // deploy smart contracts
  81 | *   |     function deploySampleContract() internal {
  82 |     | 
  83 |     |         // Create Beanstalk Facets
  84 |     |         // farm
  85 | *   |         depotFacet = new DepotFacet();
  86 | *   |         farmFacet = new FarmFacet();
  87 | *   |         tokenFacet = new TokenFacet();
  88 | *   |         tokenSupportFacet = new TokenSupportFacet();
  89 | *   |         tractorFacet = new TractorFacet();
  90 |     | 
  91 |     |         // field
  92 | *   |         fieldFacet = new FieldFacet();
  93 |     | 
  94 |     |         // market
  95 | *   |         marketplaceFacet = new MarketplaceFacet();
  96 |     | 
  97 |     |         // metadata
  98 | *   |         metadataFacet = new MetadataFacet();
  99 |     | 
 100 |     |         // silo
 101 | *   |         approvalFacet = new ApprovalFacet();
 102 | *   |         bdvFacet = new BDVFacet();
 103 | *   |         claimFacet = new ClaimFacet();
 104 | *   |         convertFacet = new ConvertFacet();
 105 | *   |         convertGettersFacet = new ConvertGettersFacet();
 106 | *   |         pipelineConvertFacet = new PipelineConvertFacet();
 107 | *   |         siloFacet = new SiloFacet();
 108 | *   |         siloGettersFacet = new SiloGettersFacet();
 109 | *   |         whitelistFacet = new WhitelistFacet();
 110 |     | 
 111 |     |         // sun
 112 | *   |         gaugeFacet = new GaugeFacet();
 113 | *   |         gaugeGettersFacet = new GaugeGettersFacet();
 114 | *   |         liquidityWeightFacet = new LiquidityWeightFacet();
 115 | *   |         oracleFacet = new OracleFacet();
 116 | *   |         seasonFacet = new SeasonFacet();
 117 | *   |         seasonGettersFacet = new SeasonGettersFacet();
 118 |     | 
 119 |     |         // Deploy Diamond
 120 | *   |         diamondCutFacet = new DiamondCutFacet();
 121 | *   |         diamondLoupeFacet = new DiamondLoupeFacet();
 122 | *   |         ownershipFacet = new OwnershipFacet();
 123 | *   |         pauseFacet = new PauseFacet();
 124 | *   |         initDiamond = new MockInitDiamondFuzz();
 125 | *   |         diamond = new Diamond(address(diamondCutFacet));
 126 |     | 
 127 | *   |         IDiamondCut.FacetCut[] memory cuts = _getCuts();
 128 |     | 
 129 |     | 
 130 |     |         // Create Tokens
 131 |     |         // // @note uncomment for foundry tests
 132 |     |         // bytes memory bytecode = type(Bean).runtimeCode; // for foundry
 133 |     |         // vm.etch(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab, bytecode);
 134 | *   |         beanToken = Bean(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab);
 135 | *   |         beanMock = MockToken(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab);
 136 | *   |         weth = _deployToken(initERC20paramsFuzz("Weth", "WETH", 18));
 137 | *   |         wstEth = _deployToken(initERC20paramsFuzz("wstETH", "WSTETH", 18));
 138 | *   |         usdc = _deployToken(initERC20paramsFuzz("USDC", "USDC", 6));
 139 | *   |         usdt = _deployToken(initERC20paramsFuzz("USDT", "USDT", 6));
 140 | *   |         wbtc = _deployToken(initERC20paramsFuzz("WBTC", "WBTC", 6));
 141 |     | 
 142 | *   |         mockTokens = [beanMock, weth, wstEth, usdc, usdt, wbtc];
 143 |     | 
 144 |     |         // gives ADMIN default admin role & minter role
 145 | *   |         bytes32 outerSlot = keccak256(abi.encode(beanToken.DEFAULT_ADMIN_ROLE(), uint256(5)));
 146 | *   |         bytes32 memberSlot = keccak256(abi.encode(ADMIN, outerSlot));
 147 | *   |         vm.store(address(beanToken), memberSlot, bytes32(uint256(1)));
 148 |     | 
 149 | *   |         vm.prank(ADMIN);
 150 | *   |         beanToken.grantRole(keccak256("MINTER_ROLE"), ADMIN);
 151 |     | 
 152 |     |         // Deploys CP2, Well Impl, Multi Flow Pump, Mock Pump, & Aquifier
 153 | *   |         _deployBasin();
 154 |     | 
 155 |     |         // // Deploy bean eth well & bean wstEth well
 156 | *   |         beanEthWell = IWell(_deployWell(weth));
 157 | *   |         beanWstEthWell = IWell(_deployWell(wstEth));
 158 |     | 
 159 | *   |         vm.prank(address(diamondCutFacet));
 160 | *   |         IDiamondCut(address(diamond)).diamondCut(
 161 | *   |             cuts,
 162 | *   |             address(initDiamond),
 163 | *   |             abi.encodeWithSignature("init(address,address)", address(beanEthWell), address(beanWstEthWell))
 164 |     |         );
 165 |     | 
 166 |     |         // Create Ecosystem
 167 | *   |         junction = new Junction();
 168 | *   |         mathJunction = new MathJunction();
 169 | *   |         logicJunction = new LogicJunction();
 170 |     | 
 171 | *   |         lSDChainlinkOracle = new LSDChainlinkOracle();
 172 |     | 
 173 | *   |         beanstalkPrice = new BeanstalkPrice(address(diamond));
 174 | *   |         wellPrice = new WellPrice(address(diamond));
 175 |     | 
 176 | *   |         drafter = new Drafter();
 177 | *   |         gaugePriceThreshold = new GaugePriceThreshold(address(diamond), address(weth), 1e6, 1e6); //@note look into better values for last two params
 178 | *   |         operatorWhitelist = new OperatorWhitelist(ADMIN);
 179 | *   |         priceManipulation = new PriceManipulation(address(diamond));
 180 | *   |         shipment_planner = new ShipmentPlanner(address(diamond), address(beanToken));
 181 | *   |         tractorHelpers = new TractorHelpers(address(diamond), address(beanstalkPrice), ADMIN, address(priceManipulation));
 182 | *   |         sowBlueprintv0 = new SowBlueprintv0(address(diamond), ADMIN, address(tractorHelpers));
 183 |     | 
 184 |     |         // Create Pipeline
 185 | *   |         pipeLine = new Pipeline();
 186 |     | 
 187 |     |         // Create Oracles & set initital price
 188 | *   |         cl_eth_usd = _deployOracle(0);
 189 | *   |         cl_wseth_eth = _deployOracle(1);
 190 | *   |         cl_usdc_usd = _deployOracle(2);
 191 | *   |         cl_wbtc_usd = _deployOracle(3);
 192 |     | 
 193 |     |         // Whitelist oracles
 194 | *   |         _whitelistOracle();
 195 |     | 
 196 |     |         // // Initialize shipping
 197 | *   |         _initShipping();
 198 |     |         
 199 | *   |         uniFactory = new MockUniswapV3Factory();
 200 |     | 
 201 |     |         // Create Uniswap & set initital prices
 202 | *   |         uni_wstEth_weth = _deployUniswapPool(address(wstEth), address(weth), 0);
 203 | *   |         uni_wbtc_usdc = _deployUniswapPool(address(wbtc), address(usdc), 1);
 204 |     | 
 205 |     |     }
 206 |     | 
 207 |     |     // label contracts
 208 | *   |     function labelAll() internal {
 209 |     |         //CONTRACTS
 210 | *   |         vm.label(address(diamond), "PINTO");
 211 | *   |         vm.label(address(depotFacet), "DEPOT_FACET");
 212 | *   |         vm.label(address(farmFacet), "FARM_FACET");
 213 | *   |         vm.label(address(tokenFacet), "TOKEN_FACET");
 214 | *   |         vm.label(address(tokenSupportFacet), "TOKEN_SUPPORT_FACET");
 215 | *   |         vm.label(address(tractorFacet), "TRACTOR_FACET");
 216 | *   |         vm.label(address(fieldFacet), "FIELD_FACET");
 217 | *   |         vm.label(address(marketplaceFacet), "MARKETPLACE_FACET");
 218 | *   |         vm.label(address(metadataFacet), "METADATA_FACET");
 219 | *   |         vm.label(address(approvalFacet), "APPROVAL_FACET");
 220 | *   |         vm.label(address(bdvFacet), "BDV_FACET");
 221 | *   |         vm.label(address(claimFacet), "CLAIM_FACET");
 222 | *   |         vm.label(address(convertFacet), "CONVERT_FACET");
 223 | *   |         vm.label(address(convertGettersFacet), "CONVERT_GETTERS_FACET");
 224 | *   |         vm.label(address(pipelineConvertFacet), "PIPELINE_CONVERT_FACET");
 225 | *   |         vm.label(address(siloFacet), "SILO_FACET");
 226 | *   |         vm.label(address(siloGettersFacet), "SILO_GETTERS_FACET");
 227 | *   |         vm.label(address(whitelistFacet), "WHITELIST_FACET");
 228 | *   |         vm.label(address(gaugeFacet), "GAUGE_FACET");
 229 | *   |         vm.label(address(gaugeGettersFacet), "GAUGE_GETTERS_FACET");
 230 | *   |         vm.label(address(liquidityWeightFacet), "LIQ_WEIGHT_FACET");
 231 | *   |         vm.label(address(oracleFacet), "ORACLE_FACET");
 232 | *   |         vm.label(address(seasonFacet), "SEASON_FACET");
 233 | *   |         vm.label(address(seasonGettersFacet), "SEASON_GETTERS_FACET");
 234 | *   |         vm.label(address(junction), "JUNCTION");
 235 | *   |         vm.label(address(mathJunction), "MATH_JUNCTION");
 236 | *   |         vm.label(address(logicJunction), "LOGIC_JUNCTION");
 237 | *   |         vm.label(address(lSDChainlinkOracle), "LSD_CHAINLINK_ORACLE");
 238 | *   |         vm.label(address(beanstalkPrice), "BEANSTALK_PRICE");
 239 | *   |         vm.label(address(wellPrice), "WELL_PRICE");
 240 | *   |         vm.label(address(drafter), "DRAFTER");
 241 | *   |         vm.label(address(gaugePriceThreshold), "GAUGE_PRICE_THRESHOLD");
 242 | *   |         vm.label(address(operatorWhitelist), "OPERATOR_WHITELIST");
 243 | *   |         vm.label(address(priceManipulation), "PRICE_MANIPULATION");
 244 | *   |         vm.label(address(shipment_planner), "SHIPMENT_PLANNER");
 245 | *   |         vm.label(address(tractorHelpers), "TRACTOR_HELPERS");
 246 | *   |         vm.label(address(sowBlueprintv0), "SOW_BLUE_PRINT_V0");
 247 |     | 
 248 |     |         //USERS
 249 | *   |         vm.label(USER1, "USER1");
 250 | *   |         vm.label(USER2, "USER2");
 251 | *   |         vm.label(USER3, "USER3");
 252 | *   |         vm.label(ADMIN, "ADMIN");
 253 |     | 
 254 |     |         //TOKENS
 255 | *   |         vm.label(address(beanToken), "BEAN");
 256 | *   |         vm.label(address(weth), "WETH");
 257 | *   |         vm.label(address(wstEth), "WSTETH");
 258 | *   |         vm.label(address(usdc), "USDC");
 259 | *   |         vm.label(address(usdt), "USDT");
 260 | *   |         vm.label(address(wbtc), "WBTC");
 261 |     | 
 262 |     |         // ORACLES
 263 | *   |         vm.label(address(cl_eth_usd), "CL_ETH_USD");
 264 | *   |         vm.label(address(cl_wseth_eth), "CL_WSTETH_ETH");
 265 | *   |         vm.label(address(cl_usdc_usd), "CL_USDC_USDT");
 266 | *   |         vm.label(address(cl_wbtc_usd), "CL_WBTC_USD");
 267 |     | 
 268 |     |         // UNISWAP
 269 | *   |         vm.label(address(uni_wstEth_weth), "UNI_WSTETH_WETH");
 270 | *   |         vm.label(address(uni_wbtc_usdc), "UNI_WBTC_USDC");
 271 |     | 
 272 |     |         // BASIN
 273 | *   |         vm.label(0xBA510C20FD2c52E4cb0d23CFC3cCD092F9165a6E, "CP2");
 274 | *   |         vm.label(0xBA510f10E3095B83a0F33aa9ad2544E22570a87C, "MULTI_FLOW_PUMP");
 275 | *   |         vm.label(address(mockPump), "MOCK_PUMP");
 276 | *   |         vm.label(0xBA510e11eEb387fad877812108a3406CA3f43a4B, "WELL_IMPL");
 277 | *   |         vm.label(0xBA51AAAA95aeEFc1292515b36D86C51dC7877773, "AQUIFIER");
 278 |     | 
 279 | *   |         vm.label(address(beanEthWell), "BEAN_ETH_WELL");
 280 | *   |         vm.label(address(beanWstEthWell), "BEAN_WSTETH_WELL");
 281 |     |               
 282 |     |     }
 283 |     | 
 284 |     |     // helper function to deploy ERC-20 tokens
 285 | *   |     function _deployToken(initERC20paramsFuzz memory _token) internal returns(MockToken token) {
 286 | *   |         token = new MockToken(_token.name, _token.symbol);
 287 | *   |         MockToken(token).setDecimals(_token.decimals);
 288 |     |     }
 289 |     | 
 290 |     |     // helper function to deploy chainlink oracles
 291 | *   |     function _deployOracle(uint256 _index) internal returns(MockChainlinkAggregator oracle) {
 292 | *   |         oracle = new MockChainlinkAggregator();
 293 | *   |         MockChainlinkAggregator(oracle).setDecimals(6);
 294 |     | 
 295 | *   |         uint256 time;
 296 |     | 
 297 | *   |         if (block.timestamp < 900) {
 298 |     |             time = 1; // min timestamp = 1.
 299 |     |         } else {
 300 | *   |             time = block.timestamp - 900;
 301 |     |         }
 302 | *   |         uint80 latestRound = MockChainlinkAggregator(oracle).getLatestRoundId();
 303 | *   |         MockChainlinkAggregator(oracle).addRound(initialPrices[_index], time, time, latestRound + 1);
 304 |     |     }
 305 |     | 
 306 |     | 
 307 |     |     // helper function to deploy uniswap pools            
 308 | *   |     function _deployUniswapPool(address _token0, address _token1, uint256 _index) internal returns(MockUniswapV3Pool pool) {
 309 | *   |         address poolAddress = uniFactory.createPool(_token0, _token1, 100);
 310 | *   |         pool = MockUniswapV3Pool(poolAddress);        
 311 |     | 
 312 | *   |         uint256 price = _calcPrice(uniPriceData[_index][0], uniPriceData[_index][1]);
 313 | *   |         pool.setOraclePrice(price, uint8(uniPriceData[_index][1]));
 314 |     | 
 315 | *   |         pool.setToken0(_token0);
 316 | *   |         pool.setToken1(_token1);
 317 |     |     }
 318 |     | 
 319 |     |     // helper function to format price calculation
 320 | *   |     function _calcPrice(uint256 _price, uint256 decimal) internal pure returns (uint256 price) {
 321 | *   |         uint256 x;
 322 | *   |         if (decimal == 6) {
 323 |     |             x = 1e18;
 324 | *   |         } else if (decimal == 18) {
 325 | *   |             x = 1e36;
 326 | *   |         } else if (decimal == 8) {
 327 | *   |             x = 1e14;
 328 |     |         }
 329 | *   |         price = x / (_price + 1);
 330 |     |     }
 331 |     | 
 332 |     |     // deploy CP2, Well, Multi Flow Pump, & Aquifier
 333 |     |     // @note uncomment these for foundry tests  
 334 | *   |     function _deployBasin() internal {
 335 |     |         // get CP2 creation code & deploy
 336 |     |         // bytes memory cp2CreationCode = vm.getCode("./node_modules/@beanstalk/wells1.2/out/ConstantProduct2.sol/ConstantProduct2.json");
 337 |     | 
 338 |     |         // vm.etch(0xBA510C20FD2c52E4cb0d23CFC3cCD092F9165a6E, abi.encodePacked(cp2CreationCode, bytes("")));
 339 |     | 
 340 |     |         // (bool success, bytes memory runtimeBytecode) = 0xBA510C20FD2c52E4cb0d23CFC3cCD092F9165a6E.call("");
 341 |     |         
 342 |     |         // if (!success) {
 343 |     |         //     revert();
 344 |     |         // }
 345 |     |         // vm.etch(0xBA510C20FD2c52E4cb0d23CFC3cCD092F9165a6E, runtimeBytecode);
 346 | *   |         cp2 = ICP2(0xBA510C20FD2c52E4cb0d23CFC3cCD092F9165a6E);
 347 |     | 
 348 |     |         // get Multi Flow Pump creation code & deploy
 349 |     |         // bytes memory multiFlowPumpCreationCode = vm.getCode("./node_modules/@beanstalk/wells1.2/out/MultiFlowPump.sol/MultiFlowPump.json");
 350 |     |         // vm.etch(0xBA510f10E3095B83a0F33aa9ad2544E22570a87C, abi.encodePacked(multiFlowPumpCreationCode, abi.encode(bytes16(0x3ff50624dd2f1a9fbe76c8b439581062), bytes16(0x3ff505e1d27a3ee9bffd7f3dd1a32671), uint256(12), bytes16(0x3ffeef368eb04325c526c2246eec3e55))));
 351 |     |         // (success, runtimeBytecode) = 0xBA510f10E3095B83a0F33aa9ad2544E22570a87C.call("");
 352 |     | 
 353 |     |         // if (!success) {
 354 |     |         //     revert();
 355 |     |         // }
 356 |     |         // vm.etch(0xBA510f10E3095B83a0F33aa9ad2544E22570a87C, runtimeBytecode);
 357 | *   |         multiFlowPump = IMultiFlowPump(0xBA510f10E3095B83a0F33aa9ad2544E22570a87C);
 358 |     |         
 359 | *   |         mockPump = new MockPump();
 360 |     | 
 361 |     |         // get Well Implementation creation code & deploy
 362 |     |         // bytes memory wellImplementationCreationCode = vm.getCode("./node_modules/@beanstalk/wells1.2/out/Well.sol/Well.json");
 363 |     |         // vm.etch(0xBA510e11eEb387fad877812108a3406CA3f43a4B, abi.encodePacked(wellImplementationCreationCode, bytes("")));
 364 |     |         // (success, runtimeBytecode) = 0xBA510e11eEb387fad877812108a3406CA3f43a4B.call("");
 365 |     | 
 366 |     |         // if (!success) {
 367 |     |         //     revert();
 368 |     |         // }
 369 |     |         // vm.etch(0xBA510e11eEb387fad877812108a3406CA3f43a4B, runtimeBytecode);
 370 | *   |         wellImpl = IWellImpl(0xBA510e11eEb387fad877812108a3406CA3f43a4B);
 371 |     |         
 372 |     |         // get aquifier creation code & deploy
 373 |     |         // bytes memory aquifierCreationCode = vm.getCode("./node_modules/@beanstalk/wells/out/Aquifer.sol/Aquifer.json");
 374 |     |         // vm.etch(0xBA51AAAA95aeEFc1292515b36D86C51dC7877773, abi.encodePacked(aquifierCreationCode, bytes("")));
 375 |     |         // (success, runtimeBytecode) = 0xBA51AAAA95aeEFc1292515b36D86C51dC7877773.call("");
 376 |     |         
 377 |     |         // if (!success) {
 378 |     |         //     revert();
 379 |     |         // }
 380 |     |         // vm.etch(0xBA51AAAA95aeEFc1292515b36D86C51dC7877773, runtimeBytecode);
 381 | *   |         aquifier = IAquifer(0xBA51AAAA95aeEFc1292515b36D86C51dC7877773);
 382 |     |     }
 383 |     | 
 384 |     |     // deploy well
 385 | *   |     function _deployWell(MockToken _pairToken) internal returns(address) {
 386 |     | 
 387 | *   |         uint256[] memory _init0 = new uint256[](2);
 388 |     | 
 389 | *   |         string memory wellName = string(
 390 | *   |             abi.encodePacked(beanToken.name(), _pairToken.name(), "Well")
 391 |     |         );
 392 | *   |         string memory wellSymbol = string(
 393 | *   |             abi.encodePacked(beanToken.name(), _pairToken.name(), "Well")
 394 |     |         );
 395 |     | 
 396 | *   |         address[] memory tokens = new address[](2);
 397 | *   |         tokens[0] = address(beanToken);
 398 | *   |         tokens[1] = address(weth);
 399 |     | 
 400 | *   |         Call[] memory pumpData = new Call[](1);
 401 | *   |         pumpData[0].target = address(mockPump);
 402 | *   |         pumpData[0].data = new bytes(0);
 403 | *   |         DeployWellData memory wellEncodedData = DeployWellData(
 404 | *   |             tokens,            // tokens
 405 | *   |             Call(              // wellFunction
 406 | *   |                 address(cp2),  // target
 407 | *   |                 new bytes(0)   // data
 408 |     |             ), 
 409 | *   |             pumpData           // pumps
 410 |     |         ); 
 411 |     | 
 412 | *   |         bytes memory packedPumpData;
 413 |     | 
 414 | *   |         for (uint256 i; i < wellEncodedData.pumps.length; ++i) {
 415 | *   |             Call memory pump = wellEncodedData.pumps[i];
 416 | *   |             packedPumpData = abi.encodePacked(
 417 | *   |                 packedPumpData,
 418 | *   |                 pump.target,
 419 | *   |                 pump.data.length,
 420 | *   |                 pump.data
 421 |     |             );
 422 |     |         }
 423 |     | 
 424 | *   |         bytes memory encodedWellParams = abi.encodePacked(
 425 | *   |             address(aquifier),
 426 | *   |             wellEncodedData.tokens.length,
 427 | *   |             wellEncodedData.wellFunction.target,
 428 | *   |             wellEncodedData.wellFunction.data.length,
 429 | *   |             wellEncodedData.pumps.length,
 430 | *   |             wellEncodedData.tokens,
 431 | *   |             wellEncodedData.wellFunction.data,
 432 | *   |             packedPumpData
 433 |     |         );
 434 |     | 
 435 | *   |         (bool success, bytes memory val) = address(aquifier).call(abi.encodeWithSelector(IAquifer.boreWell.selector, 
 436 | *   |             address(wellImpl),
 437 | *   |             encodedWellParams,
 438 | *   |             abi.encodeWithSignature("init(string,string)", wellName, wellSymbol),
 439 | *   |             bytes32(0)
 440 |     |         ));
 441 |     | 
 442 |     |         
 443 |     | 
 444 | *   |         address wellAddress = abi.decode(val, (address));
 445 |     | 
 446 | *   |         return wellAddress;
 447 |     |     }
 448 |     | 
 449 |     |     function _copyContractState(address source, address target) internal {
 450 |     |         uint256 slot = 0;
 451 |     |         for (uint256 i = 0; i < 100; i++) {
 452 |     |             bytes32 value = vm.load(source, bytes32(slot));
 453 |     |             if (value != bytes32(0)) {
 454 |     |                 vm.store(target, bytes32(slot), value);
 455 |     |             }
 456 |     |             slot++;
 457 |     |         }
 458 |     |     }
 459 |     | 
 460 |     |     // whitelist oracle for diamond
 461 | *   |     function _whitelistOracle() internal {
 462 | *   |         IMockFBeanstalk.Implementation memory oracleImplementation = IMockFBeanstalk.Implementation(
 463 | *   |             address(cl_eth_usd),
 464 | *   |             bytes4(0),
 465 | *   |             bytes1(0x01),
 466 | *   |             abi.encode(14400)
 467 |     |         );
 468 |     | 
 469 | *   |         vm.prank(address(diamond));
 470 | *   |         address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateOracleImplementationForToken.selector, address(weth), oracleImplementation));
 471 |     | 
 472 | *   |         uint256 _ethTimeout = 3600 * 4;
 473 |     |         
 474 | *   |         vm.prank(address(diamond));
 475 | *   |         address(diamond).call(
 476 | *   |             abi.encodeWithSelector(
 477 | *   |                 WhitelistFacet.updateOracleImplementationForToken.selector, 
 478 | *   |                 address(wstEth), 
 479 | *   |                 IMockFBeanstalk.Implementation(
 480 | *   |                     address(lSDChainlinkOracle),
 481 | *   |                     lSDChainlinkOracle.getPrice.selector,
 482 | *   |                     bytes1(0x00),
 483 | *   |                     abi.encode(address(cl_eth_usd), _ethTimeout, address(cl_wseth_eth), 14400)
 484 |     |                 )
 485 |     |             )
 486 |     |         );
 487 |     |     }
 488 |     | 
 489 |     |     // initialize shipment routes
 490 | *   |     function _initShipping() internal {
 491 |     | 
 492 | *   |         vm.prank(address(diamondCutFacet));
 493 | *   |         address(diamond).call(
 494 | *   |             abi.encodeWithSelector(
 495 | *   |                 FieldFacet.addField.selector
 496 |     |             )
 497 |     |         );
 498 |     | 
 499 | *   |         vm.prank(address(diamondCutFacet));
 500 | *   |         address(diamond).call(
 501 | *   |             abi.encodeWithSelector(
 502 | *   |                 FieldFacet.setActiveField.selector,
 503 | *   |                 0,
 504 | *   |                 1
 505 |     |             )
 506 |     |         );
 507 |     | 
 508 | *   |         mockBudget = new MockBudget();
 509 | *   |         mockPayback = new MockPayback(address(beanToken));
 510 |     | 
 511 | *   |         shipPlanner = new ShipmentPlanner(address(diamond), address(beanToken));
 512 |     | 
 513 | *   |         IBeanstalk.ShipmentRoute[] memory shipmentRoutes = new IBeanstalk.ShipmentRoute[](2);
 514 | *   |         shipmentRoutes[0] = IBeanstalk.ShipmentRoute({
 515 | *   |             planContract: address(shipPlanner),
 516 | *   |             planSelector: IShipmentPlanner.getSiloPlan.selector,
 517 | *   |             recipient: IBeanstalk.ShipmentRecipient.SILO,
 518 | *   |             data: abi.encode("")
 519 |     |         });
 520 | *   |         shipmentRoutes[1] = IBeanstalk.ShipmentRoute({
 521 | *   |             planContract: address(shipPlanner),
 522 | *   |             planSelector: IShipmentPlanner.getFieldPlan.selector,
 523 | *   |             recipient: IBeanstalk.ShipmentRecipient.FIELD,
 524 | *   |             data: abi.encode(uint256(0))
 525 |     |         });
 526 |     | 
 527 | *   |         vm.prank(address(diamondCutFacet));
 528 | *   |         address(diamond).call(
 529 | *   |             abi.encodeWithSelector(
 530 | *   |                 Distribution.setShipmentRoutes.selector,
 531 | *   |                 shipmentRoutes
 532 |     |             )
 533 |     |         );
 534 |     | 
 535 |     |     }
 536 |     | 
 537 |     |     
 538 |     |     // helper function to get diamond cuts
 539 | *   |     function _getCuts() internal returns (IDiamondCut.FacetCut[] memory cuts) {
 540 | *   |         cuts = new IDiamondCut.FacetCut[](24);
 541 |     | 
 542 | *   |         cuts[0] = IDiamondCut.FacetCut({
 543 | *   |             facetAddress: address(depotFacet),
 544 | *   |             action: IDiamondCut.FacetCutAction.Add,
 545 | *   |             functionSelectors: depotSelects
 546 |     |         });
 547 |     | 
 548 |     | 
 549 | *   |         cuts[1] = IDiamondCut.FacetCut({
 550 | *   |             facetAddress: address(farmFacet),
 551 | *   |             action: IDiamondCut.FacetCutAction.Add,
 552 | *   |             functionSelectors: farmSelects
 553 |     |         });
 554 |     | 
 555 |     | 
 556 | *   |         cuts[2] = IDiamondCut.FacetCut({
 557 | *   |             facetAddress: address(tokenFacet),
 558 | *   |             action: IDiamondCut.FacetCutAction.Add,
 559 | *   |             functionSelectors: tokenSelects
 560 |     |         });
 561 |     | 
 562 | *   |         cuts[3] = IDiamondCut.FacetCut({
 563 | *   |             facetAddress: address(tokenSupportFacet),
 564 | *   |             action: IDiamondCut.FacetCutAction.Add,
 565 | *   |             functionSelectors: tokenSupportSelects
 566 |     |         });
 567 |     | 
 568 | *   |         cuts[4] = IDiamondCut.FacetCut({
 569 | *   |             facetAddress: address(tractorFacet),
 570 | *   |             action: IDiamondCut.FacetCutAction.Add,
 571 | *   |             functionSelectors: tractorSelects
 572 |     |         });
 573 |     | 
 574 | *   |         cuts[5] = IDiamondCut.FacetCut({
 575 | *   |             facetAddress: address(fieldFacet),
 576 | *   |             action: IDiamondCut.FacetCutAction.Add,
 577 | *   |             functionSelectors: fieldSelects
 578 |     |         });
 579 |     | 
 580 | *   |         cuts[6] = IDiamondCut.FacetCut({
 581 | *   |             facetAddress: address(marketplaceFacet),
 582 | *   |             action: IDiamondCut.FacetCutAction.Add,
 583 | *   |             functionSelectors: marketplaceSelects
 584 |     |         });
 585 |     | 
 586 | *   |         cuts[7] = IDiamondCut.FacetCut({
 587 | *   |             facetAddress: address(metadataFacet),
 588 | *   |             action: IDiamondCut.FacetCutAction.Add,
 589 | *   |             functionSelectors: metadataSelects
 590 |     |         });
 591 |     | 
 592 | *   |         cuts[8] = IDiamondCut.FacetCut({
 593 | *   |             facetAddress: address(approvalFacet),
 594 | *   |             action: IDiamondCut.FacetCutAction.Add,
 595 | *   |             functionSelectors: approvalSelects
 596 |     |         });
 597 |     | 
 598 | *   |         cuts[9] = IDiamondCut.FacetCut({
 599 | *   |             facetAddress: address(bdvFacet),
 600 | *   |             action: IDiamondCut.FacetCutAction.Add,
 601 | *   |             functionSelectors: bdvSelects
 602 |     |         });
 603 |     | 
 604 | *   |         cuts[10] = IDiamondCut.FacetCut({
 605 | *   |             facetAddress: address(claimFacet),
 606 | *   |             action: IDiamondCut.FacetCutAction.Add,
 607 | *   |             functionSelectors: claimSelects
 608 |     |         });
 609 |     | 
 610 | *   |         cuts[11] = IDiamondCut.FacetCut({
 611 | *   |             facetAddress: address(convertFacet),
 612 | *   |             action: IDiamondCut.FacetCutAction.Add,
 613 | *   |             functionSelectors: convertSelects
 614 |     |         });
 615 |     | 
 616 | *   |         cuts[12] = IDiamondCut.FacetCut({
 617 | *   |             facetAddress: address(convertGettersFacet),
 618 | *   |             action: IDiamondCut.FacetCutAction.Add,
 619 | *   |             functionSelectors: convertGettersSelects
 620 |     |         });
 621 |     | 
 622 | *   |         cuts[13] = IDiamondCut.FacetCut({
 623 | *   |             facetAddress: address(pipelineConvertFacet),
 624 | *   |             action: IDiamondCut.FacetCutAction.Add,
 625 | *   |             functionSelectors: pipelineConvertSelects
 626 |     |         });
 627 |     | 
 628 | *   |         cuts[14] = IDiamondCut.FacetCut({
 629 | *   |             facetAddress: address(siloFacet),
 630 | *   |             action: IDiamondCut.FacetCutAction.Add,
 631 | *   |             functionSelectors: siloSelects
 632 |     |         });
 633 |     | 
 634 | *   |         cuts[15] = IDiamondCut.FacetCut({
 635 | *   |             facetAddress: address(siloGettersFacet),
 636 | *   |             action: IDiamondCut.FacetCutAction.Add,
 637 | *   |             functionSelectors: siloGettersSelects
 638 |     |         });
 639 |     | 
 640 | *   |         cuts[16] = IDiamondCut.FacetCut({
 641 | *   |             facetAddress: address(whitelistFacet),
 642 | *   |             action: IDiamondCut.FacetCutAction.Add,
 643 | *   |             functionSelectors: whitelistSelects
 644 |     |         });
 645 |     | 
 646 | *   |         cuts[17] = IDiamondCut.FacetCut({
 647 | *   |             facetAddress: address(gaugeFacet),
 648 | *   |             action: IDiamondCut.FacetCutAction.Add,
 649 | *   |             functionSelectors: gaugeSelects
 650 |     |         });
 651 |     | 
 652 | *   |         cuts[18] = IDiamondCut.FacetCut({
 653 | *   |             facetAddress: address(gaugeGettersFacet),
 654 | *   |             action: IDiamondCut.FacetCutAction.Add,
 655 | *   |             functionSelectors: gaugeGettersSelects
 656 |     |         });
 657 |     | 
 658 | *   |         cuts[19] = IDiamondCut.FacetCut({
 659 | *   |             facetAddress: address(liquidityWeightFacet),
 660 | *   |             action: IDiamondCut.FacetCutAction.Add,
 661 | *   |             functionSelectors: liquidityWeightSelects
 662 |     |         });
 663 |     | 
 664 | *   |         cuts[20] = IDiamondCut.FacetCut({
 665 | *   |             facetAddress: address(oracleFacet),
 666 | *   |             action: IDiamondCut.FacetCutAction.Add,
 667 | *   |             functionSelectors: oracleSelects
 668 |     |         });
 669 |     | 
 670 | *   |         cuts[21] = IDiamondCut.FacetCut({
 671 | *   |             facetAddress: address(seasonFacet),
 672 | *   |             action: IDiamondCut.FacetCutAction.Add,
 673 | *   |             functionSelectors: seasonSelects
 674 |     |         });
 675 |     | 
 676 | *   |         cuts[22] = IDiamondCut.FacetCut({
 677 | *   |             facetAddress: address(seasonGettersFacet),
 678 | *   |             action: IDiamondCut.FacetCutAction.Add,
 679 | *   |             functionSelectors: seasonGettersSelects
 680 |     |         });
 681 |     | 
 682 | *   |         cuts[23] = IDiamondCut.FacetCut({
 683 | *   |             facetAddress: address(ownershipFacet),
 684 | *   |             action: IDiamondCut.FacetCutAction.Add,
 685 | *   |             functionSelectors: ownershipSelects
 686 |     |         });
 687 |     |     }
 688 |     | 
 689 |     | 
 690 |     |     
 691 |     |     
 692 |     |     
 693 |     | }
 694 |     | 
 695 |     | 
 696 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/fuzz_calls/farm/FuzzDepotFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../../helpers/preconditions/farm/PreconditionsDepotFacet.sol";
  5 |     | import "../../helpers/postconditions/farm/PostconditionsDepotFacet.sol";
  6 |     | 
  7 |     | contract FuzzDepotFacet is PreconditionsDepotFacet, PostconditionsDepotFacet {
  8 |     | 
  9 | *   |     function fuzz_pipe() public {
 10 |     | 
 11 |     |         
 12 |     |         // (bool success, bytes memory returnData) = _pipeCall();
 13 |     |     }
 14 |     | 
 15 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/fuzz_calls/silo/FuzzApprovalFacet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../../helpers/preconditions/silo/PreconditionsApprovalFacet.sol";
   5 |     | import "../../helpers/postconditions/silo/PostconditionsApprovalFacet.sol";
   6 |     | 
   7 |     | contract FuzzApprovalFacet is PreconditionsApprovalFacet, PostconditionsApprovalFacet {
   8 |     | 
   9 | *   |     function fuzz_approve_approval_facet(uint256 _amountSalt, uint256 _recieverIndex) public setCurrentActor {
  10 |     | 
  11 | *   |         MockToken token = mockTokens[0];
  12 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  13 |     | 
  14 |     |         // verify different user is receiver
  15 | *   |         address spender = USERS[_recieverIndex];
  16 | *   |         if (spender == currentActor) {
  17 | *   |             spender = USERS[(_recieverIndex + 1) % 3];
  18 |     |         }
  19 |     | 
  20 | *   |         address[] memory actorsToUpdate = new address[](1);
  21 | *   |         actorsToUpdate[0] = currentActor;
  22 | *   |         actorsToUpdate[1] = spender;
  23 |     | 
  24 |     |         _setWellLiquidity();
  25 |     |         uint256 approvalAmount = _depositSilo(tokenAmount, currentActor); // @TODO check if we should be using the approval amount or not
  26 |     | 
  27 |     |         _before(actorsToUpdate);        
  28 |     | 
  29 |     |         (bool success, bytes memory returnData) = _approveDepositCall(spender, address(token), approvalAmount);
  30 |     | 
  31 |     |         _approvalFacetPostCondition(success, returnData, actorsToUpdate);
  32 |     |         
  33 |     |     }
  34 |     | 
  35 | *   |     function fuzz_increase_approval_facet(uint256 _amountSalt, uint256 _recieverIndex) public setCurrentActor {
  36 |     | 
  37 | *   |         MockToken token = mockTokens[0];
  38 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  39 |     | 
  40 |     |         // verify different user is receiver
  41 | *   |         address spender = USERS[_recieverIndex];
  42 | *   |         if (spender == currentActor) {
  43 | *   |             spender = USERS[(_recieverIndex + 1) % 3];
  44 |     |         }
  45 |     | 
  46 | *   |         address[] memory actorsToUpdate = new address[](1);
  47 | *   |         actorsToUpdate[0] = currentActor;
  48 | *   |         actorsToUpdate[1] = spender;
  49 |     | 
  50 |     |         _before(actorsToUpdate);
  51 |     | 
  52 |     |         _setWellLiquidity();
  53 |     |         uint256 approvalAmount = _depositSilo(tokenAmount, currentActor);
  54 |     | 
  55 |     |         (bool success, bytes memory returnData) = _approveDepositCall(spender, address(token), approvalAmount);
  56 |     | 
  57 |     |         (success, returnData) = _increaseDepositAllowanceCall(spender, address(token), approvalAmount);
  58 |     | 
  59 |     |         _approvalFacetPostCondition(success, returnData, actorsToUpdate);
  60 |     | 
  61 |     |         
  62 |     |     }
  63 |     | 
  64 |     | 
  65 | *   |     function fuzz_decrease_approval_facet(uint256 _amountSalt, uint256 _recieverIndex) public setCurrentActor {
  66 |     | 
  67 | *   |         MockToken token = mockTokens[0];
  68 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  69 |     | 
  70 |     |         // verify different user is receiver
  71 | *   |         address spender = USERS[_recieverIndex];
  72 |     |         if (spender == currentActor) {
  73 |     |             spender = USERS[(_recieverIndex + 1) % 3];
  74 |     |         }
  75 |     | 
  76 |     |         address[] memory actorsToUpdate = new address[](1);
  77 |     |         actorsToUpdate[0] = currentActor;
  78 |     |         actorsToUpdate[1] = spender;
  79 |     | 
  80 |     |         _before(actorsToUpdate);
  81 |     | 
  82 |     |         _setWellLiquidity();
  83 |     |         uint256 approvalAmount = _depositSilo(tokenAmount, currentActor);
  84 |     | 
  85 |     |         (bool success, bytes memory returnData) = _approveDepositCall(spender, address(token), approvalAmount);
  86 |     | 
  87 |     |         (success, returnData) = _decreaseDepositAllowanceCall(spender, address(token), approvalAmount);
  88 |     | 
  89 |     |         _approvalFacetPostCondition(success, returnData, actorsToUpdate);
  90 |     |         
  91 |     |     }
  92 |     | 
  93 |     | 
  94 |     | 
  95 | *   |     function fuzz_approve_all_approval_facet(uint256 _amountSalt, uint256 _recieverIndex) public setCurrentActor {
  96 |     | 
  97 | *   |         MockToken token = mockTokens[0];
  98 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  99 |     | 
 100 |     |         // verify different user is receiver
 101 | *   |         address spender = USERS[_recieverIndex];
 102 | *   |         if (spender == currentActor) {
 103 | *   |             spender = USERS[(_recieverIndex + 1) % 3];
 104 |     |         }
 105 |     | 
 106 | *   |         address[] memory actorsToUpdate = new address[](1);
 107 | *   |         actorsToUpdate[0] = currentActor;
 108 | *   |         actorsToUpdate[1] = spender;
 109 |     | 
 110 |     |         _before(actorsToUpdate);
 111 |     | 
 112 |     |         _setWellLiquidity();
 113 |     |         uint256 approvalAmount = _depositSilo(tokenAmount, currentActor);
 114 |     | 
 115 |     | 
 116 |     |         (bool success, bytes memory returnData) = _setApprovalForAllCall(spender, true);
 117 |     | 
 118 |     |         _approvalFacetPostCondition(success, returnData, actorsToUpdate);
 119 |     |         
 120 |     |     }
 121 |     | 
 122 |     | 
 123 |     | 
 124 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/fuzz_calls/silo/FuzzSiloFacet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../../helpers/preconditions/silo/PreconditionsSiloFacet.sol";
   5 |     | import "../../helpers/postconditions/silo/PostconditionsSiloFacet.sol";
   6 |     | 
   7 |     | contract FuzzSiloFacet is PreconditionsSiloFacet, PostconditionsSiloFacet {
   8 |     | 
   9 | *   |     function fuzz_deposit_silo_facet(uint256 _amountSalt, uint256 _modeSalt) public setCurrentActor {
  10 |     | 
  11 | *   |         MockToken token = mockTokens[0];
  12 | *   |         console.log(token.name());
  13 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  14 | *   |         uint256 mode = fl.clamp(_modeSalt, 0, 3);
  15 |     | 
  16 | *   |         address[] memory actorsToUpdate = new address[](1);
  17 | *   |         actorsToUpdate[0] = currentActor;
  18 |     | 
  19 | *   |         _setWellLiquidity();
  20 | *   |         _before(actorsToUpdate);
  21 |     | 
  22 | *   |         vm.prank(ADMIN);
  23 | *   |         beanToken.mint(currentActor, tokenAmount);
  24 |     | 
  25 |     | 
  26 | *   |         (bool success, bytes memory returnData) = _depositCall(address(token), tokenAmount, LibTransfer.From(mode));
  27 |     | 
  28 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
  29 |     |         
  30 |     |     }
  31 |     | 
  32 | *   |     function fuzz_withdraw_silo_facet(uint256 _amountSalt, uint256 _modeSalt) public setCurrentActor {
  33 |     | 
  34 | *   |         MockToken token = mockTokens[0];
  35 | *   |         console.log(token.name());
  36 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  37 | *   |         uint256 mode = fl.clamp(_modeSalt, 0, 3);
  38 |     | 
  39 | *   |         address[] memory actorsToUpdate = new address[](1);
  40 | *   |         actorsToUpdate[0] = currentActor;
  41 |     | 
  42 | *   |         _setWellLiquidity();
  43 | *   |         _before(actorsToUpdate);
  44 |     | 
  45 | *   |         vm.prank(ADMIN);
  46 | *   |         beanToken.mint(currentActor, tokenAmount);
  47 |     | 
  48 | *   |         (bool success, bytes memory returnData) = _depositCall(address(token), tokenAmount, LibTransfer.From(mode));
  49 |     | 
  50 | *   |         if (!success) {
  51 | *r  |             revert(); //@TODO better error handeling
  52 |     |         }
  53 |     | 
  54 | *   |         (uint256 amount, uint256 bdv, int96 stem) = abi.decode(returnData, (uint256, uint256, int96));
  55 |     | 
  56 | *   |         (success, returnData) = _withdrawDepositCall(address(token), stem, amount, LibTransfer.To(mode % 2));
  57 |     | 
  58 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
  59 |     |         
  60 |     |     }
  61 |     | 
  62 | *   |     function fuzz_multi_withdraw_silo_facet(uint256 _amountSalt1, uint256 _amountSalt2, uint256 _modeSalt) public setCurrentActor {
  63 |     | 
  64 | *   |         MockToken token = mockTokens[0];
  65 | *   |         console.log(token.name());
  66 | *   |         uint256 tokenAmount1 = fl.clamp(_amountSalt1, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  67 | *   |         uint256 tokenAmount2 = fl.clamp(_amountSalt2, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  68 | *   |         uint256 mode = fl.clamp(_modeSalt, 0, 1);
  69 |     | 
  70 | *   |         address[] memory actorsToUpdate = new address[](1);
  71 | *   |         actorsToUpdate[0] = currentActor;
  72 |     | 
  73 | *   |         _setWellLiquidity();
  74 | *   |         _before(actorsToUpdate);
  75 |     | 
  76 | *   |         vm.prank(ADMIN);
  77 | *   |         beanToken.mint(currentActor, tokenAmount1 + tokenAmount2);
  78 |     | 
  79 | *   |         (int96[] memory stems, uint256[] memory amounts) = _doubleDeposit(token, tokenAmount1, tokenAmount2);
  80 |     | 
  81 | *   |         (bool success, bytes memory returnData) = this._withdrawDepositsCall(address(token), stems, amounts, LibTransfer.To(mode));
  82 |     | 
  83 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
  84 |     |         
  85 |     |     }
  86 |     | 
  87 | *   |     function fuzz_transfer_deposit_silo_facet(uint256 _amountSalt, uint256 _receiverSalt, uint256 _modeSalt) public setCurrentActor {
  88 |     | 
  89 | *   |         MockToken token = mockTokens[0];
  90 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
  91 | *   |         uint256 mode = fl.clamp(_modeSalt, 0, 3);
  92 | *   |         uint256 recieverIndex = fl.clamp(_receiverSalt, 0, 2);
  93 |     | 
  94 |     |         // verify different user is receiver
  95 | *   |         address receiver = USERS[recieverIndex];
  96 | *   |         if (receiver == currentActor) {
  97 | *   |             receiver = USERS[(recieverIndex + 1) % 3];
  98 |     |         }
  99 |     | 
 100 | *   |         address[] memory actorsToUpdate = new address[](2);
 101 | *   |         actorsToUpdate[0] = currentActor;
 102 | *   |         actorsToUpdate[1] = receiver;
 103 |     | 
 104 | *   |         _setWellLiquidity();
 105 | *   |         _before(actorsToUpdate);
 106 |     | 
 107 | *   |         vm.prank(ADMIN);
 108 | *   |         beanToken.mint(currentActor, tokenAmount);
 109 |     | 
 110 |     |         // deposit
 111 | *   |         (bool success, bytes memory returnData) = _depositCall(address(token), tokenAmount, LibTransfer.From(mode));
 112 | *   |         if (!success) {
 113 | *r  |             revert(); //@TODO better error handeling
 114 |     |         }
 115 | *   |         (uint256 amount, uint256 bdv, int96 stem) = abi.decode(returnData, (uint256, uint256, int96));
 116 |     | 
 117 |     |         // transfer deposit
 118 | *   |         (success, returnData) = _transferDepositCall(currentActor, receiver, address(token), stem, amount);
 119 |     | 
 120 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
 121 |     |         
 122 |     |     }
 123 |     | 
 124 |     | 
 125 | *   |     function fuzz_multi_transfer_silo_facet(uint256 _amountSalt1, uint256 _amountSalt2, uint256 _receiverSalt) public setCurrentActor {
 126 |     | 
 127 | *   |         MockToken token = mockTokens[0];
 128 | *   |         uint256 tokenAmount1 = fl.clamp(_amountSalt1, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
 129 | *   |         uint256 tokenAmount2 = fl.clamp(_amountSalt2, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
 130 | *   |         uint256 recieverIndex = fl.clamp(_receiverSalt, 0, 2);
 131 |     | 
 132 |     |         // verify different user is receiver
 133 | *   |         address receiver = USERS[recieverIndex];
 134 | *   |         if (receiver == currentActor) {
 135 | *   |             receiver = USERS[(recieverIndex + 1) % 3];
 136 |     |         }
 137 |     | 
 138 | *   |         address[] memory actorsToUpdate = new address[](2);
 139 | *   |         actorsToUpdate[0] = currentActor;
 140 | *   |         actorsToUpdate[1] = receiver;
 141 |     | 
 142 | *   |         _setWellLiquidity();
 143 | *   |         _before(actorsToUpdate);
 144 |     | 
 145 | *   |         vm.prank(ADMIN);
 146 | *   |         beanToken.mint(currentActor, tokenAmount1 + tokenAmount2);
 147 |     | 
 148 | *   |         (int96[] memory stems, uint256[] memory amounts) = _doubleDeposit(token, tokenAmount1, tokenAmount2);
 149 |     | 
 150 | *   |         int256[] memory stems256 = new int256[](2);
 151 | *   |         stems256[0] = int256(stems[0]);
 152 | *   |         stems256[1] = int256(stems[1]);
 153 |     | 
 154 |     |         // transfer deposits
 155 | *   |         (bool success, bytes memory returnData) = this._transferDepositsCall(currentActor, receiver, address(token), stems256, amounts);
 156 |     | 
 157 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
 158 |     |         
 159 |     |     }
 160 |     | 
 161 | *   |     function fuzz_transfer_from_silo_facet(uint256 _amountSalt, uint256 _receiverSalt) public setCurrentActor {
 162 | *   |         MockToken token = mockTokens[0];
 163 | *   |         uint256 tokenAmount = fl.clamp(_amountSalt, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
 164 | *   |         uint256 recieverIndex = fl.clamp(_receiverSalt, 0, 2);
 165 |     | 
 166 |     |         // verify different user is receiver
 167 | *   |         address receiver = USERS[recieverIndex];
 168 | *   |         if (receiver == currentActor) {
 169 | *   |             receiver = USERS[(recieverIndex + 1) % 3];
 170 |     |         }
 171 |     | 
 172 | *   |         address[] memory actorsToUpdate = new address[](2);
 173 | *   |         actorsToUpdate[0] = currentActor;
 174 | *   |         actorsToUpdate[1] = receiver;
 175 |     | 
 176 | *   |         _setWellLiquidity();
 177 | *   |         _before(actorsToUpdate);
 178 |     | 
 179 | *   |         vm.prank(ADMIN);
 180 | *   |         beanToken.mint(currentActor, tokenAmount);
 181 |     | 
 182 |     |         // deposit
 183 | *   |         (bool success, bytes memory returnData) = _depositCall(address(token), tokenAmount, LibTransfer.From(0));
 184 | *   |         if (!success) {
 185 |     |             revert(); //@TODO better error handeling
 186 |     |         }
 187 |     | 
 188 | *   |         (uint256 amount, uint256 bdv, int96 stem) = abi.decode(returnData, (uint256, uint256, int96));
 189 |     | 
 190 |     | 
 191 | *   |         (success, returnData) = _getDepositIdCall(address(token), stem);
 192 | *   |         if (!success) {
 193 |     |             revert(); //@TODO better error handeling
 194 |     |         }
 195 |     | 
 196 | *   |         uint256 _depositId = abi.decode(returnData, (uint256));
 197 |     |        
 198 | *   |         (success, returnData) = this._safeTransferFromCall(currentActor, receiver, _depositId, amount, new bytes(0));
 199 |     | 
 200 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
 201 |     |     }
 202 |     | 
 203 | *   |     function fuzz_multi_transfer_from_silo_facet(uint256 _amountSalt1, uint256 _amountSalt2, uint256 _receiverSalt) public setCurrentActor {
 204 | *   |         MockToken token = mockTokens[0];
 205 | *   |         uint256 tokenAmount1 = fl.clamp(_amountSalt1, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
 206 | *   |         uint256 tokenAmount2 = fl.clamp(_amountSalt2, 1, 10000) * (10 ** token.decimals()); //@TODO consider incrementing
 207 | *   |         uint256 recieverIndex = fl.clamp(_receiverSalt, 0, 2);
 208 |     | 
 209 |     |         // verify different user is receiver
 210 | *   |         address receiver = USERS[recieverIndex];
 211 | *   |         if (receiver == currentActor) {
 212 | *   |             receiver = USERS[(recieverIndex + 1) % 3];
 213 |     |         }
 214 |     | 
 215 | *   |         address[] memory actorsToUpdate = new address[](2);
 216 | *   |         actorsToUpdate[0] = currentActor;
 217 | *   |         actorsToUpdate[1] = receiver;
 218 |     | 
 219 | *   |         _setWellLiquidity();
 220 | *   |         _before(actorsToUpdate);
 221 |     | 
 222 | *   |         vm.prank(ADMIN);
 223 | *   |         beanToken.mint(currentActor, tokenAmount1 + tokenAmount2);
 224 |     | 
 225 | *   |         (int96[] memory stems, uint256[] memory amounts) = _doubleDeposit(token, tokenAmount1, tokenAmount2);
 226 |     | 
 227 |     | 
 228 | *   |         (bool success, bytes memory returnData) = _getDepositIdCall(address(token), stems[0]);
 229 | *   |         if (!success) {
 230 |     |             revert(); //@TODO better error handeling
 231 |     |         }
 232 |     | 
 233 | *   |         uint256[] memory depositIds = new uint256[](2);
 234 |     | 
 235 | *   |         depositIds[0] = abi.decode(returnData, (uint256));
 236 |     | 
 237 | *   |         (success, returnData) = _getDepositIdCall(address(token), stems[1]);
 238 | *   |         if (!success) {
 239 |     |             revert(); //@TODO better error handeling
 240 |     |         }
 241 |     | 
 242 | *   |         depositIds[1] = abi.decode(returnData, (uint256));
 243 |     | 
 244 |     |         
 245 | *   |         (success, returnData) = this._safeBatchTransferFromCall(currentActor, receiver, depositIds, amounts, new bytes(0));
 246 |     | 
 247 | *   |         _siloFacetPostCondition(success, returnData, actorsToUpdate);
 248 |     |     }
 249 |     | 
 250 |     | 
 251 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/BeforeAfter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../FuzzSetup.sol";
  5 |     | 
  6 |     | contract BeforeAfter is FuzzSetup {
  7 |     | 
  8 | *   |     function _before(address[] memory actors) internal {
  9 |     | 
 10 |     |     }
 11 |     | 
 12 | *   |     function _after(address[] memory actors) internal {
 13 |     |     }
 14 |     | 
 15 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/FuzzStorageVariables.sol
   1 |     | // SPDX-License-Identifier: UNTITLED
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../utils/FuzzActors.sol";
   5 |     | import {Pipeline} from "contracts/pipeline/Pipeline.sol";
   6 |     | import {IMockFBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
   7 |     | import {OperatorWhitelist} from "contracts/ecosystem/OperatorWhitelist.sol";
   8 |     | import {MockToken} from "contracts/mocks/MockToken.sol";
   9 |     | import {MockChainlinkAggregator} from "contracts/mocks/MockChainlinkAggregator.sol";
  10 |     | import {MockUniswapV3Pool} from "contracts/mocks/uniswap/MockUniswapV3Pool.sol";
  11 |     | import {MockUniswapV3Factory} from "contracts/mocks/uniswap/MockUniswapV3Factory.sol";
  12 |     | 
  13 |     | import {LibEvaluate} from "contracts/libraries/LibEvaluate.sol";
  14 |     | import "contracts/beanstalk/storage/System.sol";
  15 |     | import "contracts/interfaces/IPipeline.sol";
  16 |     | import "contracts/beanstalk/facets/market/abstract/Listing.sol";
  17 |     | import "contracts/beanstalk/facets/market/abstract/Order.sol";
  18 |     | import "contracts/libraries/LibFarm.sol";
  19 |     | import {LibConvert} from "contracts/libraries/Convert/LibConvert.sol";
  20 |     | import {SafeERC20, IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  21 |     | import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
  22 |     | import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
  23 |     | import {LibTractor} from "contracts/libraries/LibTractor.sol";
  24 |     | import {LibTransfer} from "contracts/libraries/Token/LibTransfer.sol";
  25 |     | 
  26 |     | import {DepotFacet} from "contracts/beanstalk/facets/farm/DepotFacet.sol";
  27 |     | import {TokenFacet} from "contracts/beanstalk/facets/farm/TokenFacet.sol";
  28 |     | import {FarmFacet} from "contracts/beanstalk/facets/farm/FarmFacet.sol"; //@next
  29 |     | import {TokenFacet} from "contracts/beanstalk/facets/farm/TokenFacet.sol";
  30 |     | import {TokenSupportFacet} from "contracts/beanstalk/facets/farm/TokenSupportFacet.sol";
  31 |     | import {TractorFacet} from "contracts/beanstalk/facets/farm/TractorFacet.sol";
  32 |     | 
  33 |     | import {FieldFacet} from "contracts/beanstalk/facets/field/FieldFacet.sol";
  34 |     | 
  35 |     | import {MarketplaceFacet} from "contracts/beanstalk/facets/market/MarketplaceFacet.sol";
  36 |     | 
  37 |     | import {MetadataFacet} from "contracts/beanstalk/facets/metadata/MetadataFacet.sol";
  38 |     | 
  39 |     | import {ApprovalFacet} from "contracts/beanstalk/facets/silo/ApprovalFacet.sol";
  40 |     | import {BDVFacet} from "contracts/beanstalk/facets/silo/BDVFacet.sol";
  41 |     | import {ConvertFacet} from "contracts/beanstalk/facets/silo/ConvertFacet.sol";
  42 |     | import {ClaimFacet} from "contracts/beanstalk/facets/silo/ClaimFacet.sol";
  43 |     | import {ConvertGettersFacet} from "contracts/beanstalk/facets/silo/ConvertGettersFacet.sol";
  44 |     | import {PipelineConvertFacet} from "contracts/beanstalk/facets/silo/PipelineConvertFacet.sol";
  45 |     | import {SiloFacet} from "contracts/beanstalk/facets/silo/SiloFacet.sol";
  46 |     | import {SiloGettersFacet} from "contracts/beanstalk/facets/silo/SiloGettersFacet.sol";
  47 |     | import {WhitelistFacet} from "contracts/beanstalk/facets/silo/WhitelistFacet.sol";
  48 |     | 
  49 |     | import {GaugeFacet} from "contracts/beanstalk/facets/sun/GaugeFacet.sol";
  50 |     | import {GaugeGettersFacet} from "contracts/beanstalk/facets/sun/GaugeGettersFacet.sol";
  51 |     | import {LiquidityWeightFacet} from "contracts/beanstalk/facets/sun/LiquidityWeightFacet.sol";
  52 |     | import {OracleFacet} from "contracts/beanstalk/facets/sun/OracleFacet.sol";
  53 |     | import {SeasonFacet} from "contracts/beanstalk/facets/sun/SeasonFacet.sol";
  54 |     | import {SeasonGettersFacet} from "contracts/beanstalk/facets/sun/SeasonGettersFacet.sol";
  55 |     | 
  56 |     | import {DiamondCutFacet} from "contracts/beanstalk/facets/diamond/DiamondCutFacet.sol";
  57 |     | import {DiamondLoupeFacet} from "contracts/beanstalk/facets/diamond/DiamondLoupeFacet.sol";
  58 |     | import {OwnershipFacet} from "contracts/beanstalk/facets/diamond/OwnershipFacet.sol";
  59 |     | import {PauseFacet} from "contracts/beanstalk/facets/diamond/PauseFacet.sol";
  60 |     | 
  61 |     | import {InitDiamond} from "contracts/beanstalk/init/newInitDiamond.sol";
  62 |     | import {Diamond} from "contracts/beanstalk/Diamond.sol";
  63 |     | 
  64 |     | import {Junction} from "contracts/ecosystem/junction/Junction.sol";
  65 |     | import {LogicJunction} from "contracts/ecosystem/junction/LogicJunction.sol";
  66 |     | import {MathJunction} from "contracts/ecosystem/junction/MathJunction.sol";
  67 |     | import {LSDChainlinkOracle} from "contracts/ecosystem/oracles/LSDChainlinkOracle.sol";
  68 |     | import {BeanstalkPrice} from "contracts/ecosystem/price/BeanstalkPrice.sol";
  69 |     | import {WellPrice} from "contracts/ecosystem/price/WellPrice.sol";
  70 |     | import {Drafter} from "contracts/ecosystem/Drafter.sol";
  71 |     | import {OperatorWhitelist} from "contracts/ecosystem/OperatorWhitelist.sol";
  72 |     | import {GaugePriceThreshold} from "contracts/ecosystem/GaugePriceThreshold.sol";
  73 |     | import {PriceManipulation} from "contracts/ecosystem/PriceManipulation.sol";
  74 |     | import {ShipmentPlanner} from "contracts/ecosystem/ShipmentPlanner.sol";
  75 |     | import {SowBlueprintv0} from "contracts/ecosystem/SowBlueprintv0.sol";
  76 |     | import {TractorHelpers} from "contracts/ecosystem/TractorHelpers.sol";
  77 |     | import {LibTractorHelpers} from "contracts/libraries/Silo/LibTractorHelpers.sol";
  78 |     | 
  79 |     | import {MockPump} from "contracts/mocks/well/MockPump.sol";
  80 |     | import {IAquifer} from "contracts/interfaces/basin/IAquifer.sol";
  81 |     | import {IWellImpl} from "../interfaces/IWellImpl.sol";
  82 |     | import {ICP2} from "../interfaces/ICP2.sol";
  83 |     | import {IMultiFlowPump} from "../interfaces/IMultiFlowPump.sol";
  84 |     | import {IWell} from "contracts/libraries/Well/LibWell.sol";
  85 |     | 
  86 |     | import {MockPayback} from "contracts/mocks/MockPayback.sol";
  87 |     | import {MockBudget} from "contracts/mocks/MockBudget.sol";
  88 |     | import {ShipmentPlanner} from "contracts/ecosystem/ShipmentPlanner.sol";
  89 |     | import {IMockFBeanstalk as IBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
  90 |     | import {IShipmentPlanner} from "contracts/interfaces/IShipmentPlanner.sol";
  91 |     | import {Distribution} from "contracts/beanstalk/facets/sun/abstract/Distribution.sol";
  92 |     | 
  93 |     | import {Bean} from "contracts/tokens/Bean.sol";
  94 |     | 
  95 |     | import {MockInitDiamondFuzz} from "../mocks/MockInitDiamondFuzz.sol";
  96 |     | 
  97 |     | contract FuzzStorageVariables is FuzzActors {
  98 |     |     // ==============================================================
  99 |     |     // FUZZING SUITE SETUP
 100 |     |     // ==============================================================
 101 |     | 
 102 |     |     struct initERC20paramsFuzz {
 103 |     |         string name;
 104 |     |         string symbol;
 105 |     |         uint8 decimals;
 106 |     |     }
 107 |     | 
 108 |     |     struct Call {
 109 |     |         address target; // The address the call is executed on.
 110 |     |         bytes data; // Extra calldata to be passed during the call
 111 |     |     }
 112 |     | 
 113 |     |     struct DeployWellData {
 114 |     |         address[] tokens;
 115 |     |         Call wellFunction;
 116 |     |         Call[] pumps;
 117 |     |     }
 118 |     | 
 119 |     |     address currentActor;
 120 | *   |     bool _setActor = true;
 121 |     | 
 122 | *   |     uint256 internal constant PRIME = 2147483647;
 123 | *   |     uint256 internal constant SEED = 22;
 124 | *   |     uint256 iteration = 1; // fuzzing iteration
 125 |     |     uint256 lastTimestamp;
 126 |     | 
 127 |     |     //==============================================================
 128 |     |     // REVERTS CONFIGURATION
 129 |     |     //==============================================================
 130 |     | 
 131 | *   |     bool internal constant CATCH_REQUIRE_REVERT = true; // Set to false to ignore require()/revert()
 132 |     |     bool internal constant CATCH_EMPTY_REVERTS = true; // Set to true to allow empty return data
 133 |     | 
 134 |     |     // ==============================================================
 135 |     |     // CONTRACTS
 136 |     |     // ==============================================================
 137 |     |     
 138 |     |     // Beanstalk Facets
 139 |     |     Diamond diamond;
 140 |     |     DiamondCutFacet diamondCutFacet;
 141 |     |     DiamondLoupeFacet diamondLoupeFacet;
 142 |     |     OwnershipFacet ownershipFacet;
 143 |     |     MockInitDiamondFuzz initDiamond;
 144 |     |     PauseFacet pauseFacet;
 145 |     | 
 146 |     |     // Farm
 147 |     |     DepotFacet depotFacet;
 148 |     |     FarmFacet farmFacet;
 149 |     |     TokenFacet tokenFacet;
 150 |     |     TokenSupportFacet tokenSupportFacet;
 151 |     |     TractorFacet tractorFacet;
 152 |     | 
 153 |     |     // Field
 154 |     |     FieldFacet fieldFacet;
 155 |     | 
 156 |     |     // Market
 157 |     |     MarketplaceFacet marketplaceFacet;
 158 |     | 
 159 |     |     // Metadata
 160 |     |     MetadataFacet metadataFacet;
 161 |     | 
 162 |     |     // Silo
 163 |     |     ApprovalFacet approvalFacet;
 164 |     |     BDVFacet bdvFacet;
 165 |     |     ClaimFacet claimFacet;
 166 |     |     ConvertFacet convertFacet;
 167 |     |     ConvertGettersFacet convertGettersFacet;
 168 |     |     PipelineConvertFacet pipelineConvertFacet;
 169 |     |     SiloFacet siloFacet;
 170 |     |     SiloGettersFacet siloGettersFacet;
 171 |     |     WhitelistFacet whitelistFacet;
 172 |     | 
 173 |     |     // Sun
 174 |     |     GaugeFacet gaugeFacet;
 175 |     |     GaugeGettersFacet gaugeGettersFacet;
 176 |     |     LiquidityWeightFacet liquidityWeightFacet;
 177 |     |     OracleFacet oracleFacet;
 178 |     |     SeasonFacet seasonFacet;
 179 |     |     SeasonGettersFacet seasonGettersFacet;
 180 |     | 
 181 |     | 
 182 |     |     // Ecosystem
 183 |     |     // junction
 184 |     |     Junction junction;
 185 |     |     MathJunction mathJunction;
 186 |     |     LogicJunction logicJunction;
 187 |     |     // oracles
 188 |     |     LSDChainlinkOracle lSDChainlinkOracle;
 189 |     |     // price
 190 |     |     BeanstalkPrice beanstalkPrice;
 191 |     |     WellPrice wellPrice;
 192 |     |     // main
 193 |     |     Drafter drafter;
 194 |     |     GaugePriceThreshold gaugePriceThreshold;
 195 |     |     OperatorWhitelist operatorWhitelist;
 196 |     |     PriceManipulation priceManipulation;
 197 |     |     ShipmentPlanner shipment_planner;
 198 |     |     SowBlueprintv0 sowBlueprintv0;
 199 |     |     TractorHelpers tractorHelpers;
 200 |     | 
 201 |     |     // Pipeline
 202 |     |     Pipeline pipeLine;
 203 |     | 
 204 |     |     
 205 |     | 
 206 |     |     // Pipeline internal pipeline;
 207 |     |     IMockFBeanstalk internal beanstock;
 208 |     | 
 209 |     |     // Tokens
 210 |     |     Bean beanToken;
 211 |     | 
 212 |     |     // MockToken 
 213 |     |     MockToken internal beanMock;
 214 |     |     MockToken internal weth;
 215 |     |     MockToken internal wstEth;
 216 |     |     MockToken internal usdc;
 217 |     |     MockToken internal usdt;
 218 |     |     MockToken internal wbtc;
 219 |     | 
 220 |     |     MockToken[] mockTokens;
 221 |     | 
 222 |     | 
 223 |     |     // Chainlink
 224 |     |     MockChainlinkAggregator internal cl_eth_usd;
 225 |     |     MockChainlinkAggregator internal cl_wseth_eth;
 226 |     |     MockChainlinkAggregator internal cl_usdc_usd;
 227 |     |     MockChainlinkAggregator internal cl_wbtc_usd;
 228 |     | 
 229 |     |     // Uniswap
 230 |     |     MockUniswapV3Pool internal uni_wstEth_weth;
 231 |     |     MockUniswapV3Pool internal uni_wbtc_usdc;
 232 |     | 
 233 |     |     // Basin
 234 |     |     MockPump mockPump;
 235 |     |     IAquifer aquifier;
 236 |     |     IWellImpl wellImpl;
 237 |     |     IMultiFlowPump multiFlowPump;
 238 |     |     ICP2 cp2;
 239 |     | 
 240 |     |     IWell beanEthWell;
 241 |     |     IWell beanWstEthWell;
 242 |     | 
 243 |     |     // Routes
 244 |     |     MockBudget mockBudget;
 245 |     |     MockPayback mockPayback;
 246 |     |     ShipmentPlanner shipPlanner;
 247 |     | }
 248 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/postconditions/PostconditionsBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.25;
  3 |     | 
  4 |     | import "../../properties/Properties.sol";
  5 |     | 
  6 |     | contract PostconditionsBase is Properties {
  7 |     | 
  8 |     | 
  9 |     | 
 10 |     |     // @TODO add properties here
 11 | *   |     function onSuccessInvariantsGeneral(bytes memory returnData) internal {
 12 |     |         // invariant_GLOB_01();
 13 |     |     }
 14 |     | 
 15 | *   |     function onFailInvariantsGeneral(bytes memory returnData) internal {
 16 | *   |         invariant_ERR(returnData);
 17 |     |     }
 18 |     | 
 19 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/postconditions/farm/PostconditionsDepotFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsDepotFacet is PostconditionsBase {
  7 |     | 
  8 |     | 
  9 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/postconditions/silo/PostconditionsApprovalFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsApprovalFacet is PostconditionsBase {
  7 |     | 
  8 |     |     function _approvalFacetPostCondition(bool success, bytes memory returnData, address[] memory actorsToUpdate) internal {
  9 |     | 
 10 |     |         if (success) {
 11 |     |             _after(actorsToUpdate);
 12 |     | 
 13 |     |             onSuccessInvariantsGeneral(returnData);
 14 |     |         } else {
 15 |     |             onFailInvariantsGeneral(returnData);
 16 |     |         }
 17 |     | 
 18 |     |     }
 19 |     | 
 20 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/postconditions/silo/PostconditionsSiloFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../PostconditionsBase.sol";
  5 |     | 
  6 |     | contract PostconditionsSiloFacet is PostconditionsBase {
  7 |     | 
  8 | *   |     function _siloFacetPostCondition(bool success, bytes memory returnData, address[] memory actorsToUpdate) internal {
  9 |     | 
 10 | *   |         if (success) {
 11 | *   |             _after(actorsToUpdate);
 12 |     | 
 13 | *   |             onSuccessInvariantsGeneral(returnData);
 14 |     |         } else {
 15 | *   |             onFailInvariantsGeneral(returnData);
 16 |     |         }
 17 |     | 
 18 |     |     }
 19 |     | 
 20 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/preconditions/PreconditionsBase.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../BeforeAfter.sol";
   5 |     | 
   6 |     | contract PreconditionsBase is BeforeAfter {
   7 |     |     event LogAddress(address actor);
   8 |     | 
   9 |     |     modifier setCurrentActor() {
  10 | *   |         if (_setActor) {
  11 | *   |             uint256 fuzzNumber = generateFuzzNumber(iteration, SEED);
  12 | *   |             console.log("fuzz iteration", iteration);
  13 | *   |             currentActor = USERS[uint256(keccak256(abi.encodePacked(iteration * PRIME + SEED))) % (USERS.length)];
  14 |     | 
  15 | *   |             iteration += 1;
  16 |     | 
  17 |     |             // vm.startPrank(currentActor);
  18 | *   |             console.log("Pranking: ", toString(currentActor)); //echidna logs output
  19 | *   |             console.log("Block timestamp: ", block.timestamp);
  20 |     |             //check state and revert workaround
  21 | *   |             if (block.timestamp < lastTimestamp) {
  22 |     |                 vm.warp(lastTimestamp);
  23 |     |             } else {
  24 | *   |                 lastTimestamp = block.timestamp;
  25 |     |             }
  26 |     |         }
  27 | *   |         emit LogAddress(currentActor);
  28 |     |         _;
  29 |     |         // vm.stopPrank();
  30 |     |         // console.log("Stopped prank: ", toString(msg.sender));
  31 |     |     }
  32 |     | 
  33 |     |     function setActor(address targetUser) internal {
  34 |     |         address[] memory targetArray = USERS; //use several arrays
  35 |     |         require(targetArray.length > 0, "Target array is empty");
  36 |     | 
  37 |     |         // Find target user index
  38 |     |         uint256 targetIndex;
  39 |     |         bool found = false;
  40 |     |         for (uint256 i = 0; i < targetArray.length; i++) {
  41 |     |             if (targetArray[i] == targetUser) {
  42 |     |                 targetIndex = i;
  43 |     |                 console.log("Setting user", targetUser);
  44 |     |                 console.log("Index", i);
  45 |     | 
  46 |     |                 found = true;
  47 |     |                 break;
  48 |     |             }
  49 |     |         }
  50 |     | 
  51 |     |         require(found, "Target user not found in array");
  52 |     | 
  53 |     |         uint256 maxIterations = 100000; //  prevent infinite loops
  54 |     |         uint256 currentIteration = iteration;
  55 |     |         bool iterationFound = false;
  56 |     | 
  57 |     |         for (uint256 i = 0; i < maxIterations; i++) {
  58 |     |             uint256 hash = uint256(keccak256(abi.encodePacked(currentIteration * PRIME + SEED)));
  59 |     |             uint256 index = hash % targetArray.length;
  60 |     | 
  61 |     |             if (index == targetIndex) {
  62 |     |                 iteration = currentIteration;
  63 |     |                 iterationFound = true;
  64 |     |                 break;
  65 |     |             }
  66 |     | 
  67 |     |             currentIteration++;
  68 |     |         }
  69 |     | 
  70 |     |         require(iterationFound, "User index not found by setter");
  71 |     |     }
  72 |     | 
  73 | *   |     function generateFuzzNumber(uint256 iteration, uint256 seed) internal pure returns (uint256) {
  74 | *   |         return uint256(keccak256(abi.encodePacked(iteration * PRIME + seed)));
  75 |     |     }
  76 |     | 
  77 | *   |     function toString(address value) internal pure returns (string memory str) {
  78 | *   |         bytes memory s = new bytes(40);
  79 | *   |         for (uint256 i = 0; i < 20; i++) {
  80 | *   |             bytes1 b = bytes1(uint8(uint256(uint160(value)) / (2 ** (8 * (19 - i)))));
  81 | *   |             bytes1 hi = bytes1(uint8(b) / 16);
  82 | *   |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  83 | *   |             s[2 * i] = char(hi);
  84 | *   |             s[2 * i + 1] = char(lo);
  85 |     |         }
  86 | *   |         return string(s);
  87 |     |     }
  88 |     | 
  89 | *   |     function char(bytes1 b) internal pure returns (bytes1 c) {
  90 | *   |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  91 |     |         else return bytes1(uint8(b) + 0x57);
  92 |     |     }
  93 |     | 
  94 | *   |     function _setWellLiquidity() internal {
  95 | *   |         vm.prank(currentActor);
  96 | *   |         beanToken.approve(address(diamond), type(uint256).max);
  97 |     | 
  98 |     |         // add liquidity to both wells
  99 | *   |         _addLiquidityToWell(address(beanEthWell), 10000e6, 10 ether); //@TODO consider changing these values
 100 | *   |         _addLiquidityToWell(address(beanWstEthWell), 10000e6, 10 ether);
 101 |     |     }
 102 |     | 
 103 |     |     // helper function to LP well
 104 | *   |     function _addLiquidityToWell(address _well, uint256 _beanAmount, uint256 _token2Amount) internal {
 105 |     | 
 106 | *   |         (bool success, bytes memory returnData) = address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getNonBeanTokenAndIndexFromWell.selector, _well));
 107 |     |         
 108 | *   |         if (!success) {
 109 |     |             revert(); //@TODO add better error handeling
 110 |     |         }
 111 |     | 
 112 | *   |         (address token2, ) = abi.decode(returnData, (address, uint256));
 113 |     |         
 114 | *   |         vm.prank(ADMIN);
 115 | *   |         beanToken.mint(_well, _beanAmount);
 116 | *   |         vm.prank(ADMIN);
 117 | *   |         MockToken(token2).mint(_well, _token2Amount);
 118 |     | 
 119 | *   |         IWell(_well).sync(currentActor, 0);
 120 |     | 
 121 |     |         // sync again to update reserves.
 122 | *   |         IWell(_well).sync(currentActor, 0);
 123 |     |     }
 124 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/preconditions/farm/PreconditionsDepotFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../PreconditionsBase.sol";
  5 |     | 
  6 |     | contract PreconditionsDepotFacet is PreconditionsBase {
  7 |     | 
  8 |     |     
  9 |     | 
 10 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/preconditions/silo/PreconditionsApprovalFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../PreconditionsBase.sol";
  5 |     | import "../../../properties/Properties.sol";
  6 |     | 
  7 |     | contract PreconditionsApprovalFacet is PreconditionsBase, Properties {
  8 |     | 
  9 |     |     // deposit into silo
 10 |     |     function _depositSilo(uint256 _tokenAmount, address _currentActor) internal returns (uint256 amount) {
 11 |     | 
 12 |     |         // mint user tokens
 13 |     |         vm.prank(ADMIN);
 14 |     |         beanToken.mint(_currentActor, _tokenAmount);
 15 |     | 
 16 |     |         // first deposit
 17 |     |         (bool success, bytes memory returnData) = _depositCall(address(beanToken), _tokenAmount, LibTransfer.From(0));
 18 |     |         if (!success) {
 19 |     |             revert(); //@TODO better error handeling
 20 |     |         }
 21 |     | 
 22 |     |         (amount, , ) = abi.decode(returnData, (uint256, uint256, int96));
 23 |     | 
 24 |     |         return amount;
 25 |     |     }
 26 |     | 
 27 |     | 
 28 |     | 
 29 |     | }
 30 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/helpers/preconditions/silo/PreconditionsSiloFacet.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../PreconditionsBase.sol";
  5 |     | import "../../../properties/Properties.sol";
  6 |     | 
  7 |     | contract PreconditionsSiloFacet is PreconditionsBase, Properties {
  8 |     | 
  9 | *   |     function _doubleDeposit(MockToken _token, uint256 _tokenAmount1, uint256 _tokenAmount2) internal returns(int96[] memory stems, uint256[] memory amounts) {
 10 | *   |         stems = new int96[](2);
 11 | *   |         amounts = new uint256[](2);
 12 |     | 
 13 | *   |         uint256 _mode = 0;
 14 |     | 
 15 |     |         // first deposit
 16 | *   |         (bool success, bytes memory returnData) = _depositCall(address(_token), _tokenAmount1, LibTransfer.From(_mode));
 17 | *   |         if (!success) {
 18 |     |             revert(); //@TODO better error handeling
 19 |     |         }
 20 | *   |         (uint256 amount, , int96 stem) = abi.decode(returnData, (uint256, uint256, int96));
 21 |     | 
 22 | *   |         stems[0] = stem;
 23 | *   |         amounts[0] = amount;
 24 |     | 
 25 |     |         // second deposit
 26 | *   |         (success, returnData) = _depositCall(address(_token), _tokenAmount2, LibTransfer.From(_mode));
 27 | *   |         if (!success) {
 28 |     |             revert(); //@TODO better error handeling
 29 |     |         }
 30 | *   |         (amount, ,stem) = abi.decode(returnData, (uint256, uint256, int96));
 31 |     | 
 32 | *   |         stems[1] = stem;
 33 | *   |         amounts[1] = amount;
 34 |     |     }
 35 |     | 
 36 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/interfaces/ICP2.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface ICP2 {
  5 |     |     
  6 |     |     function getAmountOut(
  7 |     |         uint256 amountIn,
  8 |     |         uint256 reserveIn,
  9 |     |         uint256 reserveOut
 10 |     |     ) external pure returns (uint256 amountOut);
 11 |     | 
 12 |     |     function getAmountIn(
 13 |     |         uint256 amountOut,
 14 |     |         uint256 reserveIn,
 15 |     |         uint256 reserveOut
 16 |     |     ) external pure returns (uint256 amountIn);
 17 |     | 
 18 |     |     function getAmountsOut(
 19 |     |         uint256 amountIn,
 20 |     |         address[] calldata path,
 21 |     |         uint256[] calldata reserves
 22 |     |     ) external pure returns (uint256[] memory amounts);
 23 |     | 
 24 |     |     function getAmountsIn(
 25 |     |         uint256 amountOut,
 26 |     |         address[] calldata path,
 27 |     |         uint256[] calldata reserves
 28 |     |     ) external pure returns (uint256[] memory amounts);
 29 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/interfaces/IMultiFlowPump.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IMultiFlowPump {
  5 |     |     
  6 |     |     function initialize(
  7 |     |         uint256 maxIncrease,
  8 |     |         uint256 maxDecrease,
  9 |     |         uint256 capInterval,
 10 |     |         uint256 alpha
 11 |     |     ) external;
 12 |     | 
 13 |     |     function update(uint256[] calldata reserves) external;
 14 |     | 
 15 |     |     function getFlowRate() external view returns (uint256 flowRate);
 16 |     | 
 17 |     |     function getLastUpdate() external view returns (uint256 lastUpdate);
 18 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/interfaces/IWellImpl.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IWellImpl {
  5 |     |     function tokens() external view returns (address[] memory);
  6 |     | 
  7 |     |     function getReserves() external view returns (uint256[] memory);
  8 |     | 
  9 |     |     function addLiquidity(uint256[] calldata amounts, address recipient) external returns (uint256 lpTokensMinted);
 10 |     | 
 11 |     |     function removeLiquidity(uint256 lpAmount, address recipient) external returns (uint256[] memory amounts);
 12 |     | 
 13 |     |     function swapFrom(address tokenIn, address tokenOut, uint256 amountIn, address recipient) external returns (uint256 amountOut);
 14 |     | 
 15 |     |     function wellFunction() external view returns (address);
 16 |     | 
 17 |     |     function pumps() external view returns (address[] memory);
 18 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/mocks/MockInitDiamondFuzz.sol
  1 |     | /*
  2 |     |  SPDX-License-Identifier: MIT
  3 |     | */
  4 |     | 
  5 |     | pragma solidity ^0.8.20;
  6 |     | 
  7 |     | import {AppStorage} from "contracts/beanstalk/storage/AppStorage.sol";
  8 |     | import {AssetSettings} from "contracts/beanstalk/storage/System.sol";
  9 |     | import "contracts/beanstalk/init/InitalizeDiamond.sol";
 10 |     | import {LibWhitelistedTokens} from "contracts/libraries/Silo/LibWhitelistedTokens.sol";
 11 |     | import {LibWhitelist} from "contracts/libraries/Silo/LibWhitelist.sol";
 12 |     | import {BDVFacet} from "contracts/beanstalk/facets/silo/BDVFacet.sol";
 13 |     | 
 14 |     | import "forge-std/console.sol";
 15 |     | 
 16 |     | /**
 17 |     |  * @title MockInitDiamond
 18 |     |  * @notice MockInitDiamond initializes the Beanstalk Diamond.
 19 |     |  * @dev MockInitDiamond additionally:
 20 |     |  * - Whitelists the bean:wsteth well.
 21 |     |  **/
 22 | *   | contract MockInitDiamondFuzz is InitalizeDiamond {
 23 |     |     // min 1micro stalk earned per season due to germination.
 24 | *   |     uint32 internal constant INIT_BEAN_WSTETH_WELL_STALK_EARNED_PER_SEASON = 4e6;
 25 | *   |     uint128 internal constant INIT_TOKEN_POINTS = 100e18;
 26 | *   |     uint32 internal constant INIT_BEAN_PERCENT_TARGET = 50e6;
 27 |     | 
 28 |     |     // Tokens
 29 |     |     // address internal BEAN = address(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab);
 30 |     |     address internal BEAN_ETH_WELL;
 31 |     |     address internal BEAN_WSTETH_WELL;
 32 |     | 
 33 | *   |     function init(address bean_eth_well, address bean_wsteth_well) external {
 34 | *   |         BEAN_ETH_WELL = bean_eth_well;
 35 | *   |         BEAN_WSTETH_WELL = bean_wsteth_well;
 36 |     | 
 37 | *   |         address BEAN = address(0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab);
 38 |     | 
 39 |     |         
 40 |     |         // initalize the default state of the diamond.
 41 |     |         // {see. InitalizeDiamond.initalizeDiamond()}
 42 | *   |         initalizeDiamond(BEAN, BEAN_ETH_WELL);
 43 |     | 
 44 |     |         // Whitelist the LP well.
 45 | *   |         whitelistLPWell(BEAN_WSTETH_WELL);
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @notice Whitelist a well LP token.
 50 |     |      */
 51 | *   |     function whitelistLPWell(address well) internal {
 52 |     |         // note: no error checking:
 53 | *   |         s.sys.silo.assetSettings[well] = AssetSettings({
 54 | *   |             selector: BDVFacet.wellBdv.selector,
 55 |     |             stalkEarnedPerSeason: INIT_BEAN_WSTETH_WELL_STALK_EARNED_PER_SEASON,
 56 |     |             stalkIssuedPerBdv: INIT_STALK_ISSUED_PER_BDV,
 57 | *   |             milestoneSeason: s.sys.season.current,
 58 | *   |             milestoneStem: 0,
 59 | *   |             encodeType: 0x01,
 60 | *   |             deltaStalkEarnedPerSeason: 0,
 61 |     |             gaugePoints: INIT_TOKEN_POINTS,
 62 |     |             optimalPercentDepositedBdv: INIT_BEAN_PERCENT_TARGET,
 63 | *   |             gaugePointImplementation: Implementation(
 64 | *   |                 address(0),
 65 | *   |                 IGaugeFacet.defaultGaugePoints.selector,
 66 | *   |                 bytes1(0),
 67 | *   |                 new bytes(0)
 68 |     |             ),
 69 | *   |             liquidityWeightImplementation: Implementation(
 70 | *   |                 address(0),
 71 | *   |                 ILiquidityWeightFacet.maxWeight.selector,
 72 | *   |                 bytes1(0),
 73 | *   |                 new bytes(0)
 74 |     |             )
 75 |     |         });
 76 |     | 
 77 |     |         // updates the optimal percent deposited for bean:eth.
 78 | *   |         LibWhitelist.updateOptimalPercentDepositedBdvForToken(
 79 | *   |             BEAN_ETH_WELL,
 80 | *   |             INIT_BEAN_TOKEN_WELL_PERCENT_TARGET - INIT_BEAN_PERCENT_TARGET
 81 |     |         );
 82 |     | 
 83 |     |         // update whitelist status.
 84 | *   |         LibWhitelistedTokens.addWhitelistStatus(
 85 | *   |             well,
 86 | *   |             true, // is whitelisted,
 87 | *   |             true, // is LP
 88 | *   |             true, // is well
 89 | *   |             true // is soppable
 90 |     |         );
 91 |     | 
 92 | *   |         s.sys.usdTokenPrice[well] = 1;
 93 | *   |         s.sys.twaReserves[well].reserve0 = 1;
 94 | *   |         s.sys.twaReserves[well].reserve1 = 1;
 95 |     |     }
 96 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/properties/Properties.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./Properties_ERR.sol";
  5 |     | 
  6 |     | contract Properties is Properties_ERR {
  7 |     |     // ==============================================================
  8 |     |     // Global Properties (GLOB)
  9 |     |     // ==============================================================
 10 |     | 
 11 |     |     function invariant_GLOB_01() internal view returns (bool) {
 12 |     |         return true;
 13 |     |     }
 14 |     | 
 15 |     |     // ==============================================================
 16 |     |     // Invariant Properties (INV)
 17 |     |     // ==============================================================
 18 |     | 
 19 |     |     function invariant_INV_01() internal view returns (bool) {
 20 |     |         return true;
 21 |     |     }
 22 |     | 
 23 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/properties/PropertiesBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
  5 |     | import "@perimetersec/fuzzlib/src/FuzzLibString.sol";
  6 |     | 
  7 |     | 
  8 |     | import "./PropertiesDescriptions.sol";
  9 |     | import "../helpers/BeforeAfter.sol";
 10 |     | import "../utils/FuzzConstants.sol";
 11 |     | 
 12 |     | import {stdMath} from "forge-std/StdMath.sol";
 13 |     | 
 14 |     | contract PropertiesBase is PropertiesDescriptions, BeforeAfter, FuzzConstants {
 15 |     |     // ==============================================================
 16 |     |     // Helpers
 17 |     |     // ==============================================================
 18 |     | 
 19 |     |     function assertApproxEq(uint256 a, uint256 b, uint256 maxDelta, string memory reason) internal {
 20 |     |         uint256 dt;
 21 |     |         if (a >= b) dt = a - b;
 22 |     |         else dt = b - a;
 23 |     |         if (dt > maxDelta) {
 24 |     |             bytes memory aBytes = abi.encodePacked(a);
 25 |     |             bytes memory bBytes = abi.encodePacked(b);
 26 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
 27 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
 28 |     |             fl.log("Error: a =~ b not satisfied [uint]");
 29 |     |             fl.log("   Value a", a);
 30 |     |             fl.log("   Value b", b);
 31 |     |             fl.log(" Max Delta", maxDelta);
 32 |     |             fl.log("     Delta", dt);
 33 |     |             fl.t(false, reason);
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function assertApproxEq(int256 a, int256 b, int256 maxDelta, string memory reason) internal {
 38 |     |         int256 dt;
 39 |     |         if (a >= b) dt = a - b;
 40 |     |         else dt = b - a;
 41 |     |         if (dt > maxDelta) {
 42 |     |             bytes memory aBytes = abi.encodePacked(a);
 43 |     |             bytes memory bBytes = abi.encodePacked(b);
 44 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
 45 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
 46 |     |             fl.log("Error: a =~ b not satisfied [uint]");
 47 |     |             fl.log("   Value a", a);
 48 |     |             fl.log("   Value b", b);
 49 |     |             fl.log(" Max Delta", maxDelta);
 50 |     |             fl.log("     Delta", dt);
 51 |     |             fl.t(false, reason);
 52 |     |         }
 53 |     |     }
 54 |     | 
 55 |     |     function greaterThanOrEqualWithToleranceWei(uint256 a, uint256 b, uint256 maxWeiDiff, string memory reason)
 56 |     |         internal
 57 |     |     {
 58 |     |         if (a >= b) {
 59 |     |             fl.t(true, "Invariant ok, checked for: ");
 60 |     |             fl.log(reason);
 61 |     |             fl.log("a is greater than or equal to b");
 62 |     |             return;
 63 |     |         }
 64 |     | 
 65 |     |         uint256 diff = b - a;
 66 |     | 
 67 |     |         if (diff > maxWeiDiff) {
 68 |     |             fl.log("a: ", a);
 69 |     |             fl.log("b: ", b);
 70 |     |             fl.log("Difference in wei is bigger than expected", diff);
 71 |     |             fl.t(false, reason);
 72 |     |         } else {
 73 |     |             fl.t(true, "Invariant ok, checked for: ");
 74 |     |             fl.log(reason);
 75 |     |             fl.log("Difference in wei: ", diff);
 76 |     |         }
 77 |     |     }
 78 |     | 
 79 |     |     function isApproxEqRel(uint256 a, uint256 b, uint256 maxDelta, string memory reason) internal returns (bool) {
 80 |     |         a < b ? b = a : a = b;
 81 |     |         uint256 delta = stdMath.percentDelta(a, b);
 82 |     |         fl.log("a: ", a);
 83 |     |         fl.log("b: ", b);
 84 |     |         fl.log("Difference % is bigger than expected", delta);
 85 |     |         if (delta > maxDelta) fl.t(false, reason);
 86 |     |     }
 87 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/properties/PropertiesDescriptions.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | // @TODO fill these out
  5 |     | contract PropertiesDescriptions {
  6 |     |     // ==============================================================
  7 |     |     // Global Properties (GLOB)
  8 |     |     // These properties define invariants that must hold true across all market states and operations
  9 |     |     // ==============================================================
 10 |     | 
 11 |     |     string constant GLOB_01 = "GLOB_01: Sample Global Invariant";
 12 |     | 
 13 |     |     // ==============================================================
 14 |     |     // Invariant Properties (INV)
 15 |     |     // These properties define invariants that must hold true as a sample
 16 |     |     // ==============================================================
 17 |     | 
 18 |     |     string constant INV_01 = "INV_01: Sample Invariant";
 19 |     | 
 20 |     |     string constant ERR_01 = "ERR_01: Unexpected Error";
 21 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/properties/Properties_ERR.sol
  1 |     | //SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./RevertHandler.sol";
  5 |     | 
  6 |     | abstract contract Properties_ERR is RevertHandler {
  7 |     |     /*
  8 |     |     *
  9 |     |     * FUZZ NOTE: CHECK REVERTS CONFIGURATION IN FUZZ STORAGE VARIABLES
 10 |     |     *
 11 |     |     */
 12 |     | 
 13 |     |     function _getAllowedPanicCodes() internal pure virtual override returns (uint256[] memory) {
 14 |     |         uint256[] memory panicCodes = new uint256[](4);
 15 |     |         panicCodes[0] = PANIC_ENUM_OUT_OF_BOUNDS;
 16 |     |         panicCodes[1] = PANIC_POP_EMPTY_ARRAY;
 17 |     |         panicCodes[2] = PANIC_ARRAY_OUT_OF_BOUNDS;
 18 |     |         panicCodes[3] = PANIC_ARITHMETIC;
 19 |     | 
 20 |     |         // @TODO Add additional codes
 21 |     |         return panicCodes;
 22 |     |     }
 23 |     | 
 24 |     |     // Add additional errors here
 25 |     |     // Example:
 26 |     |     // Deposit errors [0-5]
 27 |     |     // allowedErrors[0] = IUsdnProtocolErrors.UsdnProtocolEmptyVault.selector;
 28 |     |     // allowedErrors[1] = IUsdnProtocolErrors
 29 |     |     //     .UsdnProtocolDepositTooSmall
 30 |     |     //     .selector;
 31 |     | 
 32 |     |     function _getAllowedCustomErrors() internal pure virtual override returns (bytes4[] memory) {
 33 |     |         bytes4[] memory allowedErrors = new bytes4[](1);
 34 |     |         // allowedErrors[0] = bytes4(abi.encode(""));
 35 |     |         return allowedErrors;
 36 |     |     }
 37 |     | 
 38 | *   |     function _isAllowedERC20Error(bytes memory returnData) internal pure virtual override returns (bool) {
 39 | *   |         bytes[] memory allowedErrors = new bytes[](9);
 40 | *   |         allowedErrors[0] = INSUFFICIENT_ALLOWANCE;
 41 | *   |         allowedErrors[1] = TRANSFER_FROM_ZERO;
 42 | *   |         allowedErrors[2] = TRANSFER_TO_ZERO;
 43 | *   |         allowedErrors[3] = APPROVE_TO_ZERO;
 44 | *   |         allowedErrors[4] = MINT_TO_ZERO;
 45 | *   |         allowedErrors[5] = BURN_FROM_ZERO;
 46 | *   |         allowedErrors[6] = DECREASED_ALLOWANCE;
 47 | *   |         allowedErrors[7] = BURN_EXCEEDS_BALANCE;
 48 | *   |         allowedErrors[8] = EXCEEDS_BALANCE_ERROR;
 49 |     | 
 50 | *   |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 51 | *   |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
 52 |     |                 return true;
 53 |     |             }
 54 |     |         }
 55 | *   |         return false;
 56 |     |     }
 57 |     | 
 58 |     |     function _getAllowedSoladyERC20Error() internal pure virtual override returns (bytes4[] memory) {
 59 |     |         bytes4[] memory allowedErrors = new bytes4[](7);
 60 |     |         allowedErrors[0] = SafeTransferLib.ETHTransferFailed.selector;
 61 |     |         allowedErrors[1] = SafeTransferLib.TransferFromFailed.selector;
 62 |     |         allowedErrors[2] = SafeTransferLib.TransferFailed.selector;
 63 |     |         allowedErrors[3] = SafeTransferLib.ApproveFailed.selector;
 64 |     |         allowedErrors[4] = SafeTransferLib.Permit2Failed.selector;
 65 |     |         allowedErrors[5] = SafeTransferLib.Permit2AmountOverflow.selector;
 66 |     |         allowedErrors[6] = bytes4(0x82b42900); //unauthorized selector
 67 |     | 
 68 |     |         return allowedErrors;
 69 |     |     }
 70 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/properties/RevertHandler.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./PropertiesBase.sol";
   5 |     | import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
   6 |     | 
   7 |     | abstract contract RevertHandler is PropertiesBase {
   8 | *   |     function invariant_ERR(bytes memory returnData) internal {
   9 |     |         // Handle empty reverts
  10 | *   |         if (returnData.length == 0) {
  11 |     |             if (CATCH_EMPTY_REVERTS) {
  12 |     |                 fl.t(false, "Empty revert data not allowed");
  13 |     |             } else {
  14 |     |                 fl.t(true, "Revert data is empty, allowed by config");
  15 |     |             }
  16 |     | 
  17 |     |             return;
  18 |     |         }
  19 |     | 
  20 | *   |         bytes4 returnedError;
  21 |     |         assembly {
  22 | *   |             returnedError := mload(add(returnData, 0x20))
  23 |     |         }
  24 |     | 
  25 |     |         // Handle Panic errors
  26 | *   |         if (returnedError == bytes4(keccak256("Panic(uint256)"))) {
  27 |     |             _handlePanic(returnData);
  28 |     |             return;
  29 |     |         }
  30 |     | 
  31 |     |         // Handle Error(string) errors
  32 | *   |         if (returnedError == bytes4(keccak256("Error(string)"))) {
  33 | *   |             _handleError(returnData);
  34 |     |             return;
  35 |     |         }
  36 |     | 
  37 |     |         // Handle custom protocol errors
  38 |     |         _handleCustomError(returnData);
  39 |     |     }
  40 |     | 
  41 |     |     function _getAllowedPanicCodes() internal pure virtual returns (uint256[] memory) {
  42 |     |         uint256[] memory panicCodes = new uint256[](3);
  43 |     |         panicCodes[0] = PANIC_ENUM_OUT_OF_BOUNDS;
  44 |     |         panicCodes[1] = PANIC_POP_EMPTY_ARRAY;
  45 |     |         panicCodes[2] = PANIC_ARRAY_OUT_OF_BOUNDS;
  46 |     |         return panicCodes;
  47 |     |     }
  48 |     | 
  49 |     |     function _getAllowedCustomErrors() internal pure virtual returns (bytes4[] memory) {
  50 |     |         bytes4[] memory allowedErrors = new bytes4[](1);
  51 |     |         // Uncomment to allow empty reverts:
  52 |     |         // allowedErrors[0] = bytes4(abi.encode(""));
  53 |     |         return allowedErrors;
  54 |     |     }
  55 |     | 
  56 |     |     function _handleSoladyError(bytes memory returnData) private {
  57 |     |         bytes4 returnedError;
  58 |     |         assembly {
  59 |     |             returnedError := mload(add(returnData, 0x20))
  60 |     |         }
  61 |     | 
  62 |     |         fl.errAllow(returnedError, _getAllowedSoladyERC20Error(), ERR_01);
  63 |     |     }
  64 |     | 
  65 |     |     function _getAllowedSoladyERC20Error() internal pure virtual returns (bytes4[] memory) {
  66 |     |         bytes4[] memory allowedErrors = new bytes4[](7);
  67 |     |         allowedErrors[0] = SafeTransferLib.ETHTransferFailed.selector;
  68 |     |         allowedErrors[1] = SafeTransferLib.TransferFromFailed.selector;
  69 |     |         allowedErrors[2] = SafeTransferLib.TransferFailed.selector;
  70 |     |         allowedErrors[3] = SafeTransferLib.ApproveFailed.selector;
  71 |     |         allowedErrors[4] = SafeTransferLib.Permit2Failed.selector;
  72 |     |         allowedErrors[5] = SafeTransferLib.Permit2AmountOverflow.selector;
  73 |     |         allowedErrors[6] = bytes4(0x82b42900); //unauthorized selector
  74 |     | 
  75 |     |         return allowedErrors;
  76 |     |     }
  77 |     | 
  78 |     |     function _isAllowedERC20Error(bytes memory returnData) internal pure virtual returns (bool) {
  79 |     |         bytes[] memory allowedErrors = new bytes[](9);
  80 |     |         allowedErrors[0] = INSUFFICIENT_ALLOWANCE;
  81 |     |         allowedErrors[1] = TRANSFER_FROM_ZERO;
  82 |     |         allowedErrors[2] = TRANSFER_TO_ZERO;
  83 |     |         allowedErrors[3] = APPROVE_TO_ZERO;
  84 |     |         allowedErrors[4] = MINT_TO_ZERO;
  85 |     |         allowedErrors[5] = BURN_FROM_ZERO;
  86 |     |         allowedErrors[6] = DECREASED_ALLOWANCE;
  87 |     |         allowedErrors[7] = BURN_EXCEEDS_BALANCE;
  88 |     |         allowedErrors[8] = EXCEEDS_BALANCE_ERROR;
  89 |     | 
  90 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
  91 |     |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
  92 |     |                 return true;
  93 |     |             }
  94 |     |         }
  95 |     |         return false;
  96 |     |     }
  97 |     | 
  98 | *   |     function _isAllowedFoundryERC20Error(bytes memory returnData) internal virtual returns (bool) {
  99 | *   |         bytes memory ADDITION_OVERFLOW =
 100 | *   |             abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: addition overflow");
 101 |     | 
 102 | *   |         bytes[] memory allowedErrors = new bytes[](1);
 103 | *   |         allowedErrors[0] = ADDITION_OVERFLOW;
 104 |     | 
 105 | *   |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 106 | *   |             if (keccak256(returnData) == keccak256(allowedErrors[i])) {
 107 |     |                 return true;
 108 |     |             }
 109 |     |         }
 110 | *   |         return false;
 111 |     |     }
 112 |     | 
 113 |     |     function _handlePanic(bytes memory returnData) private {
 114 |     |         uint256 panicCode = _extractPanicCode(returnData);
 115 |     |         uint256[] memory allowedCodes = _getAllowedPanicCodes();
 116 |     |         bool isAllowed = false;
 117 |     | 
 118 |     |         for (uint256 i = 0; i < allowedCodes.length; i++) {
 119 |     |             if (panicCode == allowedCodes[i]) {
 120 |     |                 isAllowed = true;
 121 |     |                 break;
 122 |     |             }
 123 |     |         }
 124 |     | 
 125 |     |         fl.log("Panic code", bytes32(panicCode));
 126 |     |         if (!isAllowed) {
 127 |     |             fl.t(false, "Disallowed Panic code encountered!");
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 | *   |     function _handleError(bytes memory returnData) private {
 132 | *   |         string memory revertMsg = _extractRevertMessage(returnData);
 133 | *   |         fl.log("Error(string) revert returnData: ", revertMsg);
 134 |     | 
 135 | *   |         if (_isAllowedERC20Error(returnData)) {
 136 |     |             fl.log("ERC20 error encountered", revertMsg);
 137 |     |             return;
 138 |     |         }
 139 |     | 
 140 | *   |         if (_isAllowedFoundryERC20Error(returnData)) {
 141 |     |             fl.log("Foundry MockERC20 error encountered", revertMsg);
 142 |     |             return;
 143 |     |         }
 144 |     | 
 145 | *   |         if (CATCH_REQUIRE_REVERT) {
 146 | *r  |             fl.t(false, revertMsg);
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     function _handleCustomError(bytes memory returnData) private {
 151 |     |         bytes4 returnedError;
 152 |     |         assembly {
 153 |     |             returnedError := mload(add(returnData, 0x20))
 154 |     |         }
 155 |     | 
 156 |     |         fl.log("Custom protocol error returnData: ", _extractRevertMessage(returnData));
 157 |     |         fl.errAllow(returnedError, _getAllowedCustomErrors(), ERR_01);
 158 |     |     }
 159 |     | 
 160 |     |     function _extractPanicCode(bytes memory revertData) private returns (uint256) {
 161 |     |         fl.log("REVERT DATA LENGTH", revertData.length);
 162 |     |         if (revertData.length < 36) {
 163 |     |             fl.t(false, "Unexpected revert data length for panic code");
 164 |     |             return 0;
 165 |     |         }
 166 |     | 
 167 |     |         uint256 panicCode;
 168 |     |         assembly {
 169 |     |             panicCode := mload(add(revertData, 36))
 170 |     |         }
 171 |     |         return panicCode;
 172 |     |     }
 173 |     | 
 174 | *   |     function _extractRevertMessage(bytes memory _returnData) private returns (string memory) {
 175 |     |         // If data is too short or not properly formatted, return a default message
 176 | *   |         if (_returnData.length < 4) {
 177 |     |             return "Invalid error data";
 178 |     |         }
 179 |     | 
 180 |     |         // Try-catch block to handle non-decodeable data
 181 | *   |         try this._decodeErrorMessage(_returnData) returns (string memory message) {
 182 | *   |             return message;
 183 |     |         } catch {
 184 |     |             return string(abi.encodePacked("Non-decodeable error: 0x", FuzzLibString.toHexString(_returnData)));
 185 |     |         }
 186 |     |     }
 187 |     | 
 188 |     |     // Helper function to safely decode error messages
 189 | *   |     function _decodeErrorMessage(bytes memory _data) external pure returns (string memory) {
 190 |     |         // Skip the error selector (first 4 bytes)
 191 | *   |         bytes memory strBytes = new bytes(_data.length - 4);
 192 | *   |         for (uint256 i = 4; i < _data.length; i++) {
 193 | *   |             strBytes[i - 4] = _data[i];
 194 |     |         }
 195 | *   |         return abi.decode(strBytes, (string));
 196 |     |     }
 197 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/utils/FunctionCalls.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity ^0.8.0;
    3 |     | 
    4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
    5 |     | import "../helpers/FuzzStorageVariables.sol";
    6 |     | 
    7 |     | contract FunctionCalls is FuzzBase, FuzzStorageVariables {
    8 |     | 
    9 |     |     function _pipeCall(PipeCall calldata _input) internal returns (bool success, bytes memory returnData) {
   10 |     | 
   11 |     |         vm.prank(currentActor);
   12 |     |         (success, returnData) =
   13 |     |             address(diamond).call(abi.encodeWithSelector(DepotFacet.pipe.selector, _input));
   14 |     |     }
   15 |     | 
   16 |     |     function _multiPipeCall(PipeCall[] calldata _input) internal returns (bool success, bytes memory returnData) {
   17 |     | 
   18 |     |         vm.prank(currentActor);
   19 |     |         (success, returnData) =
   20 |     |             address(diamond).call(abi.encodeWithSelector(DepotFacet.multiPipe.selector, _input));
   21 |     |     }
   22 |     | 
   23 |     |     //@TODO look into this being payable
   24 |     |     function _advancedPipeCall(PipeCall[] calldata _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
   25 |     | 
   26 |     |         vm.prank(currentActor);
   27 |     |         (success, returnData) =
   28 |     |             address(diamond).call(abi.encodeWithSelector(DepotFacet.advancedPipe.selector, _input1, _input2));
   29 |     |     }
   30 |     | 
   31 |     | 
   32 |     |     //@TODO look into this being payable
   33 |     |     function _etherPipeCall(PipeCall[] calldata _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
   34 |     | 
   35 |     |         vm.prank(currentActor);
   36 |     |         (success, returnData) =
   37 |     |             address(diamond).call(abi.encodeWithSelector(DepotFacet.etherPipe.selector, _input1, _input2));
   38 |     |     }
   39 |     | 
   40 |     |     function _readPipeCall(PipeCall[] calldata _input1) internal returns (bool success, bytes memory returnData) {
   41 |     | 
   42 |     |         vm.prank(currentActor);
   43 |     |         (success, returnData) =
   44 |     |             address(diamond).call(abi.encodeWithSelector(DepotFacet.readPipe.selector, _input1));
   45 |     |     }
   46 |     | 
   47 |     |     function _farmCall(bytes[] calldata _input) internal returns (bool success, bytes memory returnData) {
   48 |     | 
   49 |     |         vm.prank(currentActor);
   50 |     |         (success, returnData) =
   51 |     |             address(diamond).call(abi.encodeWithSelector(FarmFacet.farm.selector, _input));
   52 |     |     }
   53 |     | 
   54 |     |     function _advancedFarmCall(AdvancedFarmCall[] calldata _input) internal returns (bool success, bytes memory returnData) {
   55 |     | 
   56 |     |         vm.prank(currentActor);
   57 |     |         (success, returnData) =
   58 |     |             address(diamond).call(abi.encodeWithSelector(FarmFacet.advancedFarm.selector, _input));
   59 |     |     }
   60 |     | 
   61 |     |     function _transferTokenCall(IERC20 _input1, address _input2, address _input3, LibTransfer.From _input4, LibTransfer.To _input5) internal returns (bool success, bytes memory returnData) {
   62 |     | 
   63 |     |         vm.prank(currentActor);
   64 |     |         (success, returnData) =
   65 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.transferToken.selector, _input1, _input2, _input3, _input4, _input5));
   66 |     |     }
   67 |     | 
   68 |     |     function _transferInternalTokenFromCall(IERC20 _input1, address _input2, address _input3, uint256 _input4, LibTransfer.To _input5) internal returns (bool success, bytes memory returnData) {
   69 |     | 
   70 |     |         vm.prank(currentActor);
   71 |     |         (success, returnData) =
   72 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.transferInternalTokenFrom.selector, _input1, _input2, _input3, _input4, _input5));
   73 |     |     }
   74 |     | 
   75 |     |     function _approveTokenCall(address _input1, IERC20 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
   76 |     | 
   77 |     |         vm.prank(currentActor);
   78 |     |         (success, returnData) =
   79 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.approveToken.selector, _input1, _input2, _input3));
   80 |     |     }
   81 |     | 
   82 |     | 
   83 |     |     function _increaseTokenAllowanceCall(address _input1, IERC20 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
   84 |     | 
   85 |     |         vm.prank(currentActor);
   86 |     |         (success, returnData) =
   87 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.increaseTokenAllowance.selector, _input1, _input2, _input3));
   88 |     |     }
   89 |     | 
   90 |     |     function _decreaseTokenAllowanceCall(address _input1, IERC20 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
   91 |     | 
   92 |     |         vm.prank(currentActor);
   93 |     |         (success, returnData) =
   94 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.decreaseTokenAllowance.selector, _input1, _input2, _input3));
   95 |     |     }
   96 |     | 
   97 |     |     function _tokenAllowanceCall(address _input1, address _input2, IERC20 _input3) internal returns (bool success, bytes memory returnData) {
   98 |     | 
   99 |     |         vm.prank(currentActor);
  100 |     |         (success, returnData) =
  101 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.tokenAllowance.selector, _input1, _input2, _input3));
  102 |     |     }
  103 |     | 
  104 |     |     function _onERC1155ReceivedCall(address _input1, address _input2, uint256 _input3, uint256 _input4, bytes calldata _input5) internal returns (bool success, bytes memory returnData) {
  105 |     | 
  106 |     |         vm.prank(currentActor);
  107 |     |         (success, returnData) =
  108 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.onERC1155Received.selector, _input1, _input2, _input3, _input4, _input5));
  109 |     |     }
  110 |     | 
  111 |     |     function _onERC1155BatchReceivedCall(address _input1, address _input2, uint256[] calldata _input3, uint256[] calldata _input4, bytes calldata _input5) internal returns (bool success, bytes memory returnData) {
  112 |     | 
  113 |     |         vm.prank(currentActor);
  114 |     |         (success, returnData) =
  115 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.onERC1155BatchReceived.selector, _input1, _input2, _input3, _input4, _input5));
  116 |     |     }
  117 |     | 
  118 |     |     function _wrapEthCall(uint256 _input1, LibTransfer.To _input2) internal returns (bool success, bytes memory returnData) {
  119 |     | 
  120 |     |         vm.prank(currentActor);
  121 |     |         (success, returnData) =
  122 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.wrapEth.selector, _input1, _input2));
  123 |     |     }
  124 |     | 
  125 |     |     function _unwrapEthCall(uint256 _input1, LibTransfer.From _input2) internal returns (bool success, bytes memory returnData) {
  126 |     | 
  127 |     |         vm.prank(currentActor);
  128 |     |         (success, returnData) =
  129 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.unwrapEth.selector, _input1, _input2));
  130 |     |     }
  131 |     | 
  132 |     |     function _getInternalBalanceCall(address _input1, IERC20 _input2) internal returns (bool success, bytes memory returnData) {
  133 |     | 
  134 |     |         vm.prank(currentActor);
  135 |     |         (success, returnData) =
  136 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getInternalBalance.selector, _input1, _input2));
  137 |     |     }
  138 |     | 
  139 |     |     function _getInternalBalancesCall(address _input1, IERC20[] memory _input2) internal returns (bool success, bytes memory returnData) {
  140 |     | 
  141 |     |         vm.prank(currentActor);
  142 |     |         (success, returnData) =
  143 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getInternalBalances.selector, _input1, _input2));
  144 |     |     }
  145 |     | 
  146 |     |     function _getExternalBalanceCall(address _input1, IERC20 _input2) internal returns (bool success, bytes memory returnData) {
  147 |     | 
  148 |     |         vm.prank(currentActor);
  149 |     |         (success, returnData) =
  150 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getExternalBalance.selector, _input1, _input2));
  151 |     |     }
  152 |     | 
  153 |     |     function _getExternalBalancesCall(address _input1, IERC20[] memory _input2) internal returns (bool success, bytes memory returnData) {
  154 |     | 
  155 |     |         vm.prank(currentActor);
  156 |     |         (success, returnData) =
  157 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getExternalBalances.selector, _input1, _input2));
  158 |     |     }
  159 |     | 
  160 |     |     function _getBalanceCall(address _input1, IERC20 _input2) internal returns (bool success, bytes memory returnData) {
  161 |     | 
  162 |     |         vm.prank(currentActor);
  163 |     |         (success, returnData) =
  164 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getBalance.selector, _input1, _input2));
  165 |     |     }
  166 |     | 
  167 |     |     function _getBalancesCall(address _input1, IERC20[] memory _input2) internal returns (bool success, bytes memory returnData) {
  168 |     | 
  169 |     |         vm.prank(currentActor);
  170 |     |         (success, returnData) =
  171 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getBalances.selector, _input1, _input2));
  172 |     |     }
  173 |     | 
  174 |     |     function _getAllBalanceCall(address _input1, IERC20 _input2) internal returns (bool success, bytes memory returnData) {
  175 |     | 
  176 |     |         vm.prank(currentActor);
  177 |     |         (success, returnData) =
  178 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getAllBalance.selector, _input1, _input2));
  179 |     |     }
  180 |     | 
  181 |     |     function _getAllBalancesCall(address _input1, IERC20[] memory _input2) internal returns (bool success, bytes memory returnData) {
  182 |     | 
  183 |     |         vm.prank(currentActor);
  184 |     |         (success, returnData) =
  185 |     |             address(diamond).call(abi.encodeWithSelector(TokenFacet.getAllBalances.selector, _input1, _input2));
  186 |     |     }
  187 |     | 
  188 |     |     function _transferERC721Call(IERC721 _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  189 |     | 
  190 |     |         vm.prank(currentActor);
  191 |     |         (success, returnData) =
  192 |     |             address(diamond).call(abi.encodeWithSelector(TokenSupportFacet.transferERC721.selector, _input1, _input2, _input3));
  193 |     |     }
  194 |     | 
  195 |     |     function _transferERC1155Call(IERC1155 _input1, address _input2, uint256 _input3, uint256 _input4) internal returns (bool success, bytes memory returnData) {
  196 |     | 
  197 |     |         vm.prank(currentActor);
  198 |     |         (success, returnData) =
  199 |     |             address(diamond).call(abi.encodeWithSelector(TokenSupportFacet.transferERC1155.selector, _input1, _input2, _input3, _input4));
  200 |     |     }
  201 |     | 
  202 |     |     function _batchTransferERC1155Call(IERC1155 _input1, address _input2, uint256[] calldata _input3, uint256[] calldata _input4) internal returns (bool success, bytes memory returnData) {
  203 |     | 
  204 |     |         vm.prank(currentActor);
  205 |     |         (success, returnData) =
  206 |     |             address(diamond).call(abi.encodeWithSelector(TokenSupportFacet.batchTransferERC1155.selector, _input1, _input2, _input3, _input4));
  207 |     |     }
  208 |     | 
  209 |     |     function _updateTractorVersionall(string calldata _input) internal returns (bool success, bytes memory returnData) {
  210 |     | 
  211 |     |         vm.prank(currentActor);
  212 |     |         (success, returnData) =
  213 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.updateTractorVersion.selector, _input));
  214 |     |     }
  215 |     | 
  216 |     |     function _getTractorVersionCall() internal returns (bool success, bytes memory returnData) {
  217 |     | 
  218 |     |         vm.prank(currentActor);
  219 |     |         (success, returnData) =
  220 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.getTractorVersion.selector));
  221 |     |     }
  222 |     | 
  223 |     |     function _publishRequisitionCall(LibTractor.Requisition calldata _input) internal returns (bool success, bytes memory returnData) {
  224 |     | 
  225 |     |         vm.prank(currentActor);
  226 |     |         (success, returnData) =
  227 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.publishRequisition.selector, _input));
  228 |     |     }
  229 |     | 
  230 |     |     function _cancelBlueprintCall(LibTractor.Requisition calldata _input) internal returns (bool success, bytes memory returnData) {
  231 |     | 
  232 |     |         vm.prank(currentActor);
  233 |     |         (success, returnData) =
  234 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.cancelBlueprint.selector, _input));
  235 |     |     }
  236 |     | 
  237 |     |     function _tractorCall(LibTractor.Requisition calldata _input1, bytes memory _input2) internal returns (bool success, bytes memory returnData) {
  238 |     | 
  239 |     |         vm.prank(currentActor);
  240 |     |         (success, returnData) =
  241 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.tractor.selector, _input1, _input2));
  242 |     |     }
  243 |     | 
  244 |     |     function _sendTokenToInternalBalanceCall(IERC20 _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  245 |     | 
  246 |     |         vm.prank(currentActor);
  247 |     |         (success, returnData) =
  248 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.sendTokenToInternalBalance.selector, _input1, _input2, _input3));
  249 |     |     }
  250 |     | 
  251 |     |     function _getCounterCall(address _input1, bytes32 _input2) internal returns (bool success, bytes memory returnData) {
  252 |     | 
  253 |     |         vm.prank(currentActor);
  254 |     |         (success, returnData) =
  255 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.getCounter.selector, _input1, _input2));
  256 |     |     }
  257 |     | 
  258 |     |     function _getPublisherCounterCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
  259 |     | 
  260 |     |         vm.prank(currentActor);
  261 |     |         (success, returnData) =
  262 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.getPublisherCounter.selector, _input1));
  263 |     |     }
  264 |     | 
  265 |     |     function _updatePublisherCounterCall(bytes32 _input1, LibTractor.CounterUpdateType _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  266 |     | 
  267 |     |         vm.prank(currentActor);
  268 |     |         (success, returnData) =
  269 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.updatePublisherCounter.selector, _input1, _input2, _input3));
  270 |     |     }
  271 |     | 
  272 |     |     function _getBlueprintNonceCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
  273 |     | 
  274 |     |         vm.prank(currentActor);
  275 |     |         (success, returnData) =
  276 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.getBlueprintNonce.selector, _input1));
  277 |     |     }
  278 |     | 
  279 |     |     function _getBlueprintHashCall(LibTractor.Blueprint calldata _input1) internal returns (bool success, bytes memory returnData) {
  280 |     | 
  281 |     |         vm.prank(currentActor);
  282 |     |         (success, returnData) =
  283 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.getBlueprintHash.selector, _input1));
  284 |     |     }
  285 |     | 
  286 |     |     function _tractorUserCall() internal returns (bool success, bytes memory returnData) {
  287 |     | 
  288 |     |         vm.prank(currentActor);
  289 |     |         (success, returnData) =
  290 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.tractorUser.selector));
  291 |     |     }
  292 |     | 
  293 |     |     function _operatorCall() internal returns (bool success, bytes memory returnData) {
  294 |     | 
  295 |     |         vm.prank(currentActor);
  296 |     |         (success, returnData) =
  297 |     |             address(diamond).call(abi.encodeWithSelector(TractorFacet.operator.selector));
  298 |     |     }
  299 |     | 
  300 |     |     function _sowCall(uint256 _input1, uint256 _input2, LibTransfer.From _input3) internal returns (bool success, bytes memory returnData) {
  301 |     | 
  302 |     |         vm.prank(currentActor);
  303 |     |         (success, returnData) =
  304 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.sow.selector, _input1, _input2, _input3));
  305 |     |     }
  306 |     | 
  307 |     |     function _sowWithMinCall(uint256 _input1, uint256 _input2, uint256 _input3, LibTransfer.From _input4) internal returns (bool success, bytes memory returnData) {
  308 |     | 
  309 |     |         vm.prank(currentActor);
  310 |     |         (success, returnData) =
  311 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.sowWithMin.selector, _input1, _input2, _input3, _input4));
  312 |     |     }
  313 |     | 
  314 |     |     function _harvestCall(uint256 _input1, uint256[] calldata _input2, LibTransfer.To _input3) internal returns (bool success, bytes memory returnData) {
  315 |     | 
  316 |     |         vm.prank(currentActor);
  317 |     |         (success, returnData) =
  318 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.harvest.selector, _input1, _input2, _input3));
  319 |     |     }
  320 |     | 
  321 |     |     function _addFieldCall() internal returns (bool success, bytes memory returnData) {
  322 |     | 
  323 |     |         vm.prank(currentActor);
  324 |     |         (success, returnData) =
  325 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.addField.selector));
  326 |     |     }
  327 |     | 
  328 |     |     function _setActiveFieldCall(uint256 _input1, uint32 _input2) internal returns (bool success, bytes memory returnData) {
  329 |     | 
  330 |     |         vm.prank(currentActor);
  331 |     |         (success, returnData) =
  332 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.setActiveField.selector, _input1, _input2));
  333 |     |     }
  334 |     | 
  335 |     |     function _podIndexCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  336 |     | 
  337 |     |         vm.prank(currentActor);
  338 |     |         (success, returnData) =
  339 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.podIndex.selector, _input1));
  340 |     |     }
  341 |     | 
  342 |     |     function _harvestableIndexCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  343 |     | 
  344 |     |         vm.prank(currentActor);
  345 |     |         (success, returnData) =
  346 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.harvestableIndex.selector, _input1));
  347 |     |     }
  348 |     | 
  349 |     |     function _totalPodsCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  350 |     | 
  351 |     |         vm.prank(currentActor);
  352 |     |         (success, returnData) =
  353 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalPods.selector, _input1));
  354 |     |     }
  355 |     | 
  356 |     |     function _totalHarvestedCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  357 |     | 
  358 |     |         vm.prank(currentActor);
  359 |     |         (success, returnData) =
  360 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalHarvested.selector, _input1));
  361 |     |     }
  362 |     | 
  363 |     |     function _totalHarvestableCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  364 |     | 
  365 |     |         vm.prank(currentActor);
  366 |     |         (success, returnData) =
  367 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalHarvestable.selector, _input1));
  368 |     |     }
  369 |     | 
  370 |     |     function _totalHarvestableForActiveFieldCall() internal returns (bool success, bytes memory returnData) {
  371 |     | 
  372 |     |         vm.prank(currentActor);
  373 |     |         (success, returnData) =
  374 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalHarvestableForActiveField.selector));
  375 |     |     }
  376 |     | 
  377 |     |     function _totalUnharvestableCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  378 |     | 
  379 |     |         vm.prank(currentActor);
  380 |     |         (success, returnData) =
  381 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalUnharvestable.selector, _input1));
  382 |     |     }
  383 |     | 
  384 |     |     function _totalUnharvestableForActiveFieldCall() internal returns (bool success, bytes memory returnData) {
  385 |     | 
  386 |     |         vm.prank(currentActor);
  387 |     |         (success, returnData) =
  388 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalUnharvestableForActiveField.selector));
  389 |     |     }
  390 |     | 
  391 |     |     function _floodHarvestablePodsCall() internal returns (bool success, bytes memory returnData) {
  392 |     | 
  393 |     |         vm.prank(currentActor);
  394 |     |         (success, returnData) =
  395 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.floodHarvestablePods.selector));
  396 |     |     }
  397 |     | 
  398 |     |     function _isHarvestingCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  399 |     | 
  400 |     |         vm.prank(currentActor);
  401 |     |         (success, returnData) =
  402 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.isHarvesting.selector, _input1));
  403 |     |     }
  404 |     | 
  405 |     |     function _plotCall(address _input1, uint256 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  406 |     | 
  407 |     |         vm.prank(currentActor);
  408 |     |         (success, returnData) =
  409 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.plot.selector, _input1, _input2, _input3));
  410 |     |     }
  411 |     | 
  412 |     |     function _activeFieldCall() internal returns (bool success, bytes memory returnData) {
  413 |     | 
  414 |     |         vm.prank(currentActor);
  415 |     |         (success, returnData) =
  416 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.activeField.selector));
  417 |     |     }
  418 |     | 
  419 |     |     function _fieldCountCall() internal returns (bool success, bytes memory returnData) {
  420 |     | 
  421 |     |         vm.prank(currentActor);
  422 |     |         (success, returnData) =
  423 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.fieldCount.selector));
  424 |     |     }
  425 |     | 
  426 |     |     function _totalSoilCall() internal returns (bool success, bytes memory returnData) {
  427 |     | 
  428 |     |         vm.prank(currentActor);
  429 |     |         (success, returnData) =
  430 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.totalSoil.selector));
  431 |     |     }
  432 |     | 
  433 |     |     function _initialSoilCall() internal returns (bool success, bytes memory returnData) {
  434 |     | 
  435 |     |         vm.prank(currentActor);
  436 |     |         (success, returnData) =
  437 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.initialSoil.selector));
  438 |     |     }
  439 |     | 
  440 |     |     function _temperatureCall() internal returns (bool success, bytes memory returnData) {
  441 |     | 
  442 |     |         vm.prank(currentActor);
  443 |     |         (success, returnData) =
  444 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.temperature.selector));
  445 |     |     }
  446 |     | 
  447 |     |     function _remainingPodsCall() internal returns (bool success, bytes memory returnData) {
  448 |     | 
  449 |     |         vm.prank(currentActor);
  450 |     |         (success, returnData) =
  451 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.remainingPods.selector));
  452 |     |     }
  453 |     | 
  454 |     |     function _getPlotIndexesFromAccountCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  455 |     | 
  456 |     |         vm.prank(currentActor);
  457 |     |         (success, returnData) =
  458 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.getPlotIndexesFromAccount.selector, _input1, _input2));
  459 |     |     }
  460 |     | 
  461 |     |     function _getPlotsFromAccountCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  462 |     | 
  463 |     |         vm.prank(currentActor);
  464 |     |         (success, returnData) =
  465 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.getPlotsFromAccount.selector, _input1, _input2));
  466 |     |     }
  467 |     | 
  468 |     |     function _balanceOfPodsCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  469 |     | 
  470 |     |         vm.prank(currentActor);
  471 |     |         (success, returnData) =
  472 |     |             address(diamond).call(abi.encodeWithSelector(FieldFacet.balanceOfPods.selector, _input1, _input2));
  473 |     |     }
  474 |     | 
  475 |     |     function _createPodListingCall(Listing.PodListing calldata _input1) internal returns (bool success, bytes memory returnData) {
  476 |     | 
  477 |     |         vm.prank(currentActor);
  478 |     |         (success, returnData) =
  479 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.createPodListing.selector, _input1));
  480 |     |     }
  481 |     | 
  482 |     |     function _createPodListingCall(Listing.PodListing calldata _input1, uint256 _input2, LibTransfer.From _input3) internal returns (bool success, bytes memory returnData) {
  483 |     | 
  484 |     |         vm.prank(currentActor);
  485 |     |         (success, returnData) =
  486 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.fillPodListing.selector, _input1, _input2, _input3));
  487 |     |     }
  488 |     | 
  489 |     |     function _cancelPodListingCall(uint256 _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  490 |     | 
  491 |     |         vm.prank(currentActor);
  492 |     |         (success, returnData) =
  493 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.cancelPodListing.selector, _input1, _input2));
  494 |     |     }
  495 |     | 
  496 |     |     function _getPodListingCall(uint256 _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  497 |     | 
  498 |     |         vm.prank(currentActor);
  499 |     |         (success, returnData) =
  500 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.getPodListing.selector, _input1, _input2));
  501 |     |     }
  502 |     | 
  503 |     |     function _createPodOrderCall(Order.PodOrder calldata _input1, uint256 _input2, LibTransfer.From _input3) internal returns (bool success, bytes memory returnData) {
  504 |     | 
  505 |     |         vm.prank(currentActor);
  506 |     |         (success, returnData) =
  507 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.createPodOrder.selector, _input1, _input2, _input3));
  508 |     |     }
  509 |     | 
  510 |     |     function _createPodOrderCall(Order.PodOrder calldata _input1, uint256 _input2, uint256 _input3, uint256 _input4, LibTransfer.To _input5) internal returns (bool success, bytes memory returnData) {
  511 |     | 
  512 |     |         vm.prank(currentActor);
  513 |     |         (success, returnData) =
  514 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.createPodOrder.selector, _input1, _input2, _input3, _input4, _input5));
  515 |     |     }
  516 |     | 
  517 |     |     function _cancelPodOrderCall(Order.PodOrder calldata _input1, LibTransfer.To _input2) internal returns (bool success, bytes memory returnData) {
  518 |     | 
  519 |     |         vm.prank(currentActor);
  520 |     |         (success, returnData) =
  521 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.cancelPodOrder.selector, _input1, _input2));
  522 |     |     }
  523 |     | 
  524 |     |     function _getOrderIdCall(Order.PodOrder calldata _input1) internal returns (bool success, bytes memory returnData) {
  525 |     | 
  526 |     |         vm.prank(currentActor);
  527 |     |         (success, returnData) =
  528 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.getOrderId.selector, _input1));
  529 |     |     }
  530 |     | 
  531 |     |     function _getPodOrderCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
  532 |     | 
  533 |     |         vm.prank(currentActor);
  534 |     |         (success, returnData) =
  535 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.getPodOrder.selector, _input1));
  536 |     |     }
  537 |     | 
  538 |     |     function _transferPlotCall(address _input1, address _input2, uint256 _input3, uint256 _input4, uint256 _input5, uint256 _input6) internal returns (bool success, bytes memory returnData) {
  539 |     | 
  540 |     |         vm.prank(currentActor);
  541 |     |         (success, returnData) =
  542 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.transferPlot.selector, _input1, _input2, _input3, _input4, _input5, _input6));
  543 |     |     }
  544 |     | 
  545 |     |     function _transferPlotsCall(address _input1, address _input2, uint256 _input3, uint256[] calldata _input4, uint256[] calldata _input5, uint256[] calldata _input6) internal returns (bool success, bytes memory returnData) {
  546 |     | 
  547 |     |         vm.prank(currentActor);
  548 |     |         (success, returnData) =
  549 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.transferPlots.selector, _input1, _input2, _input3, _input4, _input5, _input6));
  550 |     |     }
  551 |     | 
  552 |     |     function _approvePodsCall(address _input1, uint256 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  553 |     | 
  554 |     |         vm.prank(currentActor);
  555 |     |         (success, returnData) =
  556 |     |             address(diamond).call(abi.encodeWithSelector(MarketplaceFacet.approvePods.selector, _input1, _input2, _input3));
  557 |     |     }
  558 |     | 
  559 |     |     function _uriCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  560 |     | 
  561 |     |         vm.prank(currentActor);
  562 |     |         (success, returnData) =
  563 |     |             address(diamond).call(abi.encodeWithSelector(MetadataFacet.uri.selector, _input1));
  564 |     |     }
  565 |     | 
  566 |     |     function _nameCall() internal returns (bool success, bytes memory returnData) {
  567 |     | 
  568 |     |         vm.prank(currentActor);
  569 |     |         (success, returnData) =
  570 |     |             address(diamond).call(abi.encodeWithSelector(MetadataFacet.uri.selector));
  571 |     |     }
  572 |     | 
  573 |     |     function _symbolCall() internal returns (bool success, bytes memory returnData) {
  574 |     | 
  575 |     |         vm.prank(currentActor);
  576 |     |         (success, returnData) =
  577 |     |             address(diamond).call(abi.encodeWithSelector(MetadataFacet.symbol.selector));
  578 |     |     }
  579 |     | 
  580 |     |     function _approveDepositCall(address _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  581 |     | 
  582 |     |         vm.prank(currentActor);
  583 |     |         (success, returnData) =
  584 |     |             address(diamond).call(abi.encodeWithSelector(ApprovalFacet.approveDeposit.selector, _input1, _input2, _input3));
  585 |     |     }
  586 |     | 
  587 |     |     function _increaseDepositAllowanceCall(address _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  588 |     | 
  589 |     |         vm.prank(currentActor);
  590 |     |         (success, returnData) =
  591 |     |             address(diamond).call(abi.encodeWithSelector(ApprovalFacet.increaseDepositAllowance.selector, _input1, _input2, _input3));
  592 |     |     }
  593 |     | 
  594 |     |     function _decreaseDepositAllowanceCall(address _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  595 |     | 
  596 |     |         vm.prank(currentActor);
  597 |     |         (success, returnData) =
  598 |     |             address(diamond).call(abi.encodeWithSelector(ApprovalFacet.decreaseDepositAllowance.selector, _input1, _input2, _input3));
  599 |     |     }
  600 |     | 
  601 |     |     function _depositAllowanceCall(address _input1, address _input2, address _input3) internal returns (bool success, bytes memory returnData) {
  602 |     | 
  603 |     |         vm.prank(currentActor);
  604 |     |         (success, returnData) =
  605 |     |             address(diamond).call(abi.encodeWithSelector(ApprovalFacet.depositAllowance.selector, _input1, _input2, _input3));
  606 |     |     }
  607 |     | 
  608 |     |     function _setApprovalForAllCall(address _input1, bool _input2) internal returns (bool success, bytes memory returnData) {
  609 |     | 
  610 |     |         vm.prank(currentActor);
  611 |     |         (success, returnData) =
  612 |     |             address(diamond).call(abi.encodeWithSelector(ApprovalFacet.setApprovalForAll.selector, _input1, _input2));
  613 |     |     }
  614 |     | 
  615 |     |     function _isApprovedForAllCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
  616 |     | 
  617 |     |         vm.prank(currentActor);
  618 |     |         (success, returnData) =
  619 |     |             address(diamond).call(abi.encodeWithSelector(ApprovalFacet.isApprovedForAll.selector, _input1, _input2));
  620 |     |     }
  621 |     | 
  622 |     |     function _beanToBDVCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  623 |     | 
  624 |     |         vm.prank(currentActor);
  625 |     |         (success, returnData) =
  626 |     |             address(diamond).call(abi.encodeWithSelector(BDVFacet.beanToBDV.selector, _input1));
  627 |     |     }
  628 |     | 
  629 |     |     function _wellBdvCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  630 |     | 
  631 |     |         vm.prank(currentActor);
  632 |     |         (success, returnData) =
  633 |     |             address(diamond).call(abi.encodeWithSelector(BDVFacet.beanToBDV.selector, _input1, _input2));
  634 |     |     }
  635 |     | 
  636 |     |     function _claimPlentyCall(uint256 _input1, LibTransfer.To _input2) internal returns (bool success, bytes memory returnData) {
  637 |     | 
  638 |     |         vm.prank(currentActor);
  639 |     |         (success, returnData) =
  640 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.claimPlenty.selector, _input1, _input2));
  641 |     |     }
  642 |     | 
  643 |     |     function _claimAllPlentyCall(LibTransfer.To _input1) internal returns (bool success, bytes memory returnData) {
  644 |     | 
  645 |     |         vm.prank(currentActor);
  646 |     |         (success, returnData) =
  647 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.claimAllPlenty.selector, _input1));
  648 |     |     }
  649 |     | 
  650 |     |     function _mowCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
  651 |     | 
  652 |     |         vm.prank(currentActor);
  653 |     |         (success, returnData) =
  654 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.mow.selector, _input1, _input2));
  655 |     |     }
  656 |     | 
  657 |     |     function _mowMultipleCall(address _input1, address[] calldata _input2) internal returns (bool success, bytes memory returnData) {
  658 |     | 
  659 |     |         vm.prank(currentActor);
  660 |     |         (success, returnData) =
  661 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.mowMultiple.selector, _input1, _input2));
  662 |     |     }
  663 |     | 
  664 |     |     function _mowAllCall(address _input1) internal returns (bool success, bytes memory returnData) {
  665 |     | 
  666 |     |         vm.prank(currentActor);
  667 |     |         (success, returnData) =
  668 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.mowAll.selector, _input1));
  669 |     |     }
  670 |     | 
  671 |     |     function _mowMultipleAccountsCall(address[] calldata _input1, address[][] calldata _input2) internal returns (bool success, bytes memory returnData) {
  672 |     | 
  673 |     |         vm.prank(currentActor);
  674 |     |         (success, returnData) =
  675 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.mowMultipleAccounts.selector, _input1, _input2));
  676 |     |     }
  677 |     | 
  678 |     | 
  679 |     |     function _mowMultipleAccountsCall(address[] calldata _input1) internal returns (bool success, bytes memory returnData) {
  680 |     | 
  681 |     |         vm.prank(currentActor);
  682 |     |         (success, returnData) =
  683 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.mowMultipleAccounts.selector, _input1));
  684 |     |     }
  685 |     | 
  686 |     |     function _plantCall() internal returns (bool success, bytes memory returnData) {
  687 |     | 
  688 |     |         vm.prank(currentActor);
  689 |     |         (success, returnData) =
  690 |     |             address(diamond).call(abi.encodeWithSelector(ClaimFacet.plant.selector));
  691 |     |     }
  692 |     | 
  693 |     |     function _convertCall(bytes calldata _input1, int96[] memory _input2, uint256[] memory _input3) internal returns (bool success, bytes memory returnData) {
  694 |     | 
  695 |     |         vm.prank(currentActor);
  696 |     |         (success, returnData) =
  697 |     |             address(diamond).call(abi.encodeWithSelector(ConvertFacet.convert.selector, _input1, _input2, _input3));
  698 |     |     }
  699 |     | 
  700 |     |     function _getMaxAmountInCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
  701 |     | 
  702 |     |         vm.prank(currentActor);
  703 |     |         (success, returnData) =
  704 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.getMaxAmountIn.selector, _input1, _input2));
  705 |     |     }
  706 |     | 
  707 |     |     function _getAmountOutCall(address _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  708 |     | 
  709 |     |         vm.prank(currentActor);
  710 |     |         (success, returnData) =
  711 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.getAmountOut.selector, _input1, _input2, _input3));
  712 |     |     }
  713 |     | 
  714 |     |     function _overallCappedDeltaBCall() internal returns (bool success, bytes memory returnData) {
  715 |     | 
  716 |     |         vm.prank(currentActor);
  717 |     |         (success, returnData) =
  718 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.overallCappedDeltaB.selector));
  719 |     |     }
  720 |     | 
  721 |     |     function _overallCurrentDeltaBCall() internal returns (bool success, bytes memory returnData) {
  722 |     | 
  723 |     |         vm.prank(currentActor);
  724 |     |         (success, returnData) =
  725 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.overallCurrentDeltaB.selector));
  726 |     |     }
  727 |     | 
  728 |     |     function _scaledDeltaBCall(uint256 _input1, uint256 _input2, int256 _input3) internal returns (bool success, bytes memory returnData) {
  729 |     | 
  730 |     |         vm.prank(currentActor);
  731 |     |         (success, returnData) =
  732 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.scaledDeltaB.selector, _input1, _input2, _input3));
  733 |     |     }
  734 |     | 
  735 |     |     function _cappedReservesDeltaBCall(address _input1) internal returns (bool success, bytes memory returnData) {
  736 |     | 
  737 |     |         vm.prank(currentActor);
  738 |     |         (success, returnData) =
  739 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.cappedReservesDeltaB.selector, _input1));
  740 |     |     }
  741 |     | 
  742 |     |     function _calculateDeltaBFromReservesCall(address _input1, uint256[] memory _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  743 |     | 
  744 |     |         vm.prank(currentActor);
  745 |     |         (success, returnData) =
  746 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.calculateDeltaBFromReserves.selector, _input1, _input2, _input3));
  747 |     |     }
  748 |     | 
  749 |     |     function _getOverallConvertCapacityCall() internal returns (bool success, bytes memory returnData) {
  750 |     | 
  751 |     |         vm.prank(currentActor);
  752 |     |         (success, returnData) =
  753 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.getOverallConvertCapacity.selector));
  754 |     |     }
  755 |     | 
  756 |     |     function _getWellConvertCapacityCall(address _input1) internal returns (bool success, bytes memory returnData) {
  757 |     | 
  758 |     |         vm.prank(currentActor);
  759 |     |         (success, returnData) =
  760 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.getWellConvertCapacity.selector, _input1));
  761 |     |     }
  762 |     | 
  763 |     |     function _calculateStalkPenaltyCall(LibConvert.DeltaBStorage memory _input1, uint256 _input2, uint256 _input3, address _input4, address _input5) internal returns (bool success, bytes memory returnData) {
  764 |     | 
  765 |     |         vm.prank(currentActor);
  766 |     |         (success, returnData) =
  767 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.calculateStalkPenalty.selector, _input1, _input2, _input3, _input4, _input5));
  768 |     |     }
  769 |     | 
  770 |     |     function _downPenalizedGrownStalkCall(address _input1, uint256 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
  771 |     | 
  772 |     |         vm.prank(currentActor);
  773 |     |         (success, returnData) =
  774 |     |             address(diamond).call(abi.encodeWithSelector(ConvertGettersFacet.downPenalizedGrownStalk.selector, _input1, _input2, _input3));
  775 |     |     }
  776 |     | 
  777 |     |     function _pipelineConvertCall(address _input1, int96[] calldata _input2, uint256[] calldata _input3, address _input4, AdvancedPipeCall[] memory  _input5) internal returns (bool success, bytes memory returnData) {
  778 |     | 
  779 |     |         vm.prank(currentActor);
  780 |     |         (success, returnData) =
  781 |     |             address(diamond).call(abi.encodeWithSelector(PipelineConvertFacet.pipelineConvert.selector, _input1, _input2, _input3, _input4, _input5));
  782 |     |     }
  783 |     | 
  784 | *   |     function _depositCall(address _input1, uint256 _input2, LibTransfer.From _input3) internal returns (bool success, bytes memory returnData) {
  785 | *   |         vm.prank(currentActor);
  786 | *   |         (success, returnData) =
  787 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.deposit.selector, _input1, _input2, _input3));
  788 |     |     }
  789 |     | 
  790 | *   |     function _withdrawDepositCall(address _input1, int96 _input2, uint256 _input3, LibTransfer.To _input4) internal returns (bool success, bytes memory returnData) {
  791 | *   |         vm.prank(currentActor);
  792 | *   |         (success, returnData) =
  793 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.withdrawDeposit.selector, _input1, _input2, _input3, _input4));
  794 |     |     }
  795 |     | 
  796 | *   |     function _withdrawDepositsCall(address _input1, int96[] calldata _input2, uint256[] calldata _input3, LibTransfer.To _input4) public returns (bool success, bytes memory returnData) {
  797 |     | 
  798 | *   |         vm.prank(currentActor);
  799 | *   |         (success, returnData) =
  800 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.withdrawDeposits.selector, _input1, _input2, _input3, _input4));
  801 |     |     }
  802 |     | 
  803 | *   |     function _transferDepositCall(address _input1, address _input2, address _input3, int256 _input4, uint256 _input5) internal returns (bool success, bytes memory returnData) {
  804 |     | 
  805 | *   |         vm.prank(currentActor);
  806 | *   |         (success, returnData) =
  807 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.transferDeposit.selector, _input1, _input2, _input3, _input4, _input5));
  808 |     |     }
  809 |     | 
  810 | *   |     function _transferDepositsCall(address _input1, address _input2, address _input3, int256[] calldata _input4, uint256[] calldata _input5) public returns (bool success, bytes memory returnData) {
  811 |     | 
  812 | *   |         vm.prank(currentActor);
  813 | *   |         (success, returnData) =
  814 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.transferDeposits.selector, _input1, _input2, _input3, _input4, _input5));
  815 |     |     }
  816 |     | 
  817 |     | 
  818 | *   |     function _safeTransferFromCall(address _input1, address _input2, uint256 _input3, uint256 _input4, bytes calldata _input5) public returns (bool success, bytes memory returnData) {
  819 |     | 
  820 | *   |         vm.prank(currentActor);
  821 | *   |         (success, returnData) =
  822 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.safeTransferFrom.selector, _input1, _input2, _input3, _input4, _input5));
  823 |     |     }
  824 |     | 
  825 | *   |     function _safeBatchTransferFromCall(address _input1, address _input2, uint256[] calldata _input3, uint256[] calldata _input4, bytes calldata _input5) public returns (bool success, bytes memory returnData) {
  826 |     | 
  827 | *   |         vm.prank(currentActor);
  828 | *   |         (success, returnData) =
  829 | *   |             address(diamond).call(abi.encodeWithSelector(SiloFacet.safeBatchTransferFrom.selector, _input1, _input2, _input3, _input4, _input5));
  830 |     |     }
  831 |     | 
  832 |     |     function _updateSortedDepositIdsCall(address _input1, address _input2, uint256[] calldata _input3) internal returns (bool success, bytes memory returnData) {
  833 |     | 
  834 |     |         vm.prank(currentActor);
  835 |     |         (success, returnData) =
  836 |     |             address(diamond).call(abi.encodeWithSelector(SiloFacet.updateSortedDepositIds.selector, _input1, _input2, _input3));
  837 |     |     }
  838 |     | 
  839 |     |     function _getBeanTokenCall() internal returns (bool success, bytes memory returnData) {
  840 |     | 
  841 |     |         vm.prank(currentActor);
  842 |     |         (success, returnData) =
  843 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getBeanToken.selector));
  844 |     |     }
  845 |     | 
  846 |     |     function _getDepositCall(address _input1, address _input2, int96 _input3) internal returns (bool success, bytes memory returnData) {
  847 |     | 
  848 |     |         vm.prank(currentActor);
  849 |     |         (success, returnData) =
  850 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getDeposit.selector, _input1, _input2, _input3));
  851 |     |     }
  852 |     | 
  853 |     |     function _getTotalDepositedCall(address _input1) internal returns (bool success, bytes memory returnData) {
  854 |     | 
  855 |     |         vm.prank(currentActor);
  856 |     |         (success, returnData) =
  857 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalDeposited.selector, _input1));
  858 |     |     }
  859 |     | 
  860 |     |     function _getTotalSiloDepositedCall() internal returns (bool success, bytes memory returnData) {
  861 |     | 
  862 |     |         vm.prank(currentActor);
  863 |     |         (success, returnData) =
  864 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalSiloDeposited.selector));
  865 |     |     }
  866 |     | 
  867 |     |     function _getTotalDepositedBdvCall(address _input1) internal returns (bool success, bytes memory returnData) {
  868 |     | 
  869 |     |         vm.prank(currentActor);
  870 |     |         (success, returnData) =
  871 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalDepositedBdv.selector, _input1));
  872 |     |     }
  873 |     | 
  874 |     |     function _getTotalSiloDepositedBdvCall() internal returns (bool success, bytes memory returnData) {
  875 |     | 
  876 |     |         vm.prank(currentActor);
  877 |     |         (success, returnData) =
  878 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalSiloDepositedBdv.selector));
  879 |     |     }
  880 |     | 
  881 |     |     function _getGerminatingTotalDepositedCall(address _input1) internal returns (bool success, bytes memory returnData) {
  882 |     | 
  883 |     |         vm.prank(currentActor);
  884 |     |         (success, returnData) =
  885 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getGerminatingTotalDeposited.selector, _input1));
  886 |     |     }
  887 |     | 
  888 |     |     function _getGerminatingTotalDepositedBdvCall(address _input1) internal returns (bool success, bytes memory returnData) {
  889 |     | 
  890 |     |         vm.prank(currentActor);
  891 |     |         (success, returnData) =
  892 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getGerminatingTotalDepositedBdv.selector, _input1));
  893 |     |     }
  894 |     | 
  895 |     |     function _tokenSettingsCall(address _input1) internal returns (bool success, bytes memory returnData) {
  896 |     | 
  897 |     |         vm.prank(currentActor);
  898 |     |         (success, returnData) =
  899 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.tokenSettings.selector, _input1));
  900 |     |     }
  901 |     | 
  902 |     |     function _balanceOfCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  903 |     | 
  904 |     |         vm.prank(currentActor);
  905 |     |         (success, returnData) =
  906 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOf.selector, _input1, _input2));
  907 |     |     }
  908 |     | 
  909 |     |     function _balanceOfBatchCall(address[] calldata _input1, uint256[] calldata _input2) internal returns (bool success, bytes memory returnData) {
  910 |     | 
  911 |     |         vm.prank(currentActor);
  912 |     |         (success, returnData) =
  913 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfBatch.selector, _input1, _input2));
  914 |     |     }
  915 |     | 
  916 |     | 
  917 | *   |     function _getDepositIdCall(address _input1, int96 _input2) internal returns (bool success, bytes memory returnData) {
  918 |     | 
  919 | *   |         vm.prank(currentActor);
  920 | *   |         (success, returnData) =
  921 | *   |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getDepositId.selector, _input1, _input2));
  922 |     |     }
  923 |     | 
  924 |     |     function _getAddressAndStemCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
  925 |     | 
  926 |     |         vm.prank(currentActor);
  927 |     |         (success, returnData) =
  928 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getAddressAndStem.selector, _input1));
  929 |     |     }
  930 |     | 
  931 |     |     function _bdvCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
  932 |     | 
  933 |     |         vm.prank(currentActor);
  934 |     |         (success, returnData) =
  935 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.bdv.selector, _input1, _input2));
  936 |     |     }
  937 |     | 
  938 |     |     function _bdvsCall(address[] calldata _input1, uint256[] calldata _input2) internal returns (bool success, bytes memory returnData) {
  939 |     | 
  940 |     |         vm.prank(currentActor);
  941 |     |         (success, returnData) =
  942 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.bdvs.selector, _input1, _input2));
  943 |     |     }
  944 |     | 
  945 |     |     function _lastUpdateCall(address _input1) internal returns (bool success, bytes memory returnData) {
  946 |     | 
  947 |     |         vm.prank(currentActor);
  948 |     |         (success, returnData) =
  949 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.lastUpdate.selector, _input1));
  950 |     |     }
  951 |     | 
  952 |     | 
  953 |     |     function _totalStalkCall() internal returns (bool success, bytes memory returnData) {
  954 |     | 
  955 |     |         vm.prank(currentActor);
  956 |     |         (success, returnData) =
  957 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.totalStalk.selector));
  958 |     |     }
  959 |     | 
  960 |     |     function _getGerminatingStalkAndRootsForSeasonCall(uint32 _input1) internal returns (bool success, bytes memory returnData) {
  961 |     | 
  962 |     |         vm.prank(currentActor);
  963 |     |         (success, returnData) =
  964 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getGerminatingStalkAndRootsForSeason.selector, _input1));
  965 |     |     }
  966 |     | 
  967 |     |     function _getGerminatingRootsForSeasonCall(uint32 _input1) internal returns (bool success, bytes memory returnData) {
  968 |     | 
  969 |     |         vm.prank(currentActor);
  970 |     |         (success, returnData) =
  971 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getGerminatingRootsForSeason.selector, _input1));
  972 |     |     }
  973 |     | 
  974 |     |     function _getTotalGerminatingStalkCall() internal returns (bool success, bytes memory returnData) {
  975 |     | 
  976 |     |         vm.prank(currentActor);
  977 |     |         (success, returnData) =
  978 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalGerminatingStalk.selector));
  979 |     |     }
  980 |     | 
  981 |     |     function _getYoungAndMatureGerminatingTotalStalkCall() internal returns (bool success, bytes memory returnData) {
  982 |     | 
  983 |     |         vm.prank(currentActor);
  984 |     |         (success, returnData) =
  985 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getYoungAndMatureGerminatingTotalStalk.selector));
  986 |     |     }
  987 |     | 
  988 |     |     function _getTotalGerminatingAmountCall(address _input1) internal returns (bool success, bytes memory returnData) {
  989 |     | 
  990 |     |         vm.prank(currentActor);
  991 |     |         (success, returnData) =
  992 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalGerminatingAmount.selector, _input1));
  993 |     |     }
  994 |     | 
  995 |     |     function _getTotalGerminatingBdvCall(address _input1) internal returns (bool success, bytes memory returnData) {
  996 |     | 
  997 |     |         vm.prank(currentActor);
  998 |     |         (success, returnData) =
  999 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTotalGerminatingBdv.selector, _input1));
 1000 |     |     }
 1001 |     | 
 1002 |     |     function _getOddGerminatingCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1003 |     | 
 1004 |     |         vm.prank(currentActor);
 1005 |     |         (success, returnData) =
 1006 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getOddGerminating.selector, _input1));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function _getEvenGerminatingCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1010 |     | 
 1011 |     |         vm.prank(currentActor);
 1012 |     |         (success, returnData) =
 1013 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getEvenGerminating.selector, _input1));
 1014 |     |     }
 1015 |     | 
 1016 |     |     function _balanceOfFinishedGerminatingStalkAndRootsCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1017 |     | 
 1018 |     |         vm.prank(currentActor);
 1019 |     |         (success, returnData) =
 1020 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfFinishedGerminatingStalkAndRoots.selector, _input1));
 1021 |     |     }
 1022 |     | 
 1023 |     |     function _totalRootsCall() internal returns (bool success, bytes memory returnData) {
 1024 |     | 
 1025 |     |         vm.prank(currentActor);
 1026 |     |         (success, returnData) =
 1027 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.totalRoots.selector));
 1028 |     |     }
 1029 |     | 
 1030 |     |     function _totalEarnedBeansCall() internal returns (bool success, bytes memory returnData) {
 1031 |     | 
 1032 |     |         vm.prank(currentActor);
 1033 |     |         (success, returnData) =
 1034 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.totalEarnedBeans.selector));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function _balanceOfStalkCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1038 |     | 
 1039 |     |         vm.prank(currentActor);
 1040 |     |         (success, returnData) =
 1041 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfStalk.selector, _input1));
 1042 |     |     }
 1043 |     | 
 1044 |     |     function _balanceOfGerminatingStalkCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1045 |     | 
 1046 |     |         vm.prank(currentActor);
 1047 |     |         (success, returnData) =
 1048 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfGerminatingStalk.selector, _input1));
 1049 |     |     }
 1050 |     | 
 1051 |     |     function _balanceOfYoungAndMatureGerminatingStalkCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1052 |     | 
 1053 |     |         vm.prank(currentActor);
 1054 |     |         (success, returnData) =
 1055 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfYoungAndMatureGerminatingStalk.selector, _input1));
 1056 |     |     }
 1057 |     | 
 1058 |     | 
 1059 |     |     function _balanceOfRootsCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1060 |     | 
 1061 |     |         vm.prank(currentActor);
 1062 |     |         (success, returnData) =
 1063 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfRoots.selector, _input1));
 1064 |     |     }
 1065 |     | 
 1066 |     |     function _balanceOfGrownStalkCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1067 |     | 
 1068 |     |         vm.prank(currentActor);
 1069 |     |         (success, returnData) =
 1070 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfGrownStalk.selector, _input1, _input2));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function _balanceOfGrownStalkMultipleCall(address _input1, address[] calldata _input2) internal returns (bool success, bytes memory returnData) {
 1074 |     | 
 1075 |     |         vm.prank(currentActor);
 1076 |     |         (success, returnData) =
 1077 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfGrownStalkMultiple.selector, _input1, _input2));
 1078 |     |     }
 1079 |     | 
 1080 |     |     function _grownStalkForDepositCall(address _input1, address _input2, int96 _input3) internal returns (bool success, bytes memory returnData) {
 1081 |     | 
 1082 |     |         vm.prank(currentActor);
 1083 |     |         (success, returnData) =
 1084 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.grownStalkForDeposit.selector, _input1, _input2, _input3));
 1085 |     |     }
 1086 |     | 
 1087 |     |     function _balanceOfEarnedBeansCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1088 |     | 
 1089 |     |         vm.prank(currentActor);
 1090 |     |         (success, returnData) =
 1091 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfEarnedBeans.selector, _input1));
 1092 |     |     }
 1093 |     | 
 1094 |     |     function _balanceOfEarnedStalkCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1095 |     | 
 1096 |     |         vm.prank(currentActor);
 1097 |     |         (success, returnData) =
 1098 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfEarnedStalk.selector, _input1));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function _balanceOfPlantableSeedsCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1102 |     | 
 1103 |     |         vm.prank(currentActor);
 1104 |     |         (success, returnData) =
 1105 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfPlantableSeeds.selector, _input1));
 1106 |     |     }
 1107 |     | 
 1108 |     |     function _stalkEarnedPerSeasonCall(address[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 1109 |     | 
 1110 |     |         vm.prank(currentActor);
 1111 |     |         (success, returnData) =
 1112 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.stalkEarnedPerSeason.selector, _input1));
 1113 |     |     }
 1114 |     | 
 1115 |     |     function _balanceOfDepositedBdvCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1116 |     | 
 1117 |     |         vm.prank(currentActor);
 1118 |     |         (success, returnData) =
 1119 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfDepositedBdv.selector, _input1, _input2));
 1120 |     |     }
 1121 |     | 
 1122 |     |     function _getLastMowedStemCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1123 |     | 
 1124 |     |         vm.prank(currentActor);
 1125 |     |         (success, returnData) =
 1126 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getLastMowedStem.selector, _input1, _input2));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function _getMowStatusCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1130 |     | 
 1131 |     |         vm.prank(currentActor);
 1132 |     |         (success, returnData) =
 1133 |     |             address(diamond).call(abi.encodeWithSelector(bytes4(0x113c0f9b), _input1, _input2));
 1134 |     |     }
 1135 |     | 
 1136 |     |     function _getMowStatusCall(address _input1, address[] calldata _input2) internal returns (bool success, bytes memory returnData) {
 1137 |     | 
 1138 |     |         vm.prank(currentActor);
 1139 |     |         (success, returnData) =
 1140 |     |             address(diamond).call(abi.encodeWithSelector(bytes4(0x4b5483e3), _input1, _input2));
 1141 |     |     }
 1142 |     | 
 1143 |     |     function _lastSeasonOfPlentyCall() internal returns (bool success, bytes memory returnData) {
 1144 |     | 
 1145 |     |         vm.prank(currentActor);
 1146 |     |         (success, returnData) =
 1147 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.lastSeasonOfPlenty.selector));
 1148 |     |     }
 1149 |     | 
 1150 |     |     function _balanceOfPlentyCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1151 |     | 
 1152 |     |         vm.prank(currentActor);
 1153 |     |         (success, returnData) =
 1154 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfPlenty.selector, _input1, _input2));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function _balanceOfRainRootsCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1158 |     | 
 1159 |     |         vm.prank(currentActor);
 1160 |     |         (success, returnData) =
 1161 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfRainRoots.selector, _input1));
 1162 |     |     }
 1163 |     | 
 1164 |     |     function _balanceOfSopCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1165 |     | 
 1166 |     |         vm.prank(currentActor);
 1167 |     |         (success, returnData) =
 1168 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.balanceOfSop.selector, _input1));
 1169 |     |     }
 1170 |     | 
 1171 |     |     function _totalRainRootsCall() internal returns (bool success, bytes memory returnData) {
 1172 |     | 
 1173 |     |         vm.prank(currentActor);
 1174 |     |         (success, returnData) =
 1175 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.totalRainRoots.selector));
 1176 |     |     }
 1177 |     | 
 1178 |     |     function _stemTipForTokenCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1179 |     | 
 1180 |     |         vm.prank(currentActor);
 1181 |     |         (success, returnData) =
 1182 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.stemTipForToken.selector, _input1));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function _getStemTipsCall() internal returns (bool success, bytes memory returnData) {
 1186 |     | 
 1187 |     |         vm.prank(currentActor);
 1188 |     |         (success, returnData) =
 1189 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getStemTips.selector));
 1190 |     |     }
 1191 |     | 
 1192 |     |     function _calculateStemForTokenFromGrownStalkCall(address _input1, uint256 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
 1193 |     | 
 1194 |     |         vm.prank(currentActor);
 1195 |     |         (success, returnData) =
 1196 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.calculateStemForTokenFromGrownStalk.selector, _input1, _input2, _input3));
 1197 |     |     }
 1198 |     | 
 1199 |     |     function _getGerminatingStemCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1200 |     | 
 1201 |     |         vm.prank(currentActor);
 1202 |     |         (success, returnData) =
 1203 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getGerminatingStem.selector, _input1));
 1204 |     |     }
 1205 |     | 
 1206 |     |     function _getHighestNonGerminatingStemCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1207 |     | 
 1208 |     |         vm.prank(currentActor);
 1209 |     |         (success, returnData) =
 1210 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getHighestNonGerminatingStem.selector, _input1));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function _getGerminatingStemsCall(address[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 1214 |     | 
 1215 |     |         vm.prank(currentActor);
 1216 |     |         (success, returnData) =
 1217 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getGerminatingStems.selector, _input1));
 1218 |     |     }
 1219 |     | 
 1220 |     |     function _getHighestNonGerminatingStemsCall(address[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 1221 |     | 
 1222 |     |         vm.prank(currentActor);
 1223 |     |         (success, returnData) =
 1224 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getHighestNonGerminatingStems.selector, _input1));
 1225 |     |     }
 1226 |     | 
 1227 |     |     function _getDepositsForAccountCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1228 |     | 
 1229 |     |         vm.prank(currentActor);
 1230 |     |         (success, returnData) =
 1231 |     |             address(diamond).call(abi.encodeWithSelector(bytes4(0x0c8d13f8), _input1));
 1232 |     |     }
 1233 |     | 
 1234 |     |     function _getDepositsForAccountCall(address _input1, address[] calldata _input2) internal returns (bool success, bytes memory returnData) {
 1235 |     | 
 1236 |     |         vm.prank(currentActor);
 1237 |     |         (success, returnData) =
 1238 |     |             address(diamond).call(abi.encodeWithSelector(bytes4(0xced2e3e8), _input1, _input2));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function _getTokenDepositsForAccountCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1242 |     | 
 1243 |     |         vm.prank(currentActor);
 1244 |     |         (success, returnData) =
 1245 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTokenDepositsForAccount.selector, _input1, _input2));
 1246 |     |     }
 1247 |     | 
 1248 |     |     function _getTokenDepositIdsForAccountCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1249 |     | 
 1250 |     |         vm.prank(currentActor);
 1251 |     |         (success, returnData) =
 1252 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getTokenDepositIdsForAccount.selector, _input1, _input2));
 1253 |     |     }
 1254 |     | 
 1255 |     |     function _getIndexForDepositIdCall(address _input1, address _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
 1256 |     | 
 1257 |     |         vm.prank(currentActor);
 1258 |     |         (success, returnData) =
 1259 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getIndexForDepositId.selector, _input1, _input2, _input3));
 1260 |     |     }
 1261 |     | 
 1262 |     |     function _getBeanIndexCall(IERC20[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 1263 |     | 
 1264 |     |         vm.prank(currentActor);
 1265 |     |         (success, returnData) =
 1266 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getBeanIndex.selector, _input1));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function _getNonBeanTokenAndIndexFromWellCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1270 |     | 
 1271 |     |         vm.prank(currentActor);
 1272 |     |         (success, returnData) =
 1273 |     |             address(diamond).call(abi.encodeWithSelector(SiloGettersFacet.getNonBeanTokenAndIndexFromWell.selector, _input1));
 1274 |     |     }
 1275 |     | 
 1276 |     |     function _dewhitelistTokenCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1277 |     | 
 1278 |     |         vm.prank(currentActor);
 1279 |     |         (success, returnData) =
 1280 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.dewhitelistToken.selector, _input1));
 1281 |     |     }
 1282 |     | 
 1283 |     |     function _whitelistTokenCall(address _input1, bytes4 _input2, uint48 _input3, uint40 _input4, bytes1 _input5, uint128 _input6, uint64 _input7, Implementation memory _input8, Implementation memory _input9, Implementation memory _input10) internal returns (bool success, bytes memory returnData) {
 1284 |     | 
 1285 |     |         vm.prank(currentActor);
 1286 |     |         (success, returnData) =
 1287 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.whitelistToken.selector, _input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10));
 1288 |     |     }
 1289 |     | 
 1290 |     |     function _updateStalkPerBdvPerSeasonForTokenCall(address _input1, uint40 _input2) internal returns (bool success, bytes memory returnData) {
 1291 |     | 
 1292 |     |         vm.prank(currentActor);
 1293 |     |         (success, returnData) =
 1294 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateStalkPerBdvPerSeasonForToken.selector, _input1, _input2));
 1295 |     |     }
 1296 |     | 
 1297 |     | 
 1298 |     |     function _updateGaugeForTokenCall(address _input1, uint64 _input2,Implementation memory _input3, Implementation memory _input4) internal returns (bool success, bytes memory returnData) {
 1299 |     | 
 1300 |     |         vm.prank(currentActor);
 1301 |     |         (success, returnData) =
 1302 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateGaugeForToken.selector, _input1, _input2, _input3, _input4));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function _updateOracleImplementationForTokenCall(address _input1, Implementation memory _input2) internal returns (bool success, bytes memory returnData) {
 1306 |     | 
 1307 |     |         vm.prank(currentActor);
 1308 |     |         (success, returnData) =
 1309 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateOracleImplementationForToken.selector, _input1, _input2));
 1310 |     |     }
 1311 |     | 
 1312 |     |     function _updateLiquidityWeightImplementationForTokenCall(address _input1, Implementation memory _input2) internal returns (bool success, bytes memory returnData) {
 1313 |     | 
 1314 |     |         vm.prank(currentActor);
 1315 |     |         (success, returnData) =
 1316 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateLiquidityWeightImplementationForToken.selector, _input1, _input2));
 1317 |     |     }
 1318 |     | 
 1319 |     |     function _updateGaugePointImplementationForTokenCall(address _input1, Implementation memory _input2) internal returns (bool success, bytes memory returnData) {
 1320 |     | 
 1321 |     |         vm.prank(currentActor);
 1322 |     |         (success, returnData) =
 1323 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateGaugePointImplementationForToken.selector, _input1, _input2));
 1324 |     |     }
 1325 |     | 
 1326 |     |     function _updateSeedGaugeSettingsCall(EvaluationParameters memory _input1) internal returns (bool success, bytes memory returnData) {
 1327 |     | 
 1328 |     |         vm.prank(currentActor);
 1329 |     |         (success, returnData) =
 1330 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.updateSeedGaugeSettings.selector, _input1));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function _getOracleImplementationForTokenCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1334 |     | 
 1335 |     |         vm.prank(currentActor);
 1336 |     |         (success, returnData) =
 1337 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.getOracleImplementationForToken.selector, _input1));
 1338 |     |     }
 1339 |     | 
 1340 |     |     function _getGaugePointImplementationForTokenCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1341 |     | 
 1342 |     |         vm.prank(currentActor);
 1343 |     |         (success, returnData) =
 1344 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.getGaugePointImplementationForToken.selector, _input1));
 1345 |     |     }
 1346 |     | 
 1347 |     |     function _getLiquidityWeightImplementationForTokenCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1348 |     | 
 1349 |     |         vm.prank(currentActor);
 1350 |     |         (success, returnData) =
 1351 |     |             address(diamond).call(abi.encodeWithSelector(WhitelistFacet.getLiquidityWeightImplementationForToken.selector, _input1));
 1352 |     |     }
 1353 |     | 
 1354 |     |     function _cultivationFactorCall(bytes memory _input1, bytes memory _input2, bytes memory _input3) internal returns (bool success, bytes memory returnData) {
 1355 |     | 
 1356 |     |         vm.prank(currentActor);
 1357 |     |         (success, returnData) =
 1358 |     |             address(diamond).call(abi.encodeWithSelector(GaugeFacet.cultivationFactor.selector, _input1, _input2, _input3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function _convertDownPenaltyGaugeCall(bytes memory _input1, bytes memory _input2, bytes memory _input3) internal returns (bool success, bytes memory returnData) {
 1362 |     | 
 1363 |     |         vm.prank(currentActor);
 1364 |     |         (success, returnData) =
 1365 |     |             address(diamond).call(abi.encodeWithSelector(GaugeFacet.convertDownPenaltyGauge.selector, _input1, _input2, _input3));
 1366 |     |     }
 1367 |     | 
 1368 |     |     function _getGaugeCall(GaugeId _input1) internal returns (bool success, bytes memory returnData) {
 1369 |     | 
 1370 |     |         vm.prank(currentActor);
 1371 |     |         (success, returnData) =
 1372 |     |             address(diamond).call(abi.encodeWithSelector(GaugeFacet.getGauge.selector, _input1));
 1373 |     |     }
 1374 |     | 
 1375 |     |     function _getGaugeValueCall(GaugeId _input1) internal returns (bool success, bytes memory returnData) {
 1376 |     | 
 1377 |     |         vm.prank(currentActor);
 1378 |     |         (success, returnData) =
 1379 |     |             address(diamond).call(abi.encodeWithSelector(GaugeFacet.getGaugeValue.selector, _input1));
 1380 |     |     }
 1381 |     | 
 1382 |     |     function _getGaugeDataCall(GaugeId _input1) internal returns (bool success, bytes memory returnData) {
 1383 |     | 
 1384 |     |         vm.prank(currentActor);
 1385 |     |         (success, returnData) =
 1386 |     |             address(diamond).call(abi.encodeWithSelector(GaugeFacet.getGaugeData.selector, _input1));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function _getAverageGrownStalkPerBdvCall() internal returns (bool success, bytes memory returnData) {
 1390 |     | 
 1391 |     |         vm.prank(currentActor);
 1392 |     |         (success, returnData) =
 1393 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getAverageGrownStalkPerBdv.selector));
 1394 |     |     }
 1395 |     | 
 1396 |     |     function _getTotalBdvCall() internal returns (bool success, bytes memory returnData) {
 1397 |     | 
 1398 |     |         vm.prank(currentActor);
 1399 |     |         (success, returnData) =
 1400 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getTotalBdv.selector));
 1401 |     |     }
 1402 |     | 
 1403 |     |     function _getSeedGaugeCall() internal returns (bool success, bytes memory returnData) {
 1404 |     | 
 1405 |     |         vm.prank(currentActor);
 1406 |     |         (success, returnData) =
 1407 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getSeedGauge.selector));
 1408 |     |     }
 1409 |     | 
 1410 |     |     function _getAverageGrownStalkPerBdvPerSeasonCall() internal returns (bool success, bytes memory returnData) {
 1411 |     | 
 1412 |     |         vm.prank(currentActor);
 1413 |     |         (success, returnData) =
 1414 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getAverageGrownStalkPerBdvPerSeason.selector));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function _getBeanToMaxLpGpPerBdvRatioCall() internal returns (bool success, bytes memory returnData) {
 1418 |     | 
 1419 |     |         vm.prank(currentActor);
 1420 |     |         (success, returnData) =
 1421 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getBeanToMaxLpGpPerBdvRatio.selector));
 1422 |     |     }
 1423 |     | 
 1424 |     |     function _getBeanToMaxLpGpPerBdvRatioScaledCall() internal returns (bool success, bytes memory returnData) {
 1425 |     | 
 1426 |     |         vm.prank(currentActor);
 1427 |     |         (success, returnData) =
 1428 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getBeanToMaxLpGpPerBdvRatioScaled.selector));
 1429 |     |     }
 1430 |     | 
 1431 |     |     function _getGaugePointsPerBdvForTokenCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1432 |     | 
 1433 |     |         vm.prank(currentActor);
 1434 |     |         (success, returnData) =
 1435 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getGaugePointsPerBdvForToken.selector, _input1));
 1436 |     |     }
 1437 |     | 
 1438 |     |     function _getGaugePointsPerBdvForWellCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1439 |     | 
 1440 |     |         vm.prank(currentActor);
 1441 |     |         (success, returnData) =
 1442 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getGaugePointsPerBdvForWell.selector, _input1));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function _getLargestGpPerBdvCall() internal returns (bool success, bytes memory returnData) {
 1446 |     | 
 1447 |     |         vm.prank(currentActor);
 1448 |     |         (success, returnData) =
 1449 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getLargestGpPerBdv.selector));
 1450 |     |     }
 1451 |     | 
 1452 |     |     function _getBeanGaugePointsPerBdvCall() internal returns (bool success, bytes memory returnData) {
 1453 |     | 
 1454 |     |         vm.prank(currentActor);
 1455 |     |         (success, returnData) =
 1456 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getBeanGaugePointsPerBdv.selector));
 1457 |     |     }
 1458 |     | 
 1459 |     |     function _getGrownStalkIssuedPerSeasonCall() internal returns (bool success, bytes memory returnData) {
 1460 |     | 
 1461 |     |         vm.prank(currentActor);
 1462 |     |         (success, returnData) =
 1463 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getGrownStalkIssuedPerSeason.selector));
 1464 |     |     }
 1465 |     | 
 1466 |     |     function _getGrownStalkIssuedPerGpCall() internal returns (bool success, bytes memory returnData) {
 1467 |     | 
 1468 |     |         vm.prank(currentActor);
 1469 |     |         (success, returnData) =
 1470 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getGrownStalkIssuedPerGp.selector));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function _getPodRateCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1474 |     | 
 1475 |     |         vm.prank(currentActor);
 1476 |     |         (success, returnData) =
 1477 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getPodRate.selector, _input1));
 1478 |     |     }
 1479 |     | 
 1480 |     |     function _getLiquidityToSupplyRatioCall() internal returns (bool success, bytes memory returnData) {
 1481 |     | 
 1482 |     |         vm.prank(currentActor);
 1483 |     |         (success, returnData) =
 1484 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getLiquidityToSupplyRatio.selector));
 1485 |     |     }
 1486 |     | 
 1487 |     |     function _getDeltaPodDemandCall() internal returns (bool success, bytes memory returnData) {
 1488 |     | 
 1489 |     |         vm.prank(currentActor);
 1490 |     |         (success, returnData) =
 1491 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getDeltaPodDemand.selector));
 1492 |     |     }
 1493 |     | 
 1494 |     |     function _getGaugePointsCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1495 |     | 
 1496 |     |         vm.prank(currentActor);
 1497 |     |         (success, returnData) =
 1498 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getGaugePoints.selector, _input1));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function _calcGaugePointsWithParamsCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1502 |     | 
 1503 |     |         vm.prank(currentActor);
 1504 |     |         (success, returnData) =
 1505 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.calcGaugePointsWithParams.selector, _input1, _input2));
 1506 |     |     }
 1507 |     | 
 1508 |     |     function _getGaugePointsWithParamsCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1509 |     | 
 1510 |     |         vm.prank(currentActor);
 1511 |     |         (success, returnData) =
 1512 |     |             address(diamond).call(abi.encodeWithSelector(GaugeGettersFacet.getGaugePointsWithParams.selector, _input1));
 1513 |     |     }
 1514 |     | 
 1515 |     |     function _maxWeightCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 1516 |     | 
 1517 |     |         vm.prank(currentActor);
 1518 |     |         (success, returnData) =
 1519 |     |             address(diamond).call(abi.encodeWithSelector(LiquidityWeightFacet.maxWeight.selector, _input1));
 1520 |     |     }
 1521 |     | 
 1522 |     |     function _noWeightCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 1523 |     | 
 1524 |     |         vm.prank(currentActor);
 1525 |     |         (success, returnData) =
 1526 |     |             address(diamond).call(abi.encodeWithSelector(LiquidityWeightFacet.noWeight.selector, _input1));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function _getUsdTokenPriceCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1530 |     | 
 1531 |     |         vm.prank(currentActor);
 1532 |     |         (success, returnData) =
 1533 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getUsdTokenPrice.selector, _input1));
 1534 |     |     }
 1535 |     | 
 1536 |     |     function _getUsdTokenTwapCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1537 |     | 
 1538 |     |         vm.prank(currentActor);
 1539 |     |         (success, returnData) =
 1540 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getUsdTokenTwap.selector, _input1, _input2));
 1541 |     |     }
 1542 |     | 
 1543 |     |     function _getTokenUsdPriceCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1544 |     | 
 1545 |     |         vm.prank(currentActor);
 1546 |     |         (success, returnData) =
 1547 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getTokenUsdPrice.selector, _input1));
 1548 |     |     }
 1549 |     | 
 1550 |     |     function _getTokenUsdTwapCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1551 |     | 
 1552 |     |         vm.prank(currentActor);
 1553 |     |         (success, returnData) =
 1554 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getTokenUsdTwap.selector, _input1, _input2));
 1555 |     |     }
 1556 |     | 
 1557 |     |     function _getUsdTokenPriceFromExternalCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1558 |     | 
 1559 |     |         vm.prank(currentActor);
 1560 |     |         (success, returnData) =
 1561 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getUsdTokenPriceFromExternal.selector, _input1, _input2));
 1562 |     |     }
 1563 |     | 
 1564 |     |     function _getTokenUsdPriceFromExternalCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1565 |     | 
 1566 |     |         vm.prank(currentActor);
 1567 |     |         (success, returnData) =
 1568 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getTokenUsdPriceFromExternal.selector, _input1, _input2));
 1569 |     |     }
 1570 |     | 
 1571 |     |     function _getRatiosAndBeanIndexCall(IERC20[] memory _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1572 |     | 
 1573 |     |         vm.prank(currentActor);
 1574 |     |         (success, returnData) =
 1575 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getRatiosAndBeanIndex.selector, _input1, _input2));
 1576 |     |     }
 1577 |     | 
 1578 |     |     function _getMillionUsdPriceCall(address _input1, uint256 _input2) internal returns (bool success, bytes memory returnData) {
 1579 |     | 
 1580 |     |         vm.prank(currentActor);
 1581 |     |         (success, returnData) =
 1582 |     |             address(diamond).call(abi.encodeWithSelector(OracleFacet.getMillionUsdPrice.selector, _input1, _input2));
 1583 |     |     }
 1584 |     | 
 1585 |     |     function _sunriseCall() internal returns (bool success, bytes memory returnData) {
 1586 |     | 
 1587 |     |         vm.prank(currentActor);
 1588 |     |         (success, returnData) =
 1589 |     |             address(diamond).call(abi.encodeWithSelector(SeasonFacet.sunrise.selector));
 1590 |     |     }
 1591 |     | 
 1592 |     |     function _gmCall(address _input1, LibTransfer.To _input2) internal returns (bool success, bytes memory returnData) {
 1593 |     | 
 1594 |     |         vm.prank(currentActor);
 1595 |     |         (success, returnData) =
 1596 |     |             address(diamond).call(abi.encodeWithSelector(SeasonFacet.gm.selector, _input1, _input2));
 1597 |     |     }
 1598 |     | 
 1599 |     |     function _seasonTimeCall() internal returns (bool success, bytes memory returnData) {
 1600 |     | 
 1601 |     |         vm.prank(currentActor);
 1602 |     |         (success, returnData) =
 1603 |     |             address(diamond).call(abi.encodeWithSelector(SeasonFacet.seasonTime.selector));
 1604 |     |     }
 1605 |     | 
 1606 |     |     function _seasonCall() internal returns (bool success, bytes memory returnData) {
 1607 |     | 
 1608 |     |         vm.prank(currentActor);
 1609 |     |         (success, returnData) =
 1610 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.season.selector));
 1611 |     |     }
 1612 |     | 
 1613 |     |     function _pausedCall() internal returns (bool success, bytes memory returnData) {
 1614 |     | 
 1615 |     |         vm.prank(currentActor);
 1616 |     |         (success, returnData) =
 1617 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.paused.selector));
 1618 |     |     }
 1619 |     | 
 1620 |     |     function _timeCall() internal returns (bool success, bytes memory returnData) {
 1621 |     | 
 1622 |     |         vm.prank(currentActor);
 1623 |     |         (success, returnData) =
 1624 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.time.selector));
 1625 |     |     }
 1626 |     | 
 1627 |     |     function _abovePegCall() internal returns (bool success, bytes memory returnData) {
 1628 |     | 
 1629 |     |         vm.prank(currentActor);
 1630 |     |         (success, returnData) =
 1631 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.abovePeg.selector));
 1632 |     |     }
 1633 |     | 
 1634 |     |     function _sunriseBlockCall() internal returns (bool success, bytes memory returnData) {
 1635 |     | 
 1636 |     |         vm.prank(currentActor);
 1637 |     |         (success, returnData) =
 1638 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.sunriseBlock.selector));
 1639 |     |     }
 1640 |     | 
 1641 |     |     function _weatherCall() internal returns (bool success, bytes memory returnData) {
 1642 |     | 
 1643 |     |         vm.prank(currentActor);
 1644 |     |         (success, returnData) =
 1645 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.weather.selector));
 1646 |     |     }
 1647 |     | 
 1648 |     |     function _rainCall() internal returns (bool success, bytes memory returnData) {
 1649 |     | 
 1650 |     |         vm.prank(currentActor);
 1651 |     |         (success, returnData) =
 1652 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.rain.selector));
 1653 |     |     }
 1654 |     | 
 1655 |     |     function _plentyPerRootCall(uint32 _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 1656 |     | 
 1657 |     |         vm.prank(currentActor);
 1658 |     |         (success, returnData) =
 1659 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.plentyPerRoot.selector, _input1, _input2));
 1660 |     |     }
 1661 |     | 
 1662 |     |     function _totalDeltaBCall() internal returns (bool success, bytes memory returnData) {
 1663 |     | 
 1664 |     |         vm.prank(currentActor);
 1665 |     |         (success, returnData) =
 1666 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.totalDeltaB.selector));
 1667 |     |     }
 1668 |     | 
 1669 |     |     function _totalDeltaBNoCapCall() internal returns (bool success, bytes memory returnData) {
 1670 |     | 
 1671 |     |         vm.prank(currentActor);
 1672 |     |         (success, returnData) =
 1673 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.totalDeltaBNoCap.selector));
 1674 |     |     }
 1675 |     | 
 1676 |     | 
 1677 |     |     function _poolDeltaBCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1678 |     | 
 1679 |     |         vm.prank(currentActor);
 1680 |     |         (success, returnData) =
 1681 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.plentyPerRoot.selector, _input1));
 1682 |     |     }
 1683 |     | 
 1684 |     |     function _poolDeltaBNoCapCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1685 |     | 
 1686 |     |         vm.prank(currentActor);
 1687 |     |         (success, returnData) =
 1688 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.poolDeltaBNoCap.selector, _input1));
 1689 |     |     }
 1690 |     | 
 1691 |     |     function _poolCurrentDeltaBCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1692 |     | 
 1693 |     |         vm.prank(currentActor);
 1694 |     |         (success, returnData) =
 1695 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.poolCurrentDeltaB.selector, _input1));
 1696 |     |     }
 1697 |     | 
 1698 |     |     function _cumulativeCurrentDeltaBCall(address[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 1699 |     | 
 1700 |     |         vm.prank(currentActor);
 1701 |     |         (success, returnData) =
 1702 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.cumulativeCurrentDeltaB.selector, _input1));
 1703 |     |     }
 1704 |     | 
 1705 |     |     function _totalInstantaneousDeltaBCall() internal returns (bool success, bytes memory returnData) {
 1706 |     | 
 1707 |     |         vm.prank(currentActor);
 1708 |     |         (success, returnData) =
 1709 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.totalInstantaneousDeltaB.selector));
 1710 |     |     }
 1711 |     | 
 1712 |     |     function _wellOracleSnapshotCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1713 |     | 
 1714 |     |         vm.prank(currentActor);
 1715 |     |         (success, returnData) =
 1716 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.wellOracleSnapshot.selector, _input1));
 1717 |     |     }
 1718 |     | 
 1719 |     |     function _getTwaLiquidityForWellCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1720 |     | 
 1721 |     |         vm.prank(currentActor);
 1722 |     |         (success, returnData) =
 1723 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getTwaLiquidityForWell.selector, _input1));
 1724 |     |     }
 1725 |     | 
 1726 |     |     function _getWeightedTwaLiquidityForWellCall(address _input1) internal returns (bool success, bytes memory returnData) {
 1727 |     | 
 1728 |     |         vm.prank(currentActor);
 1729 |     |         (success, returnData) =
 1730 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getWeightedTwaLiquidityForWell.selector, _input1));
 1731 |     |     }
 1732 |     | 
 1733 |     |     function _getTotalUsdLiquidityCall() internal returns (bool success, bytes memory returnData) {
 1734 |     | 
 1735 |     |         vm.prank(currentActor);
 1736 |     |         (success, returnData) =
 1737 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getTotalUsdLiquidity.selector));
 1738 |     |     }
 1739 |     | 
 1740 |     |     function _getTotalWeightedUsdLiquidityCall() internal returns (bool success, bytes memory returnData) {
 1741 |     | 
 1742 |     |         vm.prank(currentActor);
 1743 |     |         (success, returnData) =
 1744 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getTotalWeightedUsdLiquidity.selector));
 1745 |     |     }
 1746 |     | 
 1747 |     |     function _getLargestLiqWellCall() internal returns (bool success, bytes memory returnData) {
 1748 |     | 
 1749 |     |         vm.prank(currentActor);
 1750 |     |         (success, returnData) =
 1751 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getLargestLiqWell.selector));
 1752 |     |     }
 1753 |     | 
 1754 |     |     function _getCasesCall() internal returns (bool success, bytes memory returnData) {
 1755 |     | 
 1756 |     |         vm.prank(currentActor);
 1757 |     |         (success, returnData) =
 1758 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getCases.selector));
 1759 |     |     }
 1760 |     | 
 1761 |     |     function _getCaseDataCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1762 |     | 
 1763 |     |         vm.prank(currentActor);
 1764 |     |         (success, returnData) =
 1765 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getCaseData.selector, _input1));
 1766 |     |     }
 1767 |     | 
 1768 |     |     function _getChangeFromCaseIdCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1769 |     | 
 1770 |     |         vm.prank(currentActor);
 1771 |     |         (success, returnData) =
 1772 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getChangeFromCaseId.selector, _input1));
 1773 |     |     }
 1774 |     | 
 1775 |     |     function _getAbsTemperatureChangeFromCaseIdCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1776 |     | 
 1777 |     |         vm.prank(currentActor);
 1778 |     |         (success, returnData) =
 1779 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getAbsTemperatureChangeFromCaseId.selector, _input1));
 1780 |     |     }
 1781 |     | 
 1782 |     |     function _getRelTemperatureChangeFromCaseIdCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1783 |     | 
 1784 |     |         vm.prank(currentActor);
 1785 |     |         (success, returnData) =
 1786 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getRelTemperatureChangeFromCaseId.selector, _input1));
 1787 |     |     }
 1788 |     | 
 1789 |     |     function _getAbsBeanToMaxLpRatioChangeFromCaseIdCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1790 |     | 
 1791 |     |         vm.prank(currentActor);
 1792 |     |         (success, returnData) =
 1793 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getAbsBeanToMaxLpRatioChangeFromCaseId.selector, _input1));
 1794 |     |     }
 1795 |     | 
 1796 |     |     function _getRelBeanToMaxLpRatioChangeFromCaseIdCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 1797 |     | 
 1798 |     |         vm.prank(currentActor);
 1799 |     |         (success, returnData) =
 1800 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getRelBeanToMaxLpRatioChangeFromCaseId.selector, _input1));
 1801 |     |     }
 1802 |     | 
 1803 |     |     function _getSeasonStructCall() internal returns (bool success, bytes memory returnData) {
 1804 |     | 
 1805 |     |         vm.prank(currentActor);
 1806 |     |         (success, returnData) =
 1807 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getSeasonStruct.selector));
 1808 |     |     }
 1809 |     | 
 1810 |     |     function _getSeasonTimestampCall() internal returns (bool success, bytes memory returnData) {
 1811 |     | 
 1812 |     |         vm.prank(currentActor);
 1813 |     |         (success, returnData) =
 1814 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getSeasonTimestamp.selector));
 1815 |     |     }
 1816 |     | 
 1817 |     |     function _getEvaluationParametersCall() internal returns (bool success, bytes memory returnData) {
 1818 |     | 
 1819 |     |         vm.prank(currentActor);
 1820 |     |         (success, returnData) =
 1821 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getEvaluationParameters.selector));
 1822 |     |     }
 1823 |     | 
 1824 |     |     function _getExtEvaluationParametersCall() internal returns (bool success, bytes memory returnData) {
 1825 |     | 
 1826 |     |         vm.prank(currentActor);
 1827 |     |         (success, returnData) =
 1828 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getExtEvaluationParameters.selector));
 1829 |     |     }
 1830 |     | 
 1831 |     |     function _getMaxBeanMaxLpGpPerBdvRatioCall() internal returns (bool success, bytes memory returnData) {
 1832 |     | 
 1833 |     |         vm.prank(currentActor);
 1834 |     |         (success, returnData) =
 1835 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getMaxBeanMaxLpGpPerBdvRatio.selector));
 1836 |     |     }
 1837 |     | 
 1838 |     |     function _getMinBeanMaxLpGpPerBdvRatioCall() internal returns (bool success, bytes memory returnData) {
 1839 |     | 
 1840 |     |         vm.prank(currentActor);
 1841 |     |         (success, returnData) =
 1842 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getMinBeanMaxLpGpPerBdvRatio.selector));
 1843 |     |     }
 1844 |     | 
 1845 |     |     function _getTargetSeasonsToCatchUpCall() internal returns (bool success, bytes memory returnData) {
 1846 |     | 
 1847 |     |         vm.prank(currentActor);
 1848 |     |         (success, returnData) =
 1849 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getTargetSeasonsToCatchUp.selector));
 1850 |     |     }
 1851 |     | 
 1852 |     |     function _getPodRateLowerBoundCall() internal returns (bool success, bytes memory returnData) {
 1853 |     | 
 1854 |     |         vm.prank(currentActor);
 1855 |     |         (success, returnData) =
 1856 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getPodRateLowerBound.selector));
 1857 |     |     }
 1858 |     | 
 1859 |     |     function _getPodRateOptimalCall() internal returns (bool success, bytes memory returnData) {
 1860 |     | 
 1861 |     |         vm.prank(currentActor);
 1862 |     |         (success, returnData) =
 1863 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getPodRateOptimal.selector));
 1864 |     |     }
 1865 |     | 
 1866 |     |     function _getPodRateUpperBoundCall() internal returns (bool success, bytes memory returnData) {
 1867 |     | 
 1868 |     |         vm.prank(currentActor);
 1869 |     |         (success, returnData) =
 1870 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getPodRateUpperBound.selector));
 1871 |     |     }
 1872 |     | 
 1873 |     |     function _getDeltaPodDemandLowerBoundCall() internal returns (bool success, bytes memory returnData) {
 1874 |     | 
 1875 |     |         vm.prank(currentActor);
 1876 |     |         (success, returnData) =
 1877 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getDeltaPodDemandLowerBound.selector));
 1878 |     |     }
 1879 |     | 
 1880 |     |     function _getDeltaPodDemandUpperBoundCall() internal returns (bool success, bytes memory returnData) {
 1881 |     | 
 1882 |     |         vm.prank(currentActor);
 1883 |     |         (success, returnData) =
 1884 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getDeltaPodDemandUpperBound.selector));
 1885 |     |     }
 1886 |     | 
 1887 |     |     function _getLpToSupplyRatioUpperBoundCall() internal returns (bool success, bytes memory returnData) {
 1888 |     | 
 1889 |     |         vm.prank(currentActor);
 1890 |     |         (success, returnData) =
 1891 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getLpToSupplyRatioUpperBound.selector));
 1892 |     |     }
 1893 |     | 
 1894 |     |     function _getLpToSupplyRatioOptimalCall() internal returns (bool success, bytes memory returnData) {
 1895 |     | 
 1896 |     |         vm.prank(currentActor);
 1897 |     |         (success, returnData) =
 1898 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getLpToSupplyRatioOptimal.selector));
 1899 |     |     }
 1900 |     | 
 1901 |     |     function _getLpToSupplyRatioLowerBoundCall() internal returns (bool success, bytes memory returnData) {
 1902 |     | 
 1903 |     |         vm.prank(currentActor);
 1904 |     |         (success, returnData) =
 1905 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getLpToSupplyRatioLowerBound.selector));
 1906 |     |     }
 1907 |     | 
 1908 |     |     function _getExcessivePriceThresholdCall() internal returns (bool success, bytes memory returnData) {
 1909 |     | 
 1910 |     |         vm.prank(currentActor);
 1911 |     |         (success, returnData) =
 1912 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getExcessivePriceThreshold.selector));
 1913 |     |     }
 1914 |     | 
 1915 |     |     function _getWellsByDeltaBCall() internal returns (bool success, bytes memory returnData) {
 1916 |     | 
 1917 |     |         vm.prank(currentActor);
 1918 |     |         (success, returnData) =
 1919 |     |             address(diamond).call(abi.encodeWithSelector(SeasonGettersFacet.getWellsByDeltaB.selector));
 1920 |     |     }
 1921 |     | 
 1922 |     |     function _setShipmentRoutesCall(ShipmentRoute[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 1923 |     | 
 1924 |     |         vm.prank(currentActor);
 1925 |     |         (success, returnData) =
 1926 |     |             address(diamond).call(abi.encodeWithSelector(Distribution.setShipmentRoutes.selector, _input1));
 1927 |     |     }
 1928 |     | 
 1929 |     |     function _encodeOperatorPasteInstrCall(uint80 _input1, uint80 _input2, uint80 _input3) internal returns (bool success, bytes memory returnData) {
 1930 |     | 
 1931 |     |         vm.prank(currentActor);
 1932 |     |         (success, returnData) =
 1933 |     |             address(drafter).call(abi.encodeWithSelector(Drafter.encodeOperatorPasteInstr.selector, _input1, _input2, _input3));
 1934 |     |     }
 1935 |     | 
 1936 |     |     function _decodeOperatorPasteInstrCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
 1937 |     | 
 1938 |     |         vm.prank(currentActor);
 1939 |     |         (success, returnData) =
 1940 |     |             address(drafter).call(abi.encodeWithSelector(Drafter.decodeOperatorPasteInstr.selector, _input1));
 1941 |     |     }
 1942 |     | 
 1943 |     |     function _encodeLibReturnPasteParamCall(uint80 _input1, uint80 _input2, uint80 _input3) internal returns (bool success, bytes memory returnData) {
 1944 |     | 
 1945 |     |         vm.prank(currentActor);
 1946 |     |         (success, returnData) =
 1947 |     |             address(drafter).call(abi.encodeWithSelector(Drafter.encodeLibReturnPasteParam.selector, _input1, _input2, _input3));
 1948 |     |     }
 1949 |     | 
 1950 |     |     function _decodeLibReturnPasteParamCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
 1951 |     | 
 1952 |     |         vm.prank(currentActor);
 1953 |     |         (success, returnData) =
 1954 |     |             address(drafter).call(abi.encodeWithSelector(Drafter.decodeLibReturnPasteParam.selector, _input1));
 1955 |     |     }
 1956 |     | 
 1957 |     |     function _encodeClipboardCall(uint256 _input1, bytes32[] memory _input2) internal returns (bool success, bytes memory returnData) {
 1958 |     | 
 1959 |     |         vm.prank(currentActor);
 1960 |     |         (success, returnData) =
 1961 |     |             address(drafter).call(abi.encodeWithSelector(Drafter.encodeClipboard.selector, _input1, _input2));
 1962 |     |     }
 1963 |     | 
 1964 |     |     function _decodeClipboardCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 1965 |     | 
 1966 |     |         vm.prank(currentActor);
 1967 |     |         (success, returnData) =
 1968 |     |             address(drafter).call(abi.encodeWithSelector(Drafter.decodeClipboard.selector, _input1));
 1969 |     |     }
 1970 |     | 
 1971 |     |     function _priceThresholdGaugePointsCall(uint80 _input1, uint80 _input2, uint80 _input3, bytes memory _input4) internal returns (bool success, bytes memory returnData) {
 1972 |     | 
 1973 |     |         vm.prank(currentActor);
 1974 |     |         (success, returnData) =
 1975 |     |             address(gaugePriceThreshold).call(abi.encodeWithSelector(GaugePriceThreshold.priceThresholdGaugePoints.selector, _input1, _input2, _input3, _input4));
 1976 |     |     }
 1977 |     | 
 1978 |     |     function _getBeanstalkCall() internal returns (bool success, bytes memory returnData) {
 1979 |     | 
 1980 |     |         vm.prank(currentActor);
 1981 |     |         (success, returnData) =
 1982 |     |             address(gaugePriceThreshold).call(abi.encodeWithSelector(GaugePriceThreshold.getBeanstalk.selector));
 1983 |     |     }
 1984 |     | 
 1985 |     |     function _getTokenCall() internal returns (bool success, bytes memory returnData) {
 1986 |     | 
 1987 |     |         vm.prank(currentActor);
 1988 |     |         (success, returnData) =
 1989 |     |             address(gaugePriceThreshold).call(abi.encodeWithSelector(GaugePriceThreshold.getToken.selector));
 1990 |     |     }
 1991 |     | 
 1992 |     |     function _getPriceThresholdCall() internal returns (bool success, bytes memory returnData) {
 1993 |     |         vm.prank(currentActor);
 1994 |     |         (success, returnData) =
 1995 |     |             address(gaugePriceThreshold).call(abi.encodeWithSelector(GaugePriceThreshold.getPriceThreshold.selector));
 1996 |     |     }
 1997 |     | 
 1998 |     |     function _getGaugePointsPriceCall() internal returns (bool success, bytes memory returnData) {
 1999 |     |         vm.prank(currentActor);
 2000 |     |         (success, returnData) =
 2001 |     |             address(gaugePriceThreshold).call(abi.encodeWithSelector(GaugePriceThreshold.getGaugePointsPrice.selector));
 2002 |     |     }
 2003 |     | 
 2004 |     |     function _addOperatorCall(address _input1) internal returns (bool success, bytes memory returnData) {
 2005 |     | 
 2006 |     |         vm.prank(currentActor);
 2007 |     |         (success, returnData) =
 2008 |     |             address(operatorWhitelist).call(abi.encodeWithSelector(OperatorWhitelist.addOperator.selector, _input1));
 2009 |     |     }
 2010 |     | 
 2011 |     |     function _removeOperatorCall(address _input1) internal returns (bool success, bytes memory returnData) {
 2012 |     | 
 2013 |     |         vm.prank(currentActor);
 2014 |     |         (success, returnData) =
 2015 |     |             address(operatorWhitelist).call(abi.encodeWithSelector(OperatorWhitelist.removeOperator.selector, _input1));
 2016 |     |     }
 2017 |     | 
 2018 |     |     function _checkOperatorWhitelistCall(address _input1) internal returns (bool success, bytes memory returnData) {
 2019 |     | 
 2020 |     |         vm.prank(currentActor);
 2021 |     |         (success, returnData) =
 2022 |     |             address(operatorWhitelist).call(abi.encodeWithSelector(OperatorWhitelist.checkOperatorWhitelist.selector, _input1));
 2023 |     |     }
 2024 |     | 
 2025 |     |     function _getWhitelistedOperatorsCall() internal returns (bool success, bytes memory returnData) {
 2026 |     | 
 2027 |     |         vm.prank(currentActor);
 2028 |     |         (success, returnData) =
 2029 |     |             address(operatorWhitelist).call(abi.encodeWithSelector(OperatorWhitelist.getWhitelistedOperators.selector));
 2030 |     |     }
 2031 |     | 
 2032 |     |     function _isValidSlippageCall(IWell _input1, IERC20 _input2, uint256 _input3) internal returns (bool success, bytes memory returnData) {
 2033 |     | 
 2034 |     |         vm.prank(currentActor);
 2035 |     |         (success, returnData) =
 2036 |     |             address(priceManipulation).call(abi.encodeWithSelector(PriceManipulation.isValidSlippage.selector, _input1, _input2, _input3));
 2037 |     |     }
 2038 |     | 
 2039 |     |     function _aggregatePintoPerUsdcCall() internal returns (bool success, bytes memory returnData) {
 2040 |     | 
 2041 |     |         vm.prank(currentActor);
 2042 |     |         (success, returnData) =
 2043 |     |             address(priceManipulation).call(abi.encodeWithSelector(PriceManipulation.aggregatePintoPerUsdc.selector));
 2044 |     |     }
 2045 |     | 
 2046 |     |     function _priceCall() internal returns (bool success, bytes memory returnData) {
 2047 |     | 
 2048 |     |         vm.prank(currentActor);
 2049 |     |         (success, returnData) =
 2050 |     |             address(priceManipulation).call(abi.encodeWithSelector(PriceManipulation.price.selector));
 2051 |     |     }
 2052 |     | 
 2053 |     |     function _getFieldPlanCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 2054 |     | 
 2055 |     |         vm.prank(currentActor);
 2056 |     |         (success, returnData) =
 2057 |     |             address(shipPlanner).call(abi.encodeWithSelector(ShipmentPlanner.getFieldPlan.selector, _input1));
 2058 |     |     }
 2059 |     | 
 2060 |     |     function _getSiloPlanCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 2061 |     | 
 2062 |     |         vm.prank(currentActor);
 2063 |     |         (success, returnData) =
 2064 |     |             address(shipPlanner).call(abi.encodeWithSelector(ShipmentPlanner.getSiloPlan.selector, _input1));
 2065 |     |     }
 2066 |     | 
 2067 |     |     function _getBudgetPlanCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 2068 |     | 
 2069 |     |         vm.prank(currentActor);
 2070 |     |         (success, returnData) =
 2071 |     |             address(shipPlanner).call(abi.encodeWithSelector(ShipmentPlanner.getBudgetPlan.selector, _input1));
 2072 |     |     }
 2073 |     | 
 2074 |     |     function _getPaybackFieldPlanCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 2075 |     | 
 2076 |     |         vm.prank(currentActor);
 2077 |     |         (success, returnData) =
 2078 |     |             address(shipPlanner).call(abi.encodeWithSelector(ShipmentPlanner.getPaybackFieldPlan.selector, _input1));
 2079 |     |     }
 2080 |     | 
 2081 |     |     function _getPaybackPlanCall(bytes memory _input1) internal returns (bool success, bytes memory returnData) {
 2082 |     | 
 2083 |     |         vm.prank(currentActor);
 2084 |     |         (success, returnData) =
 2085 |     |             address(shipPlanner).call(abi.encodeWithSelector(ShipmentPlanner.getPaybackPlan.selector, _input1));
 2086 |     |     }
 2087 |     | 
 2088 |     |     function _sowBlueprintv0Call(SowBlueprintv0.SowBlueprintStruct calldata _input1) internal returns (bool success, bytes memory returnData) {
 2089 |     | 
 2090 |     |         vm.prank(currentActor);
 2091 |     |         (success, returnData) =
 2092 |     |             address(sowBlueprintv0).call(abi.encodeWithSelector(SowBlueprintv0.sowBlueprintv0.selector, _input1));
 2093 |     |     }
 2094 |     | 
 2095 |     |     function _getLastExecutedSeasonCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
 2096 |     | 
 2097 |     |         vm.prank(currentActor);
 2098 |     |         (success, returnData) =
 2099 |     |             address(sowBlueprintv0).call(abi.encodeWithSelector(SowBlueprintv0.getLastExecutedSeason.selector, _input1));
 2100 |     |     }
 2101 |     | 
 2102 |     |     function _getPintosLeftToSowCall(bytes32 _input1) internal returns (bool success, bytes memory returnData) {
 2103 |     | 
 2104 |     |         vm.prank(currentActor);
 2105 |     |         (success, returnData) =
 2106 |     |             address(sowBlueprintv0).call(abi.encodeWithSelector(SowBlueprintv0.getPintosLeftToSow.selector, _input1));
 2107 |     |     }
 2108 |     | 
 2109 |     | 
 2110 |     |     function _validateParamsAndReturnBeanstalkStateCall(SowBlueprintv0.SowBlueprintStruct calldata _input1, bytes32 _input2, address _input3) internal returns (bool success, bytes memory returnData) {
 2111 |     | 
 2112 |     |         vm.prank(currentActor);
 2113 |     |         (success, returnData) =
 2114 |     |             address(sowBlueprintv0).call(abi.encodeWithSelector(SowBlueprintv0.validateParamsAndReturnBeanstalkState.selector, _input1, _input2, _input3));
 2115 |     |     }
 2116 |     | 
 2117 |     |     function _validateParamsAndReturnBeanstalkStateArrayCall(SowBlueprintv0.SowBlueprintStruct[] calldata _input1, bytes32[] calldata _input2, address[] calldata _input3) internal returns (bool success, bytes memory returnData) {
 2118 |     | 
 2119 |     |         vm.prank(currentActor);
 2120 |     |         (success, returnData) =
 2121 |     |             address(sowBlueprintv0).call(abi.encodeWithSelector(SowBlueprintv0.validateParamsAndReturnBeanstalkStateArray.selector, _input1, _input2, _input3));
 2122 |     |     }
 2123 |     | 
 2124 |     |     function _getWithdrawalPlanExcludingPlanCall(address _input1,uint8[] memory _input2, uint256 _input3, uint256 _input4, LibTractorHelpers.WithdrawalPlan memory _input5) internal returns (bool success, bytes memory returnData) {
 2125 |     | 
 2126 |     |         vm.prank(currentActor);
 2127 |     |         (success, returnData) =
 2128 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getWithdrawalPlanExcludingPlan.selector, _input1, _input2, _input3, _input4, _input5));
 2129 |     |     }
 2130 |     | 
 2131 |     |     function _getWithdrawalPlanCall(address _input1,uint8[] memory _input2, uint256 _input3, uint256 _input4) internal returns (bool success, bytes memory returnData) {
 2132 |     | 
 2133 |     |         vm.prank(currentActor);
 2134 |     |         (success, returnData) =
 2135 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getWithdrawalPlan.selector, _input1, _input2, _input3, _input4));
 2136 |     |     }
 2137 |     | 
 2138 |     |     function _withdrawBeansFromSourcesCall(address _input1, uint8[] memory _input2, uint256 _input3, uint256 _input4, uint256 _input5, LibTransfer.To _input6, LibTractorHelpers.WithdrawalPlan memory _input7) internal returns (bool success, bytes memory returnData) {
 2139 |     | 
 2140 |     |         vm.prank(currentActor);
 2141 |     |         (success, returnData) =
 2142 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.withdrawBeansFromSources.selector, _input1, _input2, _input3, _input4, _input5, _input6, _input7));
 2143 |     |     }
 2144 |     | 
 2145 |     |     function _getBeanstalkPriceCall() internal returns (bool success, bytes memory returnData) {
 2146 |     | 
 2147 |     |         vm.prank(currentActor);
 2148 |     |         (success, returnData) =
 2149 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getBeanstalkPrice.selector));
 2150 |     |     }
 2151 |     | 
 2152 |     |     function _getSortedWhitelistedTokensBySeedsCall() internal returns (bool success, bytes memory returnData) {
 2153 |     | 
 2154 |     |         vm.prank(currentActor);
 2155 |     |         (success, returnData) =
 2156 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getSortedWhitelistedTokensBySeeds.selector));
 2157 |     |     }
 2158 |     | 
 2159 |     |     function _getHighestSeedTokenCall() internal returns (bool success, bytes memory returnData) {
 2160 |     | 
 2161 |     |         vm.prank(currentActor);
 2162 |     |         (success, returnData) =
 2163 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getHighestSeedToken.selector));
 2164 |     |     }
 2165 |     | 
 2166 |     |     function _getLowestSeedTokenCall() internal returns (bool success, bytes memory returnData) {
 2167 |     | 
 2168 |     |         vm.prank(currentActor);
 2169 |     |         (success, returnData) =
 2170 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getLowestSeedToken.selector));
 2171 |     |     }
 2172 |     | 
 2173 |     |     function _getUserDepositedTokensCall(address _input1) internal returns (bool success, bytes memory returnData) {
 2174 |     | 
 2175 |     |         vm.prank(currentActor);
 2176 |     |         (success, returnData) =
 2177 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getUserDepositedTokens.selector, _input1));
 2178 |     |     }
 2179 |     | 
 2180 |     |     function _getUserDepositedTokensCall(address _input1, address _input2, uint256 _input3, int96 _input4, LibTractorHelpers.WithdrawalPlan memory _input5) internal returns (bool success, bytes memory returnData) {
 2181 |     | 
 2182 |     |         vm.prank(currentActor);
 2183 |     |         (success, returnData) =
 2184 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getUserDepositedTokens.selector, _input1, _input2, _input3, _input4, _input5));
 2185 |     |     }
 2186 |     | 
 2187 |     |     function _getDepositStemsAndAmountsToWithdrawCall(address _input1, address _input2, uint256 _input3, int96 _input4, LibTractorHelpers.WithdrawalPlan memory _input5) internal returns (bool success, bytes memory returnData) {
 2188 |     | 
 2189 |     |         vm.prank(currentActor);
 2190 |     |         (success, returnData) =
 2191 |     |             address(tractorHelpers).call(abi.encodeWithSelector(0x0338e83e, _input1, _input2, _input3, _input4, _input5));
 2192 |     |     }
 2193 |     | 
 2194 |     |     function _getDepositStemsAndAmountsToWithdrawCall(address _input1, address _input2, uint256 _input3, int96 _input4) internal returns (bool success, bytes memory returnData) {
 2195 |     | 
 2196 |     |         vm.prank(currentActor);
 2197 |     |         (success, returnData) =
 2198 |     |             address(tractorHelpers).call(abi.encodeWithSelector(0x3d29d115, _input1, _input2, _input3, _input4));
 2199 |     |     }
 2200 |     | 
 2201 |     |     // function _getAddressAndStemCall(uint256 _input1) internal returns (bool success, bytes memory returnData) {
 2202 |     | 
 2203 |     |     //     vm.prank(currentActor);
 2204 |     |     //     (success, returnData) =
 2205 |     |     //         address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getAddressAndStem.selector, _input1));
 2206 |     |     // }
 2207 |     | 
 2208 |     |     function _getLPTokensToWithdrawForBeansCall(uint256 _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 2209 |     | 
 2210 |     |         vm.prank(currentActor);
 2211 |     |         (success, returnData) =
 2212 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getLPTokensToWithdrawForBeans.selector, _input1, _input2));
 2213 |     |     }
 2214 |     | 
 2215 |     |     function _getTokensAscendingSeedsCall() internal returns (bool success, bytes memory returnData) {
 2216 |     | 
 2217 |     |         vm.prank(currentActor);
 2218 |     |         (success, returnData) =
 2219 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getTokensAscendingSeeds.selector));
 2220 |     |     }
 2221 |     | 
 2222 |     |     function _getTokensAscendingPriceCall() internal returns (bool success, bytes memory returnData) {
 2223 |     | 
 2224 |     |         vm.prank(currentActor);
 2225 |     |         (success, returnData) =
 2226 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getTokensAscendingPrice.selector));
 2227 |     |     }
 2228 |     | 
 2229 |     |     function _getSortedDepositsCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 2230 |     | 
 2231 |     |         vm.prank(currentActor);
 2232 |     |         (success, returnData) =
 2233 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getSortedDeposits.selector, _input1, _input2));
 2234 |     |     }
 2235 |     | 
 2236 |     |     function _getBeanAmountAvailableCall(address _input1, address _input2) internal returns (bool success, bytes memory returnData) {
 2237 |     | 
 2238 |     |         vm.prank(currentActor);
 2239 |     |         (success, returnData) =
 2240 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getBeanAmountAvailable.selector, _input1, _input2));
 2241 |     |     }
 2242 |     | 
 2243 |     |     function _getTokenIndexCall(address _input1) internal returns (bool success, bytes memory returnData) {
 2244 |     | 
 2245 |     |         vm.prank(currentActor);
 2246 |     |         (success, returnData) =
 2247 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getTokenIndex.selector, _input1));
 2248 |     |     }
 2249 |     | 
 2250 |     |     function _tipCall(address _input1, address _input2, address _input3, int256 _input4, LibTransfer.From _input5, LibTransfer.To _input6) internal returns (bool success, bytes memory returnData) {
 2251 |     | 
 2252 |     |         vm.prank(currentActor);
 2253 |     |         (success, returnData) =
 2254 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.tip.selector, _input1, _input2, _input3, _input4, _input5, _input6));
 2255 |     |     }
 2256 |     | 
 2257 |     |     function _isOperatorWhitelistedCall(address[] calldata _input1) internal returns (bool success, bytes memory returnData) {
 2258 |     | 
 2259 |     |         vm.prank(currentActor);
 2260 |     |         (success, returnData) =
 2261 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.isOperatorWhitelisted.selector, _input1));
 2262 |     |     }
 2263 |     | 
 2264 |     |     function _combineWithdrawalPlansCall(LibTractorHelpers.WithdrawalPlan[] memory _input1) internal returns (bool success, bytes memory returnData) {
 2265 |     | 
 2266 |     |         vm.prank(currentActor);
 2267 |     |         (success, returnData) =
 2268 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.combineWithdrawalPlans.selector, _input1));
 2269 |     |     }
 2270 |     | 
 2271 |     |     function _getWhitelistStatusAddressesCall() internal returns (bool success, bytes memory returnData) {
 2272 |     | 
 2273 |     |         vm.prank(currentActor);
 2274 |     |         (success, returnData) =
 2275 |     |             address(tractorHelpers).call(abi.encodeWithSelector(TractorHelpers.getWhitelistStatusAddresses.selector));
 2276 |     |     }
 2277 |     | 
 2278 |     | 
 2279 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/utils/FuzzActors.sol
  1 |     | // SPDX-License-Identifier: UNTITLED
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@perimetersec/fuzzlib/src/FuzzBase.sol";
  5 |     | import "forge-std/Test.sol";
  6 |     | 
  7 |     | contract FuzzActors is FuzzBase, Test {
  8 |     |     address internal constant owner = address(0xfffff);
  9 |     | 
 10 | *   |     address internal constant USER1 = address(0x10000);
 11 | *   |     address internal constant USER2 = address(0x20000);
 12 | *   |     address internal constant USER3 = address(0x30000);
 13 | *   |     address internal constant ADMIN = address(0xB055);
 14 |     | 
 15 | *   |     address[] internal USERS = [USER1, USER2, USER3];
 16 |     | }

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/fuzzing/utils/FuzzConstants.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract FuzzConstants {
  5 |     |     // ==============================================================
  6 |     |     // ERC20 v4.9 ERRORS
  7 |     |     // ==============================================================
  8 |     |     bytes internal constant EXCEEDS_BALANCE_ERROR =
  9 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: transfer amount exceeds balance");
 10 |     |     bytes internal constant INSUFFICIENT_ALLOWANCE =
 11 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: insufficient allowance");
 12 |     |     bytes internal constant TRANSFER_FROM_ZERO =
 13 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: transfer from the zero address");
 14 |     |     bytes internal constant TRANSFER_TO_ZERO =
 15 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: transfer to the zero address");
 16 |     |     bytes internal constant APPROVE_TO_ZERO =
 17 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: approve to the zero address");
 18 |     |     bytes internal constant MINT_TO_ZERO =
 19 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: mint to the zero address");
 20 |     |     bytes internal constant BURN_FROM_ZERO =
 21 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: burn from the zero address");
 22 |     |     bytes internal constant DECREASED_ALLOWANCE =
 23 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: decreased allowance below zero");
 24 |     |     bytes internal constant BURN_EXCEEDS_BALANCE =
 25 | *   |         abi.encodeWithSelector(bytes4(keccak256("Error(string)")), "ERC20: burn amount exceeds balance");
 26 |     | 
 27 |     |     // ==============================================================
 28 |     |     // PANIC CODES
 29 |     |     // ==============================================================
 30 |     |     uint256 internal constant PANIC_GENERAL = 0x00;
 31 |     |     uint256 internal constant PANIC_ASSERT = 0x01;
 32 |     |     uint256 internal constant PANIC_ARITHMETIC = 0x11;
 33 |     |     uint256 internal constant PANIC_DIVISION_BY_ZERO = 0x12;
 34 |     |     uint256 internal constant PANIC_ENUM_OUT_OF_BOUNDS = 0x21;
 35 |     |     uint256 internal constant PANIC_STORAGE_BYTES_ARRAY_ENCODING = 0x22;
 36 |     |     uint256 internal constant PANIC_POP_EMPTY_ARRAY = 0x31;
 37 |     |     uint256 internal constant PANIC_ARRAY_OUT_OF_BOUNDS = 0x32;
 38 |     |     uint256 internal constant PANIC_ALLOC_TOO_MUCH_MEMORY = 0x41;
 39 |     |     uint256 internal constant PANIC_ZERO_INIT_INTERNAL_FUNCTION = 0x51;
 40 |     | }
 41 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/utils/BasinDeployer.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | pragma solidity ^0.8.20;
   5 |     | pragma abicoder v2;
   6 |     | 
   7 |     | import {Utils, console} from "test/foundry/utils/Utils.sol";
   8 |     | 
   9 |     | ////// INTERFACES //////
  10 |     | import {Call, IAquifer} from "contracts/interfaces/basin/IAquifer.sol";
  11 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  12 |     | import {MockPump} from "contracts/mocks/well/MockPump.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @title BasinDeployer
  16 |     |  * @notice Test helper contract for Beanstalk tests.
  17 |     |  */
  18 |     | contract BasinDeployer is Utils {
  19 |     |     struct DeployData {
  20 |     |         string name;
  21 |     |         address functionAddress;
  22 |     |         bytes constructorData;
  23 |     |     }
  24 |     | 
  25 |     |     struct DeployWellData {
  26 |     |         address[] tokens;
  27 |     |         Call wellFunction;
  28 |     |         Call[] pumps;
  29 |     |     }
  30 |     | 
  31 |     |     // pump constants
  32 |     |     bytes16 constant ALPHA = bytes16(0x3ffeef368eb04325c526c2246eec3e55);
  33 |     |     uint256 constant CAP_INTERVAL = 12;
  34 |     |     bytes16 constant MAX_LP_SUPPLY_INCREASE = bytes16(0x3ff50624dd2f1a9fbe76c8b439581062);
  35 |     |     bytes16 constant MAX_LP_SUPPLY_DECREASE = bytes16(0x3ff505e1d27a3ee9bffd7f3dd1a32671);
  36 |     | 
  37 |     |     // core Basin + components constants.
  38 |     |     address constant AQUIFER = address(0xBA51AAAA95aeEFc1292515b36D86C51dC7877773);
  39 |     |     address constant CP2 = address(0xBA510C20FD2c52E4cb0d23CFC3cCD092F9165a6E);
  40 |     |     address constant MFP = address(0xBA510f10E3095B83a0F33aa9ad2544E22570a87C);
  41 |     |     address constant WELL_IMPLMENTATION = address(0xBA510e11eEb387fad877812108a3406CA3f43a4B);
  42 |     | 
  43 |     |     // addresses reflect wells deployed on arbitrum
  44 |     |     address constant BEAN_USDC_WELL = address(0xBea00ee04D8289aEd04f92EA122a96dC76A91bd7);
  45 |     |     address constant BEAN_USDT_WELL = address(0xbEA00fF437ca7E8354B174339643B4d1814bED33);
  46 |     |     address constant BEAN_WBTC_WELL = address(0xBea00DDe4b34ACDcB1a30442bD2B39CA8Be1b09c);
  47 |     | 
  48 |     |     string constant BEAN_WETH_WELL_NAME = "BEAN:WETH Constant Product 2 Well";
  49 |     |     string constant BEAN_WETH_WELL_SYMBOL = "BEANWETHCP2w";
  50 |     | 
  51 |     |     // a list of well functions, pumps, and well implementations.
  52 |     |     address public aquifer;
  53 |     | 
  54 |     |     address[] public wellFunctions;
  55 |     |     address[] public pumps;
  56 |     |     address[] public wellImplementations;
  57 |     |     address[] public wells;
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice deploys basin and initlizes wells.
  61 |     |      * @dev deploys the Aquifer, ConstantProduct2, MultiFlowPump, and Well implementation,
  62 |     |      * at current mainnet addresses.
  63 |     |      */
  64 |     |     function initBasin(bool mock, bool verbose) internal {
  65 |     |         if (verbose) console.log("deploying Basin...");
  66 |     |         deployBasin(verbose);
  67 |     | 
  68 |     |         if (verbose) console.log("deploying Wells...");
  69 |     |         deployWells(mock, verbose);
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @notice deploys the basin contracts.
  74 |     |      * @dev new well functions, pumps, and well implementations should be appended.
  75 |     |      */
  76 |     |     function deployBasin(bool verbose) internal {
  77 |     |         // new well functions should be added here.
  78 |     |         DeployData[] memory wfDeployData = new DeployData[](1);
  79 |     |         wfDeployData[0] = DeployData(
  80 |     |             "./node_modules/@beanstalk/wells1.2/out/ConstantProduct2.sol/ConstantProduct2.json",
  81 |     |             CP2,
  82 |     |             new bytes(0)
  83 |     |         );
  84 |     | 
  85 |     |         // new multiFlowPumps should be added here.
  86 |     |         DeployData[] memory pumpsDeployData = new DeployData[](2);
  87 |     |         // multi flow pump
  88 |     |         pumpsDeployData[0] = DeployData(
  89 |     |             "./node_modules/@beanstalk/wells1.2/out/MultiFlowPump.sol/MultiFlowPump.json",
  90 |     |             MFP,
  91 |     |             abi.encode(MAX_LP_SUPPLY_INCREASE, MAX_LP_SUPPLY_DECREASE, CAP_INTERVAL, ALPHA)
  92 |     |         );
  93 |     |         // mock pump for testing purposes.
  94 |     |         pumpsDeployData[1] = DeployData("MockPump.sol", address(0), new bytes(0));
  95 |     | 
  96 |     |         // new well implementations should be added here.
  97 |     |         DeployData[] memory wellImplementationDeployData = new DeployData[](1);
  98 |     |         wellImplementationDeployData[0] = DeployData(
  99 |     |             "./node_modules/@beanstalk/wells1.2/out/Well.sol/Well.json",
 100 |     |             WELL_IMPLMENTATION,
 101 |     |             new bytes(0)
 102 |     |         );
 103 |     | 
 104 |     |         _deployBasin(
 105 |     |             AQUIFER, // aquifer
 106 |     |             wfDeployData, // well functions
 107 |     |             pumpsDeployData, // pumps
 108 |     |             wellImplementationDeployData, // well implementations
 109 |     |             verbose
 110 |     |         );
 111 |     |     }
 112 |     | 
 113 |     |     /**
 114 |     |      * @notice deploys basin contracts, and adds to the registry.
 115 |     |      */
 116 |     |     function _deployBasin(
 117 |     |         address aquiferAddress,
 118 |     |         DeployData[] memory wfData,
 119 |     |         DeployData[] memory pumpData,
 120 |     |         DeployData[] memory wellImplementationData,
 121 |     |         bool verbose
 122 |     |     ) internal {
 123 |     |         // deploy Aquifier.
 124 |     |         deployCodeTo(
 125 |     |             "./node_modules/@beanstalk/wells/out/Aquifer.sol/Aquifer.json",
 126 |     |             aquiferAddress
 127 |     |         );
 128 |     |         if (verbose) console.log("Aquifer Deployed at:", aquiferAddress);
 129 |     |         aquifer = aquiferAddress;
 130 |     | 
 131 |     |         // deploy well functions.
 132 |     |         if (verbose) console.log("deploying well functions:");
 133 |     |         for (uint i; i < wfData.length; ++i) {
 134 |     |             wellFunctions.push(deployCodeWithArgs(wfData[i]));
 135 |     |             if (verbose) console.log("WellFunction", i, "Deployed at:", wellFunctions[i]);
 136 |     |         }
 137 |     | 
 138 |     |         // deploy pumps
 139 |     |         if (verbose) console.log("deploying pump:");
 140 |     |         for (uint i; i < pumpData.length; i++) {
 141 |     |             pumps.push(deployCodeWithArgs(pumpData[i]));
 142 |     |             if (verbose) console.log("Pump", i, "Deployed at:", pumps[i]);
 143 |     |         }
 144 |     | 
 145 |     |         // deploy implementations
 146 |     |         if (verbose) console.log("deploying well implm:");
 147 |     |         for (uint i; i < wellImplementationData.length; i++) {
 148 |     |             wellImplementations.push(deployCodeWithArgs(wellImplementationData[i]));
 149 |     |             if (verbose) console.log("Well Implm", i, "Deployed at:", wellImplementations[i]);
 150 |     |         }
 151 |     | 
 152 |     |         // optional labels for testing.
 153 |     |         vm.label(CP2, "Constant Product 2");
 154 |     |         vm.label(MFP, "MultiFlowPump");
 155 |     |         vm.label(pumps[1], "MockPump");
 156 |     |         vm.label(wellImplementations[0], "well");
 157 |     |     }
 158 |     | 
 159 |     |     /**
 160 |     |      * @notice deploy wells for beanstalk.
 161 |     |      * @dev new wells should be added here.
 162 |     |      * @param mock if true, deploys wells with mock pump (for testing purposes).
 163 |     |      */
 164 |     |     function deployWells(bool mock, bool verbose) internal {
 165 |     |         address _pump;
 166 |     | 
 167 |     |         if (mock) {
 168 |     |             // mock pump.
 169 |     |             _pump = pumps[1];
 170 |     |         } else {
 171 |     |             // multi flow pump.
 172 |     |             _pump = pumps[0];
 173 |     |         }
 174 |     | 
 175 |     |         // deploy bean eth well:
 176 |     |         wells.push(deployBeanCp2Well([BEAN_ETH_WELL, WETH], _pump));
 177 |     |         if (verbose) console.log("Bean Eth well deployed at:", wells[0]);
 178 |     |         vm.label(BEAN_ETH_WELL, "BEAN/ETH Well");
 179 |     | 
 180 |     |         // deploy bean wsteth well:
 181 |     |         wells.push(deployBeanCp2Well([BEAN_WSTETH_WELL, WSTETH], _pump));
 182 |     |         if (verbose) console.log("Bean wstEth well deployed at:", wells[1]);
 183 |     |         vm.label(BEAN_WSTETH_WELL, "BEAN/WSTETH Well");
 184 |     |     }
 185 |     | 
 186 |     |     function deployExtraWells(bool mock, bool verbose) internal {
 187 |     |         address _pump;
 188 |     | 
 189 |     |         if (mock) {
 190 |     |             // mock pump.
 191 |     |             _pump = pumps[1];
 192 |     |         } else {
 193 |     |             // multi flow pump.
 194 |     |             _pump = pumps[0];
 195 |     |         }
 196 |     | 
 197 |     |         // deploy Bean USDC well:
 198 |     |         wells.push(deployBeanCp2Well([BEAN_USDC_WELL, USDC], _pump));
 199 |     |         if (verbose) console.log("Bean USDC well deployed at:", wells[0]);
 200 |     |         vm.label(BEAN_USDC_WELL, "BEAN/USDC Well");
 201 |     | 
 202 |     |         // deploy Bean USDT well:
 203 |     |         wells.push(deployBeanCp2Well([BEAN_USDT_WELL, USDT], _pump));
 204 |     |         if (verbose) console.log("Bean USDT well deployed at:", wells[1]);
 205 |     |         vm.label(BEAN_USDT_WELL, "BEAN/USDT Well");
 206 |     |     }
 207 |     | 
 208 |     |     function deployWBTCWellOnFork(bool mock, bool verbose) internal {
 209 |     |         console.log("deploying wbtc well");
 210 |     | 
 211 |     |         // deploy Bean WBTC well:
 212 |     |         // wells.push(deployBeanCp2Well([BEAN_WBTC_WELL, WBTC], _pump));
 213 |     | 
 214 |     |         deployWellAtAddressNoData(
 215 |     |             BEAN_WBTC_WELL,
 216 |     |             BEAN,
 217 |     |             WBTC,
 218 |     |             wellFunctions[0],
 219 |     |             pumps[0], // multi flow pump
 220 |     |             wellImplementations[0]
 221 |     |         );
 222 |     | 
 223 |     |         console.log("deployed wbtc well");
 224 |     |         if (verbose) console.log("Bean WBTC well deployed at:", wells[0]);
 225 |     |         vm.label(BEAN_WBTC_WELL, "BEAN/WBTC Well");
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice deploys a well with a
 230 |     |      * Constant product 2 well function and pump.
 231 |     |      * @param wellAddressAndNonBeanToken [wellAddress, nonBeanToken]
 232 |     |      * @param pump address of the pump.
 233 |     |      */
 234 |     |     function deployBeanCp2Well(
 235 |     |         address[2] memory wellAddressAndNonBeanToken,
 236 |     |         address pump
 237 |     |     ) internal returns (address) {
 238 |     |         // initialize pump with 0 values.
 239 |     |         uint256[] memory _init0 = new uint256[](2);
 240 |     |         MockPump(pump).updateNoBytes(wellAddressAndNonBeanToken[0], _init0);
 241 |     |         return
 242 |     |             deployWellAtAddressNoData(
 243 |     |                 wellAddressAndNonBeanToken[0],
 244 |     |                 BEAN,
 245 |     |                 wellAddressAndNonBeanToken[1],
 246 |     |                 wellFunctions[0],
 247 |     |                 pump,
 248 |     |                 wellImplementations[0]
 249 |     |             );
 250 |     |     }
 251 |     | 
 252 |     |     function deployWellAtAddressNoData(
 253 |     |         address targetAddress,
 254 |     |         address token0,
 255 |     |         address token1,
 256 |     |         address wellFunction,
 257 |     |         address pumpAddress,
 258 |     |         address wellImplementation
 259 |     |     ) internal returns (address) {
 260 |     |         return
 261 |     |             deployWellAtAddress(
 262 |     |                 targetAddress,
 263 |     |                 token0,
 264 |     |                 token1,
 265 |     |                 wellFunction,
 266 |     |                 new bytes(0),
 267 |     |                 pumpAddress,
 268 |     |                 new bytes(0),
 269 |     |                 wellImplementation,
 270 |     |                 bytes32(0)
 271 |     |             );
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @notice deploys a well. If target address is specified,
 276 |     |      * mock deployment is done.
 277 |     |      */
 278 |     |     function deployWellAtAddress(
 279 |     |         address targetAddress,
 280 |     |         address token0,
 281 |     |         address token1,
 282 |     |         address wellFunction,
 283 |     |         bytes memory wellFunctionData,
 284 |     |         address pumpAddress,
 285 |     |         bytes memory pumpData,
 286 |     |         address wellImplementation,
 287 |     |         bytes32 salt
 288 |     |     ) internal returns (address) {
 289 |     |         DeployWellData memory wellEncodedData = getWellParams2Tkn1Pump(
 290 |     |             token0,
 291 |     |             token1,
 292 |     |             wellFunction,
 293 |     |             wellFunctionData,
 294 |     |             pumpAddress,
 295 |     |             pumpData
 296 |     |         );
 297 |     |         string memory wellName = string(
 298 |     |             abi.encodePacked(ERC20(token0).name(), ERC20(token1).name(), "Well")
 299 |     |         );
 300 |     | 
 301 |     |         string memory wellSymbol = string(
 302 |     |             abi.encodePacked(ERC20(token0).name(), ERC20(token1).name(), "Well")
 303 |     |         );
 304 |     |         // Bore Well
 305 |     |         address wellAddress = IAquifer(aquifer).boreWell(
 306 |     |             wellImplementation,
 307 |     |             encodeWellParams(aquifer, wellEncodedData),
 308 |     |             abi.encodeWithSignature("init(string,string)", wellName, wellSymbol),
 309 |     |             salt
 310 |     |         );
 311 |     | 
 312 |     |         // etch to address if specified.
 313 |     |         if (targetAddress != address(0)) {
 314 |     |             vm.etch(targetAddress, wellAddress.code);
 315 |     |             copyContractState(wellAddress, targetAddress);
 316 |     |             return targetAddress;
 317 |     |         } else {
 318 |     |             return wellAddress;
 319 |     |         }
 320 |     |     }
 321 |     | 
 322 |     |     // this copies the first 100 slots of the source contract to the target contract.
 323 |     |     function copyContractState(address source, address target) internal {
 324 |     |         uint256 slot = 0;
 325 |     |         for (uint256 i = 0; i < 100; i++) {
 326 |     |             bytes32 value = vm.load(source, bytes32(slot));
 327 |     |             if (value != bytes32(0)) {
 328 |     |                 vm.store(target, bytes32(slot), value);
 329 |     |             }
 330 |     |             slot++;
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @notice helper function to craft the well parameters for a 2 token, 1 pump well.
 336 |     |      */
 337 |     |     function getWellParams2Tkn1Pump(
 338 |     |         address token0,
 339 |     |         address token1,
 340 |     |         address wellFunction,
 341 |     |         bytes memory wellFunctionData,
 342 |     |         address pump,
 343 |     |         bytes memory pumpDataInPump
 344 |     |     ) internal pure returns (DeployWellData memory wellParameters) {
 345 |     |         address[] memory tokens = new address[](2);
 346 |     |         tokens[0] = token0;
 347 |     |         tokens[1] = token1;
 348 |     |         Call[] memory pumpData = new Call[](1);
 349 |     |         pumpData[0].target = pump;
 350 |     |         pumpData[0].data = pumpDataInPump;
 351 |     |         wellParameters = DeployWellData(tokens, Call(wellFunction, wellFunctionData), pumpData);
 352 |     |     }
 353 |     | 
 354 |     |     /**
 355 |     |      * @notice helper function to encode into bytes.
 356 |     |      */
 357 |     |     function encodeWellParams(
 358 |     |         address _aquifierAddress,
 359 |     |         DeployWellData memory wd
 360 |     |     ) internal pure returns (bytes memory) {
 361 |     |         bytes memory packedPumpData;
 362 |     |         for (uint i; i < wd.pumps.length; i++) {
 363 |     |             Call memory pump = wd.pumps[i];
 364 |     |             packedPumpData = abi.encodePacked(
 365 |     |                 packedPumpData,
 366 |     |                 pump.target,
 367 |     |                 pump.data.length,
 368 |     |                 pump.data
 369 |     |             );
 370 |     |         }
 371 |     |         // encode data:
 372 |     |         return
 373 |     |             abi.encodePacked(
 374 |     |                 _aquifierAddress,
 375 |     |                 wd.tokens.length,
 376 |     |                 wd.wellFunction.target,
 377 |     |                 wd.wellFunction.data.length,
 378 |     |                 wd.pumps.length,
 379 |     |                 wd.tokens,
 380 |     |                 wd.wellFunction.data,
 381 |     |                 packedPumpData
 382 |     |             );
 383 |     |     }
 384 |     | 
 385 |     |     /**
 386 |     |      * @notice deploys a contract at the specified address.
 387 |     |      * @dev if no address is specified, deploys to a new address.
 388 |     |      */
 389 |     |     function deployCodeWithArgs(DeployData memory dData) internal returns (address) {
 390 |     |         if (dData.functionAddress != address(0)) {
 391 |     |             deployCodeTo(dData.name, dData.constructorData, dData.functionAddress);
 392 |     |             return dData.functionAddress;
 393 |     |         } else {
 394 |     |             return deployCode(dData.name);
 395 |     |         }
 396 |     |     }
 397 |     | }
 398 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/utils/BeanstalkDeployer.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  */
   4 |     | pragma solidity ^0.8.20;
   5 |     | pragma abicoder v2;
   6 |     | 
   7 |     | import {Utils, console} from "test/foundry/utils/Utils.sol";
   8 |     | 
   9 |     | // Diamond setup
  10 |     | import {Diamond} from "contracts/beanstalk/Diamond.sol";
  11 |     | import {IDiamondCut} from "contracts/interfaces/IDiamondCut.sol";
  12 |     | import {MockInitDiamond} from "contracts/mocks/newMockInitDiamond.sol";
  13 |     | import {InitDiamond} from "contracts/beanstalk/init/newInitDiamond.sol";
  14 |     | import {DiamondLoupeFacet} from "contracts/beanstalk/facets/diamond/DiamondLoupeFacet.sol";
  15 |     | 
  16 |     | /// Beanstalk Contracts w/external libraries.
  17 |     | import {MockAttackFacet} from "contracts/mocks/mockFacets/MockAttackFacet.sol";
  18 |     | import {MockConvertFacet, ConvertFacet} from "contracts/mocks/mockFacets/MockConvertFacet.sol";
  19 |     | import {MockSeasonFacet, SeasonFacet} from "contracts/mocks/mockFacets/MockSeasonFacet.sol";
  20 |     | import {MockSiloFacet, SiloFacet} from "contracts/mocks/mockFacets/MockSiloFacet.sol";
  21 |     | import {MockPipelineConvertFacet, PipelineConvertFacet} from "contracts/mocks/mockFacets/MockPipelineConvertFacet.sol";
  22 |     | import {MockWhitelistFacet, WhitelistFacet} from "contracts/mocks/mockFacets/MockWhitelistFacet.sol";
  23 |     | import {MockFieldFacet, FieldFacet} from "contracts/mocks/mockFacets/MockFieldFacet.sol";
  24 |     | import {SeasonGettersFacet} from "contracts/beanstalk/facets/sun/SeasonGettersFacet.sol";
  25 |     | import {DiamondCutFacet} from "contracts/beanstalk/facets/diamond/DiamondCutFacet.sol";
  26 |     | import {IDiamondLoupe} from "contracts/interfaces/IDiamondLoupe.sol";
  27 |     | 
  28 |     | import {IMockFBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
  29 |     | import "forge-std/console.sol";
  30 |     | 
  31 |     | /**
  32 |     |  * @title TestHelper
  33 |     |  * @notice Test helper contract for Beanstalk tests.
  34 |     |  */
  35 |     | contract BeanstalkDeployer is Utils {
  36 |     |     // add or remove facets here. Facets here do not have mocks.
  37 |     |     string[] facets = [
  38 |     |         "BDVFacet",
  39 |     |         "FarmFacet",
  40 |     |         "PauseFacet",
  41 |     |         "OwnershipFacet",
  42 |     |         "TokenFacet",
  43 |     |         "TokenSupportFacet",
  44 |     |         "GaugeFacet",
  45 |     |         "LiquidityWeightFacet",
  46 |     |         "SiloGettersFacet",
  47 |     |         "ConvertGettersFacet",
  48 |     |         "MetadataFacet",
  49 |     |         "DepotFacet",
  50 |     |         "MarketplaceFacet",
  51 |     |         "ClaimFacet",
  52 |     |         "OracleFacet",
  53 |     |         "GaugeGettersFacet",
  54 |     |         "TractorFacet"
  55 |     |     ];
  56 |     | 
  57 |     |     // Facets that have a mock counter part should be appended here.
  58 |     |     string[] mockFacets = [
  59 |     |         "FieldFacet", // MockFieldFacet
  60 |     |         "WhitelistFacet", // MockWhitelistFacet
  61 |     |         "SiloFacet", // MockSiloFacet
  62 |     |         "ConvertFacet", // MockConvertFacet
  63 |     |         "SeasonFacet", // MockSeasonFacet
  64 |     |         "PipelineConvertFacet", // MockPipelineConvertFacet
  65 |     |         "SeasonGettersFacet" // MockSeasonGettersFacet
  66 |     |     ];
  67 |     |     address[] initialDeployFacetAddresses;
  68 |     |     string[] initialDeploFacetNames;
  69 |     |     address[] upgradeFacetAddresses;
  70 |     |     string[] upgradeFacetNames;
  71 |     | 
  72 |     |     IDiamondCut.FacetCutAction[] cutActions;
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice deploys the beanstalk diamond contract.
  76 |     |      * @param mock if true, deploys all mocks and sets the diamond address to the canonical beanstalk address.
  77 |     |      */
  78 |     |     function setupDiamond(bool mock, bool verbose) internal returns (Diamond d) {
  79 |     |         users = createUsers(6);
  80 |     |         deployer = users[0];
  81 |     |         vm.label(deployer, "Deployer");
  82 |     |         vm.label(BEANSTALK, "Beanstalk");
  83 |     | 
  84 |     |         // Create cuts.
  85 |     |         setupFacetAddresses(mock, true, false);
  86 |     | 
  87 |     |         IDiamondCut.FacetCut[] memory cut = _multiCut(
  88 |     |             initialDeploFacetNames,
  89 |     |             initialDeployFacetAddresses,
  90 |     |             cutActions
  91 |     |         );
  92 |     |         d = deployDiamondAtAddress(deployer, BEANSTALK);
  93 |     | 
  94 |     |         // if mocking, set the diamond address to
  95 |     |         // the canonical beanstalk address.
  96 |     |         address initDiamondAddress;
  97 |     |         if (mock) {
  98 |     |             initDiamondAddress = address(new MockInitDiamond());
  99 |     |         } else {
 100 |     |             initDiamondAddress = address(new InitDiamond());
 101 |     |         }
 102 |     | 
 103 |     |         vm.prank(deployer);
 104 |     |         IDiamondCut(address(d)).diamondCut(
 105 |     |             cut,
 106 |     |             initDiamondAddress,
 107 |     |             abi.encodeWithSignature("init()")
 108 |     |         );
 109 |     | 
 110 |     |         if (verbose) console.log("Diamond deployed at: ", address(d));
 111 |     |     }
 112 |     | 
 113 |     |     function setupFacetAddresses(bool mock, bool attack, bool includeUpgradeFacetsOnly) internal {
 114 |     |         address[] memory facetAddresses = new address[](100);
 115 |     |         string[] memory facetNames = new string[](100);
 116 |     | 
 117 |     |         uint256 facetCounter;
 118 |     | 
 119 |     |         // Facets that require external libraries need to be deployed by
 120 |     |         // `address(new Facet())`
 121 |     |         // otherwise, use deployCode() to speed up test compiles.
 122 |     |         for (uint256 i; i < facets.length; i++) {
 123 |     |             // for facets with external libraries, deploy the facet,
 124 |     |             // rather than deploying using the bytecode.
 125 |     |             string memory facetName = facets[i];
 126 |     | 
 127 |     |             if (
 128 |     |                 includeUpgradeFacetsOnly &&
 129 |     |                 (keccak256(abi.encodePacked(facetName)) ==
 130 |     |                     keccak256(abi.encodePacked("OwnershipFacet")) ||
 131 |     |                     keccak256(abi.encodePacked(facetName)) ==
 132 |     |                     keccak256(abi.encodePacked("PauseFacet")) ||
 133 |     |                     keccak256(abi.encodePacked(facetName)) ==
 134 |     |                     keccak256(abi.encodePacked("DiamondCutFacet")))
 135 |     |             ) {
 136 |     |                 continue;
 137 |     |             }
 138 |     | 
 139 |     |             if (keccak256(abi.encode(facetName)) == keccak256(abi.encode("SeasonGettersFacet"))) {
 140 |     |                 facetAddresses[facetCounter++] = address(new SeasonGettersFacet());
 141 |     |             } else {
 142 |     |                 facetAddresses[facetCounter++] = address(deployCode(facetName));
 143 |     |             }
 144 |     | 
 145 |     |             cutActions.push(IDiamondCut.FacetCutAction.Add);
 146 |     |             // facetNames.push(facetName);
 147 |     |             facetNames[facetCounter - 1] = facetName;
 148 |     |         }
 149 |     | 
 150 |     |         // Deploy mock only facets.
 151 |     |         if (mock && attack) {
 152 |     |             // facetAddresses.push(address(new MockAttackFacet()));
 153 |     |             facetAddresses[facetCounter++] = address(new MockAttackFacet());
 154 |     |             cutActions.push(IDiamondCut.FacetCutAction.Add);
 155 |     |             facetNames[facetCounter - 1] = "MockAttackFacet";
 156 |     |         }
 157 |     | 
 158 |     |         for (uint256 i; i < mockFacets.length; i++) {
 159 |     |             // for facets with external libraries, deploy the facet,
 160 |     |             // rather than deploying using the bytecode.
 161 |     |             string memory facet = mockFacets[i];
 162 |     |             // append "Mock" to the facet name.
 163 |     |             if (mock) facet = string(abi.encodePacked("Mock", facet));
 164 |     |             // Facets with an external library should be placed here.
 165 |     |             bytes32 hashedName = keccak256(abi.encode(mockFacets[i]));
 166 |     |             address facetAddress;
 167 |     |             if (hashedName == keccak256(abi.encode("ConvertFacet"))) {
 168 |     |                 if (mock) {
 169 |     |                     facetAddress = address(new MockConvertFacet());
 170 |     |                 } else {
 171 |     |                     facetAddress = address(new ConvertFacet());
 172 |     |                 }
 173 |     |             } else if (hashedName == keccak256(abi.encode("SeasonFacet"))) {
 174 |     |                 if (mock) {
 175 |     |                     facetAddress = address(new MockSeasonFacet());
 176 |     |                 } else {
 177 |     |                     facetAddress = address(new SeasonFacet());
 178 |     |                 }
 179 |     |             } else if (hashedName == keccak256(abi.encode("WhitelistFacet"))) {
 180 |     |                 if (mock) {
 181 |     |                     facetAddress = address(new MockWhitelistFacet());
 182 |     |                 } else {
 183 |     |                     facetAddress = address(new WhitelistFacet());
 184 |     |                 }
 185 |     |             } else if (hashedName == keccak256(abi.encode("FieldFacet"))) {
 186 |     |                 if (mock) {
 187 |     |                     facetAddress = address(new MockFieldFacet());
 188 |     |                 } else {
 189 |     |                     facetAddress = address(new FieldFacet());
 190 |     |                 }
 191 |     |             } else if (hashedName == keccak256(abi.encode("SiloFacet"))) {
 192 |     |                 if (mock) {
 193 |     |                     facetAddress = address(new MockSiloFacet());
 194 |     |                 } else {
 195 |     |                     facetAddress = address(new SiloFacet());
 196 |     |                 }
 197 |     |             } else if (hashedName == keccak256(abi.encode("PipelineConvertFacet"))) {
 198 |     |                 if (mock) {
 199 |     |                     facetAddress = address(new MockPipelineConvertFacet());
 200 |     |                 } else {
 201 |     |                     facetAddress = address(new PipelineConvertFacet());
 202 |     |                 }
 203 |     |             } else {
 204 |     |                 facetAddress = address(deployCode(facet));
 205 |     |             }
 206 |     | 
 207 |     |             facetAddresses[facetCounter++] = facetAddress;
 208 |     | 
 209 |     |             cutActions.push(IDiamondCut.FacetCutAction.Add);
 210 |     |             facetNames[facetCounter - 1] = facet;
 211 |     |         }
 212 |     | 
 213 |     |         // update array lengths
 214 |     |         assembly {
 215 |     |             mstore(facetAddresses, facetCounter)
 216 |     |             mstore(facetNames, facetCounter)
 217 |     |         }
 218 |     | 
 219 |     |         if (includeUpgradeFacetsOnly) {
 220 |     |             upgradeFacetAddresses = facetAddresses;
 221 |     |             upgradeFacetNames = facetNames;
 222 |     |         } else {
 223 |     |             initialDeployFacetAddresses = facetAddresses;
 224 |     |             initialDeploFacetNames = facetNames;
 225 |     |         }
 226 |     |     }
 227 |     | 
 228 |     |     /**
 229 |     |      * @notice upgrades a diamond contract with new facets.
 230 |     |      * @param diamondAddress the address of the diamond contract.
 231 |     |      * @param newFacetNames the names of the new facets. Used to generate selectors.
 232 |     |      * @param newFacetAddresses the addresses of the new facets.
 233 |     |      * @param initAddress the address of the init diamond contract.
 234 |     |      * @param selectorsToRemove the selectors to remove.
 235 |     |      * .
 236 |     |      * @dev the hardhat deploy script should be used when deploying to mainnet.
 237 |     |      * This is used in the scope of testing.
 238 |     |      */
 239 |     |     function upgradeWithNewFacets(
 240 |     |         address diamondAddress,
 241 |     |         address diamondOwner,
 242 |     |         string[] memory newFacetNames,
 243 |     |         address[] memory newFacetAddresses,
 244 |     |         IDiamondCut.FacetCutAction[] memory actions,
 245 |     |         address initAddress,
 246 |     |         bytes memory initFunctionCall,
 247 |     |         bytes4[] memory selectorsToRemove
 248 |     |     ) internal {
 249 |     |         vm.startPrank(diamondOwner);
 250 |     | 
 251 |     |         // create facet cuts
 252 |     |         IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](newFacetNames.length + 1);
 253 |     | 
 254 |     |         // generate cut for new facets:
 255 |     |         cut = _multiCutWithSelectorRemovals(
 256 |     |             newFacetNames,
 257 |     |             newFacetAddresses,
 258 |     |             actions,
 259 |     |             selectorsToRemove
 260 |     |         );
 261 |     | 
 262 |     |         // call diamondcut
 263 |     |         IDiamondCut(diamondAddress).diamondCut(cut, initAddress, initFunctionCall);
 264 |     |         vm.stopPrank();
 265 |     |     }
 266 |     | 
 267 |     |     // useful for debugging which facets are erroring by adding logs to LibDiamond and deploying after forking
 268 |     |     /*function upgradeDiamondFacet() internal {
 269 |     |         string[] memory _facetNames = new string[](1);
 270 |     |         _facetNames[0] = "DiamondCutFacet";
 271 |     |         address[] memory newFacetAddresses = new address[](1);
 272 |     |         newFacetAddresses[0] = address(new DiamondCutFacet());
 273 |     | 
 274 |     |         IDiamondCut.FacetCutAction[] memory facetCutActions = new IDiamondCut.FacetCutAction[](1);
 275 |     |         facetCutActions[0] = IDiamondCut.FacetCutAction.Replace;
 276 |     | 
 277 |     |         // upgrade just the diamond cut facet
 278 |     |         upgradeWithNewFacets(
 279 |     |             BEANSTALK, // upgrading beanstalk.
 280 |     |             IMockFBeanstalk(BEANSTALK).owner(), // fetch beanstalk owner.
 281 |     |             _facetNames,
 282 |     |             newFacetAddresses,
 283 |     |             facetCutActions,
 284 |     |             address(new EmptyInitContract()),
 285 |     |             abi.encodeWithSignature("init()"), // call init.
 286 |     |             new bytes4[](0)
 287 |     |         );
 288 |     |     }*/
 289 |     | 
 290 |     |     function forkMainnetAndUpgradeAllFacets(
 291 |     |         uint256 blockNumber,
 292 |     |         string memory forkingUrl,
 293 |     |         address beanstalkAddress
 294 |     |     ) internal {
 295 |     |         forkMainnetAndUpgradeAllFacets(blockNumber, forkingUrl, beanstalkAddress, "");
 296 |     |     }
 297 |     | 
 298 |     |     /**
 299 |     |      * @notice Forks mainnet at a given block,
 300 |     |      */
 301 |     |     function forkMainnetAndUpgradeAllFacets(
 302 |     |         uint256 blockNumber,
 303 |     |         string memory forkingUrl,
 304 |     |         address beanstalkAddress,
 305 |     |         string memory initContractName
 306 |     |     ) internal {
 307 |     |         vm.createSelectFork(forkingUrl, blockNumber);
 308 |     | 
 309 |     |         setupFacetAddresses(true, false, true);
 310 |     | 
 311 |     |         // Deploy the init contract if a name is provided
 312 |     |         address initAddress = address(0);
 313 |     |         bytes memory initData = new bytes(0);
 314 |     | 
 315 |     |         if (bytes(initContractName).length > 0) {
 316 |     |             // Deploy the initialization contract
 317 |     |             initAddress = address(deployCode(initContractName));
 318 |     |             initData = abi.encodeWithSignature("init()");
 319 |     |         }
 320 |     | 
 321 |     |         // upgradeDiamondFacet();
 322 |     | 
 323 |     |         // the idea is to add/upgrade all the facets/mock facets that are in the constants at the top of this file
 324 |     |         // get the list of all current selectors
 325 |     |         IDiamondLoupe.Facet[] memory currentFacets = IDiamondLoupe(beanstalkAddress).facets();
 326 |     |         bytes4[] memory currentSelectors = new bytes4[](1000);
 327 |     |         uint256 selectorsCounter = 0;
 328 |     |         for (uint256 i = 0; i < currentFacets.length; i++) {
 329 |     |             // loop through all selectors in the facet
 330 |     |             bytes4[] memory selectors = IDiamondLoupe(beanstalkAddress).facetFunctionSelectors(
 331 |     |                 currentFacets[i].facetAddress
 332 |     |             );
 333 |     |             for (uint256 j = 0; j < selectors.length; j++) {
 334 |     |                 // add the selector to the currentSelectors array
 335 |     |                 currentSelectors[selectorsCounter++] = selectors[j];
 336 |     |             }
 337 |     |         }
 338 |     |         assembly {
 339 |     |             mstore(currentSelectors, selectorsCounter)
 340 |     |         }
 341 |     | 
 342 |     |         // generated list of all the new facets
 343 |     |         IDiamondLoupe.Facet[] memory newFacets = new IDiamondLoupe.Facet[](
 344 |     |             upgradeFacetAddresses.length
 345 |     |         );
 346 |     | 
 347 |     |         uint256 facetAddressesLength = upgradeFacetAddresses.length;
 348 |     | 
 349 |     |         bytes4[][] memory functionSelectorsArray = _generateMultiSelectors(upgradeFacetNames);
 350 |     |         for (uint256 i = 0; i < upgradeFacetNames.length; i++) {
 351 |     |             IDiamondLoupe.Facet memory facet = IDiamondLoupe.Facet(
 352 |     |                 upgradeFacetAddresses[i],
 353 |     |                 functionSelectorsArray[i]
 354 |     |             );
 355 |     |             newFacets[i] = facet;
 356 |     |         }
 357 |     | 
 358 |     |         assembly {
 359 |     |             mstore(newFacets, facetAddressesLength)
 360 |     |         }
 361 |     | 
 362 |     |         // generate the diamond cut required to upgrade all facets
 363 |     |         IDiamondCut.FacetCut[] memory cut = generateDiamondCut(currentFacets, newFacets);
 364 |     | 
 365 |     |         vm.startPrank(IMockFBeanstalk(beanstalkAddress).owner());
 366 |     |         // perform the diamond cut (upgrades Beanstalk)
 367 |     |         IDiamondCut(beanstalkAddress).diamondCut(cut, initAddress, initData);
 368 |     |         vm.stopPrank();
 369 |     |     }
 370 |     | 
 371 |     |     //////////////////////// Deploy /////////////////////////
 372 |     | 
 373 |     |     /**
 374 |     |      * @notice deploys a diamond contract at an address.
 375 |     |      */
 376 |     |     function deployDiamondAtAddress(
 377 |     |         address _deployer,
 378 |     |         address payable beanstalkAddress
 379 |     |     ) internal returns (Diamond d) {
 380 |     |         vm.prank(_deployer);
 381 |     |         deployCodeTo("Diamond.sol", abi.encode(_deployer), beanstalkAddress);
 382 |     |         return Diamond(beanstalkAddress);
 383 |     |     }
 384 |     | 
 385 |     |     /**
 386 |     |      * @notice generates the diamond cut array for multiple facets.
 387 |     |      * @dev optimized such that ffi is only called once.
 388 |     |      */
 389 |     |     function _multiCut(
 390 |     |         string[] memory _facetNames,
 391 |     |         address[] memory _facetAddresses,
 392 |     |         IDiamondCut.FacetCutAction[] memory _actions
 393 |     |     ) internal returns (IDiamondCut.FacetCut[] memory cutArray) {
 394 |     |         cutArray = new IDiamondCut.FacetCut[](_facetNames.length);
 395 |     |         bytes4[][] memory functionSelectorsArray = _generateMultiSelectors(_facetNames);
 396 |     |         for (uint256 i; i < _facetNames.length; i++) {
 397 |     |             cutArray[i] = IDiamondCut.FacetCut({
 398 |     |                 facetAddress: _facetAddresses[i],
 399 |     |                 action: _actions[i],
 400 |     |                 functionSelectors: functionSelectorsArray[i]
 401 |     |             });
 402 |     |         }
 403 |     |     }
 404 |     | 
 405 |     |     /**
 406 |     |      * @dev assumes selectors that are removed are grouped by facets.
 407 |     |      */
 408 |     |     function _multiCutWithSelectorRemovals(
 409 |     |         string[] memory _facetNames,
 410 |     |         address[] memory _facetAddresses,
 411 |     |         IDiamondCut.FacetCutAction[] memory actions,
 412 |     |         bytes4[] memory _selectorsToRemove
 413 |     |     ) internal returns (IDiamondCut.FacetCut[] memory cutArray) {
 414 |     |         // get initial cutArray.
 415 |     |         IDiamondCut.FacetCut[] memory initialCutArray = _multiCut(
 416 |     |             _facetNames,
 417 |     |             _facetAddresses,
 418 |     |             actions
 419 |     |         );
 420 |     | 
 421 |     |         // generate cuts for selectors to remove.
 422 |     |         if (_selectorsToRemove.length != 0) {
 423 |     |             cutArray = new IDiamondCut.FacetCut[](initialCutArray.length + 1);
 424 |     |             cutArray[0] = IDiamondCut.FacetCut(
 425 |     |                 address(0),
 426 |     |                 IDiamondCut.FacetCutAction.Remove,
 427 |     |                 _selectorsToRemove
 428 |     |             );
 429 |     | 
 430 |     |             for (uint256 i; i < initialCutArray.length; i++) {
 431 |     |                 cutArray[i + 1] = initialCutArray[i];
 432 |     |             }
 433 |     |         } else {
 434 |     |             cutArray = initialCutArray;
 435 |     |         }
 436 |     |     }
 437 |     | 
 438 |     |     /**
 439 |     |      * @notice generates the selectors for multiple facets.
 440 |     |      * @dev optimized such that ffi is only called once to
 441 |     |      * optimize on compile time.
 442 |     |      */
 443 |     |     function _generateMultiSelectors(
 444 |     |         string[] memory _facetNames
 445 |     |     ) internal returns (bytes4[][] memory selectorsArray) {
 446 |     |         string[] memory cmd = new string[](_facetNames.length + 2);
 447 |     |         cmd[0] = "node";
 448 |     |         cmd[1] = "scripts/genSelectors.js";
 449 |     |         for (uint256 i = 0; i < _facetNames.length; i++) {
 450 |     |             cmd[i + 2] = _facetNames[i];
 451 |     |         }
 452 |     |         // be aware of cases where the response may be very large, which can break the EVM
 453 |     |         bytes memory res = vm.ffi(cmd);
 454 |     | 
 455 |     |         if (res.length > 0) {
 456 |     |             selectorsArray = _decodeCompactSelectors(res);
 457 |     |         } else {
 458 |     |             selectorsArray = new bytes4[][](0);
 459 |     |         }
 460 |     |     }
 461 |     | 
 462 |     |     function _decodeCompactSelectors(bytes memory data) internal pure returns (bytes4[][] memory) {
 463 |     |         uint256 pointer = 0;
 464 |     |         uint256 numContracts = uint256(bytes32(slice(data, pointer, 32)));
 465 |     |         pointer += 32;
 466 |     | 
 467 |     |         bytes4[][] memory selectorsArray = new bytes4[][](numContracts);
 468 |     | 
 469 |     |         for (uint256 i = 0; i < numContracts; i++) {
 470 |     |             uint16 numSelectors = uint16(bytes2(slice(data, pointer, 2)));
 471 |     |             pointer += 2;
 472 |     | 
 473 |     |             bytes4[] memory selectors = new bytes4[](numSelectors);
 474 |     |             for (uint256 j = 0; j < numSelectors; j++) {
 475 |     |                 selectors[j] = bytes4(slice(data, pointer, 4));
 476 |     |                 pointer += 4;
 477 |     |             }
 478 |     | 
 479 |     |             selectorsArray[i] = selectors;
 480 |     |         }
 481 |     | 
 482 |     |         return selectorsArray;
 483 |     |     }
 484 |     | 
 485 |     |     function generateDiamondCut(
 486 |     |         IDiamondLoupe.Facet[] memory currentFacets,
 487 |     |         IDiamondLoupe.Facet[] memory newFacets
 488 |     |     ) internal pure returns (IDiamondCut.FacetCut[] memory) {
 489 |     |         // Use a dynamic array for cuts
 490 |     |         IDiamondCut.FacetCut[] memory cuts = new IDiamondCut.FacetCut[](0);
 491 |     | 
 492 |     |         // Create arrays to store all selectors and their corresponding new facet addresses
 493 |     |         bytes4[] memory allSelectors = new bytes4[](0);
 494 |     |         address[] memory allNewFacetAddresses = new address[](0);
 495 |     | 
 496 |     |         // Populate the arrays with data from newFacets
 497 |     |         for (uint256 i = 0; i < newFacets.length; i++) {
 498 |     |             for (uint256 j = 0; j < newFacets[i].functionSelectors.length; j++) {
 499 |     |                 allSelectors = appendToBytes4Array(allSelectors, newFacets[i].functionSelectors[j]);
 500 |     |                 allNewFacetAddresses = appendToAddressArray(
 501 |     |                     allNewFacetAddresses,
 502 |     |                     newFacets[i].facetAddress
 503 |     |                 );
 504 |     |             }
 505 |     |         }
 506 |     | 
 507 |     |         // Process removals and replacements
 508 |     |         for (uint256 i = 0; i < currentFacets.length; i++) {
 509 |     |             bytes4[] memory selectorsToRemove = new bytes4[](
 510 |     |                 currentFacets[i].functionSelectors.length
 511 |     |             );
 512 |     |             bytes4[] memory selectorsToReplace = new bytes4[](
 513 |     |                 currentFacets[i].functionSelectors.length
 514 |     |             );
 515 |     |             uint256 removeCount = 0;
 516 |     |             uint256 replaceCount = 0;
 517 |     | 
 518 |     |             for (uint256 j = 0; j < currentFacets[i].functionSelectors.length; j++) {
 519 |     |                 bytes4 selector = currentFacets[i].functionSelectors[j];
 520 |     |                 (bool found, address newFacetAddress) = findNewFacetAddress(
 521 |     |                     selector,
 522 |     |                     allSelectors,
 523 |     |                     allNewFacetAddresses
 524 |     |                 );
 525 |     | 
 526 |     |                 if (!found) {
 527 |     |                     selectorsToRemove[removeCount] = selector;
 528 |     |                     removeCount++;
 529 |     |                 } else if (newFacetAddress != currentFacets[i].facetAddress) {
 530 |     |                     selectorsToReplace[replaceCount] = selector;
 531 |     |                     replaceCount++;
 532 |     |                 }
 533 |     |             }
 534 |     | 
 535 |     |             if (removeCount > 0) {
 536 |     |                 bytes4[] memory finalSelectorsToRemove = new bytes4[](removeCount);
 537 |     |                 for (uint256 j = 0; j < removeCount; j++) {
 538 |     |                     finalSelectorsToRemove[j] = selectorsToRemove[j];
 539 |     |                 }
 540 |     |                 cuts = appendToCuts(
 541 |     |                     cuts,
 542 |     |                     IDiamondCut.FacetCut(
 543 |     |                         address(0),
 544 |     |                         IDiamondCut.FacetCutAction.Remove,
 545 |     |                         finalSelectorsToRemove
 546 |     |                     )
 547 |     |                 );
 548 |     |             }
 549 |     | 
 550 |     |             if (replaceCount > 0) {
 551 |     |                 bytes4[] memory finalSelectorsToReplace = new bytes4[](replaceCount);
 552 |     |                 for (uint256 j = 0; j < replaceCount; j++) {
 553 |     |                     finalSelectorsToReplace[j] = selectorsToReplace[j];
 554 |     |                 }
 555 |     |                 (, address newFacetAddress) = findNewFacetAddress(
 556 |     |                     finalSelectorsToReplace[0],
 557 |     |                     allSelectors,
 558 |     |                     allNewFacetAddresses
 559 |     |                 );
 560 |     |                 cuts = appendToCuts(
 561 |     |                     cuts,
 562 |     |                     IDiamondCut.FacetCut(
 563 |     |                         newFacetAddress,
 564 |     |                         IDiamondCut.FacetCutAction.Replace,
 565 |     |                         finalSelectorsToReplace
 566 |     |                     )
 567 |     |                 );
 568 |     |             }
 569 |     |         }
 570 |     | 
 571 |     |         // Process additions
 572 |     |         for (uint256 i = 0; i < newFacets.length; i++) {
 573 |     |             bytes4[] memory selectorsToAdd = new bytes4[](newFacets[i].functionSelectors.length);
 574 |     |             uint256 addCount = 0;
 575 |     | 
 576 |     |             for (uint256 j = 0; j < newFacets[i].functionSelectors.length; j++) {
 577 |     |                 bytes4 selector = newFacets[i].functionSelectors[j];
 578 |     |                 bool isNewSelector = true;
 579 |     |                 for (uint256 k = 0; k < currentFacets.length; k++) {
 580 |     |                     if (contains(currentFacets[k].functionSelectors, selector)) {
 581 |     |                         isNewSelector = false;
 582 |     |                         break;
 583 |     |                     }
 584 |     |                 }
 585 |     |                 if (isNewSelector) {
 586 |     |                     selectorsToAdd[addCount] = selector;
 587 |     |                     addCount++;
 588 |     |                 }
 589 |     |             }
 590 |     | 
 591 |     |             if (addCount > 0) {
 592 |     |                 bytes4[] memory finalSelectorsToAdd = new bytes4[](addCount);
 593 |     |                 for (uint256 j = 0; j < addCount; j++) {
 594 |     |                     finalSelectorsToAdd[j] = selectorsToAdd[j];
 595 |     |                 }
 596 |     |                 cuts = appendToCuts(
 597 |     |                     cuts,
 598 |     |                     IDiamondCut.FacetCut(
 599 |     |                         newFacets[i].facetAddress,
 600 |     |                         IDiamondCut.FacetCutAction.Add,
 601 |     |                         finalSelectorsToAdd
 602 |     |                     )
 603 |     |                 );
 604 |     |             }
 605 |     |         }
 606 |     | 
 607 |     |         return cuts;
 608 |     |     }
 609 |     | 
 610 |     |     function findNewFacetAddress(
 611 |     |         bytes4 selector,
 612 |     |         bytes4[] memory allSelectors,
 613 |     |         address[] memory allNewFacetAddresses
 614 |     |     ) internal pure returns (bool, address) {
 615 |     |         for (uint256 i = 0; i < allSelectors.length; i++) {
 616 |     |             if (allSelectors[i] == selector) {
 617 |     |                 return (true, allNewFacetAddresses[i]);
 618 |     |             }
 619 |     |         }
 620 |     |         return (false, address(0));
 621 |     |     }
 622 |     | 
 623 |     |     // these append functions are not ideal in terms for gas/performance, but they are convenient for testing
 624 |     |     function appendToBytes4Array(
 625 |     |         bytes4[] memory array,
 626 |     |         bytes4 element
 627 |     |     ) internal pure returns (bytes4[] memory) {
 628 |     |         bytes4[] memory newArray = new bytes4[](array.length + 1);
 629 |     |         for (uint256 i = 0; i < array.length; i++) {
 630 |     |             newArray[i] = array[i];
 631 |     |         }
 632 |     |         newArray[array.length] = element;
 633 |     |         return newArray;
 634 |     |     }
 635 |     | 
 636 |     |     function appendToAddressArray(
 637 |     |         address[] memory array,
 638 |     |         address element
 639 |     |     ) internal pure returns (address[] memory) {
 640 |     |         address[] memory newArray = new address[](array.length + 1);
 641 |     |         for (uint256 i = 0; i < array.length; i++) {
 642 |     |             newArray[i] = array[i];
 643 |     |         }
 644 |     |         newArray[array.length] = element;
 645 |     |         return newArray;
 646 |     |     }
 647 |     | 
 648 |     |     function appendToCuts(
 649 |     |         IDiamondCut.FacetCut[] memory cuts,
 650 |     |         IDiamondCut.FacetCut memory newCut
 651 |     |     ) internal pure returns (IDiamondCut.FacetCut[] memory) {
 652 |     |         IDiamondCut.FacetCut[] memory newCuts = new IDiamondCut.FacetCut[](cuts.length + 1);
 653 |     |         for (uint256 i = 0; i < cuts.length; i++) {
 654 |     |             newCuts[i] = cuts[i];
 655 |     |         }
 656 |     |         newCuts[cuts.length] = newCut;
 657 |     |         return newCuts;
 658 |     |     }
 659 |     | 
 660 |     |     function contains(bytes4[] memory array, bytes4 value) internal pure returns (bool) {
 661 |     |         for (uint256 i = 0; i < array.length; i++) {
 662 |     |             if (array[i] == value) {
 663 |     |                 return true;
 664 |     |             }
 665 |     |         }
 666 |     |         return false;
 667 |     |     }
 668 |     | 
 669 |     |     function _decodeDiamondCut(
 670 |     |         bytes memory data
 671 |     |     ) internal pure returns (IDiamondCut.FacetCut[] memory) {
 672 |     |         uint256 pointer = 0;
 673 |     |         uint256 numCuts = uint256(bytes32(slice(data, pointer, 32)));
 674 |     |         pointer += 32;
 675 |     | 
 676 |     |         IDiamondCut.FacetCut[] memory cuts = new IDiamondCut.FacetCut[](numCuts);
 677 |     | 
 678 |     |         for (uint256 i = 0; i < numCuts; i++) {
 679 |     |             address facetAddress = address(bytes20(slice(data, pointer, 20)));
 680 |     |             pointer += 20;
 681 |     | 
 682 |     |             uint8 action = uint8(slice(data, pointer, 1)[0]);
 683 |     |             pointer += 1;
 684 |     | 
 685 |     |             uint16 numSelectors = uint16(bytes2(slice(data, pointer, 2)));
 686 |     |             pointer += 2;
 687 |     | 
 688 |     |             bytes4[] memory selectors = new bytes4[](numSelectors);
 689 |     |             for (uint256 j = 0; j < numSelectors; j++) {
 690 |     |                 selectors[j] = bytes4(slice(data, pointer, 4));
 691 |     |                 pointer += 4;
 692 |     |             }
 693 |     | 
 694 |     |             cuts[i] = IDiamondCut.FacetCut(
 695 |     |                 facetAddress,
 696 |     |                 IDiamondCut.FacetCutAction(action),
 697 |     |                 selectors
 698 |     |             );
 699 |     |         }
 700 |     | 
 701 |     |         return cuts;
 702 |     |     }
 703 |     | 
 704 |     |     function slice(
 705 |     |         bytes memory data,
 706 |     |         uint256 start,
 707 |     |         uint256 length
 708 |     |     ) internal pure returns (bytes memory) {
 709 |     |         bytes memory result = new bytes(length);
 710 |     |         for (uint256 i = 0; i < length; i++) {
 711 |     |             result[i] = data[start + i];
 712 |     |         }
 713 |     |         return result;
 714 |     |     }
 715 |     | }
 716 |     | 
 717 |     | contract EmptyInitContract {
 718 |     |     function init() external {}
 719 |     | }
 720 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/utils/DepotDeployer.sol
  1 |     | /**
  2 |     |  * SPDX-License-Identifier: MIT
  3 |     |  **/
  4 |     | pragma solidity ^0.8.20;
  5 |     | pragma abicoder v2;
  6 |     | 
  7 |     | import {Utils, console} from "test/foundry/utils/Utils.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title DepotDeployer
 11 |     |  * @notice Test helper contract to deploy Depot.
 12 |     |  */
 13 |     | contract DepotDeployer is Utils {
 14 |     |     function initDepot(bool verbose) internal {
 15 |     |         deployCodeTo("Pipeline.sol", PIPELINE);
 16 |     |         if (verbose) console.log("Pipeline deposited at: %s", PIPELINE);
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/utils/OracleDeployer.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  *
   4 |     |  */
   5 |     | pragma solidity ^0.8.20;
   6 |     | pragma abicoder v2;
   7 |     | 
   8 |     | import {Utils, console} from "test/foundry/utils/Utils.sol";
   9 |     | 
  10 |     | ///////// MOCKS ////////
  11 |     | import {MockChainlinkAggregator} from "contracts/mocks/MockChainlinkAggregator.sol";
  12 |     | import {MockUniswapV3Pool} from "contracts/mocks/uniswap/MockUniswapV3Pool.sol";
  13 |     | import {MockUniswapV3Factory} from "contracts/mocks/uniswap/MockUniswapV3Factory.sol";
  14 |     | import {IMockFBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
  15 |     | import {LSDChainlinkOracle} from "contracts/ecosystem/oracles/LSDChainlinkOracle.sol";
  16 |     | 
  17 |     | /**
  18 |     |  * @title OracleDeployer
  19 |     |  * @notice Test helper contract to deploy Depot.
  20 |     |  */
  21 |     | interface ChainlinkPriceFeedRegistry {
  22 |     |     function getFeed(address base, address quote) external view returns (address aggregator);
  23 |     | }
  24 |     | 
  25 |     | contract OracleDeployer is Utils {
  26 |     |     ////////// CHAINLINK //////////
  27 |     |     address constant USDC_USD_CHAINLINK_PRICE_AGGREGATOR =
  28 |     |         address(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);
  29 |     | 
  30 |     |     address constant WBTC_USD_CHAINLINK_PRICE_AGGREGATOR =
  31 |     |         address(0xd0C7101eACbB49F3deCcCc166d238410D6D46d57);
  32 |     | 
  33 |     |     address constant ETH_USD_CHAINLINK_PRICE_AGGREGATOR =
  34 |     |         0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
  35 |     | 
  36 |     |     address constant WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR =
  37 |     |         0x86392dC19c0b719886221c78AB11eb8Cf5c52812;
  38 |     | 
  39 |     |     //////// UNISWAP ORACLES ////////
  40 |     |     address internal constant WSTETH_ETH_UNIV3_01_POOL = 0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa; // 0.01% pool
  41 |     | 
  42 |     |     // timeout for Oracles with a 1 hour heartbeat.
  43 |     |     uint256 constant FOUR_HOUR_TIMEOUT = 14400;
  44 |     |     // timeout for Oracles with a 1 day heartbeat.
  45 |     |     uint256 constant FOUR_DAY_TIMEOUT = 345600;
  46 |     | 
  47 |     |     // new chainlink oracles should be added here.
  48 |     |     address[] public chainlinkOracles = [
  49 |     |         ETH_USD_CHAINLINK_PRICE_AGGREGATOR,
  50 |     |         WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR,
  51 |     |         USDC_USD_CHAINLINK_PRICE_AGGREGATOR,
  52 |     |         WBTC_USD_CHAINLINK_PRICE_AGGREGATOR
  53 |     |     ];
  54 |     | 
  55 |     |     // initial prices for chainlink oracles should be added here.
  56 |     |     // assumes index matching with chainlinkOracles.
  57 |     |     int256[] initalPrices = [
  58 |     |         int256(1000e6), // ETH/USD
  59 |     |         1e6, // wstETH/ETH
  60 |     |         1e6, // USDC/USD
  61 |     |         50000e6 // WBTC/USD
  62 |     |     ];
  63 |     | 
  64 |     |     ////////// UNISWAP //////////
  65 |     | 
  66 |     |     address constant WBTC_USDC_03_POOL = address(0x99ac8cA7087fA4A2A1FB6357269965A2014ABc35);
  67 |     |     address constant AAVE_ETH_03_POOL = address(0x5aB53EE1d50eeF2C1DD3d5402789cd27bB52c1bB);
  68 |     |     address constant WSTETH_ETH_001_POOL = address(0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa);
  69 |     |     // address constant WBTC = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
  70 |     |     address constant AAVE = address(0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9);
  71 |     | 
  72 |     |     // new uniswap pools should be appended here.
  73 |     |     address[][] public pools = [
  74 |     |         [WSTETH_ETH_UNIV3_01_POOL, WSTETH, WETH], // wstETH/ETH
  75 |     |         [WBTC_USDC_03_POOL, WBTC, USDC] // WBTC/USDC
  76 |     |     ];
  77 |     | 
  78 |     |     // oracles must be initalized at some price. Assumes index matching with pools.
  79 |     |     uint256[][] public priceData = [[uint256(1e18), 18], [uint256(500e6), 8]];
  80 |     | 
  81 |     |     // new custom oracle implmenetations should be added here.
  82 |     |     address lsdChainlinkOracle; // LSD Chainlink Oracle
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice initializes chainlink oracles.
  86 |     |      * @dev oracles are mocked, and thus require initalization/updates.
  87 |     |      */
  88 |     |     function initChainlink(bool verbose) internal {
  89 |     |         // optional labels to assist in testing.
  90 |     |         vm.label(ETH_USD_CHAINLINK_PRICE_AGGREGATOR, "CL ETH/USD");
  91 |     |         vm.label(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, "CL WstETH/ETH");
  92 |     |         vm.label(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6, "CL USDC/USD");
  93 |     |         vm.label(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D, "CL USDT/USD");
  94 |     |         vm.label(WBTC_USD_CHAINLINK_PRICE_AGGREGATOR, "CL WBTC/USD");
  95 |     | 
  96 |     |         for (uint256 i; i < chainlinkOracles.length; i++) {
  97 |     |             deployCodeTo("MockChainlinkAggregator.sol", new bytes(0), chainlinkOracles[i]);
  98 |     |             MockChainlinkAggregator(chainlinkOracles[i]).setDecimals(6);
  99 |     |             if (verbose) console.log("Chainlink Oracle Deployed at:", chainlinkOracles[i]);
 100 |     | 
 101 |     |             mockAddRound(chainlinkOracles[i], initalPrices[i], 900);
 102 |     |         }
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @notice adds a round to a chainlink oracle.
 107 |     |      */
 108 |     |     function mockAddRound(address chainlinkOracle, int256 price, uint256 secondsAgo) internal {
 109 |     |         uint256 time;
 110 |     | 
 111 |     |         if (block.timestamp < secondsAgo) {
 112 |     |             time = 1; // min timestamp = 1.
 113 |     |         } else {
 114 |     |             time = block.timestamp - secondsAgo;
 115 |     |         }
 116 |     |         uint80 latestRound = MockChainlinkAggregator(chainlinkOracle).getLatestRoundId();
 117 |     |         MockChainlinkAggregator(chainlinkOracle).addRound(price, time, time, latestRound + 1);
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @notice adds an invalid round to a chainlink oracle.
 122 |     |      */
 123 |     |     function mockAddInvalidRound(address chainlinkOracle) internal {
 124 |     |         uint80 roundId = MockChainlinkAggregator(chainlinkOracle).getLatestRoundId();
 125 |     |         MockChainlinkAggregator(chainlinkOracle).addRound(0, 0, 0, roundId + 1);
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @notice adds a round to the chainlink oracle, using the last rounds data.
 130 |     |      * @dev adds 2 rounds. 1 Round that goes back 900 seconds,
 131 |     |      * and another that goes back 3600 + 900 seconds, due to how beanstalk calculates the twap.
 132 |     |      * the block.timestamp must be greater than 4500 seconds.
 133 |     |      */
 134 |     |     function updateChainlinkOracleWithPreviousData(address chainlinkOracle) internal {
 135 |     |         (, int256 answer, , , ) = MockChainlinkAggregator(chainlinkOracle).latestRoundData();
 136 |     |         mockAddRound(chainlinkOracle, answer, 4500);
 137 |     |         mockAddRound(chainlinkOracle, answer, 900);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @notice initializes uniswap pools for testing.
 142 |     |      */
 143 |     |     function initUniswapPools(bool verbose) internal {
 144 |     |         vm.label(WSTETH_ETH_UNIV3_01_POOL, "UNI WSTETH_ETH_UNIV3_01");
 145 |     |         vm.label(WBTC_USDC_03_POOL, "UNI WBTC_USDC_03_POOL");
 146 |     | 
 147 |     |         MockUniswapV3Factory uniFactory = MockUniswapV3Factory(new MockUniswapV3Factory());
 148 |     | 
 149 |     |         for (uint256 i; i < pools.length; i++) {
 150 |     |             address[] memory poolData = pools[i];
 151 |     |             address pool = uniFactory.createPool(poolData[1], poolData[2], 100);
 152 |     |             vm.etch(poolData[0], pool.code);
 153 |     |             if (verbose) console.log("Uniswap Oracle Deployed at:", poolData[0]);
 154 |     |             uint256 price = calcPrice(priceData[i][0], priceData[i][1]);
 155 |     |             MockUniswapV3Pool(poolData[0]).setOraclePrice(price, uint8(priceData[i][1]));
 156 |     |             if (verbose) console.log("Price set at:", priceData[i][0]);
 157 |     |             MockUniswapV3Pool(poolData[0]).setToken0(poolData[1]);
 158 |     |             MockUniswapV3Pool(poolData[0]).setToken1(poolData[2]);
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice calculates the price for a uniswap pool.
 164 |     |      * @dev will need to be updated for different pools w/different decimals.
 165 |     |      */
 166 |     |     function calcPrice(uint256 _price, uint256 decimal) internal pure returns (uint256 price) {
 167 |     |         uint256 x;
 168 |     |         if (decimal == 6) {
 169 |     |             x = 1e18;
 170 |     |         } else if (decimal == 18) {
 171 |     |             x = 1e36;
 172 |     |         } else if (decimal == 8) {
 173 |     |             x = 1e14;
 174 |     |         }
 175 |     |         price = x / (_price + 1);
 176 |     |     }
 177 |     | 
 178 |     |     function initWhitelistOracles(bool verbose) internal {
 179 |     |         // deploy LSD Chainlink Oracle
 180 |     |         lsdChainlinkOracle = address(new LSDChainlinkOracle());
 181 |     |         vm.label(lsdChainlinkOracle, "LSD Chainlink Oracle");
 182 |     |         // new custom oracles should be added here.
 183 |     | 
 184 |     |         // init ETH:USD oracle
 185 |     |         updateOracleImplementationForTokenUsingChainlinkAggregator(
 186 |     |             WETH,
 187 |     |             ETH_USD_CHAINLINK_PRICE_AGGREGATOR,
 188 |     |             verbose
 189 |     |         );
 190 |     | 
 191 |     |         // init wsteth oracle.
 192 |     |         setupLSDChainlinkOracleForToken(
 193 |     |             WSTETH,
 194 |     |             WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR,
 195 |     |             FOUR_HOUR_TIMEOUT
 196 |     |         );
 197 |     |     }
 198 |     | 
 199 |     |     function updateOracleImplementationForTokenUsingChainlinkAggregator(
 200 |     |         address token,
 201 |     |         address oracleAddress,
 202 |     |         bool verbose
 203 |     |     ) internal {
 204 |     |         IMockFBeanstalk.Implementation memory oracleImplementation = IMockFBeanstalk.Implementation(
 205 |     |             oracleAddress,
 206 |     |             bytes4(0),
 207 |     |             bytes1(0x01),
 208 |     |             abi.encode(FOUR_HOUR_TIMEOUT)
 209 |     |         );
 210 |     | 
 211 |     |         vm.prank(BEANSTALK);
 212 |     |         bs.updateOracleImplementationForToken(token, oracleImplementation);
 213 |     | 
 214 |     |         if (verbose) {
 215 |     |             console.log("Updated oracle implementation for token: ", token, " to: ", oracleAddress);
 216 |     |         }
 217 |     |     }
 218 |     | 
 219 |     |     function setupLSDChainlinkOracleForToken(
 220 |     |         address token,
 221 |     |         address tokenChainlinkOracle,
 222 |     |         uint256 tokenTimeout
 223 |     |     ) internal {
 224 |     |         address _ethChainlinkOracle = ETH_USD_CHAINLINK_PRICE_AGGREGATOR;
 225 |     |         uint256 _ethTimeout = 3600 * 4;
 226 |     |         vm.prank(BEANSTALK);
 227 |     |         bs.updateOracleImplementationForToken(
 228 |     |             token,
 229 |     |             IMockFBeanstalk.Implementation(
 230 |     |                 lsdChainlinkOracle,
 231 |     |                 LSDChainlinkOracle.getPrice.selector,
 232 |     |                 bytes1(0x00),
 233 |     |                 abi.encode(_ethChainlinkOracle, _ethTimeout, tokenChainlinkOracle, tokenTimeout)
 234 |     |             )
 235 |     |         );
 236 |     |     }
 237 |     | }
 238 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/utils/ShipmentDeployer.sol
   1 |     | /**
   2 |     |  * SPDX-License-Identifier: MIT
   3 |     |  **/
   4 |     | pragma solidity ^0.8.20;
   5 |     | pragma abicoder v2;
   6 |     | 
   7 |     | import {IMockFBeanstalk as IBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
   8 |     | import {MockPayback} from "contracts/mocks/MockPayback.sol";
   9 |     | import {MockBudget} from "contracts/mocks/MockBudget.sol";
  10 |     | import {Utils, console} from "test/foundry/utils/Utils.sol";
  11 |     | import {C} from "contracts/C.sol";
  12 |     | import {ShipmentPlanner, ShipmentPlan} from "contracts/ecosystem/ShipmentPlanner.sol";
  13 |     | import {IShipmentPlanner} from "contracts/interfaces/IShipmentPlanner.sol";
  14 |     | import {MockShipmentPlanner} from "contracts/mocks/MockShipmentPlanner.sol";
  15 |     | 
  16 |     | // Extend the interface to support Fields with different points.
  17 |     | interface IMockShipmentPlanner is IShipmentPlanner {
  18 |     |     function getFieldPlanMulti(bytes memory data) external view returns (ShipmentPlan memory);
  19 |     | }
  20 |     | 
  21 |     | /**
  22 |     |  * @title ShipmentDeployer
  23 |     |  * @notice Test helper contract to deploy ShipmentPlanner and set Routes.
  24 |     |  */
  25 |     | contract ShipmentDeployer is Utils {
  26 |     |     address shipmentPlanner;
  27 |     |     address mockShipmentPlanner;
  28 |     | 
  29 |     |     // Deploy fake budget address.
  30 |     |     address budget;
  31 |     |     // Deploy fake payback contract.
  32 |     |     address payback;
  33 |     | 
  34 |     |     function initShipping(bool verbose) internal {
  35 |     |         bs = IBeanstalk(BEANSTALK);
  36 |     | 
  37 |     |         // Create Field, set active, and initialize Temperature.
  38 |     |         vm.prank(deployer);
  39 |     |         bs.addField();
  40 |     |         vm.prank(deployer);
  41 |     |         bs.setActiveField(0, 1);
  42 |     | 
  43 |     |         // Deploy fake budget address.
  44 |     |         budget = address(new MockBudget());
  45 |     |         // Deploy fake payback contract.
  46 |     |         payback = address(new MockPayback(BEAN));
  47 |     | 
  48 |     |         // Deploy the planner, which will determine points and caps of each route.
  49 |     |         shipmentPlanner = address(new ShipmentPlanner(BEANSTALK, BEAN));
  50 |     |         mockShipmentPlanner = address(new MockShipmentPlanner(BEANSTALK, BEAN));
  51 |     | 
  52 |     |         // TODO: Update this with new routes.
  53 |     |         // Set up two routes: the Silo and a Field.
  54 |     |         setRoutes_siloAndField();
  55 |     | 
  56 |     |         if (verbose) console.log("ShipmentPlanner deployed at: ", shipmentPlanner);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Set the shipment routes to only the Silo. It will receive 100% of Mints.
  61 |     |      */
  62 |     |     function setRoutes_silo() internal {
  63 |     |         IBeanstalk.ShipmentRoute[] memory shipmentRoutes = new IBeanstalk.ShipmentRoute[](1);
  64 |     |         shipmentRoutes[0] = IBeanstalk.ShipmentRoute({
  65 |     |             planContract: shipmentPlanner,
  66 |     |             planSelector: IShipmentPlanner.getSiloPlan.selector,
  67 |     |             recipient: IBeanstalk.ShipmentRecipient.SILO,
  68 |     |             data: abi.encode("")
  69 |     |         });
  70 |     |         vm.prank(deployer);
  71 |     |         bs.setShipmentRoutes(shipmentRoutes);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Set the shipment routes to the Silo and 1 Field. Each will receive 1/2 of Mints.
  76 |     |      * @dev Need to add Fields before calling.
  77 |     |      */
  78 |     |     function setRoutes_siloAndField() internal {
  79 |     |         IBeanstalk.ShipmentRoute[] memory shipmentRoutes = new IBeanstalk.ShipmentRoute[](2);
  80 |     |         shipmentRoutes[0] = IBeanstalk.ShipmentRoute({
  81 |     |             planContract: shipmentPlanner,
  82 |     |             planSelector: IShipmentPlanner.getSiloPlan.selector,
  83 |     |             recipient: IBeanstalk.ShipmentRecipient.SILO,
  84 |     |             data: abi.encode("")
  85 |     |         });
  86 |     |         shipmentRoutes[1] = IBeanstalk.ShipmentRoute({
  87 |     |             planContract: shipmentPlanner,
  88 |     |             planSelector: IShipmentPlanner.getFieldPlan.selector,
  89 |     |             recipient: IBeanstalk.ShipmentRecipient.FIELD,
  90 |     |             data: abi.encode(uint256(0))
  91 |     |         });
  92 |     |         vm.prank(deployer);
  93 |     |         bs.setShipmentRoutes(shipmentRoutes);
  94 |     |     }
  95 |     | 
  96 |     |     function setRoutes_siloAndFields() internal {
  97 |     |         uint256 fieldCount = IBeanstalk(BEANSTALK).fieldCount();
  98 |     |         IBeanstalk.ShipmentRoute[] memory shipmentRoutes = new IBeanstalk.ShipmentRoute[](
  99 |     |             1 + fieldCount
 100 |     |         );
 101 |     |         shipmentRoutes[0] = IBeanstalk.ShipmentRoute({
 102 |     |             planContract: shipmentPlanner,
 103 |     |             planSelector: IShipmentPlanner.getSiloPlan.selector,
 104 |     |             recipient: IBeanstalk.ShipmentRecipient.SILO,
 105 |     |             data: abi.encode("")
 106 |     |         });
 107 |     |         for (uint256 i = 0; i < fieldCount; i++) {
 108 |     |             shipmentRoutes[i + 1] = IBeanstalk.ShipmentRoute({
 109 |     |                 planContract: shipmentPlanner,
 110 |     |                 planSelector: IShipmentPlanner.getFieldPlan.selector,
 111 |     |                 recipient: IBeanstalk.ShipmentRecipient.FIELD,
 112 |     |                 data: abi.encode(i)
 113 |     |             });
 114 |     |         }
 115 |     |         vm.prank(deployer);
 116 |     |         bs.setShipmentRoutes(shipmentRoutes);
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Set the shipment routes to the Silo, one active Field, and one reduced Field.
 121 |     |      *         Mints are split 5/5/1, respectively.
 122 |     |      * @dev Need to add Fields before calling.
 123 |     |      */
 124 |     |     function setRoutes_siloAndTwoFields() internal {
 125 |     |         uint256 fieldCount = IBeanstalk(BEANSTALK).fieldCount();
 126 |     |         require(fieldCount == 2, "Must have 2 Fields to set routes");
 127 |     |         IBeanstalk.ShipmentRoute[] memory shipmentRoutes = new IBeanstalk.ShipmentRoute[](
 128 |     |             1 + fieldCount
 129 |     |         );
 130 |     |         shipmentRoutes[0] = IBeanstalk.ShipmentRoute({
 131 |     |             planContract: mockShipmentPlanner,
 132 |     |             planSelector: IShipmentPlanner.getSiloPlan.selector,
 133 |     |             recipient: IBeanstalk.ShipmentRecipient.SILO,
 134 |     |             data: abi.encodePacked("")
 135 |     |         });
 136 |     |         shipmentRoutes[1] = IBeanstalk.ShipmentRoute({
 137 |     |             planContract: mockShipmentPlanner,
 138 |     |             planSelector: IMockShipmentPlanner.getFieldPlanMulti.selector,
 139 |     |             recipient: IBeanstalk.ShipmentRecipient.FIELD,
 140 |     |             data: abi.encodePacked(uint256(0))
 141 |     |         });
 142 |     |         shipmentRoutes[2] = IBeanstalk.ShipmentRoute({
 143 |     |             planContract: mockShipmentPlanner,
 144 |     |             planSelector: IMockShipmentPlanner.getFieldPlanMulti.selector,
 145 |     |             recipient: IBeanstalk.ShipmentRecipient.FIELD,
 146 |     |             data: abi.encodePacked(uint256(1))
 147 |     |         });
 148 |     |         vm.prank(deployer);
 149 |     |         bs.setShipmentRoutes(shipmentRoutes);
 150 |     |     }
 151 |     | 
 152 |     |     /**
 153 |     |      * @notice Set the shipment routes to the Silo, one active Field, one reduced Field,
 154 |     |      *         the budget and payback contracts.
 155 |     |      *         Mints are split 50/50/1/3/2, respectively.
 156 |     |      * @dev Need to add Fields before calling.
 157 |     |      */
 158 |     |     function setRoutes_all() internal {
 159 |     |         uint256 fieldCount = IBeanstalk(BEANSTALK).fieldCount();
 160 |     |         require(fieldCount == 2, "Must have 2 Fields to set routes");
 161 |     |         require(IBeanstalk(BEANSTALK).activeField() == 0, "Acive field must be 0");
 162 |     |         IBeanstalk.ShipmentRoute[] memory shipmentRoutes = new IBeanstalk.ShipmentRoute[](5);
 163 |     | 
 164 |     |         // Silo.
 165 |     |         shipmentRoutes[0] = IBeanstalk.ShipmentRoute({
 166 |     |             planContract: shipmentPlanner,
 167 |     |             planSelector: IShipmentPlanner.getSiloPlan.selector,
 168 |     |             recipient: IBeanstalk.ShipmentRecipient.SILO,
 169 |     |             data: abi.encode("")
 170 |     |         });
 171 |     |         // Active Field.
 172 |     |         shipmentRoutes[1] = IBeanstalk.ShipmentRoute({
 173 |     |             planContract: shipmentPlanner,
 174 |     |             planSelector: IShipmentPlanner.getFieldPlan.selector,
 175 |     |             recipient: IBeanstalk.ShipmentRecipient.FIELD,
 176 |     |             data: abi.encode(uint256(0))
 177 |     |         });
 178 |     |         // Second Field (1/3 of payback).
 179 |     |         shipmentRoutes[2] = IBeanstalk.ShipmentRoute({
 180 |     |             planContract: shipmentPlanner,
 181 |     |             planSelector: IShipmentPlanner.getPaybackFieldPlan.selector,
 182 |     |             recipient: IBeanstalk.ShipmentRecipient.FIELD,
 183 |     |             data: abi.encode(uint256(1), payback)
 184 |     |         });
 185 |     |         // Budget.
 186 |     |         shipmentRoutes[3] = IBeanstalk.ShipmentRoute({
 187 |     |             planContract: shipmentPlanner,
 188 |     |             planSelector: IShipmentPlanner.getBudgetPlan.selector,
 189 |     |             recipient: IBeanstalk.ShipmentRecipient.INTERNAL_BALANCE,
 190 |     |             data: abi.encode(budget)
 191 |     |         });
 192 |     |         // Payback.
 193 |     |         shipmentRoutes[4] = IBeanstalk.ShipmentRoute({
 194 |     |             planContract: shipmentPlanner,
 195 |     |             planSelector: IShipmentPlanner.getPaybackPlan.selector,
 196 |     |             recipient: IBeanstalk.ShipmentRecipient.EXTERNAL_BALANCE,
 197 |     |             data: abi.encode(payback)
 198 |     |         });
 199 |     | 
 200 |     |         vm.prank(deployer);
 201 |     |         bs.setShipmentRoutes(shipmentRoutes);
 202 |     |     }
 203 |     | }
 204 |     | 

/Users/markjonathas/Desktop/audits/guardian/pinto fuzzing/Pinto-fuzzing/test/foundry/utils/Utils.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.20;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "forge-std/Test.sol";
  6 |     | import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
  7 |     | import {IMockFBeanstalk} from "contracts/interfaces/IMockFBeanstalk.sol";
  8 |     | import {BeanstalkERC20} from "contracts/tokens/ERC20/BeanstalkERC20.sol";
  9 |     | import {LibWeth} from "contracts/libraries/Token/LibWeth.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @dev common utilities for forge tests
 13 |     |  */
 14 |     | contract Utils is Test {
 15 |     |     // beanstalk
 16 |     |     address payable constant BEANSTALK =
 17 |     |         payable(address(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5));
 18 |     | 
 19 |     |     address constant PINTO = address(0xD1A0D188E861ed9d15773a2F3574a2e94134bA8f);
 20 |     | 
 21 |     |     // bean tokens
 22 |     |     address constant L2_PINTO = address(0xb170000aeeFa790fa61D6e837d1035906839a3c8);
 23 |     | 
 24 |     |     address internal constant BEAN = 0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab;
 25 |     |     address internal constant WETH = LibWeth.WETH;
 26 |     |     address internal constant L1_WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
 27 |     |     address internal constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
 28 |     |     address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
 29 |     |     address internal constant USDC_BASE = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;
 30 |     |     address internal constant USDC_MINTER_BASE = 0x880AD1D79c50f9FA0050CDdAd139E52e06B9C725;
 31 |     |     address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
 32 |     |     address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
 33 |     |     address internal constant BEAN_ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd;
 34 |     |     address internal constant BEAN_WSTETH_WELL = 0xBeA0000113B0d182f4064C86B71c315389E4715D;
 35 |     |     address payable internal constant PIPELINE =
 36 |     |         payable(0xb1bE0001f5a373b69b1E132b420e6D9687155e80);
 37 |     | 
 38 |     |     IMockFBeanstalk bs;
 39 |     |     address internal deployer;
 40 |     | 
 41 |     |     using Strings for uint256;
 42 |     |     using Strings for bytes;
 43 |     |     address payable[] internal users;
 44 |     | 
 45 |     |     bytes32 internal nextUser = keccak256(abi.encodePacked("user address"));
 46 |     | 
 47 |     |     // Store private keys and their corresponding addresses
 48 |     |     mapping(address => uint256) internal _privateKeys;
 49 |     | 
 50 |     |     /// @dev impersonate `from`
 51 |     |     modifier prank(address from) {
 52 |     |         vm.startPrank(from);
 53 |     |         _;
 54 |     |         vm.stopPrank();
 55 |     |     }
 56 |     | 
 57 |     |     function getNextUserAddress() public returns (address payable) {
 58 |     |         //bytes32 to address conversion
 59 |     |         address payable user = payable(address(bytes20(nextUser)));
 60 |     |         nextUser = keccak256(abi.encodePacked(nextUser));
 61 |     |         return user;
 62 |     |     }
 63 |     | 
 64 |     |     // create users with 100 ether balance
 65 |     |     function createUsers(uint256 userNum) public returns (address payable[] memory) {
 66 |     |         address payable[] memory _users = new address payable[](userNum);
 67 |     |         for (uint256 i = 0; i < userNum; i++) {
 68 |     |             // Create deterministic private key
 69 |     |             uint256 privateKey = 0x1234 + i;
 70 |     |             // Get the corresponding address
 71 |     |             address payable user = payable(vm.addr(privateKey));
 72 |     | 
 73 |     |             // Store the private key
 74 |     |             _privateKeys[user] = privateKey;
 75 |     | 
 76 |     |             vm.label(user, string(abi.encodePacked("Farmer ", i.toString())));
 77 |     |             vm.deal(user, 100 ether);
 78 |     |             _users[i] = user;
 79 |     |         }
 80 |     |         return _users;
 81 |     |     }
 82 |     | 
 83 |     |     // Helper to get private key for an address
 84 |     |     function getPrivateKey(address user) public view returns (uint256) {
 85 |     |         return _privateKeys[user];
 86 |     |     }
 87 |     | 
 88 |     |     function toStalk(uint256 stalk) public pure returns (uint256) {
 89 |     |         return stalk * 1e10;
 90 |     |     }
 91 |     | }
 92 |     | 

